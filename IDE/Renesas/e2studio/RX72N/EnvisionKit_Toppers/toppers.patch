diff -cr --new-file 1.9.1/asp/arch/gcc/tool_stddef.h ASPs/asp/arch/gcc/tool_stddef.h
*** 1.9.1/asp/arch/gcc/tool_stddef.h	Sat Aug 27 06:56:56 2011
--- ASPs/asp/arch/gcc/tool_stddef.h	Fri Dec  9 13:53:56 2022
***************
*** 7,81 ****
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: tool_stddef.h 2243 2011-08-26 21:56:55Z ertl-hiro $
   */
  
  /*
!  *		t_stddef.hγȯĶ¸GCCѡ
   */
  
  #ifndef TOPPERS_TOOL_STDDEF_H
  #define TOPPERS_TOOL_STDDEF_H
  
  /*
!  *  ѥγĥǽΤΥޥ
   */
! #ifndef __cplusplus					/* C++ˤinline  */
  #if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L
! 									/* C99ˤinline  */
! #define inline	__inline__			/* 饤ؿ */
  #endif /* !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L */
  #endif /* __cplusplus */
  
! #define Inline	static __inline__	/* 饤ؿ */
  
! #ifndef __cplusplus					/* C++ˤasm */
! #define asm		__asm__				/* 饤󥢥֥ */
  #endif /* __cplusplus */
  
! #define Asm		__asm__ volatile	/* 饤󥢥֥ʺŬ޻ߡ*/
  
  #define NoReturn	__attribute__((__noreturn__))
! 									/* ꥿󤷤ʤؿ */
  
  /*
!  *  ȯĶɸ।󥯥롼ɥե
   *
!  *  NULLstddef.h顤INT_MAXINT_MINUINT_MAXLONG_MAX
!  *  LONG_MINULONG_MAXCHAR_BITlimits.hࡥ
   *
!  *  C++/EC++Ǥϡɸ;ϤΥ󥯥롼ɥե뤬Ѱդ
!  *  Ȥϸ¤ʤΤդɬפǤʤۤȤɤγȯĶѰդ
!  *  Ƥˡ
   */
  #ifndef TOPPERS_MACRO_ONLY
  #include <stddef.h>
--- 7,81 ----
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: tool_stddef.h 2243 2011-08-26 21:56:55Z ertl-hiro $
   */
  
  /*
!  *		t_stddef.hの開発環境依存部（GCC用）
   */
  
  #ifndef TOPPERS_TOOL_STDDEF_H
  #define TOPPERS_TOOL_STDDEF_H
  
  /*
!  *  コンパイラの拡張機能のためのマクロ定義
   */
! #ifndef __cplusplus					/* C++にはinline がある */
  #if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L
! 									/* C99にはinline がある */
! #define inline	__inline__			/* インライン関数 */
  #endif /* !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L */
  #endif /* __cplusplus */
  
! #define Inline	static __inline__	/* インライン関数 */
  
! #ifndef __cplusplus					/* C++にはasmがある */
! #define asm		__asm__				/* インラインアセンブラ */
  #endif /* __cplusplus */
  
! #define Asm		__asm__ volatile	/* インラインアセンブラ（最適化抑止）*/
  
  #define NoReturn	__attribute__((__noreturn__))
! 									/* リターンしない関数 */
  
  /*
!  *  開発環境の標準インクルードファイルの利用
   *
!  *  NULLの定義をstddef.hから，INT_MAX，INT_MIN，UINT_MAX，LONG_MAX，
!  *  LONG_MIN，ULONG_MAX，CHAR_BITの定義をlimits.hから取り込む．
   *
!  *  C++/EC++では，標準仕様上はこれらのインクルードファイルが用意されて
!  *  いるとは限らないので注意が必要である（ほとんどの開発環境で用意され
!  *  ている）．
   */
  #ifndef TOPPERS_MACRO_ONLY
  #include <stddef.h>
***************
*** 83,126 ****
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  stdint.hѤȤʤ
   *
!  *  ȯĶstdint.hѰդƤ餺Υѥ
!  *  ƤϤޤˡstdint.hѤȤʤͿ롥
   *
!  *  TOPPERS_STDINT_TYPE1: char/short/int/long longΥӥåĹ줾
!  *                        8/16/32/64ӥåȤǡݥ󥿤ΥӥåĹlong
!  *                        ΥӥåĹȰפ
   */
  #ifdef TOPPERS_STDINT_TYPE1
  
  /*
!  *  ѥ¸Υǡ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
! typedef signed char			int8_t;		/* դ8ӥå */
! typedef unsigned char		uint8_t;	/* ̵8ӥå */
  
! typedef signed short		int16_t;	/* դ16ӥå */
! typedef unsigned short		uint16_t;	/* ̵16ӥå */
  
! typedef signed int			int32_t;	/* դ32ӥå */
! typedef unsigned int		uint32_t;	/* ̵32ӥå */
  
! typedef signed long long	int64_t;	/* դ64ӥå */
! typedef unsigned long long	uint64_t;	/* ̵64ӥå */
  
! typedef int8_t				int_least8_t;	/* 8ӥåȰʾդ */
! typedef uint8_t				uint_least8_t;	/* 8ӥåȰʾ̵ */
  
! typedef long				intptr_t;	/* ݥ󥿤ǼǤդ */
! typedef unsigned long		uintptr_t;	/* ݥ󥿤ǼǤ̵ */
  
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ѥ¸Υǡޥ
   */
  #ifndef INT8_C
  #define INT8_C(val)			(val)
--- 83,126 ----
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  stdint.hの代用となる定義
   *
!  *  開発環境にstdint.hが用意されておらず，各整数型のサイズがあるパター
!  *  ンに当てはまる場合に，stdint.hの代用となる定義を与える．
   *
!  *  TOPPERS_STDINT_TYPE1: char/short/int/long longのビット長がそれぞれ
!  *                        8/16/32/64ビットで，ポインタのビット長がlong
!  *                        のビット長と一致する場合
   */
  #ifdef TOPPERS_STDINT_TYPE1
  
  /*
!  *  コンパイラ依存のデータ型の定義
   */
  #ifndef TOPPERS_MACRO_ONLY
  
! typedef signed char			int8_t;		/* 符号付き8ビット整数 */
! typedef unsigned char		uint8_t;	/* 符号無し8ビット整数 */
  
! typedef signed short		int16_t;	/* 符号付き16ビット整数 */
! typedef unsigned short		uint16_t;	/* 符号無し16ビット整数 */
  
! typedef signed int			int32_t;	/* 符号付き32ビット整数 */
! typedef unsigned int		uint32_t;	/* 符号無し32ビット整数 */
  
! typedef signed long long	int64_t;	/* 符号付き64ビット整数 */
! typedef unsigned long long	uint64_t;	/* 符号無し64ビット整数 */
  
! typedef int8_t				int_least8_t;	/* 8ビット以上の符号付き整数 */
! typedef uint8_t				uint_least8_t;	/* 8ビット以上の符号無し整数 */
  
! typedef long				intptr_t;	/* ポインタを格納できる符号付き整数 */
! typedef unsigned long		uintptr_t;	/* ポインタを格納できる符号無し整数 */
  
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  コンパイラ依存のデータ型の整数定数を作るマクロ
   */
  #ifndef INT8_C
  #define INT8_C(val)			(val)
***************
*** 155,161 ****
  #endif /* UINT64_C */
  
  /*
!  *  ѥ¸Υǡ˳ǼǤͤȺǾͤ
   */
  #define INT8_MAX			SCHAR_MAX
  #define INT8_MIN			SCHAR_MIN
--- 155,161 ----
  #endif /* UINT64_C */
  
  /*
!  *  コンパイラ依存のデータ型に格納できる最大値と最小値の定義
   */
  #define INT8_MAX			SCHAR_MAX
  #define INT8_MIN			SCHAR_MIN
***************
*** 180,195 ****
  #endif /* TOPPERS_STDINT_TYPE1 */
  
  /*
!  *  ư˴ؤ
   *
!  *  TOPPERS_STDFLOAT_TYPE1: floatIEEE754ñư
!  *							doubleưξ
   */
  #ifdef TOPPERS_STDFLOAT_TYPE1
  #ifndef TOPPERS_MACRO_ONLY
  
! typedef float		float32_t;			/* IEEE754ñư */
! typedef double		double64_t;			/* IEEE754ư */
  
  #endif /* TOPPERS_MACRO_ONLY */
  
--- 180,195 ----
  #endif /* TOPPERS_STDINT_TYPE1 */
  
  /*
!  *  浮動小数点型に関する定義
   *
!  *  TOPPERS_STDFLOAT_TYPE1: floatがIEEE754準拠の単精度浮動小数点数，
!  *							doubleが倍精度浮動小数点数の場合
   */
  #ifdef TOPPERS_STDFLOAT_TYPE1
  #ifndef TOPPERS_MACRO_ONLY
  
! typedef float		float32_t;			/* IEEE754準拠の単精度浮動小数点数 */
! typedef double		double64_t;			/* IEEE754準拠の倍精度浮動小数点数 */
  
  #endif /* TOPPERS_MACRO_ONLY */
  
diff -cr --new-file 1.9.1/asp/arch/logtrace/trace_config.c ASPs/asp/arch/logtrace/trace_config.c
*** 1.9.1/asp/arch/logtrace/trace_config.c	Sun Nov 11 15:34:17 2012
--- ASPs/asp/arch/logtrace/trace_config.c	Fri Dec  9 13:53:57 2022
***************
*** 7,46 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: trace_config.c 2420 2012-11-11 06:34:11Z ertl-hiro $
   */
  
  /*
!  *		ȥ졼ǽ
   */
  
  #include "kernel_impl.h"
--- 7,46 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: trace_config.c 2420 2012-11-11 06:34:11Z ertl-hiro $
   */
  
  /*
!  *		トレースログ機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,64 ****
  #include <sil.h>
  
  /*
!  *  ȥ졼ХåեȤ˥뤿Υݥ
   */
! SYSLOG	trace_buffer[TCNT_TRACE_BUFFER];	/* ȥ졼Хåե */
! uint_t	trace_count;				/* ȥ졼ХåեΥο */
! uint_t	trace_head;					/* ƬΥȥ졼γǼ */
! uint_t	trace_tail;					/* Υȥ졼γǼ */
! MODE	trace_mode;					/* ȥ졼⡼ */
  
  /*
!  *  ȥ졼ǽν
   */
  void
  trace_initialize(intptr_t exinf)
--- 49,64 ----
  #include <sil.h>
  
  /*
!  *  トレースログバッファとそれにアクセスするためのポインタ
   */
! SYSLOG	trace_buffer[TCNT_TRACE_BUFFER];	/* トレースログバッファ */
! uint_t	trace_count;				/* トレースログバッファ中のログの数 */
! uint_t	trace_head;					/* 先頭のトレースログの格納位置 */
! uint_t	trace_tail;					/* 次のトレースログの格納位置 */
! MODE	trace_mode;					/* トレースモード */
  
  /*
!  *  トレースログ機能の初期化
   */
  void
  trace_initialize(intptr_t exinf)
***************
*** 72,78 ****
  }     
  
  /*
!  *  ȥ졼γ
   */
  ER
  trace_sta_log(MODE mode)
--- 72,78 ----
  }     
  
  /*
!  *  トレースログの開始
   */
  ER
  trace_sta_log(MODE mode)
***************
*** 87,93 ****
  }     
  
  /* 
!  *  ȥ졼ν
   */
  ER
  trace_wri_log(TRACE *p_trace)
--- 87,93 ----
  }     
  
  /* 
!  *  トレースログの書込み
   */
  ER
  trace_wri_log(TRACE *p_trace)
***************
*** 98,113 ****
  		SIL_LOC_INT();
  
  		/*
! 		 *  ȥ졼
  		 *
! 		 *  LOG_WRI_LOG_ENTERƤФ줿p_trace->logtim񤭴
! 		 *  ƤޤΤϵwri_logǾ񤭤뤿
! 		 *  Ϥʤ
  		 */
  		p_trace->logtim = TRACE_GET_TIM();
  
  		/*
! 		 *  ȥ졼Хåե˵Ͽ
  		 */
  		trace_buffer[trace_tail] = *p_trace;
  		trace_tail++;
--- 98,113 ----
  		SIL_LOC_INT();
  
  		/*
! 		 *  トレース時刻の設定
  		 *
! 		 *  LOG_WRI_LOG_ENTERから呼ばれた場合にp_trace->logtimを書き換
! 		 *  えてしまうのは気持ちが悪いが，wri_logの方で上書きするため問
! 		 *  題はない．
  		 */
  		p_trace->logtim = TRACE_GET_TIM();
  
  		/*
! 		 *  トレースバッファに記録
  		 */
  		trace_buffer[trace_tail] = *p_trace;
  		trace_tail++;
***************
*** 131,137 ****
  }
  
  /*
!  *  ȥ졼ɽФ
   */
  ER
  trace_rea_log(TRACE *p_trace)
--- 131,137 ----
  }
  
  /*
!  *  トレースログの読出し
   */
  ER
  trace_rea_log(TRACE *p_trace)
***************
*** 142,148 ****
  	SIL_LOC_INT();
  
  	/*
! 	 *  ȥ졼ХåեμФ
  	 */
  	if (trace_count > 0U) {
  		*p_trace = trace_buffer[trace_head];
--- 142,148 ----
  	SIL_LOC_INT();
  
  	/*
! 	 *  トレースログバッファからの取出し
  	 */
  	if (trace_count > 0U) {
  		*p_trace = trace_buffer[trace_head];
***************
*** 162,168 ****
  }
  
  /*
!  *  ȥ졼Ϥ뤿Υ饤֥ؿ
   */
  
  void
--- 162,168 ----
  }
  
  /*
!  *  トレースログを出力するためのライブラリ関数
   */
  
  void
***************
*** 208,215 ****
  }
  
  /*
!  *  ֥ǵҤ륳ɤȥ졼Ϥ뤿δ
!  *  
   */
  
  void
--- 208,215 ----
  }
  
  /*
!  *  アセンブリ言語で記述されるコードからトレースログを出力するための関
!  *  数
   */
  
  void
diff -cr --new-file 1.9.1/asp/arch/logtrace/trace_config.h ASPs/asp/arch/logtrace/trace_config.h
*** 1.9.1/asp/arch/logtrace/trace_config.h	Sun Nov 11 15:34:17 2012
--- ASPs/asp/arch/logtrace/trace_config.h	Fri Dec  9 13:53:57 2022
***************
*** 1,65 ****
  /*
   *  TOPPERS Software
   *      Toyohashi Open Platform for Embedded Real-Time Systems
!  * 
   *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
   *                              Toyohashi Univ. of Technology, JAPAN
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
!  * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
!  * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
!  * 
   *  $Id: trace_config.h 2420 2012-11-11 06:34:11Z ertl-hiro $
   */
  
  /*
!  *		ȥ졼˴ؤ
   *
!  *  Υ󥯥롼ɥեϡtarget_config.htarget_syssvc.h
!  *  ߤ饤󥯥롼ɤ롥ޤȥ졼ǽν䵭Ͽγ
!  *  ϡߡȥ졼ΥפԤץफ饤󥯥롼ɤ
!  *  ȤꤷƤ롥
   */
  
  #ifndef TOPPERS_TRACE_CONFIG_H
  #define TOPPERS_TRACE_CONFIG_H
  
  /*
!  *  ȥ졼ХåեΥ
   */
  #ifndef TCNT_TRACE_BUFFER
! #define TCNT_TRACE_BUFFER	1024
  #endif /* TCNT_TRACE_BUFFER */
  
  /*
!  *  ȥ졼μˡ
   */
  #ifndef TRACE_GET_TIM
  #define TRACE_GET_TIM()		(current_time)
--- 1,65 ----
  /*
   *  TOPPERS Software
   *      Toyohashi Open Platform for Embedded Real-Time Systems
!  *
   *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
   *                              Toyohashi Univ. of Technology, JAPAN
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
!  *
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
!  *
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
!  *
   *  $Id: trace_config.h 2420 2012-11-11 06:34:11Z ertl-hiro $
   */
  
  /*
!  *		トレースログに関する設定
   *
!  *  このインクルードファイルは，target_config.hおよびtarget_syssvc.hの
!  *  みからインクルードされる．また，トレースログ機能の初期化や記録の開
!  *  始／停止，トレースログのダンプを行うプログラムからインクルードする
!  *  ことを想定している．
   */
  
  #ifndef TOPPERS_TRACE_CONFIG_H
  #define TOPPERS_TRACE_CONFIG_H
  
  /*
!  *  トレースログバッファのサイズ
   */
  #ifndef TCNT_TRACE_BUFFER
! #define TCNT_TRACE_BUFFER	32
  #endif /* TCNT_TRACE_BUFFER */
  
  /*
!  *  トレース時刻の取得方法
   */
  #ifndef TRACE_GET_TIM
  #define TRACE_GET_TIM()		(current_time)
***************
*** 68,147 ****
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ȥ졼Υǡ¤
   *
!  *  ƥǽΥΥǡ¤ƱΤѤ롥
   */
  #include <t_syslog.h>
  typedef	SYSLOG	TRACE;
  
  /*
!  *  ȥ졼ХåեȤ˥뤿Υݥ
   */
! extern TRACE	trace_buffer[];		/* ȥ졼Хåե */
! extern uint_t	trace_count;		/* ȥ졼ХåեΥο */
! extern uint_t	trace_head;			/* ƬΥȥ졼γǼ */
! extern uint_t	trace_tail;			/* Υȥ졼γǼ */
! extern uint_t	trace_lost;			/* 줿ȥ졼ο */
  
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ȥ졼⡼ɤ
   */
! #define TRACE_STOP			UINT_C(0x00)	/* ȥ졼 */
! #define TRACE_RINGBUF		UINT_C(0x01)	/* 󥰥Хåե⡼ */
! #define TRACE_AUTOSTOP		UINT_C(0x02)	/* ưߥ⡼ */
! #define TRACE_CLEAR			UINT_C(0x04)	/* ȥ졼Υꥢ */
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ȥ졼ǽν
   *
!  *  ȥ졼ǽ롥롼ȤϿ뤳Ȥ
!  *  ꤷƤ롥ˤ꼡ưԤ
   *
!  *  TRACE_STOPΤߤǥȥ졼ϳϤʤ
!  *  TRACE_RINGBUF󥰥Хåե⡼ɤǥȥ졼򳫻ϡ
!  *  TRACE_AUTOSTOPưߥ⡼ɤǥȥ졼򳫻ϡ
   */
  extern void	trace_initialize(intptr_t exinf);
  
  /*
!  *  ȥ졼γ
   *
!  *  ȥ졼εϿ򳫻ϡߤ롥ˤ꼡ưԤ
   *
!  *  TRACE_STOPȥ졼ߡ
!  *  TRACE_RINGBUF󥰥Хåե⡼ɤǥȥ졼򳫻ϡ
!  *  TRACE_AUTOSTOPưߥ⡼ɤǥȥ졼򳫻ϡ
!  *  TRACE_CLEARȥ졼򥯥ꥢ
   */
  extern ER	trace_sta_log(MODE mode);
  
  /*
!  *  ȥ졼ν
   */
  extern ER	trace_wri_log(TRACE *p_trace);
  
  /*
!  *  ȥ졼ɽФ
   */
  extern ER	trace_rea_log(TRACE *p_trace);
  
! /* 
!  *  ȥ졼Υסtrace_dump.c
   *
!  *  ȥ졼פ롥λ롼ȤϿ뤳Ȥ
!  *  Ƥ롥ȤơȤʤʸϴؿؤΥݥ󥿤Ϥ
!  *  åȰ¸٥ʸϤѤˤϡtarget_putc
!  *  
   */
  extern void	trace_dump(intptr_t exinf);
  
  /*
!  *  ȥ졼Ϥ뤿Υ饤֥ؿ
   */
  extern void	trace_write_0(uint_t type);
  extern void	trace_write_1(uint_t type, intptr_t arg1);
--- 68,147 ----
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  トレースログのデータ構造
   *
!  *  システムログ機能のログ情報のデータ構造と同じものを用いる．
   */
  #include <t_syslog.h>
  typedef	SYSLOG	TRACE;
  
  /*
!  *  トレースログバッファとそれにアクセスするためのポインタ
   */
! extern TRACE	trace_buffer[];		/* トレースログバッファ */
! extern uint_t	trace_count;		/* トレースログバッファ中のログの数 */
! extern uint_t	trace_head;			/* 先頭のトレースログの格納位置 */
! extern uint_t	trace_tail;			/* 次のトレースログの格納位置 */
! extern uint_t	trace_lost;			/* 失われたトレースの数 */
  
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  トレースモードの定義
   */
! #define TRACE_STOP			UINT_C(0x00)	/* トレース停止 */
! #define TRACE_RINGBUF		UINT_C(0x01)	/* リングバッファモード */
! #define TRACE_AUTOSTOP		UINT_C(0x02)	/* 自動停止モード */
! #define TRACE_CLEAR			UINT_C(0x04)	/* トレースログのクリア */
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  トレースログ機能の初期化
   *
!  *  トレースログ機能を初期化する．初期化ルーチンとして登録することを想
!  *  定している．引数により次の動作を行う．
   *
!  *  TRACE_STOP：初期化のみでトレースは開始しない．
!  *  TRACE_RINGBUF：リングバッファモードでトレースを開始．
!  *  TRACE_AUTOSTOP：自動停止モードでトレースを開始．
   */
  extern void	trace_initialize(intptr_t exinf);
  
  /*
!  *  トレースログの開始
   *
!  *  トレースログの記録を開始／停止する．引数により次の動作を行う．
   *
!  *  TRACE_STOP：トレースを停止．
!  *  TRACE_RINGBUF：リングバッファモードでトレースを開始．
!  *  TRACE_AUTOSTOP：自動停止モードでトレースを開始．
!  *  TRACE_CLEAR：トレースログをクリア．
   */
  extern ER	trace_sta_log(MODE mode);
  
  /*
!  *  トレースログの書込み
   */
  extern ER	trace_wri_log(TRACE *p_trace);
  
  /*
!  *  トレースログの読出し
   */
  extern ER	trace_rea_log(TRACE *p_trace);
  
! /*
!  *  トレースログのダンプ（trace_dump.c）
   *
!  *  トレースログをダンプする．終了処理ルーチンとして登録することも想定
!  *  している．引数として，ダンプ先となる文字出力関数へのポインタを渡す．
!  *  ターゲット依存の低レベル文字出力を利用する場合には，target_putcを渡
!  *  す．
   */
  extern void	trace_dump(intptr_t exinf);
  
  /*
!  *  トレースログを出力するためのライブラリ関数
   */
  extern void	trace_write_0(uint_t type);
  extern void	trace_write_1(uint_t type, intptr_t arg1);
***************
*** 150,156 ****
  														intptr_t arg3);
  
  /*
!  *  ȥ졼Ϥ뤿Υޥ
   */
  
  #define trace_0(type) \
--- 150,156 ----
  														intptr_t arg3);
  
  /*
!  *  トレースログを出力するためのマクロ
   */
  
  #define trace_0(type) \
***************
*** 169,181 ****
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ȥ졼ˡ
   */
! #define LOG_TSKSTAT(p_tcb)		trace_2(LOG_TYPE_TSKSTAT, p_tcb, p_tcb->tstat)
  
! #define LOG_DSP_LEAVE(p_tcb)	trace_1(LOG_TYPE_DSP|LOG_LEAVE, p_tcb)
  
! #define LOG_SYSLOG_WRI_LOG_ENTER(prio, p_syslog) \
  								trace_wri_log((TRACE *) p_syslog)
  
  #endif /* TOPPERS_TRACE_CONFIG_H */
--- 169,181 ----
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  トレースログ方法の設定
   */
! //#define LOG_TSKSTAT(p_tcb)		trace_2(LOG_TYPE_TSKSTAT, p_tcb, p_tcb->tstat)
  
! //#define LOG_DSP_LEAVE(p_tcb)	trace_1(LOG_TYPE_DSP|LOG_LEAVE, p_tcb)
  
! //#define LOG_SYSLOG_WRI_LOG_ENTER(prio, p_syslog)                  \
  								trace_wri_log((TRACE *) p_syslog)
  
  #endif /* TOPPERS_TRACE_CONFIG_H */
diff -cr --new-file 1.9.1/asp/arch/logtrace/trace_dump.c ASPs/asp/arch/logtrace/trace_dump.c
*** 1.9.1/asp/arch/logtrace/trace_dump.c	Sun Nov 11 15:34:17 2012
--- ASPs/asp/arch/logtrace/trace_dump.c	Fri Dec  9 13:53:57 2022
***************
*** 1,52 ****
  /*
   *  TOPPERS Software
   *      Toyohashi Open Platform for Embedded Real-Time Systems
!  * 
   *  Copyright (C) 2007-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
!  * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
!  * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
!  * 
   *  $Id: trace_dump.c 2420 2012-11-11 06:34:11Z ertl-hiro $
   */
  
  /*
!  *		ȥ졼Υ
   */
  
  #include "kernel_impl.h"
  #include "task.h"
  #include <log_output.h>
  
! /* 
!  *  ͥμФ
   */
  static intptr_t
  get_tskid(intptr_t info)
--- 1,52 ----
  /*
   *  TOPPERS Software
   *      Toyohashi Open Platform for Embedded Real-Time Systems
!  *
   *  Copyright (C) 2007-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
!  *
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
!  *
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
!  *
   *  $Id: trace_dump.c 2420 2012-11-11 06:34:11Z ertl-hiro $
   */
  
  /*
!  *		トレースログのダンプ
   */
  
  #include "kernel_impl.h"
  #include "task.h"
  #include <log_output.h>
  
! /*
!  *  カーネル情報の取出し
   */
  static intptr_t
  get_tskid(intptr_t info)
***************
*** 94,101 ****
  	return((intptr_t) tstatstr);
  }
  
! /* 
!  *  ȥ졼ɽ
   */
  static void
  trace_print(TRACE *p_trace, void (*putc)(char))
--- 94,101 ----
  	return((intptr_t) tstatstr);
  }
  
! /*
!  *  トレースログの表示
   */
  static void
  trace_print(TRACE *p_trace, void (*putc)(char))
***************
*** 113,121 ****
  		traceinfo[1] = get_tskstat(p_trace->loginfo[1]);
  		tracemsg = "task %d becomes %s.";
  		break;
  	case LOG_TYPE_DSP|LOG_LEAVE:
  		traceinfo[0] = get_tskid(p_trace->loginfo[0]);
! 		tracemsg = "dispatch to task %d.";
  		break;
  	case LOG_TYPE_COMMENT:
  		for (i = 1; i < TMAX_LOGINFO; i++) {
--- 113,133 ----
  		traceinfo[1] = get_tskstat(p_trace->loginfo[1]);
  		tracemsg = "task %d becomes %s.";
  		break;
+ 	case LOG_TYPE_DSP|LOG_ENTER:
+ 		traceinfo[0] = get_tskid(p_trace->loginfo[0]);
+ 		tracemsg = "dispatch from task %d";
+ 		break;
  	case LOG_TYPE_DSP|LOG_LEAVE:
  		traceinfo[0] = get_tskid(p_trace->loginfo[0]);
! 		tracemsg = "dispatch to task %d";
! 		break;
! 	case LOG_TYPE_INH|LOG_ENTER:
! 		traceinfo[0] = p_trace->loginfo[0];
! 		tracemsg = "enter int no. %d";
! 		break;
! 	case LOG_TYPE_INH|LOG_LEAVE:
! 		traceinfo[0] = p_trace->loginfo[0];
! 		tracemsg = "leave int no. %d.";
  		break;
  	case LOG_TYPE_COMMENT:
  		for (i = 1; i < TMAX_LOGINFO; i++) {
***************
*** 138,146 ****
  	(*putc)('\n');
  }
  
! /* 
!  *  ȥ졼Υ
   */
  void
  trace_dump(intptr_t exinf)
  {
--- 150,162 ----
  	(*putc)('\n');
  }
  
! /*
!  *  トレースログのダンプ
   */
+ extern uint_t	trace_count;				/* トレースログバッファ中のログの数 */
+ extern uint_t	trace_head;					/* 先頭のトレースログの格納位置 */
+ extern uint_t	trace_tail;					/* 次のトレースログの格納位置 */
+ 
  void
  trace_dump(intptr_t exinf)
  {
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/MANIFEST ASPs/asp/arch/m68k_gcc/MANIFEST
*** 1.9.1/asp/arch/m68k_gcc/MANIFEST	Sun Apr 10 20:42:40 2011
--- ASPs/asp/arch/m68k_gcc/MANIFEST	Thu Jan  1 09:00:00 1970
***************
*** 1,21 ****
- PACKAGE asp
- 
- MANIFEST
- Makefile.prc
- m68kelf.ld
- makeoffset.c
- prc_cfg1_out.h
- prc_config.c
- prc_config.h
- prc_def.csv
- prc_insn.h
- prc_kernel.h
- prc_offset.tf
- prc_rename.def
- prc_rename.h
- prc_sil.h
- prc_stddef.h
- prc_support.S
- prc_test.h
- prc_unrename.h
- start.S
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/Makefile.prc ASPs/asp/arch/m68k_gcc/Makefile.prc
*** 1.9.1/asp/arch/m68k_gcc/Makefile.prc	Wed Mar 30 23:04:45 2011
--- ASPs/asp/arch/m68k_gcc/Makefile.prc	Thu Jan  1 09:00:00 1970
***************
*** 1,36 ****
- #
- #		MakefileΥץå¸M68040ѡ
- #
- 
- #
- #  GNUȯĶΥåȥƥ
- #
- GCC_TARGET = m68k-unknown-elf
- 
- #
- #  ץå¸ǥ쥯ȥ̾
- #
- PRCDIR = $(SRCDIR)/arch/$(PRC)_$(TOOL)
- 
- #
- #  ѥ륪ץ
- #
- COPTS := $(COPTS) -m68020-40 -msoft-float
- LDFLAGS := $(LDFLAGS) -msoft-float
- 
- #
- #  ͥ˴ؤ
- #
- KERNEL_DIR := $(KERNEL_DIR) $(PRCDIR)
- KERNEL_ASMOBJS := $(KERNEL_ASMOBJS) prc_support.o
- KERNEL_COBJS := $(KERNEL_COBJS) prc_config.o
- 
- #
- #  ե졼طѿ
- #
- CFG_TABS := $(CFG_TABS) --cfg1-def-table $(PRCDIR)/prc_def.csv
- 
- #
- #  եåȥեΤ
- #
- OFFSET_TF = $(PRCDIR)/prc_offset.tf
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/m68kelf.ld ASPs/asp/arch/m68k_gcc/m68kelf.ld
*** 1.9.1/asp/arch/m68k_gcc/m68kelf.ld	Sat Apr 12 10:31:25 2008
--- ASPs/asp/arch/m68k_gcc/m68kelf.ld	Thu Jan  1 09:00:00 1970
***************
*** 1,78 ****
- /*
-  *  @(#) $Id: m68kelf.ld 127 2007-06-19 07:23:10Z hiro $
-  */
- 
- OUTPUT_FORMAT("elf32-m68k","elf32-m68k","elf32-m68k")
- OUTPUT_ARCH(m68k)
- STARTUP(start.o)
- 
- PROVIDE (__stack = 0) ;
- PROVIDE (hardware_init_hook = 0) ;
- PROVIDE (software_init_hook = 0) ;
- PROVIDE (software_term_hook = 0) ;
- SECTIONS
- {
-     .init :
-     {
-         KEEP (*(.init))
-     }
-     .text :
-     {
-         __text = . ;
-         *(.text .stub .text.* .gnu.linkonce.t.*)
- 
-     }
-     .fini :
-     {
-         KEEP (*(.fini))
-     }
-     _etext = . ;
-     PROVIDE (etext = .) ;
-     .rodata :
-     {
-         *(.rodata .rodata.* .gnu.linkonce.r.*)
-     }
-     . = ALIGN(4) ;
-     __idata_start = . ;
-     .data : AT(__idata_start) 
-     {
-         __data_start = . ;
-         *(.data)
-     }
-     .eh_frame : { KEEP (*(.eh_frame)) }
-     .gcc_except_table : { *(.gcc_except_table) }
-     .ctors :
-     {
-         KEEP (*crtbegin.o(.ctors))
-         KEEP (*(EXCLUDE_FILE (*crtend.o ) .ctors))
-         KEEP (*(SORT(.ctors.*)))
-         KEEP (*(.ctors))
-     }
-     .dtors :
-     {
-         KEEP (*crtbegin.o(.dtors))
-         KEEP (*(EXCLUDE_FILE (*crtend.o ) .dtors))
-         KEEP (*(SORT(.dtors.*)))
-         KEEP (*(.dtors))
-     }
-     __idata_end = __idata_start + SIZEOF(.data) ;
-     _edata  = . ;
-     PROVIDE (edata = .) ;
-     . = ALIGN(4) ;
-     __bss_start = . ;
-     .bss :
-     {
-         *(.bss)
-         *(COMMON)
-     }
-     _end = . ;
-     __bss_end = . ;
-     PROVIDE (end = .) ;
-     .comment        0 : { *(.comment) }
-     .debug          0 : { *(.debug) }
-     .line           0 : { *(.line) }
-     .debug_srcinfo  0 : { *(.debug_srcinfo) }
-     .debug_sfnames  0 : { *(.debug_sfnames) }
-     .debug_aranges  0 : { *(.debug_aranges) }
-     .debug_pubnames 0 : { *(.debug_pubnames) }
- }
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/makeoffset.c ASPs/asp/arch/m68k_gcc/makeoffset.c
*** 1.9.1/asp/arch/m68k_gcc/makeoffset.c	Mon Aug  6 11:45:37 2012
--- ASPs/asp/arch/m68k_gcc/makeoffset.c	Thu Jan  1 09:00:00 1970
***************
*** 1,105 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: makeoffset.c 2395 2012-08-06 02:45:37Z ertl-hiro $
-  */
- 
- #include "kernel_impl.h"
- #include "task.h"
- #include "sil.h"
- 
- #define OFFSET_DEF(TYPE, FIELD)							\
- 	Asm("OFFSET_DEF " #TYPE "_" #FIELD " = %0"			\
- 	  : /* no output */									\
- 	  : "g"(offsetof(TYPE, FIELD)))
- 
- #define OFFSET_DEF2(TYPE, FIELD, FIELDNAME)				\
- 	Asm("OFFSET_DEF " #TYPE "_" #FIELDNAME " = %0"		\
- 	  : /* no output */									\
- 	  : "g"(offsetof(TYPE, FIELD)))
- 
- void
- makeoffset(void)
- {
- 	OFFSET_DEF(TCB, p_tinib);
- 	OFFSET_DEF(TCB, texptn);
- 	OFFSET_DEF2(TCB, tskctxb.msp, msp);
- 	OFFSET_DEF2(TCB, tskctxb.pc, pc);
- 
- 	OFFSET_DEF(TINIB, exinf);
- 	OFFSET_DEF(TINIB, task);
- }
- 
- void
- sil_endian(void)
- {
- #ifdef SIL_ENDIAN_BIG			/* ӥåǥץå */
- 	Asm("SIL_ENDIAN = BIG");
- #else /* SIL_ENDIAN_BIG */
- #ifdef SIL_ENDIAN_LITTLE		/* ȥ륨ǥץå */
- 	Asm("SIL_ENDIAN = LITTLE");
- #endif /* SIL_ENDIAN_LITTLE */
- #endif /* SIL_ENDIAN_BIG */
- }
- 
- uint32_t	BIT_REF_4 = 0x12345678;
- uint16_t	BIT_REF_2 = 0x1234;
- uint8_t		BIT_REF_1 = 0x12;
- 
- TCB	BIT_BB_TCB_enatex = {
- 	{ NULL, NULL },			/* task_queue */
- 	NULL,					/* p_tinib */
- 	0U,						/* tstat */
- #ifdef TOPPERS_SUPPORT_MUTEX
- 	0U,						/* bpriority */
- #endif /* TOPPERS_SUPPORT_MUTEX */
- 	0U,						/* priority */
- 	false,					/* acqeue */
- 	false,					/* wupque */
- 	true,					/* enatex */
- 	0U,						/* texptn */
- 	NULL,					/* p_winifo */
- #ifdef TOPPERS_SUPPORT_MUTEX
- 	{ NULL, NULL },			/* mutex_queue */
- #endif /* TOPPERS_SUPPORT_MUTEX */
- #ifdef TOPPERS_SUPPORT_OVRHDR
- 	0U,						/* leftotm */
- #endif /* TOPPERS_SUPPORT_OVRHDR */
- 	{ NULL, NULL }			/* tskctxb */
- };
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_cfg1_out.h ASPs/asp/arch/m68k_gcc/prc_cfg1_out.h
*** 1.9.1/asp/arch/m68k_gcc/prc_cfg1_out.h	Mon Aug  6 11:38:29 2012
--- ASPs/asp/arch/m68k_gcc/prc_cfg1_out.h	Thu Jan  1 09:00:00 1970
***************
*** 1,48 ****
- /*
-  *		cfg1_out.cΥ󥯤ɬפʥ֤
-  */
- 
- void sta_ker(void)
- {
- }
- 
- void hardware_init_hook(void)
- {
- }
- 
- void software_init_hook(void)
- {
- }
- 
- const SIZE		_kernel_istksz = 0;
- 
- STK_T *const	_kernel_istk = NULL;
- 
- /*
-  *  եåȥե뤿
-  */
- const uint8_t	MAGIC_1 = 0x12;
- const uint16_t	MAGIC_2 = 0x1234;
- const uint32_t	MAGIC_4 = 0x12345678;
- 
- const TCB	TCB_enatex = {
- 	{ NULL, NULL },			/* task_queue */
- 	NULL,					/* p_tinib */
- 	0U,						/* tstat */
- #ifdef TOPPERS_SUPPORT_MUTEX
- 	0U,						/* bpriority */
- #endif /* TOPPERS_SUPPORT_MUTEX */
- 	0U,						/* priority */
- 	false,					/* acqeue */
- 	false,					/* wupque */
- 	true,					/* enatex */
- 	0U,						/* texptn */
- 	NULL,					/* p_winifo */
- #ifdef TOPPERS_SUPPORT_MUTEX
- 	{ NULL, NULL },			/* mutex_queue */
- #endif /* TOPPERS_SUPPORT_MUTEX */
- #ifdef TOPPERS_SUPPORT_OVRHDR
- 	0U,						/* leftotm */
- #endif /* TOPPERS_SUPPORT_OVRHDR */
- 	{ NULL, NULL }			/* tskctxb */
- };
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_config.c ASPs/asp/arch/m68k_gcc/prc_config.c
*** 1.9.1/asp/arch/m68k_gcc/prc_config.c	Thu Jan 15 02:38:01 2009
--- ASPs/asp/arch/m68k_gcc/prc_config.c	Thu Jan  1 09:00:00 1970
***************
*** 1,130 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: prc_config.c 1430 2009-01-14 17:37:56Z ertl-hiro $
-  */
- 
- /*
-  *		ץå¸⥸塼M68040ѡ
-  */
- 
- #include "kernel_impl.h"
- #include "check.h"
- #include "task.h"
- 
- /*
-  *  CPUåե饰¸Τѿ
-  */
- volatile bool_t		lock_flag;		/* CPUåե饰ͤݻѿ */
- volatile uint16_t	saved_iipm;		/* ͥ٥ޥ¸ѿ */
- 
- /*
-  *  ץå¸ν
-  */
- void
- prc_initialize(void)
- {
- 	/*
- 	 *  CPUåե饰¸Τѿν
- 	 */
- 	lock_flag = true;
- 	saved_iipm = IIPM_ENAALL;
- 
- 	/*
- 	 *  㳰٥ơ֥ν
- 	 */
- #ifdef EXCVT_KERNEL
- 	memcpy(EXCVT_KERNEL, EXCVT_ORIG, EXCVT_LEN);
- 	set_vbr(EXCVT_KERNEL);
- #endif /* EXCVT_KERNEL */
- }
- 
- /*
-  *  ץå¸νλ
-  */
- void
- prc_terminate(void)
- {
- 	extern void	software_term_hook(void);
- 	void (*volatile fp)(void) = software_term_hook;
- 
- 	/*
- 	 *  software_term_hookؤΥݥ󥿤򡤰övolatileΤfp
- 	 *  ƤȤΤϡ0ȤӤŬǺʤ褦ˤ뤿
- 	 *  Ǥ롥
- 	 */
- 	if (fp != 0) {
- 		(*fp)();
- 	}
- 
- #ifdef EXCVT_KERNEL
- 	set_vbr(EXCVT_ORIG);
- #endif /* EXCVT_KERNEL */
- }
- 
- /*
-  *  CPU㳰ȯΥ
-  *
-  *  CPU㳰ϥɥ椫顤CPU㳰ݥ󥿡p_excinfˤȤ
-  *  ƸƤӽФȤǡCPU㳰ȯ򥷥ƥ˽Ϥ롥
-  */
- #ifdef SUPPORT_XLOG_SYS
- 
- void
- xlog_sys(void *p_excinf)
- {
- 	char	*excsp = (char *) p_excinf;
- 	uint_t	format;
- 
- 	syslog_0(LOG_ERROR, "CPU Exception Information:");
- 	syslog_4(LOG_ERROR, "SR = %04x (M = %d, S = %d, IPM = %d)",
- 				*((uint16_t *) excsp),
- 				(*((uint16_t *) excsp) & 0x1000U) >> 12,
- 				(*((uint16_t *) excsp) & 0x2000U) >> 13,
- 				(*((uint16_t *) excsp) & 0x0700U) >> 8);
- 	syslog_1(LOG_ERROR, "PC = %08x", *((uint32_t *)(excsp + 2)));
- 	format = (*((uint16_t *)(excsp + 6)) & 0xf000U) >> 12;
- 	syslog_2(LOG_ERROR, "Format = %d, Vector Offset = %03x",
- 				format, (*((uint16_t *)(excsp + 6)) & 0x0fffU));
- 	if (format >= 2U) {
- 		syslog_1(LOG_ERROR, "ADR = %08x", *((uint32_t *)(excsp + 8)));
- 	}
- }
- 
- #endif /* SUPPORT_XLOG_SYS */
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_config.h ASPs/asp/arch/m68k_gcc/prc_config.h
*** 1.9.1/asp/arch/m68k_gcc/prc_config.h	Fri Dec 31 21:47:36 2010
--- ASPs/asp/arch/m68k_gcc/prc_config.h	Thu Jan  1 09:00:00 1970
***************
*** 1,603 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  $Id: prc_config.h 2013 2010-12-31 12:47:36Z ertl-hiro $
-  */
- 
- /*
-  *		ץå¸⥸塼M68040ѡ
-  *
-  *  Υ󥯥롼ɥեϡtarget_config.hʤޤϡ饤
-  *  롼ɤեˤΤߤ饤󥯥롼ɤ롥¾Υե뤫
-  *  ľܥ󥯥롼ɤƤϤʤʤ
-  */
- 
- #ifndef TOPPERS_PRC_CONFIG_H
- #define TOPPERS_PRC_CONFIG_H
- 
- #ifndef TOPPERS_MACRO_ONLY
- 
- /*
-  *  ץåü̿Υ饤ؿ
-  */
- #include "prc_insn.h"
- 
- /*
-  *  ƥȥ֥å
-  */
- typedef struct task_context_block {
- 	void	*msp;		/* åݥ */
- 	FP		pc;			/* ץ५ */
- } TSKCTXB;
- 
- #endif /* TOPPERS_MACRO_ONLY */
- 
- /*
-  *  ͥ٥ޥ饤֥
-  *
-  *  M68040Ǥϡơ쥸SRˤβ810ӥåȤ3ӥå
-  *  ˳ͥ٥ޥʥϡɥγͥ٥ޥIPMˤ֤
-  *  Ƥ롥IPM¸Ƥˡͥ٤γɽ-1Ϣ
-  *  ³͡ˤȤȤǽǤ뤬;פʺӥåȥեȤ
-  *  ȿžɬפˤʤ롥򤱤뤿ˡIPM¸ˤϡSR
-  *  810ӥåȤФͤȤȤˤ롥ͤͥ٥
-  *  ɽȸƤӡIIPMȽ񤯤Ȥˤ롥
-  */
- 
- /*
-  *  ͥ٥ޥγɽɽѴ
-  */
- #define EXT_IPM(iipm)	(-CAST(PRI, (iipm) >> 8))		/* ɽѴ */
- #define INT_IPM(ipm)	(CAST(uint16_t, -(ipm)) << 8)	/* ɽѴ */
- 
- #ifndef TOPPERS_MACRO_ONLY
- 
- /*
-  *  IPMʥϡɥγͥ٥ޥɽˤθͤɽФ
-  */
- Inline uint16_t
- current_iipm(void)
- {
- 	return(current_sr() & 0x0700U);
- }
- 
- /*
-  *  IPMʥϡɥγͥ٥ޥɽˤθͤ
-  */
- Inline void
- set_iipm(uint16_t iipm)
- {
- 	set_sr((current_sr() & ~0x0700U) | iipm);
- }
- 
- /*
-  *  TOPPERSɸ߽ǥμ¸
-  *
-  *  M68040ϡơ쥸SR˳ͥ٥ޥʥϡɥ
-  *  γͥ٥ޥIPMˤäƤ뤬CPUåե饰
-  *  뵡ǽʤΤᡤCPUåե饰εǽIPMˤä
-  *  ¸롥
-  *
-  *  ޤCPUåե饰͡ʤʤCPUå֤CPUå
-  *  ˤϡΤѿlock_flagˤѰդݻ롥
-  *
-  *  CPUåե饰ꥢƤ֡ʤʤCPUå֤
-  *  ֡ˤϡIPMʥϡɥγͥ٥ޥˤ򡤥ǥγ
-  *  ͥ٥ޥͤꤹ롥δ֤ϡǥγͥ٥ޥ
-  *  ϡIPMѤݻ롥
-  *
-  *  ФCPUåե饰åȤƤ֡ʤʤCPU
-  *  ֤δ֡ˤϡIPMʥϡɥγͥ٥ޥˤ򡤥ͥ
-  *  γߤ򤹤٤ƥޥ͡TIPM_LOCKˤȡǥγͥ
-  *  ٥ޥȤι⤤ꤹ롥δ֤Υǥγͥ٥ޥ
-  *  ϡΤѿsaved_iipmɽݻˤѰդݻ
-  *  롥
-  */
- 
- /*
-  *  ƥȤλ
-  *
-  *  M68040ǤϡƥȤޥ⡼ɤǡ󥿥ƥ
-  *  Ȥߥ⡼ɤǼ¹Ԥ롥ޥ⡼ɤߥ⡼ɤϡơ
-  *  쥸SRγߥ⡼ɥӥåȤˤȽ̤Ǥ롥
-  */
- Inline bool_t
- sense_context(void)
- {
- 	return((current_sr() & 0x1000U) == 0U);
- }
- 
- #endif /* TOPPERS_MACRO_ONLY */
- 
- /*
-  *  CPUå֤Ǥγͥ٥ޥ
-  *
-  *  TIPM_LOCKϡͥγߤ򤹤٤ƥޥͤ롥
-  *
-  *  TIPM_LOCKϡŪˤTMIN_INTPRI˰פФ褤M68040Ǥϡ
-  *  IPMʥϡɥγͥ٥ޥˤ-6ξ-7ξο
-  *  ƱǡIPM-7ꤹ뤳ȤϸΨŪ˹Ԥ뤳Ȥ顤
-  *  TMIN_INTPRI-6λTIPM_LOCK-7ˤƤ롥
-  */
- #if TMIN_INTPRI == -6		/* NMIʳ˥ͥγߤߤʤ */
- #define TIPM_LOCK		(-7)
- #else /* TMIN_INTPRI == -6 */
- #if (-1 >= TMIN_INTPRI) && (TMIN_INTPRI > -6)
- #define TIPM_LOCK		TMIN_INTPRI
- #else /* (-1 >= TMIN_INTPRI) && (TMIN_INTPRI > -6) */
- #error TMIN_INTPRI out of range.
- #endif /* (-1 >= TMIN_INTPRI) && (TMIN_INTPRI > -6) */
- #endif /* TMIN_INTPRI == -6 */
- 
- /*
-  *  CPUå֤Ǥγͥ٥ޥɽ
-  */
- #define IIPM_LOCK		INT_IPM(TIPM_LOCK)
- 
- /*
-  *  TIPM_ENAALLʳͥ٥ޥˤɽ
-  */
- #define IIPM_ENAALL		INT_IPM(TIPM_ENAALL)
- 
- #ifndef TOPPERS_MACRO_ONLY
- 
- /*
-  *  CPUåե饰¸Τѿ
-  *
-  *  ѿϡCPUå֤λΤ߽񤭴Ƥ褤ΤȤ롥
-  */
- extern volatile bool_t		lock_flag;	/* CPUåե饰ͤݻѿ */
- extern volatile uint16_t	saved_iipm;	/* ͥ٥ޥ¸ѿ */
- 
- /*
-  *  CPUå֤ؤΰܹ
-  *
-  *  IPMʥϡɥγͥ٥ޥˤsaved_iipm¸
-  *  ͥγߤ򤹤٤ƥޥ͡TIPM_LOCKˤꤹ롥ޤ
-  *  lock_flagtrueˤ롥
-  *
-  *  IPMǽ餫TIPM_LOCKƱ⤤ˤϡ
-  *  saved_iipm¸ΤߤǡTIPM_LOCKˤꤷʤϡǥ
-  *  γͥ٥ޥTIPM_LOCKƱ⤤٥
-  *  Ƥ֤ˤ롥
-  *
-  *  δؿϡCPUå֡lock_flagtrueξ֡ˤǸƤФ뤳Ȥ
-  *  ʤΤꤷƤ롥
-  */
- Inline void
- x_lock_cpu(void)
- {
- 	uint16_t	iipm;
- 
- 	/*
- 	 *  current_iipm()֤ͤľsaved_iipm¸ѿiipm
- 	 *  ѤƤΤϡcurrent_iipm()Ƥľ˳ߤȯ
- 	 *  ư줿߽saved_iipmѹǽ뤿
- 	 *  롥
- 	 */
- 	iipm = current_iipm();
- #if TIPM_LOCK == -7
- 	disint();
- #else /* TIPM_LOCK == -7 */
- 	if (IIPM_LOCK > iipm) {
- 		set_iipm(IIPM_LOCK);
- 	}
- #endif /* TIPM_LOCK == -7 */
- 	saved_iipm = iipm;
- 	lock_flag = true;
- 	Asm("":::"memory");
- }
- 
- #define t_lock_cpu()	x_lock_cpu()
- #define i_lock_cpu()	x_lock_cpu()
- 
- /*
-  *  CPUå֤β
-  *
-  *  lock_flagfalseˤIPMʥϡɥγͥ٥ޥˤ
-  *  saved_iipm¸᤹ͤ
-  *
-  *  δؿϡCPUå֡lock_flagtrueξ֡ˤǤΤ߸ƤФ
-  *  ΤꤷƤ롥
-  */
- Inline void
- x_unlock_cpu(void)
- {
- 	Asm("":::"memory");
- 	lock_flag = false;
- 	set_iipm(saved_iipm);
- }
- 
- #define t_unlock_cpu()	x_unlock_cpu()
- #define i_unlock_cpu()	x_unlock_cpu()
- 
- /*
-  *  CPUå֤λ
-  */
- Inline bool_t
- x_sense_lock(void)
- {
- 	return(lock_flag);
- }
- 
- #define t_sense_lock()	x_sense_lock()
- #define i_sense_lock()	x_sense_lock()
- 
- /*
-  *  chg_ipmͭʳͥ٤ϰϤȽ
-  *
-  *  TMIN_INTPRIͤˤ餺chg_ipmǤϡ-6TIPM_ENAALLʡ0ˤϰ
-  *  Ǥ뤳ȤȤʥåγĥˡ
-  */
- #define VALID_INTPRI_CHGIPM(intpri) \
- 				(-6 <= (intpri) && (intpri) <= TIPM_ENAALL)
- 
- /*
-  * ʥǥΡ˳ͥ٥ޥ
-  *
-  *  CPUåե饰ꥢƤϡϡɥγͥ٥
-  *  ꤹ롥CPUåե饰åȤƤϡsaved_iipm
-  *  ꤷˡϡɥγͥ٥ޥꤷ褦
-  *  ʥǥΡ˳ͥ٥ޥTIPM_LOCKι⤤ꤹ롥
-  */
- Inline void
- x_set_ipm(PRI intpri)
- {
- 	uint16_t	iipm = INT_IPM(intpri);
- 
- 	if (!lock_flag) {
- 		set_iipm(iipm);
- 	}
- 	else {
- 		saved_iipm = iipm;
- #if TIPM_LOCK == -7
- 		/*
- 		 *  TIPM_LOCK-7ξˤϡλǥϡɥγͥ
- 		 *  ٥ޥɬ7ꤵƤ뤿ᡤꤷʤɬפʤ
- 		 */
- #else /* TIPM_LOCK == -7 */
- 		set_iipm(iipm > IIPM_LOCK ? iipm : IIPM_LOCK);
- #endif /* TIPM_LOCK == -7 */
- 	}
- }
- 
- #define t_set_ipm(intpri)	x_set_ipm(intpri)
- #define i_set_ipm(intpri)	x_set_ipm(intpri)
- 
- /*
-  * ʥǥΡ˳ͥ٥ޥλ
-  *
-  *  CPUåե饰ꥢƤϥϡɥγͥ٥
-  *  򡤥åȤƤsaved_iipm򻲾Ȥ롥
-  */
- Inline PRI
- x_get_ipm(void)
- {
- 	uint16_t	iipm;
- 
- 	if (!lock_flag) {
- 		iipm = current_iipm();
- 	}
- 	else {
- 		iipm = saved_iipm;
- 	}
- 	return(EXT_IPM(iipm));
- }
- 
- #define t_get_ipm()		x_get_ipm()
- #define i_get_ipm()		x_get_ipm()
- 
- /*
-  *  ǹ̥ͥؤΥǥѥåprc_support.S
-  *
-  *  dispatchϡƥȤƤӽФ줿ӥ
-  *  ƤӽФ٤ΤǡƥȡCPUå֡ǥѥ
-  *  ľ֡ʥǥΡ˳ͥ٥ޥ֤ǸƤӽФ
-  *  Фʤʤ
-  */
- extern void	dispatch(void);
- 
- /*
-  *  ǥѥåưϡprc_support.S
-  *
-  *  start_dispatchϡͥ뵯ư˸ƤӽФ٤Τǡ٤Ƥγ
-  *  ߤػߤ֡ʳߥå֤Ʊξ֡ˤǸƤӽФʤ
-  *  ʤʤ
-  */
- extern void	start_dispatch(void) NoReturn;
- 
- /*
-  *  ߤΥƥȤΤƤƥǥѥåprc_support.S
-  *
-  *  exit_and_dispatchϡext_tskƤӽФ٤Τǡƥ
-  *  ȡCPUå֡ǥѥåľ֡ʥǥΡ˳ͥ
-  *  ٥ޥ֤ǸƤӽФʤФʤʤ
-  */
- extern void	exit_and_dispatch(void) NoReturn;
- 
- /*
-  *  ͥνλθƽФprc_support.S
-  *
-  *  call_exit_kernelϡͥνλ˸ƤӽФ٤Τǡ󥿥
-  *  ƥȤڤ괹ơͥνλexit_kernelˤƤӽ
-  *  
-  */
- extern void call_exit_kernel(void) NoReturn;
- 
- /*
-  *  ƥȤν
-  *
-  *  ٻ߾֤¹ԤǤ֤˰ܹԤ˸ƤФ롥λ
-  *  ǥåΰȤäƤϤʤʤ
-  *
-  *  activate_context򡤥饤ؿǤϤʤޥȤƤΤϡ
-  *  λǤTCBƤʤǤ롥
-  */
- extern void	start_r(void);
- 
- #define activate_context(p_tcb)											\
- {																		\
- 	(p_tcb)->tskctxb.msp = (void *)((char *)((p_tcb)->p_tinib->stk)		\
- 										+ (p_tcb)->p_tinib->stksz);		\
- 	(p_tcb)->tskctxb.pc = (void *) start_r;								\
- }
- 
- /*
-  *  calltexϻѤʤ
-  */
- #define OMIT_CALLTEX
- 
- /*
-  *  㳰٥ơ֥ι¤
-  */
- typedef struct exc_vector_entry {
- 	FP		exc_handler;		/* 㳰ϥɥεư */
- } EXCVE;
- 
- /*
-  *  ߥϥɥֹCPU㳰ϥɥֹϰϤȽ
-  */
- #define VALID_INHNO_DEFINH(inhno)	((0x10U <= (inhno) && (inhno) <= 0x1fU) \
- 									|| (0x40U <= (inhno) && (inhno) <= 0xffU))
- #define VALID_EXCNO_DEFEXC(excno)	((0x02U <= (excno) && (excno) <= 0x0fU) \
- 									|| (0x20U <= (excno) && (excno) <= 0x3fU))
- 
- /*
-  *  ߥϥɥ
-  *
-  *  ٥ȥֹinhnoγߥϥɥνϤint_entry
-  *  ꤹ롥
-  */
- Inline void
- x_define_inh(INHNO inhno, FP int_entry)
- {
- 	EXCVE	*excvt;
- 
- 	assert(VALID_INHNO_DEFINH(inhno));
- 
- #ifdef EXCVT_KERNEL
- 	/*
- 	 *  EXCVT_KERNELƤϡVBR
- 	 *  EXCVT_KERNELꤹΤǡEXCVT_KERNELȤ
- 	 */
- 	excvt = (EXCVE *) EXCVT_KERNEL;
- #else /* EXCVT_KERNEL */
- 	excvt = (EXCVE *) current_vbr();
- #endif /* EXCVT_KERNEL */
- 	excvt[inhno].exc_handler = int_entry;
- }
- 
- /*
-  *  CPU㳰ϥɥ
-  *
-  *  ٥ȥֹexcnoCPU㳰ϥɥνϤexc_entry
-  *  ꤹ롥
-  */
- Inline void
- x_define_exc(EXCNO excno, FP exc_entry)
- {
- 	EXCVE	*excvt;
- 
- 	assert(VALID_EXCNO_DEFEXC(excno));
- 
- #ifdef EXCVT_KERNEL
- 	/*
- 	 *  EXCVT_KERNELƤϡVBR
- 	 *  EXCVT_KERNELꤹΤǡEXCVT_KERNELȤ
- 	 */
- 	excvt = (EXCVE *) EXCVT_KERNEL;
- #else /* EXCVT_KERNEL */
- 	excvt = (EXCVE *) current_vbr();
- #endif /* EXCVT_KERNEL */
- 	excvt[excno].exc_handler = exc_entry;
- }
- 
- /*
-  *  ߥϥɥν
-  */
- 
- /*
-  *  ߥϥɥνΥ٥ޥ
-  */
- #define INT_ENTRY(inhno, inthdr)	_kernel_##inthdr##_##inhno
- 
- /*
-  *  LOG_INH_ENTERޥƤˡCALL_LOG_INH_ENTER
-  *  inhno_numѥ᡼Ȥlog_inh_enterƤӽФ֥쥳
-  *  ɤ˥ޥ롥
-  */
- #ifdef LOG_INH_ENTER
- 
- #define CALL_LOG_INH_ENTER(inhno_num) \
- "	move.l #" #inhno_num ", -(%sp)	\n"  /* inhno_numѥ᡼ */ \
- "	jsr _kernel_log_inh_enter		\n"  /* log_inh_enterƤӽФ */ \
- "	addq.l #4, %sp					\n"
- 
- #else /* LOG_INH_ENTER */
- #define CALL_LOG_INH_ENTER(inhno_num)
- #endif /* LOG_INH_ENTER */
- 
- #ifdef LOG_INH_LEAVE
- 
- /*
-  *  CALL_LOG_INH_LEAVEinhno_numѥ᡼Ȥlog_inh_leave
-  *  ӽФ֥쥳ɤ˥ޥ롥
-  */
- #define CALL_LOG_INH_LEAVE(inhno_num) \
- "	move.l #" #inhno_num ", -(%sp)	\n"  /* inhno_numѥ᡼ */ \
- "	jsr _kernel_log_inh_leave		\n"  /* log_inh_leaveƤӽФ */ \
- "	addq.l #4, %sp					\n"
- 
- /*
-  *  LOG_INH_LEAVEޥƤγߥϥɥν
-  *  ߥϥɥ򥵥֥롼󥳡뤷äƤ顤ȥ졼
-  *  塤ret_intʬ롥
-  */
- #define INTHDR_ENTRY(inhno, inhno_num, inthdr) \
- extern void _kernel_##inthdr##_##inhno(void); \
- asm(".text							\n" \
- "_kernel_" #inthdr "_" #inhno ":	\n" \
- "	movem.l %d0-%d1/%a0-%a1, -(%sp)	\n"  /* å쥸¸ */ \
- 	CALL_LOG_INH_ENTER(inhno_num) \
- "	jsr " #inthdr "					\n"  /* ߥϥɥƤӽФ */ \
- 	CALL_LOG_INH_LEAVE(inhno_num) \
- "	jmp _kernel_ret_int				\n");/* ret_intʬ */
- 
- #else /* LOG_INH_LEAVE */
- 
- /*
-  *  LOG_INH_LEAVEޥƤʤγߥϥɥν
-  *  ϤȤret_int򥹥åѤ塤ߥϥɥεư
-  *  Ϥʬ롥ߥϥɥ餫Υ꥿ˤꡤret_intʬ
-  *  롥
-  */
- #define INTHDR_ENTRY(inhno, inhno_num, inthdr) \
- extern void _kernel_##inthdr##_##inhno(void); \
- asm(".text							\n" \
- "_kernel_" #inthdr "_" #inhno ":	\n" \
- "	movem.l %d0-%d1/%a0-%a1, -(%sp)	\n"  /* å쥸¸ */ \
- 	CALL_LOG_INH_ENTER(inhno_num) \
- "	move.l #_kernel_ret_int, -(%sp)	\n"  /* Ϥ򥹥åѤ */ \
- "	jmp " #inthdr "					\n");/* ߥϥɥʬ */
- 
- #endif /* LOG_INH_LEAVE */
- 
- /*
-  *  CPU㳰ϥɥν
-  *
-  *  CPU㳰ϥɥϤA1ˡCPU㳰ϥɥֹD1ơ
-  *  exchdr_entryʬ롥ߥϥɥνƱͤˡCPU㳰
-  *  ϥɥCPU㳰ϥɥƤӽФŸˡ⤢뤬Ÿ
-  *  ƤʣǤ뤿ᡤѤƤʤ
-  */
- 
- /*
-  *  CPU㳰ϥɥνΥ٥ޥ
-  */
- #define EXC_ENTRY(excno, exchdr)	_kernel_##exchdr##_##excno
- 
- /*
-  *  CPU㳰ϥɥν
-  */
- #define EXCHDR_ENTRY(excno, excno_num, exchdr) \
- extern void _kernel_##exchdr##_##excno(void *sp); \
- asm(".text							\n" \
- "_kernel_" #exchdr "_" #excno ":	\n" \
- "	movem.l %d0-%d1/%a0-%a1, -(%sp)	\n"  /* å쥸¸ */ \
- "	lea.l " #exchdr ", %a1			\n"  /* CPU㳰ϥɥϤA1 */ \
- "	move.l #" #excno_num ", %d1		\n"  /* excno_numD1 */ \
- "	jmp _kernel_exchdr_entry		\n");/* exchdr_entryʬ */
- 
- /*
-  *  CPU㳰ȯΥƥȤλ
-  *
-  *  CPU㳰ȯΥƥȤƥȤλfalse
-  *  Ǥʤtrue֤
-  */
- Inline bool_t
- exc_sense_context(void *p_excinf)
- {
- 	return((*((uint16_t *) p_excinf) & 0x1000U) == 0U);
- }
- 
- /*
-  *  CPU㳰ȯIPMʥϡɥγͥ٥ޥɽ
-  *  ˤλ
-  */
- Inline uint16_t
- exc_get_iipm(void *p_excinf)
- {
- 	return(*((uint16_t *) p_excinf) & 0x0700U);
- }
- 
- /*
-  *  CPU㳰ȯΥƥȤȳߤΥޥ֤λ
-  *
-  *  CPU㳰ȯΥƥ֤ͥ¹Ǥʤ
-  *  ƥȤǤꡤߥå֤ǤʤCPUå֤Ǥʤ
-  *  ͥ٥ޥ֤ǤtrueǤʤfalse֤
-  *  CPU㳰ͥγ߽ȯˤfalse
-  *  ˡ
-  *
-  *  M68040ǤϡCPU㳰ȯIPMʥϡɥγͥ٥
-  *  ˤ٤ƤγߤĤ֤Ǥ뤳Ȥå뤳Ȥǡ
-  *  ͥ¹Ǥʤȡߥå֤ǤʤȡCPUå
-  *  ֤Ǥʤȡͥ٥ޥ֤Ǥ뤳Ȥ4Ĥξ
-  *  å뤳ȤǤCPU㳰ȯlock_flag򻲾Ȥ
-  *  ɬפϤʤˡ
-  */
- Inline bool_t
- exc_sense_intmask(void *p_excinf)
- {
- 	return(!exc_sense_context(p_excinf)
- 					&& exc_get_iipm(p_excinf) == IIPM_ENAALL);
- }
- 
- /*
-  *  ץå¸ν
-  */
- extern void	prc_initialize(void);
- 
- /*
-  *  ץå¸νλ
-  */
- extern void	prc_terminate(void);
- 
- #endif /* TOPPERS_MACRO_ONLY */
- #endif /* TOPPERS_PRC_CONFIG_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_def.csv ASPs/asp/arch/m68k_gcc/prc_def.csv
*** 1.9.1/asp/arch/m68k_gcc/prc_def.csv	Wed Mar 30 23:01:24 2011
--- ASPs/asp/arch/m68k_gcc/prc_def.csv	Thu Jan  1 09:00:00 1970
***************
*** 1,5 ****
- sizeof_TCB,sizeof(TCB)
- offsetof_TCB_p_tinib,"offsetof(TCB,p_tinib)"
- offsetof_TCB_texptn,"offsetof(TCB,texptn)"
- offsetof_TCB_msp,"offsetof(TCB,tskctxb.msp)"
- offsetof_TCB_pc,"offsetof(TCB,tskctxb.pc)"
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_insn.h ASPs/asp/arch/m68k_gcc/prc_insn.h
*** 1.9.1/asp/arch/m68k_gcc/prc_insn.h	Sun Feb 21 15:10:07 2010
--- ASPs/asp/arch/m68k_gcc/prc_insn.h	Thu Jan  1 09:00:00 1970
***************
*** 1,134 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2007 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: prc_insn.h 591 2007-11-12 02:39:38Z asp $
-  */
- 
- /*
-  *		ץåü̿Υ饤ؿM68040ѡ
-  */
- 
- #ifndef	TOPPERS_PRC_INSN_H
- #define	TOPPERS_PRC_INSN_H
- 
- /*
-  *  ơ쥸SRˤθͤɽФ
-  */
- Inline uint16_t
- current_sr(void)
- {
- 	uint16_t	sr;
- 
- 	Asm("move.w %%sr, %0" : "=g"(sr));
- 	return(sr);
- }
- 
- /*
-  *  ơ쥸SRˤθͤ
-  */
- Inline void
- set_sr(uint16_t sr)
- {
- 	Asm("move.w %0, %%sr" : : "g"(sr) : "cc");
- }
- 
- /*
-  *  NMI٤Ƥγߤζػ
-  *
-  *  set_srѤƼ¸뤳ȤǤ뤬̤̿ѤƼ¸
-  *  ΨɤѰդƤ롥
-  */
- Inline void
- disint(void)
- {
- 	Asm("or.w #0x0700, %sr");
- }
- 
- /*
-  *  ٤Ƥγߤε
-  *
-  *  set_srѤƼ¸뤳ȤǤ뤬̤̿ѤƼ¸
-  *  ΨɤѰդƤ롥
-  */
- Inline void
- enaint(void)
- {
- 	Asm("and.w #~0x0700, %sr");
- }
- 
- /*
-  *  ٥١쥸VBRˤθͤɽФ
-  */
- Inline void
- *current_vbr(void)
- {
- 	void	*vbr;
- 
- 	Asm("movec.l %%vbr, %0" : "=r"(vbr));
- 	return(vbr);
- }
- 
- /*
-  *  ٥١쥸VBRˤθͤ
-  */
- Inline void
- set_vbr(void *vbr)
- {
- 	Asm("movec.l %0, %%vbr" : : "r"(vbr));
- }
- 
- /*
-  *  ǥ塼ΤΥӥåȥޥåץؿ
-  *
-  *  bfffo̿ϺǾ̥ӥåȤ饵뤿ᡤǾ̥ӥåȤǹͥ
-  *  б롥
-  */
- #define	OMIT_BITMAP_SEARCH
- #define	PRIMAP_BIT(pri)		(0x8000U >> (pri))
- 
- Inline uint_t
- bitmap_search(uint16_t bitmap)
- {
- 	uint32_t	offset;
- 
- 	Asm("bfffo %1{16,16}, %0" : "=d"(offset) : "d"((uint32_t) bitmap));
- 	return((uint_t)(offset - 16));
- }
- 
- #endif /* TOPPERS_PRC_INSN_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_kernel.h ASPs/asp/arch/m68k_gcc/prc_kernel.h
*** 1.9.1/asp/arch/m68k_gcc/prc_kernel.h	Sat Apr 12 10:31:25 2008
--- ASPs/asp/arch/m68k_gcc/prc_kernel.h	Thu Jan  1 09:00:00 1970
***************
*** 1,70 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2004-2007 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: prc_kernel.h 264 2007-07-12 08:23:10Z hiro $
-  */
- 
- /*
-  *		kernel.hΥץå¸M68040ѡ
-  *
-  *  Υ󥯥롼ɥեϡtarget_kernel.hʤޤϡ饤
-  *  롼ɤեˤΤߤ饤󥯥롼ɤ롥¾Υե뤫
-  *  ľܥ󥯥롼ɤƤϤʤʤ
-  */
- 
- #ifndef TOPPERS_PRC_KERNEL_H
- #define TOPPERS_PRC_KERNEL_H
- 
- /*
-  *  ͥγͥ٤ϰ
-  *
-  *  TMIN_INTPRIѹ뤳ȤǡɤΥ٥⤤ͥ
-  *  ĤΤ򥫡ͥγߤȤ뤫ѹǤ롥
-  *
-  *  TMIN_INTPRIǤͤϡ-6-1ϰϤǤ롥㤨TMIN_INTPRI
-  *  -5ꤹȡNMI˲äƥ٥6γߤͥȤʤ
-  *  M68040Ǥϡ٥7NMI򼨤ˡTMIN_INTPRI-6ꤹȡ
-  *  NMIʳ˥ͥγߤߤʤȤˤʤ롥
-  */
- #ifndef TMIN_INTPRI
- #define TMIN_INTPRI		(-6)		/* ͥ٤κǾ͡ʺǹ͡*/
- #endif /* TMIN_INTPRI */
- #define TMAX_INTPRI		(-1)		/* ͥ٤κ͡ʺ͡ */
- 
- #endif /* TOPPERS_PRC_KERNEL_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_offset.tf ASPs/asp/arch/m68k_gcc/prc_offset.tf
*** 1.9.1/asp/arch/m68k_gcc/prc_offset.tf	Wed Mar 30 23:20:49 2011
--- ASPs/asp/arch/m68k_gcc/prc_offset.tf	Thu Jan  1 09:00:00 1970
***************
*** 1,24 ****
- $ 
- $ 		եåȥեѥƥץ졼ȥեM68040ѡ
- $ 
- 
- $ 
- $  ɸƥץ졼ȥեΥ󥯥롼
- $ 
- $INCLUDE "kernel/genoffset.tf"$
- 
- $ 
- $  եåͤΥޥ
- $ 
- $DEFINE("TCB_p_tinib", offsetof_TCB_p_tinib)$
- $DEFINE("TCB_texptn", offsetof_TCB_texptn)$
- $DEFINE("TCB_msp", offsetof_TCB_msp)$
- $DEFINE("TCB_pc", offsetof_TCB_pc)$
- 
- $DEFINE("TINIB_exinf", offsetof_TINIB_exinf)$
- $DEFINE("TINIB_task", offsetof_TINIB_task)$
- 
- $ 
- $  ӥåȥեåΥޥ
- $ 
- $DEFINE_BIT("TCB_enatex", sizeof_TCB, "B")$
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_rename.def ASPs/asp/arch/m68k_gcc/prc_rename.def
*** 1.9.1/asp/arch/m68k_gcc/prc_rename.def	Sun Feb 21 15:47:20 2010
--- ASPs/asp/arch/m68k_gcc/prc_rename.def	Thu Jan  1 09:00:00 1970
***************
*** 1,14 ****
- # prc_config.c
- prc_initialize
- prc_terminate
- 
- # prc_support.S
- dispatch
- start_dispatch
- exit_and_dispatch
- call_exit_kernel
- start_r
- ret_int
- exchdr_entry
- lock_flag
- saved_iipm
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_rename.h ASPs/asp/arch/m68k_gcc/prc_rename.h
*** 1.9.1/asp/arch/m68k_gcc/prc_rename.h	Sun Feb 21 15:56:34 2010
--- ASPs/asp/arch/m68k_gcc/prc_rename.h	Thu Jan  1 09:00:00 1970
***************
*** 1,49 ****
- /* This file is generated from prc_rename.def by genrename. */
- 
- #ifndef TOPPERS_PRC_RENAME_H
- #define TOPPERS_PRC_RENAME_H
- 
- /*
-  *  prc_config.c
-  */
- #define prc_initialize				_kernel_prc_initialize
- #define prc_terminate				_kernel_prc_terminate
- 
- /*
-  *  prc_support.S
-  */
- #define dispatch					_kernel_dispatch
- #define start_dispatch				_kernel_start_dispatch
- #define exit_and_dispatch			_kernel_exit_and_dispatch
- #define call_exit_kernel			_kernel_call_exit_kernel
- #define start_r						_kernel_start_r
- #define ret_int						_kernel_ret_int
- #define exchdr_entry				_kernel_exchdr_entry
- #define lock_flag					_kernel_lock_flag
- #define saved_iipm					_kernel_saved_iipm
- 
- #ifdef TOPPERS_LABEL_ASM
- 
- /*
-  *  prc_config.c
-  */
- #define _prc_initialize				__kernel_prc_initialize
- #define _prc_terminate				__kernel_prc_terminate
- 
- /*
-  *  prc_support.S
-  */
- #define _dispatch					__kernel_dispatch
- #define _start_dispatch				__kernel_start_dispatch
- #define _exit_and_dispatch			__kernel_exit_and_dispatch
- #define _call_exit_kernel			__kernel_call_exit_kernel
- #define _start_r					__kernel_start_r
- #define _ret_int					__kernel_ret_int
- #define _exchdr_entry				__kernel_exchdr_entry
- #define _lock_flag					__kernel_lock_flag
- #define _saved_iipm					__kernel_saved_iipm
- 
- #endif /* TOPPERS_LABEL_ASM */
- 
- 
- #endif /* TOPPERS_PRC_RENAME_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_sil.h ASPs/asp/arch/m68k_gcc/prc_sil.h
*** 1.9.1/asp/arch/m68k_gcc/prc_sil.h	Sat Apr 12 10:31:25 2008
--- ASPs/asp/arch/m68k_gcc/prc_sil.h	Thu Jan  1 09:00:00 1970
***************
*** 1,101 ****
- /*
-  *  TOPPERS Software
-  *      Toyohashi Open Platform for Embedded Real-Time Systems
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2004-2008 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: prc_sil.h 916 2008-04-11 14:33:50Z hiro $
-  */
- 
- /*
-  *		sil.hΥץå¸M68040ѡ
-  */
- 
- #ifndef TOPPERS_PRC_SIL_H
- #define TOPPERS_PRC_SIL_H
- 
- #ifndef TOPPERS_MACRO_ONLY
- 
- /*
-  *  NMI٤Ƥγߤζػ
-  */
- Inline uint16_t
- TOPPERS_disint(void)
- {
- 	uint16_t	TOPPERS_sr;
- 
- 	Asm("move.w %%sr, %0" : "=g"(TOPPERS_sr));
- 	Asm("or.w #0x0700, %%sr" : : : "memory");
- 	return(TOPPERS_sr & 0x0700U);
- }
- 
- /*
-  *  ͥ٥ޥɽˤθͤ
-  */
- Inline void
- TOPPERS_set_iipm(uint16_t TOPPERS_iipm)
- {
- 	uint16_t	TOPPERS_sr;
- 
- 	Asm("move.w %%sr, %0" : "=g"(TOPPERS_sr));
- 	Asm("move.w %0, %%sr" : : "g"((TOPPERS_sr & ~0x0700U) | TOPPERS_iipm)
- 							: "memory");
- }
- 
- /*
-  *  ߥå֤
-  */
- #define SIL_PRE_LOC		uint16_t TOPPERS_iipm
- #define SIL_LOC_INT()	((void)(TOPPERS_iipm = TOPPERS_disint()))
- #define SIL_UNL_INT()	(TOPPERS_set_iipm(TOPPERS_iipm))
- 
- /*
-  *  Ԥ
-  */
- Inline void
- sil_dly_nse(ulong_t dlytim)
- {
- 	register uint32_t d0 asm("d0") = (uint32_t) dlytim;
- 	Asm("jsr _sil_dly_nse" : "=g"(d0) : "0"(d0));
- }
- 
- #endif /* TOPPERS_MACRO_ONLY */
- 
- /*
-  *  ץåΥǥ
-  */
- #define SIL_ENDIAN_BIG				/* ӥåǥ */
- 
- #endif /* TOPPERS_PRC_SIL_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_stddef.h ASPs/asp/arch/m68k_gcc/prc_stddef.h
*** 1.9.1/asp/arch/m68k_gcc/prc_stddef.h	Sat Apr 12 10:31:25 2008
--- ASPs/asp/arch/m68k_gcc/prc_stddef.h	Thu Jan  1 09:00:00 1970
***************
*** 1,58 ****
- /*
-  *  TOPPERS Software
-  *      Toyohashi Open Platform for Embedded Real-Time Systems
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2004-2007 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: prc_stddef.h 264 2007-07-12 08:23:10Z hiro $
-  */
- 
- /*
-  *		t_stddef.hΥץå¸M68040ѡ
-  *
-  *  Υ󥯥롼ɥեϡtarget_stddef.hʤޤϡ饤
-  *  롼ɤեˤΤߤ饤󥯥롼ɤ롥¾Υե뤫
-  *  ľܥ󥯥롼ɤƤϤʤʤ
-  */
- 
- #ifndef TOPPERS_PRC_STDDEF_H
- #define TOPPERS_PRC_STDDEF_H
- 
- /*
-  *  åȤ̤뤿Υޥ
-  */
- #define TOPPERS_M68K				/* ץåά */
- 
- #endif /* TOPPERS_PRC_STDDEF_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_support.S ASPs/asp/arch/m68k_gcc/prc_support.S
*** 1.9.1/asp/arch/m68k_gcc/prc_support.S	Fri Dec 31 22:05:05 2010
--- ASPs/asp/arch/m68k_gcc/prc_support.S	Thu Jan  1 09:00:00 1970
***************
*** 1,434 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  $Id: prc_support.S 2015 2010-12-31 13:05:04Z ertl-hiro $
-  */
- 
- /*
-  *		ץå¸⥸塼 ֥M68040ѡ
-  */
- 
- #define	TOPPERS_MACRO_ONLY
- #define UINT_C(val)			(val)		/* uint_tޥ */
- #define ULONG_C(val)		(val)		/* ulong_tޥ */
- #define CAST(type, val)		(val)		/* 㥹ȤԤޥ */
- #include "kernel_impl.h"
- #include "offset.h"
- 
- /*
-  *  ǥѥå
-  */
- 	.text
- 	.globl dispatch
- dispatch:
- 	/*
- 	 *  Υ롼ϡƥȡCPUå֡ǥѥå
- 	 *  ľ֡ʥǥΡ˳ͥ٥ޥ֤ǸƤӽФ
- 	 *  롥
- 	 */
- 	movem.l %d2-%d7/%a2-%a6, -(%sp)		/* 쥸¸ */
- 	move.l p_runtsk, %a0				/* p_runtskA0 */
- 	move.l %sp, TCB_msp(%a0)			/* å¸ */
- 	move.l #dispatch_r, TCB_pc(%a0)		/* ¹ԺƳϤ¸ */
- 	jbra dispatcher
- 
- dispatch_r:
- 	movem.l (%sp)+, %d2-%d7/%a2-%a6		/* 쥸 */
- 	btst.b #TCB_enatex_bit, TCB_enatex(%a0)
- 	jbeq dispatch_r_1					/* enatexfalseʤ꥿ */
- 	tst.l TCB_texptn(%a0)				/* texptn0ʤ꥿ */
- 	jbeq dispatch_r_1
- 	tst.l ipmflg						/* ipmflgtrueǤ            */
- 	jbne call_texrtn					/*  㳰롼θƽФ */
- dispatch_r_1:
- 	rts
- 
- /*
-  *  ǥѥåưϡprc_support.S
-  */
- 	.globl start_dispatch
- start_dispatch:
- 	/*
- 	 *  Υ롼ϡͥ뵯ưˡ٤Ƥγߤػߤ
- 	 * ʳߥå֤ƱˤǸƤӽФ롥ޤߥ⡼ɡ
- 	 *  ƥȤƱˤǸƤӽФ뤳ȤꤷƤ롥
- 	 *
- 	 *  prc_initializeǡlock_flagtrueˡsaved_iipmIIPM_ENAALL
- 	 *  Ƥ뤿ᡤͥγߤĤ뤳Ȥǡ
- 	 *  CPUå֡ʥǥΡ˳ͥ٥ޥ֤ˤʤ롥
- 	 *  ޤinitialize_taskdisdspfalse˽Ƥ뤿ᡤǥ
- 	 *  ѥåľ֤ˤʤäƤ롥
- 	 */
- #if TIPM_LOCK == -7
- 	or.w #0x1000, %sr					/* ޥ⡼ɤ */
- #else /* TIPM_LOCK == -7 */
- 	move.w %sr, %d0						/* ޥ⡼ɡ                */
- 	and.w #~0x0700, %d0					/*  ͥγߤ */
- 	or.w #(0x1000 | IIPM_LOCK), %d0
- 	move.w %d0, %sr
- #endif /* TIPM_LOCK == -7 */
- 	jbra dispatcher_0
- 
- /*
-  *  ߤΥƥȤΤƤƥǥѥå
-  */
- 	.globl exit_and_dispatch
- exit_and_dispatch:
- 	/* ǥѥåΡdispatcherˤ */
- 
- /*
-  *  ǥѥå
-  */
- dispatcher:
- 	/*
- 	 *  Υ롼ϡƥȡCPUå֡ǥѥå
- 	 *  ľ֡ʥǥΡ˳ͥ٥ޥ֤ǸƤӽФ
- 	 *  롥
- 	 *
- 	 *  ʤޥ⡼ɡlock_flagtruedisdspfalsedspflg
- 	 *  truesaved_iipmIIPM_ENAALLȤʤäƤ롥¹ԺƳϤؤ⤳
- 	 *  ξ֤Τޤʬ롥
- 	 */
- #ifdef LOG_DSP_ENTER
- 	move.l p_runtsk, %d0				/* p_runtskѥ᡼ */
- 	move.l %d0, -(%sp)
- 	jsr log_dsp_enter
- 	addq.l #4, %sp
- #endif /* LOG_DSP_ENTER */
- dispatcher_0:
- 	move.l p_schedtsk, %a0				/* p_schedtskp_runtsk */
- 	move.l %a0, p_runtsk
- 	jbeq dispatcher_1					/* p_runtskNULLʤdispatcher_1 */
- 	move.l TCB_msp(%a0), %sp			/* å */
- #ifdef LOG_DSP_LEAVE
- 	move.l %a0, -(%sp)					/* p_runtskѥ᡼ */
- 	jsr log_dsp_leave
- 	addq.l #4, %sp
- 	move.l p_runtsk, %a0
- #endif /* LOG_DSP_LEAVE */
- 	move.l TCB_pc(%a0), %a1				/* ¹ԺƳϤʬ */
- 	jmp (%a1)
- dispatcher_1:
- 	/*
- 	 *  CPUå֤򤹤롥
- 	 */
- 	move.w %sr, %d0						/* SRD0¸ */
- 	clr.l lock_flag						/* CPUå֤ */
- dispatcher_2:
- 	/*
- 	 *  ߤĤߥ⡼ɤڤ괹ơߤԤġ
- 	 *
- 	 *  ǳߥ⡼ɤڤ괹Τϡȯ߽
- 	 *  ɤΥåȤȤβȡߥϥɥǤΥ
- 	 *  ǥѥåɻߤȤ2Ĥΰ̣롥
- 	 *
- 	 *  ץåԤ˰ܹԤȡߵĤȤϡԲ
- 	 *  ʬ˹ԤʤɬפM68040Ǥstop̿ξԤʤΤ
- 	 *  ˡԲʬ˹Ԥʤʤ硤ߤĤľ˳
- 	 *  ߤꡤǥ¹Բǽ֤ˤʤȡ¹Ԥ٤
- 	 *  ˤ⤫餺ץåԤˤʤäƤޤ
- 	 *
- 	 *  Ԥδ֤ϡp_runtskNULLʡ0ˤꤷʤФʤ
- 	 *  Τ褦ꤷʤȡߥϥɥ餫iget_tidƤӽ
- 	 *  ݤưͤ˹פʤʤ롥
- 	 */
- 	stop #0x2000						/* Ԥ */
- 	move.w %d0, %sr						/* ξ֤᤹ */
- 	tst.l reqflg						/* reqflgfalseʤdispatcher_2 */
- 	jbeq dispatcher_2
- 	clr.l reqflg						/* reqflgfalse */
- 	/*
- 	 *  CPUå֤᤹Ԥδ֤˼¹Ԥߥϥɥˤ
- 	 *  ꡤsaved_iipm񤭴ǽ뤿ᡤ᤹ͤɬ
- 	 *  פ롥dispatcher¹Ԥϡsaved_iipmIIPM_ENAALL
- 	 *  ȤʤäƤ뤿ᡤǤsaved_iipmIIPM_ENAALLʡ0ˤ᤻
- 	 *  Ф褤
- 	 */
- 	clr.w saved_iipm					/* saved_iipm0ˤ */
- 	move.l #true, lock_flag				/* CPUå֤ */
- 	jbra dispatcher_0
- 
- /*
-  *  ͥνλθƽФ
-  *
-  *  M68040Ǥϡ⡼ڴˤꥹåڤ괹뤿ᡤŪʥ
-  *  åڴɬפʤǽ餫ߥ⡼ɤǤä⡤Ʊ
-  *  Ǥ褤
-  */
- 	.globl call_exit_kernel
- call_exit_kernel:
- 	and.w #~0x1000, %sr					/* ߥ⡼ɤ */
- 	jmp exit_kernel						/* ͥνλƤ */
- 	
- /*
-  *  ϻ
-  */
- 	.text
- 	.globl start_r
- start_r:
- 	clr.l lock_flag						/* CPUå֤ */
- 	and.w #~0x0700, %sr
- 	move.l TCB_p_tinib(%a0), %a1		/* p_runtsk->p_tinibA1 */
- 	move.l TINIB_exinf(%a1), -(%sp)		/* exinf򥹥åѤ */
- 	move.l #ext_tsk, -(%sp)				/* ext_tsk򥹥åѤ */
- 	move.l TINIB_task(%a1), %a0			/* εưϤA0 */
- 	jmp (%a0)
- 
- /*
-  *  ߥϥɥи
-  *
-  *  ret_intϡߥϥɥ餫äľ˼¹Ԥ롼ǡ
-  *  INTHDR_ENTRYޥŸߥϥɥǡߥϥ
-  *  ɥ餫Ϥꤵ롥
-  */
- 	.text
- 	.globl ret_int
- ret_int:
- 	btst.b #4, 16(%sp)					/* 褬ߥ⡼ɤʤ */
- 	jbeq ret_int_1						/*           ˥꥿ */
- 	/*
- 	 *  ͥγߤػߤ롥λǤϡCPUå֤
- 	 *  Ϥʤʤlock_flagsaved_iipmϹʤˡ
- 	 *
- 	 *  reqflgå˳ߤػߤΤϡreqflgå
- 	 *  ľ˳ߥϥɥ餬ư졤ǥǥѥå׵
- 	 *  줿ˡ˥ǥѥåʤȤ꤬뤿
- 	 *  Ǥ롥
- 	 */
- #if TIPM_LOCK == -7
- 	or.w #0x0700, %sr					/* ٤Ƥγߤػ */
- #else /* TIPM_LOCK == -7 */
- 	/*
- 	 *  Υ롼ϥͥγߤ鵯ư뤿ᡤǤϡ
- 	 *  ͥ٥ޥTIPM_LOCK㤤Ǥ롥
- 	 */
- 	move.w %sr, %d0						/* ͥγߤػ */
- 	and.w #~0x0700, %d0
- 	or.w #IIPM_LOCK, %d0
- 	move.w %d0, %sr
- #endif /* TIPM_LOCK == -7 */
- 	tst.l reqflg						/* reqflgtrueǤret_int_2 */
- 	jbne ret_int_2
- ret_int_1:
- 	/*
- 	 *  ߽Υ꥿ˤꡤCPUå֤˰ܹԤ褦
- 	 *  롥ͥ٥ޥϡRTE̿ˤ긵ͤ뤿ᡤ
- 	 *  lock_flagfalseˤƤФ褤lock_flagfalseˤΤϡ
- 	 *  CPUå֤Τޤ޳ߥϥɥ餫äкˡ
- 	 */
- 	clr.l lock_flag						/* CPUåν */
- 	movem.l (%sp)+, %d0-%d1/%a0-%a1		/* å쥸 */
- 	rte
- 
- ret_int_2:
- 	movem.l (%sp)+, %d0-%d1/%a0-%a1		/* å쥸 */
- 	addq.l #8, %sp						/* ե졼ΤƤ */
- 	or.w #0x1000, %sr					/* ޥ⡼ɤˡʥåڴ*/
- 	movem.l %d0-%d1/%a0-%a1, -(%sp)		/* å쥸¸ */
- ret_int_3:
- 	/*
- 	 *  ؤϡCPU㳰ϥɥνиʬƤ롥
- 	 *
- 	 *  Ǥϡ褬Ǥꡤåϡ㳰åե졼
- 	 *  ξ˥å쥸Τߤ¸줿֤ˤʤäƤ롥
- 	 *  ץåϡޥ⡼ɡͥγߤػߤ
- 	 *  ֤ȤʤäƤ롥
- 	 */
- 	clr.l reqflg						/* reqflgfalse */
- 	/*
- 	 *  CPUå֤˰ܹԤͥ٥ޥ߽ͤ
- 	 *	ꤹ롥ͥγߤϤǤ˶ػߤƤΤǡlock_flag
- 	 *  saved_iipm򹹿롥saved_iipmϡγͥ٥ޥ
- 	 *  ʤɽˤꤹ롥
- 	 *
- 	 *  λCPUå֤ȤΤϡdispatcherʬȡ
- 	 *  call_texrtnƤӽФˡCPUå֤ˤʤäƤɬפ
- 	 *  Ǥ롥
- 	 */
- 	move.w 16(%sp), %d0					/* SRD0 */
- 	and.w #0x0700, %d0					/* IPMФsaved_iipm */
- 	move.w %d0, saved_iipm
- 	move.l #true, lock_flag				/* lock_flagtrue */
- 	/*
- 	 *  dspflgfalseǤȡp_runtskp_schedtskƱˤϡ
- 	 *  ǥѥåԤʤΥåɬפʤΤϡ㳰
- 	 *  롼θƽФɬפʾˡǥѥåɬפʤƤ⡤
- 	 *  reqflgtrueˤ뤿Ǥ롥
- 	 */
- 	move.l p_runtsk, %a0				/* p_runtskA0 */
- 	tst.l dspflg						/* dspflgfalseʤret_int_4 */
- 	jbeq ret_int_4
- 	cmp.l p_schedtsk, %a0				/* p_runtskp_schedtskƱʤ */
- 	jbeq ret_int_4						/*                    ret_int_4 */
- 	movem.l %d2-%d7/%a2-%a6, -(%sp)		/* ĤΥ쥸¸ */
- 	move.l %sp, TCB_msp(%a0)			/* å¸ */
- 	move.l #ret_int_r, TCB_pc(%a0)		/* ¹ԺƳϤ¸ */
- 	jbra dispatcher
- 
- ret_int_r:
- 	movem.l (%sp)+, %d2-%d7/%a2-%a6		/* 쥸 */
- ret_int_4:
- 	/*
- 	 *  enatextrueǡtexptn0ǤʤipmflgtrueǤС
- 	 *  㳰롼ƤӽФ
- 	 */
- 	btst.b #TCB_enatex_bit, TCB_enatex(%a0)
- 	jbeq ret_int_5						/* enatexfalseʤret_int_5 */
- 	tst.l TCB_texptn(%a0)				/* texptn0ʤret_int_5 */
- 	jbeq ret_int_5
- 	tst.l ipmflg						/* ipmflgfalseʤret_int_5 */
- 	jbeq ret_int_5
- 	jsr call_texrtn						/* 㳰롼θƽФ */
- ret_int_5:
- 	/*
- 	 *  ߽Υ꥿ˤꡤCPUå֤˰ܹԤ
- 	 *  롥ͥ٥ޥϡRTE̿ˤ긵ͤ뤿
- 	 *  ᡤlock_flagfalseˤƤФ褤
- 	 */
- 	clr.l lock_flag						/* CPUåν */
- 	movem.l (%sp)+, %d0-%d1/%a0-%a1		/* å쥸 */
- 	rte
- 
- /*
-  *  CPU㳰ϥɥ
-  *
-  *  exchdr_entryϡCPU㳰ȯ˼¹Ԥ롼ǡEXCHDR_ENTRY
-  *  ޥŸCPU㳰ϥɥ顤CPU㳰ϥɥϤ
-  *  A1ˡCPU㳰ϥɥֹD1ʬƤ롥
-  *
-  *  CPU㳰ϥɥϡ󥿥ƥȤǼ¹Ԥ롥ΤᡤCPU
-  *  ϥɥƤӽФ˳ߥ⡼ɤ˰ܹԤ꥿󤷤Ƥ
-  *  Υ⡼ɤ᤹Υ⡼ɤ᤹ˡߥ⡼ɤ˰ܹԤ
-  *  SRߥå¸ʥ꥿SR򻲾Ȥ⤢
-  *  å¸礬ꡤȤΤݡˡ
-  */
- 	.text
- 	.globl exchdr_entry
- exchdr_entry:
- 	lea.l 16(%sp), %a0					/* 㳰ե졼ƬA0 */
- 	move.w %sr, %d0						/* SRD0 */
- 	and.w #~0x1000, %sr					/* ߥ⡼ɤˡʥåڴ*/
- 	move.l %d0, -(%sp)					/* SR򥹥å¸ */
- 	and.w #0x0700, %d0					/* IPMINT_IPM(TMIN_INTPRI) */
- 	cmp.w #INT_IPM(TMIN_INTPRI), %d0	/*    꾮Сͥ */
- 	blt exchdr_entry_1					/*    CPU㳰ν */
- 
- 	/*
- 	 *  ͥCPU㳰ϥɥθƽФ
- 	 */
- 	move.l lock_flag, %d0				/* lock_flag򥹥å¸ */
- 	move.l %d0, -(%sp)
- 	move.l %a0, -(%sp)					/* A0ѥ᡼ */
- 	jsr (%a1)							/* CPU㳰ϥɥƤӽФ */
- 	addq.l #4, %sp						/* åΰΤƤ */
- 	move.l (%sp)+, %d0					/* lock_flag򸵤᤹ */
- 	move.l %d0, lock_flag
- 	move.l (%sp)+, %d0					/* SR򸵤᤹ */
- 	move.w %d0, %sr
- 	movem.l (%sp)+, %d0-%d1/%a0-%a1		/* å쥸 */
- 	rte
- 
- 	/*
- 	 *  ͥCPU㳰ϥɥθƽФ
- 	 */
- exchdr_entry_1:
- #ifdef LOG_EXC_LEAVE					/* excno_numlog_exc_leave */
- 	move.l %d1, -(%sp)					/*               ѥ᡼ */
- #endif /* LOG_EXC_LEAVE */
- 	move.l %a0, -(%sp)					/* A0CPU㳰ϥɥΥѥ᡼ */
- #ifdef LOG_EXC_ENTER
- 	move.l %a1, -(%sp)					/* A1¸ */
- 	move.l %d1, -(%sp)					/* excno_numѥ᡼ */
- 	jsr _kernel_log_exc_enter			/* log_exc_enterƤӽФ */
- 	addq.l #4, %sp
- 	move.l (%sp)+, %a1					/* A1 */
- #endif /* LOG_EXC_ENTER */
- 	jsr (%a1)							/* CPU㳰ϥɥƤӽФ */
- 	addq.l #4, %sp						/* åΰΤƤ */
- #ifdef LOG_EXC_LEAVE
- 	jsr _kernel_log_exc_leave			/* log_exc_leaveƤӽФ */
- 	addq.l #4, %sp
- #endif /* LOG_EXC_LEAVE */
- ret_exc:
- 	move.l (%sp)+, %d0					/* SRD0 */
- 	and.w #0x1000, %d0					/* ߥ⡼ɤʤ */
- 	jbeq ret_exc_1						/*       ˥꥿ */
- 	/*
- 	 *  ͥγߤػߤޥ⡼ɤ᤹λǤϡ
- 	 *  CPUå֤ˤϤʤʤlock_flagsaved_iipmϹʤˡ
- 	 *
- 	 *  reqflgå˳ߤػߤΤϡreqflgå
- 	 *  ľ˳ߥϥɥ餬ư졤ǥǥѥå׵
- 	 *  줿ˡ˥ǥѥåʤȤ꤬뤿
- 	 *  Ǥ롥
- 	 */
- #if TIPM_LOCK == -7
- 	or.w #0x1700, %sr					/* ޥ⡼ɡ߶ػ */
- #else /* TIPM_LOCK == -7 */
- 	/*
- 	 *  Υ롼ϥͥCPU㳰鵯ư뤿ᡤǤϡ
- 	 *  ͥ٥ޥTIPM_LOCK㤤Ǥ롥
- 	 */
- 	move.w %sr, %d0						/* ޥ⡼ɡ                */
- 	and.w #~0x0700, %d0					/*    ͥγߤػ */
- 	or.w #(0x1000|IIPM_LOCK), %d0
- 	move.w %d0, %sr
- #endif /* TIPM_LOCK == -7 */
- 	/*
- 	 *  CPU㳰Ǥϳߥ⡼ɤڤ괹ʤᡤreqflgtrueξ硤
- 	 *  ret_int_2ǤϤʤret_int_3ʬ롥
- 	 */
- 	tst.l reqflg						/* reqflgtrueǤret_int_3 */
- 	jbne ret_int_3
- ret_exc_1:
- 	movem.l (%sp)+, %d0-%d1/%a0-%a1		/* å쥸 */
- 	rte
- 
- /*
-  *  ԤSILΥåȰ¸
-  */
- 	.globl _sil_dly_nse
- _sil_dly_nse:
- 	subi.l #SIL_DLY_TIM1, %d0			/* D0SIL_DLY_TIM1 */
- 	jbhi _sil_dly_nse_1					/* ̤0ʲʤ꥿ */
- 	rts
- _sil_dly_nse_1:
- 	subi.l #SIL_DLY_TIM2, %d0			/* D0SIL_DLY_TIM2 */
- 	jbhi _sil_dly_nse_1					/* ̤0礭Х롼 */
- 	rts
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_test.h ASPs/asp/arch/m68k_gcc/prc_test.h
*** 1.9.1/asp/arch/m68k_gcc/prc_test.h	Sat Apr 12 10:31:25 2008
--- ASPs/asp/arch/m68k_gcc/prc_test.h	Thu Jan  1 09:00:00 1970
***************
*** 1,51 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: prc_test.h 328 2007-07-17 07:07:27Z hiro $
-  */
- 
- /*
-  *		ƥȥץΥåȰ¸M68040ѡ
-  */
- 
- #ifndef TOPPERS_PRC_TEST_H
- #define TOPPERS_PRC_TEST_H
- 
- #define CPUEXC1					5		/* 㳰 */
- #define RAISE_CPU_EXCEPTION		syslog(LOG_NOTICE, "zerodiv = %d", 10 / 0)
- 
- #endif /* TOPPERS_PRC_TEST_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/prc_unrename.h ASPs/asp/arch/m68k_gcc/prc_unrename.h
*** 1.9.1/asp/arch/m68k_gcc/prc_unrename.h	Sun Feb 21 15:56:34 2010
--- ASPs/asp/arch/m68k_gcc/prc_unrename.h	Thu Jan  1 09:00:00 1970
***************
*** 1,50 ****
- /* This file is generated from prc_rename.def by genrename. */
- 
- /* This file is included only when prc_rename.h has been included. */
- #ifdef TOPPERS_PRC_RENAME_H
- #undef TOPPERS_PRC_RENAME_H
- 
- /*
-  *  prc_config.c
-  */
- #undef prc_initialize
- #undef prc_terminate
- 
- /*
-  *  prc_support.S
-  */
- #undef dispatch
- #undef start_dispatch
- #undef exit_and_dispatch
- #undef call_exit_kernel
- #undef start_r
- #undef ret_int
- #undef exchdr_entry
- #undef lock_flag
- #undef saved_iipm
- 
- #ifdef TOPPERS_LABEL_ASM
- 
- /*
-  *  prc_config.c
-  */
- #undef _prc_initialize
- #undef _prc_terminate
- 
- /*
-  *  prc_support.S
-  */
- #undef _dispatch
- #undef _start_dispatch
- #undef _exit_and_dispatch
- #undef _call_exit_kernel
- #undef _start_r
- #undef _ret_int
- #undef _exchdr_entry
- #undef _lock_flag
- #undef _saved_iipm
- 
- #endif /* TOPPERS_LABEL_ASM */
- 
- 
- #endif /* TOPPERS_PRC_RENAME_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/m68k_gcc/start.S ASPs/asp/arch/m68k_gcc/start.S
*** 1.9.1/asp/arch/m68k_gcc/start.S	Sat Apr 12 10:31:25 2008
--- ASPs/asp/arch/m68k_gcc/start.S	Thu Jan  1 09:00:00 1970
***************
*** 1,129 ****
- /*
-  *  TOPPERS Software
-  *      Toyohashi Open Platform for Embedded Real-Time Systems
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: start.S 264 2007-07-12 08:23:10Z hiro $
-  */
- 
- /*
-  *		ͥбΥȥåץ⥸塼M68040ѡ
-  */
- 
- #define	TOPPERS_MACRO_ONLY
- #include "kernel_impl.h"
- 
- 	.text
- 	.globl start
- start:
- 	/*
- 	 *  ץå⡼ɤȥåݥ󥿤ν
- 	 */
- 	cinva %bc							/* ٤ƤΥå̵ */
- 	move.l #0x80008000, %d0				/* ξΥåON */
- 	movec.l %d0, %cacr
- 
- 	move.w %sr, %d0
- 	or.w #0x2700, %d0					/* ѥХ⡼ɡIPM=7 */
- 	and.w #0xefff ,%d0					/* ߥ⡼ɤ */
- 	move.w %d0, %sr
- 
- 	move.l _kernel_istk, %sp			/* åݥ󥿡SPIˤν */
- 	add.l _kernel_istksz, %sp
- 	move.l #0, %fp						/* ե졼ݥ󥿤ν */
- 
- 	/*
- 	 *  hardware_init_hookθƽФ0Ǥʤ
- 	 *
- 	 *  åȥϡɥ˰¸ɬפʽϡ
- 	 *  hardware_init_hookȤؿѰդ롥
- 	 */
- 	move.l #hardware_init_hook, %a0
- 	cmp.l #0, %a0
- 	jbeq start_1
- 	jsr (%a0)
- 
- 	/*
- 	 *  bssΥꥢ
- 	 */
- start_1:
- 	move.l #__bss_start, %a0
- 	move.l #_end, %d0
- 	sub.l %a0, %d0
- 	jbeq start_3
- start_2:
- 	clr.b (%a0)+
- 	dbra %d0, start_2
- 	clr.w %d0
- 	subq.l #1, %d0
- 	jbcc start_2
- 
- 	/*
- 	 *  dataνROMб
- 	 *
- 	 *  __idata_start__idata_endޤǤ__data_startʹߤ˥ԡ
- 	 *  롥
- 	 */
- start_3:
- 	move.l #__idata_end, %d0
- 	sub.l #__idata_start, %d0
- 	jbls start_5
- 	move.l #__idata_start, %a0
- 	move.l #__data_start, %a1
- start_4:
- 	move.b (%a0)+, (%a1)+
- 	dbra %d0, start_4
- 	clr.w %d0
- 	subq.l #1, %d0
- 	jbcc start_4
- 
- 	/*
- 	 *  software_init_hookθƽФ0Ǥʤ
- 	 *
- 	 *  եȥĶä˥饤֥ˤ˰¸ɬפʽ
- 	 *  ϡsoftware_init_hookȤؿѰդФ褤
- 	 */
- start_5:
- 	move.l #software_init_hook, %a0
- 	cmp.l #0, %a0
- 	jbeq start_6
- 	jsr (%a0)
- 
- 	/*
- 	 *  ͥư롥
- 	 */
- start_6:
- 	jmp sta_ker
--- 0 ----
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/MANIFEST ASPs/asp/arch/rx_gcc/rx72n/MANIFEST
*** 1.9.1/asp/arch/rx_gcc/rx72n/MANIFEST	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/MANIFEST	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,35 ----
+ PACKAGE asp_arch_rx_rxc
+ VERSION 1.6.1
+ 
+ MANIFEST
+ genoffset.bat
+ makeoffset.c
+ offset.exe
+ prc.tf
+ prc_asm_config.tf
+ prc_cfg1_out.h
+ prc_check.tf
+ prc_config.c
+ prc_config.h
+ prc_def.csv
+ prc_insn.h
+ prc_kernel.h
+ prc_rename.def
+ prc_rename.h
+ prc_sil.h
+ prc_stddef.h
+ prc_support.src
+ prc_syssvc.h
+ prc_test.h
+ prc_test.src
+ prc_unrename.h
+ prc_user.txt
+ RX72n.h
+ RX72n.tf
+ RX72n_config.c
+ RX72n_config.h
+ start.src
+ 
+ INCLUDE ../../target/rsk_rx_hew/MANIFEST
+ INCLUDE ../rxc/MANIFEST
+ INCLUDE ../../pdic/rx600/MANIFEST
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/Makefile.prc ASPs/asp/arch/rx_gcc/rx72n/Makefile.prc
*** 1.9.1/asp/arch/rx_gcc/rx72n/Makefile.prc	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/Makefile.prc	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,69 ----
+ #
+ #		Makefile のchip依存部（rx用）
+ #
+ 
+ #
+ #  チップ依存部ディレクトリ名の定義
+ #
+ ARCH_SYS_DIR = $(SRCDIR)/arch/rx_$(TOOL)/$(PRC)
+ 
+ #
+ # include Makefile of arch_common
+ #
+ include $(SRCDIR)/arch/rx_$(TOOL)/rx_common/Makefile.prc_common
+ 
+ #
+ #  コンパイルオプション
+ #
+ INCLUDES := $(INCLUDES) -I$(ARCH_SYS_DIR)
+ CDEFS := $(CDEFS) 
+ COPTS := $(COPTS)
+ 
+ #
+ #  カーネルに関する定義
+ #
+ KERNEL_DIR := $(KERNEL_DIR) $(ARCH_SYS_DIR)
+ KERNEL_ASMOBJS := $(KERNEL_ASMOBJS)
+ KERNEL_COBJS := $(KERNEL_COBJS) rx72n_config.o rx72n_support.o
+ 
+ #
+ #  システムサービスに関する定義
+ #
+ SYSSVC_DIR := $(SYSSVC_DIR)
+ SYSSVC_COBJS := $(SYSSVC_COBJS)
+ 
+ #
+ #  トレースログに関する設定
+ #
+ ifeq ($(ENABLE_TRACE),true)
+ 	COPTS := $(COPTS) -DTOPPERS_ENABLE_TRACE
+ 	KERNEL_DIR := $(KERNEL_DIR) $(SRCDIR)/arch/logtrace
+ 	KERNEL_COBJS := $(KERNEL_COBJS) trace_config.o trace_dump.o
+ endif
+ 
+ #
+ #  依存関係の定義
+ #
+ kernel_cfg.timestamp: $(ARCH_SYS_DIR)/rx72n.tf $(ARCH_SYS_DIR)/prc.tf
+ #kernel_cfg.timestamp: $(ARCH_COM_DIR)/prc.tf
+ 
+ 
+ #
+ #  オフセットファイル生成のための定義
+ #
+ OFFSET_TF = $(TARGETDIR)/target_offset.tf
+ 
+ 
+ #
+ #  ツール依存部ディレクトリ名の定義
+ #
+ TOOLDIR = $(SRCDIR)/arch/$(TOOL)
+ 
+ #
+ #  コンパイルオプション
+ #
+ COPTS := $(COPTS)
+ INCLUDES := $(INCLUDES) -I$(TOOLDIR)
+ LDFLAGS := -nostdlib $(LDFLAGS)
+ CDEFS := $(CDEFS)
+ LIBS := $(LIBS)  -lgcc
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/asm_config.h ASPs/asp/arch/rx_gcc/rx72n/asm_config.h
*** 1.9.1/asp/arch/rx_gcc/rx72n/asm_config.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/asm_config.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,16 ----
+ 
+ #define TIPM_LOCK	 -15 
+ #define IPL_LOCK  117440512 
+ #define PSW_I_MASK 65536 
+ #define PSW_IPL_MASK 117440512 
+ #define EXC_GET_PSW_OFFSET 80 
+ 
+ 
+ #define LOG_INH_ENTER 0 
+ #define LOG_INH_LEAVE 0 
+ #define LOG_EXC_ENTER 0 
+ #define LOG_EXC_LEAVE 0 
+ #define LOG_DSP_ENTER 0 
+ #define LOG_DSP_LEAVE 0 
+ #define SIL_DLY_TIM1 69 
+ #define SIL_DLY_TIM2 50 
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/prc.tf ASPs/asp/arch/rx_gcc/rx72n/prc.tf
*** 1.9.1/asp/arch/rx_gcc/rx72n/prc.tf	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/prc.tf	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,360 ----
+ $ 
+ $  TOPPERS/ASP Kernel
+ $      Toyohashi Open Platform for Embedded Real-Time Systems/
+ $      Advanced Standard Profile Kernel
+ $ 
+ $  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+ $ 
+ $  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ $  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ $  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ $  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ $      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ $      スコード中に含まれていること．
+ $  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ $      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ $      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ $      の無保証規定を掲載すること．
+ $  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ $      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ $      と．
+ $    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ $        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ $    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ $        報告すること．
+ $  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ $      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ $      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ $      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ $      免責すること．
+ $ 
+ $  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ $  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ $  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ $  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ $  の責任を負わない．
+ $ 
+ $ 
+ 
+ $ 
+ $  アーキテクチャ依存テンプレート（RX72n用）from rx63n
+ $ 
+ 
+ 
+ 
+ $ 
+ $  ATT_ISRで使用できる割込み番号とそれに対応する割込みハンドラ番号
+ $ 
+ 
+ $INTNO_ATTISR_VALID = INTNO_VALID$
+ $INHNO_ATTISR_VALID = INHNO_VALID$
+ 
+ 
+ $ 
+ $  DEF_INT／DEF_EXCで使用できる割込みハンドラ番号／CPU例外ハンドラ番号
+ $ 
+ 
+ $INHNO_DEFINH_VALID = INHNO_VALID$
+ $EXCNO_DEFEXC_VALID = EXCNO_VALID$
+ 
+ 
+ $ 
+ $  CFG_INTで使用できる割込み番号と割込み優先度
+ $ 
+ 
+ $INTNO_CFGINT_VALID = INHNO_VALID$
+ $INTPRI_CFGINT_VALID = { -15, -14,...,-1 }$
+ 
+ 
+ $ 
+ $  ターゲット非依存部に含まれる標準の割込み管理機能/例外管理機能の初期化処理を使用する
+ $ 
+ 
+ $OMIT_INITIALIZE_INTERRUPT = 0$
+ $OMIT_INITIALIZE_EXCEPTION = 0$
+ 
+ 
+ $ 
+ $  スタックサイズのチェック方法指定
+ $ 
+ 
+ $CHECK_STKSZ_ALIGN = 4$
+ 
+ 
+ $ 
+ $  タスクスタックサイズの最小値
+ $ 
+ $  タスク起動時に4byte,
+ $  割込み入口処理にて48byte, CPU例外入口処理にて84byte,
+ $  であるため, 最小値は88byteとする.
+ $ 
+ 
+ $TARGET_MIN_STKSZ = 88$
+ 
+ 
+ $ 
+ $  定数定義
+ $ 
+ 
+ $TA_POSEDGE = TA_EDGE$
+ 
+ 
+ $ 
+ $ ターゲット依存の割込み属性の定義
+ $ 
+ 
+ $TARGET_INTATR = TA_POSEDGE | TA_NEGEDGE | TA_BOTHEDGE | TA_LOWLEVEL$
+ 
+ 
+ $ 
+ $ ターゲット依存の割込みハンドラ属性の定義
+ $ 
+ 
+ $TARGET_INHATR = TA_NONKERNEL$
+ 
+ 
+ $ 
+ $ カーネル管理外割込みハンドラは固定させないため,
+ $ INTNO_FIX_KERNEL
+ $ INHNO_FIX_KERNEL
+ $ INHNO_FIX_NONKERNEL
+ $ INHNO_FIX_NONKERNEL
+ $ を定義しない.
+ $ 
+ 
+ 
+ $ 
+ $  標準テンプレートファイルのインクルード
+ $ 
+ $INCLUDE "kernel/kernel.tf"$
+ 
+ 
+ 
+ $ 
+ $  CFG_INTのターゲット依存のエラーチェック
+ $ 
+ 
+ $FOREACH intno INT.ORDER_LIST$
+ $ IRQ割込み番号かどうかをチェック
+ 	$IF ( LENGTH( FIND( INTNO_INT, INT.INTNO[intno] ) ) != 0 )$
+ 
+ $   TA_POSEDGEとTA_NEGEDGEが同時に設定されている場合
+ 		$IF ((INT.INTATR[intno] & ( TA_POSEDGE | TA_NEGEDGE )) == ( TA_POSEDGE | TA_NEGEDGE ))$
+ 			$ERROR$ INT.TEXT_LINE[intno]:$FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "intatr", INT.INTATR[intno], INT.INTNO[intno], "CFG_INT")$$END$
+ 		$END$
+ 
+ $   TA_POSEDGEとTA_BOTHEDGEが同時に設定されている場合
+ 		$IF ((INT.INTATR[intno] & ( TA_POSEDGE | TA_BOTHEDGE )) == ( TA_POSEDGE | TA_BOTHEDGE ))$
+ 			$ERROR$ INT.TEXT_LINE[intno]:$FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "intatr", INT.INTATR[intno], INT.INTNO[intno], "CFG_INT")$$END$
+ 		$END$
+ 
+ $   TA_NEGEDGEとTA_BOTHEDGEが同時に設定されている場合
+ 		$IF ((INT.INTATR[intno] & ( TA_NEGEDGE | TA_BOTHEDGE )) == ( TA_NEGEDGE | TA_BOTHEDGE ))$
+ 			$ERROR$ INT.TEXT_LINE[intno]:$FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "intatr", INT.INTATR[intno], INT.INTNO[intno], "CFG_INT")$$END$
+ 		$END$
+ 
+ $   TA_POSEDGEとTA_NEGEDGEとTA_BOTHEDGEが同時に設定されている場合
+ 		$IF ((INT.INTATR[intno] & ( TA_POSEDGE | TA_NEGEDGE | TA_BOTHEDGE )) == ( TA_POSEDGE | TA_NEGEDGE | TA_BOTHEDGE ))$
+ 			$ERROR$ INT.TEXT_LINE[intno]:$FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "intatr", INT.INTATR[intno], INT.INTNO[intno], "CFG_INT")$$END$
+ 		$END$
+ 
+ 	$ELSE$
+ 
+ $   IRQ割込み以外の割込みに対して割込み属性が指定されている場合
+ 		$IF (INT.INTATR[intno] & (~( TA_ENAINT | TA_EDGE ))) != 0$
+ 			$ERROR$ INT.TEXT_LINE[intno]: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "intatr", INT.INTATR[intno], INT.INTNO[intno], "CFG_INT")$$END$
+ 		$END$
+ 
+ 	$END$
+ 
+ $END$
+ 
+ 
+ 
+ $ 
+ $ 割込み番号から割込み優先度及び属性を取り出すテーブル
+ $ 
+ 
+ /*$NL$
+ $SPC$*$SPC$$SPC$Interrupt Level and Attribute Table$NL$
+ $SPC$*/$NL$
+ const CFG_INT_INFO _kernel_cfg_int_table[$LENGTH(INTNO_RANGE)$] = {$NL$
+ $FOREACH intno INTNO_RANGE$
+ $ 割込み優先度を取得
+ 	$IF LENGTH(INT.INTNO[intno])$
+ 		$intpri = -INT.INTPRI[intno]$
+ 		$intatr = INT.INTATR[intno]$
+ 	$ELSE$
+ 		$intpri = "0"$
+ 		$intatr = "0xFFFFFFFF"$
+ 	$END$
+ 
+ $ テーブルの中身を出力
+ 	$TAB$$FORMAT("{ %2d, %08x }, /* %02u */", intpri, intatr, +intno)$$NL$
+ $END$
+ };$NL$$NL$
+ 
+ 
+ $ 
+ $  アセンブラ出力ファイル
+ $ 
+ 
+ $FILE "kernel_cfg_asm.S"$
+ 
+ ;$NL$
+ ;  RX610アーキテクチャ依存出力ファイル$NL$
+ ;$NL$
+ ;  割込みベクタ及び割込みハンドラ定義$NL$
+ ;$NL$
+ $NL$$NL$
+ 
+ 
+ $ 
+ $  割込み入口処理
+ $ 
+ 
+ $ 
+ $  共通関数の宣言
+ $ 
+ 
+ $TAB$.text$NL$
+ $TAB$.extern$TAB$_kernel_interrupt$NL$
+ $TAB$.extern$TAB$__kernel_default_int_handler$NL$
+ $TAB$.extern$TAB$__kernel_default_exc_handler$NL$$NL$$NL$
+ 
+ 
+ $ 
+ $  割込みハンドラの出力
+ $ 
+ 
+ $FOREACH inhno INHNO_RANGE$
+ 	$IF LENGTH(INH.INHNO[inhno])$
+ 		$IF ((INH.INHATR[inhno] & TA_NONKERNEL) == 0)$
+ 			$TAB$.extern	_$INH.INTHDR[inhno]$$NL$
+ 			$TAB$.global	__kernel_$INH.INTHDR[inhno]$_$+INH.INHNO[inhno]$_entry$NL$
+ 			__kernel_$INH.INTHDR[inhno]$_$+INH.INHNO[inhno]$_entry:$NL$
+ 			$TAB$pushm	r1-r5						; スクラッチレジスタをタスクスタックへ退避 $NL$
+ 			$TAB$mov.l	#$+INH.INHNO[inhno]$, r1	; 割込みハンドラ番号をr1へ $NL$
+ 			$TAB$mov.l	#_$INH.INTHDR[inhno]$, r2	; ハンドラのアドレスをr2へ $NL$
+ 			$TAB$bra.a	_kernel_interrupt			; 共通ルーチンへ $NL$$NL$$NL$
+ 		$END$
+ 	$END$
+ $END$
+ 
+ 
+ $ 未登録割込みハンドラ入口処理
+ 
+ $FOREACH inhno INHNO_RANGE$
+   $TAB$.extern$TAB$__kernel_default_int_handler_entry_$inhno$$NL$
+   __kernel_default_int_handler_entry_$inhno$:$NL$
+   $TAB$pushm	r1-r5								; スクラッチレジスタをタスクスタックへ退避 $NL$
+   $TAB$mov.l	#$+inhno$, r1						; 割込みハンドラ番号をr1へ $NL$
+   $TAB$mov.l	#__kernel_default_int_handler, r2	; ハンドラのアドレスをr2へ $NL$
+   $TAB$bra.a	_kernel_interrupt					; 共通ルーチンへ $NL$$NL$$NL$
+ $END$
+ 
+ 
+ $ 
+ $  CPU例外ハンドラ入口処理
+ $ 
+ 
+ $TAB$.extern	_kernel_exception$NL$$NL$
+ 
+ $FOREACH excno EXCNO_RANGE$
+ 	$IF LENGTH(EXC.EXCNO[excno])$
+ 		$TAB$.extern	_$EXC.EXCHDR[excno]$$NL$
+ 		$TAB$.global	__kernel_$EXC.EXCHDR[excno]$_$+EXC.EXCNO[excno]$_entry$NL$
+ 		__kernel_$EXC.EXCHDR[excno]$_$+EXC.EXCNO[excno]$_entry:$NL$
+ 		$TAB$pushm	r1-r5						; スクラッチレジスタをタスクスタックへ退避 $NL$
+ 		$TAB$mov.l	#$+EXC.EXCNO[excno]$, r1	; CPU例外ハンドラ番号をr1へ $NL$
+ 		$TAB$mov.l	#_$EXC.EXCHDR[excno]$, r2	; ハンドラのアドレスをr2へ $NL$
+ 		$TAB$bra.a	_kernel_exception			; 共通ルーチンへ $NL$$NL$$NL$
+ 	$END$
+ $END$
+ 
+ 
+ $ 未登録CPU例外ハンドラ入口処理
+ $TAB$.extern$TAB$__kernel_default_exc_handler_entry$NL$
+ __kernel_default_exc_handler_entry:$NL$
+ $TAB$pushm	r1-r5								; スクラッチレジスタをタスクスタックへ退避 $NL$
+ $TAB$mov.l	#0FFFFFFFFH, r1						; CPU例外ハンドラ番号をr1へ $NL$
+ $TAB$mov.l	#__kernel_default_exc_handler, r2	; ハンドラのアドレスをr2へ $NL$
+ $TAB$bra.a	_kernel_exception					; 共通ルーチンへ $NL$$NL$$NL$
+ 
+ 
+ $ 
+ $  可変ベクタテーブル
+ $ 
+ 
+ ;$NL$
+ ;  可変ベクタテーブル$NL$
+ ;$NL$
+ $NL$
+ 
+ $TAB$.extern $TAB$ _startw$NL$$NL$
+ 
+ $FOREACH inhno INH.ORDER_LIST$
+ 	$IF ((INH.INHATR[inhno] & TA_NONKERNEL) != 0)$
+ 		$TAB$.global $TAB$ _$INH.INTHDR[inhno]$ $NL$
+ 	$END$
+ $END$
+ $NL$
+ 
+ $TAB$.section C$$VECT$NL$$NL$
+ $TAB$.glb __vvector_table$NL$$NL$
+ __vvector_table:$NL$
+ $FOREACH inhno INHNO_RANGE$
+ 	$IF LENGTH(INH.INHNO[inhno])$
+ 		$IF ((INH.INHATR[inhno] & TA_NONKERNEL) == 0)$
+ 			$inhhdr = CONCAT(CONCAT("_kernel_" , CONCAT(INH.INTHDR[inhno] , "_")) , CONCAT(+INH.INHNO[inhno] , "_entry"))$
+ 		$ELSE$
+ 			$inhhdr = INH.INTHDR[inhno]$
+ 		$END$
+ 	$ELSE$
+ 		$inhhdr = CONCAT("_kernel_default_int_handler_entry_", inhno)$
+ 	$END$
+ 
+ 	$TAB$.word$TAB$_$inhhdr$ $TAB$ $TAB$ $FORMAT("; %02d" , inhno)$ $NL$
+ $END$
+ 
+ 
+ $ 
+ $  固定ベクタテーブル
+ $ 
+ $FOREACH excno EXCNO_RANGE$
+ 	$IF LENGTH(EXC.EXCNO[excno])$
+ 		$EXCHDR[excno] = CONCAT(CONCAT("_kernel_" , CONCAT(EXC.EXCHDR[excno] , "_")) , CONCAT(+EXC.EXCNO[excno] , "_entry"))$
+ 	$ELSE$
+ 		$EXCHDR[excno] = "_kernel_default_exc_handler_entry"$
+ 	$END$
+ $END$
+ 
+ $NL$
+ ;$NL$
+ ;  固定ベクタテーブル$NL$
+ ;$NL$
+ $NL$
+ 
+ $TAB$ .section .fvect,ROMDATA,align=4 $NL$
+ $TAB$ .glb fvector_table $NL$
+ fvector_table:$NL$$NL$
+ $TAB$ .space$TAB$ 0x1c$NL$
+ $TAB$ .word$TAB$ 0xFFFFFFFF $TAB$ ; ROMコード(0xFFFFFF9C)$NL$
+ $TAB$ .word$TAB$ 0xFFFFFFFF $TAB$ ; 制御コード(0xFFFFFFA0), IDコード1 - 3$NL$
+ $TAB$ .word$TAB$ 0xFFFFFFFF $TAB$ ; IDコード4 - 7$NL$
+ $TAB$ .word$TAB$ 0xFFFFFFFF $TAB$ ; IDコード8 - 11$NL$
+ $TAB$ .word$TAB$ 0xFFFFFFFF $TAB$ ; IDコード12 - 15$NL$
+ $TAB$ .space$TAB$ 0x20$NL$
+ $TAB$ .word$TAB$ _$EXCHDR[20]$ $TAB$ $TAB$ ;$SPC$ 20:特権命令例外 $SPC$$NL$
+ $TAB$ .space$TAB$ 0x8$NL$
+ $TAB$ .word$TAB$ _$EXCHDR[23]$ $TAB$ $TAB$ ;$SPC$ 23:未定義命令例外 $SPC$$NL$
+ $TAB$ .space$TAB$ 0x4$NL$
+ $TAB$ .word$TAB$ _$EXCHDR[25]$ $TAB$ $TAB$ ;$SPC$ 25:浮動小数点例外 $SPC$$NL$
+ $TAB$ .space$TAB$ 0x10$NL$
+ $TAB$ .word$TAB$ _$EXCHDR[30]$ $TAB$ $TAB$ ;$SPC$ 30:ノンマスカブル例外 $SPC$$NL$
+ ;$TAB$ .word$TAB$ _startw $TAB$ $TAB$ $TAB$ $TAB$ ;$SPC$ 31:リセット $SPC$$NL$
+ ;wata
+ $NL$ $NL$
+ 
+ 	$TAB$.end
+ $NL$
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/prc_stddef.h ASPs/asp/arch/rx_gcc/rx72n/prc_stddef.h
*** 1.9.1/asp/arch/rx_gcc/rx72n/prc_stddef.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/prc_stddef.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,55 ----
+ /*
+  *  TOPPERS Software
+  *      Toyohashi Open Platform for Embedded Real-Time Systems
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2015 by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		t_stddef.hのプロセッサ依存部（RX72n用）from RX62n
+  *
+  *  このインクルードファイルは，target_stddef.h（または，そこからインク
+  *  ルードされるファイル）のみからインクルードされる．他のファイルから
+  *  直接インクルードしてはならない．
+  */
+ 
+ #ifndef TOPPERS_PRC_STDDEF_H
+ #define TOPPERS_PRC_STDDEF_H
+ 
+ /*
+  *  ターゲットを識別するためのマクロの定義
+  */
+ #define TOPPERS_RX72N				/* プロセッサ略称 */
+ 
+ #endif /* TOPPERS_PRC_STDDEF_H */
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/prc_syssvc.h ASPs/asp/arch/rx_gcc/rx72n/prc_syssvc.h
*** 1.9.1/asp/arch/rx_gcc/rx72n/prc_syssvc.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/prc_syssvc.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,53 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2015- by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation 
+  *  によって公表されている GNU General Public License の Version 2 に記
+  *  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
+  *  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+  *  利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
+  *  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
+  *  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		テストプログラムのターゲット依存定義（RX72n用）
+  */
+ 
+ #ifndef TOPPERS_PRC_SYSSVC_H
+ #define TOPPERS_PRC_SYSSVC_H
+ 
+ /*
+  *  起動メッセージにターゲット依存部の著作権表示を
+  *  追加するためのマクロ．
+  */
+ #define PRC_COPYRIGHT										\
+ 	"Copyright (C) 2015 by Hisashi Hata, JAPAN\n"
+ 
+ 
+ #endif	/* TOPPERS_PRC_SYSSVC_H */
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/prc_user.txt ASPs/asp/arch/rx_gcc/rx72n/prc_user.txt
*** 1.9.1/asp/arch/rx_gcc/rx72n/prc_user.txt	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/prc_user.txt	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,233 ----
+ =====================================================================
+                          RXプロセッサ依存部
+                                   Last Modified: '10/12/25
+ =====================================================================
+ 
+ ○概要
+ 
+ RX依存部はルネサスエレクトロニクス製RXファミリをターゲットとしている．
+ RXにはいくつか(600シリーズ, 200シリーズ)のバリエーションが存在する.
+ そのため，バリエーション毎に異なる部分はバリエーション毎のファイルに
+ 分けることにより対応する．
+ 
+ 
+ ○コンパイラ
+ 
+ カーネルはルネサスエレクトロニクス製RX ToolChainを用いてコンパイルする．
+ 動作確認したバージョンはターゲット依存部のドキュメントに記載する．
+ 
+ 
+ ○カーネルの使用リソース
+ 
+ カーネルは以下のリソースを使用する．
+ 
+   ・コンペアマッチタイマ
+      コンペアマッチタイマの1ユニットを使用する．カーネル内部のティックの生成に用いる．
+      使用するユニットはターゲット毎に異なる．
+ 
+   ・シリアル
+      システムのポートを1ポート使用する．使用するポートはターゲット毎に異なる．
+ 
+ 
+ ○割り込みハンドラ番号と割込み番号
+ 
+ 割込みハンドラ番号(inhno)と割込み番号(intno)は，同一であり, 可変ベクタテーブルのベクタ
+ 番号に対応する．
+ ※有効なベクタ番号は「rx610.h」にて定義
+ 
+ 
+ ○CPU例外ハンドラ番号
+ 
+ RXでは例外事象をCPU例外として扱う．
+ 
+ 例外事象には例外番号が振られていないため，固定ベクタテーブルの小さい順
+ に例外番号を割り振る.
+ 
+ CPU例外ハンドラ番号は例外番号と一致する．
+ ※FFFFFF80h番地を0とし、予約領域にも番号を割り振る.
+ ※有効な例外番号は「rx610.h」にて定義.
+ 
+ 
+ ○カーネル管理内/外の割込み
+ 
+ ある割込み優先度以上の割込み優先度をカーネル管理外の割込みとして用いる
+ ことが可能である．カーネル管理内の割込みの最小値は TMIN_INTPRI で設定
+ されている．TMIN_INTPRI はデフォルトでは，「-15」となっており，ターゲッ
+ ト依存部で上書きが可能である．ターゲット依存部にてTMIN_INTPRIに「-13」を
+ 設定した場合，割込み優先度が「-1」から「-13」の割込みをカーネル管理内割
+ 込みとし，「-14」から「-15」の割込みをカーネル管理外割込みとする．
+ 
+ 
+ ○CFG_INTに指定可能な割込み優先度
+ 
+ CFG_INTに指定可能な割込み優先度としては，「-1」から 「-15」 までの値を
+ 設定可能である．
+ カーネル管理外割込みに対しても，CFG_INTで要求ラインの属性を設定するこ
+ とができる．
+ DEF_INHで属性に管理内割込みを設定するか管理外割込みを設定するかによって
+ CFG_INTに設定可能な割込み優先度の有効範囲が異なる．ターゲット依存部にて
+ TMIN_INTPRIに「-5」を設定した場合，カーネル管理内割込みには割込み優先度
+ 「-1」から「-5」までの値を設定可能であり，カーネル管理外割込みには割込み
+ 優先度「-6」から「-15」までの値を設定可能である．
+ 
+ 
+ TMIN_INTPRIの定義場所＞
+ ・C言語用の定義
+     デフォルトの定義    ：prc_kernel.h
+     ターゲット依存の定義：target_config.h（現状では未定義）
+ 
+ 
+ ○割込み属性
+ 
+ IRQ割込みに関しては, 以下の属性を設定可能である．
+     −TA_POSEDGE
+     −TA_NEGEDGE
+     −TA_BOTHEDGE
+     −TA_LOWLEVEL
+ 
+ 
+ ○制限事項
+ ・カーネルのコンフィギュレーション
+   コンフィギュレーションのパス3（ビルド後の構成チェック）は行っていない．
+ 
+ 
+ ○注意事項
+ ・RXプロセッサ依存部は以下のWindows開発環境，文字コードをSJIS，
+   改行コードをCR+LFに設定して使用することを前提とする．
+ 
+ ・現在, 構造体オフセットのアライメントの最適化を実施していない.
+   #pragma pack命令等により, 最適化を実施する場合, makeoffsetプロジェクトを
+   再度ビルドすること.
+ 
+ ・カーネル管理外割込みハンドラはコンパイラ拡張命令"#pragma interrupt"により
+   定義すること.
+ 
+ ・タスクスタックサイズの最小値は84byteである.
+   割込み入口処理：48byte使用
+   CPU例外入口処理：84byte使用
+ 
+ 
+ =====================================================================
+                プロセッサ依存部開発者向けの情報
+ =====================================================================
+ 
+ ○サポートプロセッサの追加
+ 
+ サポートするプロセッサを追加する場合には，サポートするプロセッサの型番
+ （rxXX）でテンプレートファイル(rxXX.tf)， カーネル実装のターゲット
+ 依存の定義(rxXX_config.h)，ハードウェア資源のヘッダーファイル（rxXX.h）
+ を作成する必要がある．
+ その他のファイルが必要な場合は，プロセッサの型番を先頭に付けてファイルを
+ 作成し，ターゲット依存部からインクルードすればよい．
+ 
+ 
+ ○ターゲットプロセッサ毎の定義内容
+ 
+ ●ハードウェア資源のヘッダーファイル(rxXX.h)
+ 
+ MCU依存定義ファイルには，以下のマクロや関数やSFRアドレスを定義する．
+ （下記以外の情報を定義してもよい．）
+ 
+ ・CPU例外番号
+   INT_PRIVILEGED_INSTRUNCTION
+   INT_UNDEF_INSTRUNCTION
+   INT_FLOATINGPOINT_INSTRUCTION
+   INT_NMI
+   INT_RESET
+ 
+ ・割込み番号
+   INT_BUSERR
+   INT_FCU_FCUERR
+       :
+       :
+       :
+   INT_RIIC1_TXI1
+   INT_RIIC1_TEI1
+ 
+ ・カーネルが操作するレジスタ
+   割込み要求レジスタ（IR）
+   割込み要求先設定レジスタ（ISEL）
+   割込み要求許可レジスタ（IER）
+   割込み要求プライオリティレジスタ（IPR）
+   IRQコントロールレジスタ（IRQ）
+ 
+ ・コンペアマッチタイマ
+   CMT_CMSTRx_ADDR
+   CMTx_CMCR_ADDR
+   CMTx_CMCNT_ADDR
+   CMTx_CMCOR_ADDR
+ 
+   xはコンペアマッチタイマのチャンネルID
+ 
+ ・シリアルポートの数
+   TNUM_SIOP
+ 
+ ・シリアルコミュニケーションインタフェース
+   SCIx_SMR_ADDR
+   SCIx_BRR_ADDR
+   SCIx_SCR_ADDR
+   SCIx_TDR_ADDR
+   SCIx_SSR_ADDR
+   SCIx_RDR_ADDR
+   SCIx_SCMR_ADDR
+   SCIx_SEMR_ADDR
+ 
+   xはシリアルコミュニケーションインタフェースのチャンネルID
+ 
+ ・その他
+   モジュールストップコントロールレジスタ
+     SYSTEM_MSTPCRA_ADDR
+     SYSTEM_MSTPCRB_ADDR
+     SYSTEM_MSTPCRC_ADDR
+ 
+ 
+ ●プロセッサ依存モジュールファイル(rxXX_config.c / rxXX_config.h)
+ 
+ プロセッサ依存モジュールファイルには，以下の割込み制御用マクロや
+ 関数やデータを定義する．
+ ターゲット依存部では，使用するターゲットプロセッサのヘッダファイル
+ をインクルードする．
+ 
+ ・割込み要因プライオリティレジスタアドレス
+ 
+   volatile uint8_t * const ipr_reg_addr[ INHNO_MAX ]
+ 
+ ・割込み要求許可レジスタアドレステーブル
+ 
+   const IER_INFO ier_reg_addr[ INHNO_MAX ]
+ 
+ ・割込み要求レジスタアドレステーブル
+ 
+   volatile uint8_t * const ir_reg_addr[ INHNO_MAX ]
+ 
+ ・IRQコントロールレジスタアドレステーブル
+ 
+   volatile uint8_t * const irqcr_reg_addr[ IRQ_MAX ]
+ 
+ 
+ ●CFG用テンプレートファイル
+ 
+ CFG用のテンプレートファイルには以下の変数をを定義する．ターゲット依存
+ 部のCFG用テンプレートファイルでは，prc.tf をインクルードする前に，使用
+ するターゲットプロセッサのCFG用テンプレートファイルをインクルードする
+ こと．
+ 
+ ・有効な割込み番号，割込みハンドラ番号，CPU例外ハンドラ番号
+ 
+ $INTNO_VALID
+ $INHNO_VALID
+ $EXCNO_VALID
+ 
+ ・割込み番号数，割込みハンドラ番号数，CPU例外ハンドラ番号数
+   ・0からカウントし，予約領域等もその間をカウントする
+ 
+ $INTNO_RANGE 
+ $INHNO_RANGE 
+ $EXCNO_RANGE 
+ 
+ 
+ ○変更履歴
+ 2010/9/21  ・新規作成                                  ヴィッツ
+ 2010/9/29  ・割込み番号, 例外番号の説明を修正          ヴィッツ
+ 2010/12/25 ・カーネル管理内/外の割込みの説明追記       ヴィッツ
+            ・CFG_INTに指定可能な割込み優先度の説明修正 ヴィッツ
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/rx72n.h ASPs/asp/arch/rx_gcc/rx72n/rx72n.h
*** 1.9.1/asp/arch/rx_gcc/rx72n/rx72n.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/rx72n.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,2040 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  *
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  *
+  */
+ 
+ /*
+  *  RX72nに依存する定義
+  */
+ #ifndef TOPPERS_RX72n_H
+ #define TOPPERS_RX72n_H
+ 
+ #include <sil.h>
+ 
+ /*
+  *  CPU例外ハンドラ番号の定義(固定ベクタテーブル)
+  *
+  *  番号の範囲は0 - 31
+  */
+ #define INT_PRIVILEGED_INSTRUNCTION		20		/* 特権命令例外 */
+ #define INT_UNDEF_INSTRUNCTION			23		/* 未定義命令例外 */
+ #define INT_FLOATINGPOINT_INSTRUCTION	25		/* 浮動小数点例外 */
+ #define INT_NMI							30		/* ノンマスカブル割り込み */
+ #define INT_RESET						31		/* リセット */
+ 
+ /*
+  *  割込み番号の定義(可変ベクタテーブル)
+  */
+ 
+ #define INT_BUSERR			16
+ #define INT_FCU_FCUERR		21
+ #define INT_FCU_FRDYI		23
+ #define INT_ICU_SWINT       27
+ #define INT_CMT0_CMI0		28
+ #define INT_CMT1_CMI1		29
+ #define INT_CMT2_CMI2		128
+ #define INT_CMT3_CMI3		31
+ #define INT_ETHER_EINT      32
+ #define INT_USB0_D0FIFO0    33
+ #define INT_USB0_D1FIFO0    34
+ #define INT_USB0_USBI0      35
+ #define INT_USB1_D0FIFO1    36
+ #define INT_USB1_D1FIFO1    37
+ #define INT_USB1_USBI1      38
+ #define INT_RSPI0_SPRI0     39
+ #define INT_RSPI0_SPTI0     40
+ #define INT_RSPI0_SPII0     41
+ #define INT_RSPI1_SPRI1     42
+ #define INT_RSPI1_SPTI1     43
+ #define INT_RSPI1_SPII1     44
+ #define INT_RSPI2_SPRI2     45
+ #define INT_RSPI2_SPTI2     46
+ #define INT_RSPI2_SPII2     47
+ #define INT_CAN0_RXF0       48
+ #define INT_CAN0_TXF0       49
+ #define INT_CAN0_RXM0       50
+ #define INT_CAN0_TXM0       51
+ #define INT_CAN1_RXF1       52
+ #define INT_CAN1_TXF1       53
+ #define INT_CAN1_RXM1       54
+ #define INT_CAN1_TXM1       55
+ #define INT_CAN2_RXF2       56
+ #define INT_CAN2_TXF2       57
+ #define INT_CAN2_RXM2       58
+ #define INT_CAN2_TXM2       59
+ #define INT_RTC_CUP         62
+ #define INT_IRQ0			64
+ #define INT_IRQ1			65
+ #define INT_IRQ2			66
+ #define INT_IRQ3			67
+ #define INT_IRQ4			68
+ #define INT_IRQ5			69
+ #define INT_IRQ6			70
+ #define INT_IRQ7			71
+ #define INT_IRQ8			72
+ #define INT_IRQ9			73
+ #define INT_IRQ10			74
+ #define INT_IRQ11			75
+ #define INT_IRQ12			76
+ #define INT_IRQ13			77
+ #define INT_IRQ14			78
+ #define INT_IRQ15			79
+ #define INT_USB_USBR0       90
+ #define INT_USB_USBR1       91
+ #define INT_RTC_ALM         92
+ #define INT_RTC_PRD         93
+ #define INT_AD_ADI0         98
+ #define INT_S12AD_S12ADI0   102
+ #define INT_ICU_GROUP0      106
+ #define INT_ICU_GROUP1      107
+ #define INT_ICU_GROUP2      108
+ #define INT_ICU_GROUP3      109
+ #define INT_ICU_GROUP4      110
+ #define INT_ICU_GROUP5      111
+ #define INT_ICU_GROUP6      112
+ #define INT_EDMAC0  113
+ 
+ #define INT_ICU_GROUP12     114
+ #define INT_SCI12_SCIX0     122
+ #define INT_SCI12_SCIX1     123
+ #define INT_SCI12_SCIX2     124
+ #define INT_SCI12_SCIX3     125
+ //TPU and MTU are sheared irq.
+ //TPU define
+ #define INT_TPU0_TGI0A		126
+ #define INT_TPU0_TGI0B		127
+ #define INT_TPU0_TGI0C		30
+ #define INT_TPU0_TGI0D		129
+ #define INT_TPU1_TGI1A		130
+ #define INT_TPU1_TGI1B		131
+ #define INT_TPU2_TGI2A		132
+ #define INT_TPU2_TGI2B		133
+ #define INT_TPU3_TGI3A		134
+ #define INT_TPU3_TGI3B		135
+ #define INT_TPU3_TGI3C		136
+ #define INT_TPU3_TGI3D		137
+ #define INT_TPU4_TGI4A		138
+ #define INT_TPU4_TGI4B		139
+ #define INT_TPU5_TGI5A		140
+ #define INT_TPU5_TGI5B		141
+ #define INT_TPU6_TGI6A		142
+ #define INT_TPU6_TGI6B		143
+ #define INT_TPU6_TGI6C		144
+ #define INT_TPU7_TGI7A		148
+ #define INT_TPU7_TGI7B		149
+ #define INT_TPU8_TGI8A		150
+ #define INT_TPU8_TGI8B		151
+ #define INT_TPU9_TGI9A		152
+ #define INT_TPU9_TGI9B		153
+ #define INT_TPU9_TGI9C		154
+ #define INT_TPU9_TGI9D		155
+ #define INT_TPU10_TGI10A	156
+ #define INT_TPU10_TGI10B	157
+ #define INT_TPU11_TGI11A	164
+ #define INT_TPU11_TGI11B	165
+ //MTU define
+ #define INT_MTU0_TGIA0      142
+ #define INT_MTU0_TGIB0      143
+ #define INT_MTU0_TGIC0      144
+ #define INT_MTU0_TGID0      145
+ #define INT_MTU0_TGIE0      146
+ #define INT_MTU0_TGIF0      147
+ #define INT_MTU1_TGIA1      148
+ #define INT_MTU1_TGIB1      149
+ #define INT_MTU2_TGIA2      150
+ #define INT_MTU2_TGIB2      151
+ #define INT_MTU3_TGIA3      152
+ #define INT_MTU3_TGIB3      153
+ #define INT_MTU3_TGIC3      154
+ #define INT_MTU3_TGID3      155
+ #define INT_MTU4_TGIA4      156
+ #define INT_MTU4_TGIB4      157
+ #define INT_MTU4_TGIC4      158
+ #define INT_MTU4_TGID4      159
+ #define INT_MTU4_TGIV4      160
+ #define INT_MTU5_TGIU5      161
+ #define INT_MTU5_TGIV5      162
+ #define INT_MTU5_TGIW5      163
+ #define INT_POE_OEI1        166
+ #define INT_POE_OEI2        167
+ #define INT_TMR0_CMIA0		170
+ #define INT_TMR0_CMIB0		171
+ #define INT_TMR0_OVI0		172
+ #define INT_TMR1_CMIA1		173
+ #define INT_TMR1_CMIB1		174
+ #define INT_TMR1_OVI1		175
+ #define INT_TMR2_CMIA2		176
+ #define INT_TMR2_CMIB2		177
+ #define INT_TMR2_OVI2		178
+ #define INT_TMR3_CMIA3		179
+ #define INT_TMR3_CMIB3		180
+ #define INT_TMR3_OVI3		181
+ #define INT_RIIC0_EEI0      182
+ #define INT_RIIC0_RXI0      183
+ #define INT_RIIC0_TXI0      184
+ #define INT_RIIC0_TEI0      185
+ #define INT_RIIC1_EEI1      186
+ #define INT_RIIC1_RXI1      187
+ #define INT_RIIC1_TXI1      188
+ #define INT_RIIC1_TEI1      189
+ #define INT_RIIC2_EEI2      190
+ #define INT_RIIC2_RXI2      191
+ #define INT_RIIC2_TXI2      192
+ #define INT_RIIC2_TEI2      193
+ #define INT_RIIC3_EEI3      194
+ #define INT_RIIC3_RXI3      195
+ #define INT_RIIC3_TXI3      196
+ #define INT_RIIC3_TEI3      197
+ #define INT_DMAC_DMAC0I     198
+ #define INT_DMAC_DMAC1I     199
+ #define INT_DMAC_DMAC2I     200
+ #define INT_DMAC_DMAC3I     201
+ #define INT_EXDMAC_EXDMAC0I 202
+ #define INT_EXDMAC_EXDMAC1I 203
+ #define INT_DEU_DEU0        206
+ #define INT_DEU_DEU1        207
+ #define INT_PDC_PCDFI       208
+ #define INT_PDC_PCFEI       209
+ #define INT_PDC_PCERI       210
+ #define INT_SCI0_RXI0		214
+ #define INT_SCI0_TXI0		215
+ #define INT_SCI0_TEI0		216
+ #define INT_SCI1_RXI1		217
+ #define INT_SCI1_TXI1		218
+ #define INT_SCI1_TEI1		219
+ #define INT_SCI2_RXI2		220
+ #define INT_SCI2_TXI2		221
+ #define INT_SCI2_TEI2		222
+ #define INT_SCI3_RXI3		223
+ #define INT_SCI3_TXI3		224
+ #define INT_SCI3_TEI3		225
+ #define INT_SCI4_RXI4		226
+ #define INT_SCI4_TXI4		227
+ #define INT_SCI4_TEI4		228
+ #define INT_SCI5_RXI5		229
+ #define INT_SCI5_TXI5		230
+ #define INT_SCI5_TEI5		231
+ #define INT_SCI6_RXI6		232
+ #define INT_SCI6_TXI6		233
+ #define INT_SCI6_TEI6		234
+ #define INT_SCI7_RXI7		235
+ #define INT_SCI7_TXI7		236
+ #define INT_SCI7_TEI7		237
+ #define INT_SCI8_RXI8		238
+ #define INT_SCI8_TXI8		239
+ #define INT_SCI8_TEI8		240
+ #define INT_SCI9_RXI9		241
+ #define INT_SCI9_TXI9		242
+ #define INT_SCI9_TEI9		243
+ #define INT_SCI10_RXI10		244
+ #define INT_SCI10_TXI10		245
+ #define INT_SCI10_TEI10		246
+ #define INT_SCI11_RXI11		247
+ #define INT_SCI11_TXI11		248
+ #define INT_SCI11_TEI11		249
+ #define INT_SCI12_RXI12		250
+ #define INT_SCI12_TXI12		251
+ #define INT_SCI12_TEI12		252
+ #define INT_IEB_IEBINT		253
+ 
+ 
+ /*
+  *  各モジュールのレジスタ及び設定ビット情報
+  */
+ 
+ /*
+  *  Register write protection
+  */
+ #define SYSTEM_PRCR_ADDR ( 0x000803FE )
+ #define SYSTEM_PRKEY  0xA500
+ #define SYSTEM_PRC0	( 1UL << 0U )
+ #define SYSTEM_PRC1	( 1UL << 1U )
+ #define SYSTEM_PRC3	( 1UL << 3U )
+ 
+ /*
+  * Clock generater
+  */
+ //SCKCR define
+ #define CKG_SCKCR_ADDR ( ( volatile uint32_t *)0x00080020 )
+ #define CKG_SCKCR_RESERVE 0x11
+ #define CKG_SCKCR_PB_DIV01 ( 0UL << 8 )
+ #define CKG_SCKCR_PB_DIV02 ( 1UL << 8 )
+ #define CKG_SCKCR_PB_DIV04 ( 2UL << 8 )
+ #define CKG_SCKCR_PB_DIV08 ( 3UL << 8 )
+ #define CKG_SCKCR_PB_DIV16 ( 4UL << 8 )
+ #define CKG_SCKCR_PB_DIV32 ( 5UL << 8 )
+ #define CKG_SCKCR_PB_DIV64 ( 6UL << 8 )
+ #define CKG_SCKCR_PA_DIV01 ( 0UL << 12 )
+ #define CKG_SCKCR_PA_DIV02 ( 1UL << 12 )
+ #define CKG_SCKCR_PA_DIV04 ( 2UL << 12 )
+ #define CKG_SCKCR_PA_DIV08 ( 3UL << 12 )
+ #define CKG_SCKCR_PA_DIV16 ( 4UL << 12 )
+ #define CKG_SCKCR_PA_DIV32 ( 5UL << 12 )
+ #define CKG_SCKCR_PA_DIV64 ( 6UL << 12 )
+ #define CKG_SCKCR_BCK_DIV01 ( 0UL << 16 )
+ #define CKG_SCKCR_BCK_DIV02 ( 1UL << 16 )
+ #define CKG_SCKCR_BCK_DIV04 ( 2UL << 16 )
+ #define CKG_SCKCR_BCK_DIV08 ( 3UL << 16 )
+ #define CKG_SCKCR_BCK_DIV16 ( 4UL << 16 )
+ #define CKG_SCKCR_BCK_DIV32 ( 5UL << 16 )
+ #define CKG_SCKCR_BCK_DIV64 ( 6UL << 16 )
+ #define CKG_SCKCR_PSTOP0 ( 1UL << 22 )
+ #define CKG_SCKCR_PSTOP1 ( 1UL << 23 )
+ #define CKG_SCKCR_ICK_DIV01  ( 0UL << 24 )
+ #define CKG_SCKCR_ICK_DIV02  ( 1UL << 24 )
+ #define CKG_SCKCR_ICK_DIV04  ( 2UL << 24 )
+ #define CKG_SCKCR_ICK_DIV08  ( 3UL << 24 )
+ #define CKG_SCKCR_ICK_DIV16  ( 4UL << 24 )
+ #define CKG_SCKCR_ICK_DIV32  ( 5UL << 24 )
+ #define CKG_SCKCR_ICK_DIV64  ( 6UL << 24 )
+ #define CKG_SCKCR_FCK_DIV01  ( 0UL << 28 )
+ #define CKG_SCKCR_FCK_DIV02  ( 1UL << 28 )
+ #define CKG_SCKCR_FCK_DIV04  ( 2UL << 28 )
+ #define CKG_SCKCR_FCK_DIV08  ( 3UL << 28 )
+ #define CKG_SCKCR_FCK_DIV16  ( 4UL << 28 )
+ #define CKG_SCKCR_FCK_DIV32  ( 5UL << 28 )
+ #define CKG_SCKCR_FCK_DIV64  ( 6UL << 28 )
+ 
+ #define CKG_SCKCR2_ADDR ( ( volatile uint16_t *)0x00080024 )
+ #define CKG_SCKCR2_IEBCK_DIV2   1UL
+ #define CKG_SCKCR2_IEBCK_DIV4   2UL
+ #define CKG_SCKCR2_IEBCK_DIV8   3UL
+ #define CKG_SCKCR2_IEBCK_DIV16  4UL
+ #define CKG_SCKCR2_IEBCK_DIV32  5UL
+ #define CKG_SCKCR2_IEBCK_DIV64  6UL
+ #define CKG_SCKCR2_IEBCK_DIV6   12UL
+ #define CKG_SCKCR2_UCK_NOT_USE (1UL << 4)
+ #define CKG_SCKCR2_UCK_DIV3 (2UL << 4)
+ #define CKG_SCKCR2_UCK_DIV4 (3UL << 4)
+ 
+ 
+ //CLock Select register
+ #define CKG_SCKCR3_ADDR ( ( volatile uint16_t *)0x00080026 )
+ #define CKG_SCKCR3_LOCO ( 0UL << 8 )
+ #define CKG_SCKCR3_HOCO ( 1UL << 8 )
+ #define CKG_SCKCR3_MAIN ( 2UL << 8 )
+ #define CKG_SCKCR3_SUB ( 3UL << 8 )
+ #define CKG_SCKCR3_PLL ( 4UL << 8 )
+ //PLL freq setting
+ #define CKG_PLLCR_ADDR ( ( volatile uint16_t *)0x00080028 )
+ #define CKG_PLLCR_PLIDIV1 ( 0UL << 0U )
+ #define CKG_PLLCR_PLIDIV2 ( 1UL << 0U )
+ #define CKG_PLLCR_PLIDIV4 ( 2UL << 0U )
+ #define CKG_PLLCR_STC8  ( 0x07UL << 8U )
+ #define CKG_PLLCR_STC10 ( 0x09UL << 8U )
+ #define CKG_PLLCR_STC12 ( 0x0BUL << 8U )
+ #define CKG_PLLCR_STC16 ( 0x0FUL << 8U )
+ #define CKG_PLLCR_STC20 ( 0x13UL << 8U )
+ #define CKG_PLLCR_STC24 ( 0x17UL << 8U )
+ #define CKG_PLLCR_STC25 ( 0x18UL << 8U )
+ #define CKG_PLLCR_STC50 ( 0x19UL << 8U )
+ //Clock enable setting
+ #define CKG_PLLCR2_ADDR ( ( volatile uint16_t *)0x0008002A )
+ #define CKG_MOSCCR_ADDR ( ( volatile uint8_t *)0x00080032 )
+ #define CKG_SOSCCR_ADDR ( ( volatile uint8_t *)0x00080033 )
+ #define CKG_LOSCCR_ADDR ( ( volatile uint8_t *)0x00080034 )
+ #define CKG_ILOCOCR_ADDR ( ( volatile uint8_t *)0x00080035 )
+ #define CKG_HOCOCR_ADDR ( ( volatile uint8_t *)0x00080036 )
+ 
+ #define CKG_CLOCK_ENABLE  0UL
+ #define CKG_COCCK_DISABLE 1UL
+ 
+ 
+ 
+ 
+ /*
+  * モジュールストップコントロールレジスタA（MSTPCRA）
+  */
+ 
+ #define SYSTEM_MSTPCRA_ADDR			( ( volatile uint32_t  * )0x00080010 )
+ #define SYSTEM_MSTPCRA_MSTPA4_TMR3_2	( 1UL << 4U )
+ #define SYSTEM_MSTPCRA_MSTPA5_TMR1_0	( 1UL << 5U )
+ #define SYSTEM_MSTPCRA_MSTPA9_MTU	( 1UL << 9U )
+ #define SYSTEM_MSTPCRA_MSTPA10_PPG1	( 1UL << 10U )
+ #define SYSTEM_MSTPCRA_MSTPA11_PPG0	( 1UL << 11U )
+ #define SYSTEM_MSTPCRA_MSTPA12_TPU_U1	( 1UL << 12U )
+ #define SYSTEM_MSTPCRA_MSTPA13_TPU_U0	( 1UL << 13U )
+ #define SYSTEM_MSTPCRA_MSTPA14_CMT_U1	( 1UL << 14U )
+ #define SYSTEM_MSTPCRA_MSTPA15_CMT_U0	( 1UL << 15U )
+ #define SYSTEM_MSTPCRA_MSTPA17_S12AD	( 1UL << 17U )
+ #define SYSTEM_MSTPCRA_MSTPA19_DA	( 1UL << 19U )
+ #define SYSTEM_MSTPCRA_MSTPA23_AD	( 1UL << 23U )
+ #define SYSTEM_MSTPCRA_MSTPA24_BIT	( 1UL << 24U )
+ #define SYSTEM_MSTPCRA_MSTPA27_BIT	( 1UL << 27U )
+ #define SYSTEM_MSTPCRA_MSTPA28_DMAC_DTC	( 1UL << 28U )
+ #define SYSTEM_MSTPCRA_MSTPA29_EXDMAC	( 1UL << 29U )
+ #define SYSTEM_MSTPCRA_ACSE		( 1UL << 31U)
+ 
+ 
+ /*
+  * モジュールストップコントロールレジスタB（MSTPCRB）
+  */
+ 
+ 
+ #define SYSTEM_MSTPCRB_ADDR			( ( volatile uint32_t  * )0x00080014 )
+ #define SYSTEM_MSTPCRB_MSTPB0_CAN0	( 1UL << 0U )
+ #define SYSTEM_MSTPCRB_MSTPB1_CAN1	( 1UL << 1U )
+ #define SYSTEM_MSTPCRB_MSTPB2_CAN2	( 1UL << 2U )
+ #define SYSTEM_MSTPCRB_MSTPB4_SCId	( 1UL << 4U )
+ #define SYSTEM_MSTPCRB_MSTPB8_THERMO	( 1UL << 8U )
+ #define SYSTEM_MSTPCRB_MSTPB15_EDMAC	( 1UL << 15U )
+ #define SYSTEM_MSTPCRB_MSTPB16_RSPI1	( 1UL << 16U )
+ #define SYSTEM_MSTPCRB_MSTPB17_RSPI0	( 1UL << 17U )
+ #define SYSTEM_MSTPCRB_MSTPB18_USB1	( 1UL << 18U )
+ #define SYSTEM_MSTPCRB_MSTPB19_USB0	( 1UL << 19U )
+ #define SYSTEM_MSTPCRB_MSTPB20_RIIC1	( 1UL << 20U )
+ #define SYSTEM_MSTPCRB_MSTPB21_RIIC0	( 1UL << 21U )
+ #define SYSTEM_MSTPCRB_MSTPB22_PDC	( 1UL << 22U )
+ #define SYSTEM_MSTPCRB_MSTPB23_CRC	( 1UL << 23U )
+ #define SYSTEM_MSTPCRB_MSTPB24_SCI7	( 1UL << 24U )
+ #define SYSTEM_MSTPCRB_MSTPB25_SCI6	( 1UL << 25U )
+ #define SYSTEM_MSTPCRB_MSTPB26_SCI5	( 1UL << 26U )
+ #define SYSTEM_MSTPCRB_MSTPB27_SCI4	( 1UL << 27U )
+ #define SYSTEM_MSTPCRB_MSTPB28_SCI3	( 1UL << 28U )
+ #define SYSTEM_MSTPCRB_MSTPB29_SCI2	( 1UL << 29U )
+ #define SYSTEM_MSTPCRB_MSTPB30_SCI1 ( 1UL << 30U )
+ #define SYSTEM_MSTPCRB_MSTPB31_SCI0 ( 1UL << 31U )
+ 
+ /*
+  * モジュールストップコントロールレジスタC（MSTPCRC）
+  */
+ 
+ #define SYSTEM_MSTPCRC_ADDR			( ( volatile uint32_t  * )0x00080018 )
+ #define SYSTEM_MSTPCRC_MSTPC0_RAM0 ( 1UL << 0U )
+ #define SYSTEM_MSTPCRC_MSTPC1_RAM1 ( 1UL << 1U )
+ #define SYSTEM_MSTPCRC_MSTPC16_RIIC3 ( 1UL << 16U )
+ #define SYSTEM_MSTPCRC_MSTPC17_RIIC2 ( 1UL << 17U )
+ #define SYSTEM_MSTPCRC_MSTPC18_IEBUS ( 1UL << 18U )
+ #define SYSTEM_MSTPCRC_MSTPC19_MCK ( 1UL << 19U )
+ #define SYSTEM_MSTPCRC_MSTPC22_RSPI2 ( 1UL << 22U )
+ #define SYSTEM_MSTPCRC_MSTPC24_SCI11 ( 1UL << 24U )
+ #define SYSTEM_MSTPCRC_MSTPC25_SCI10	( 1UL << 25U )
+ #define SYSTEM_MSTPCRC_MSTPC26_SCI9	( 1UL << 26U )
+ #define SYSTEM_MSTPCRC_MSTPC27_SCI8	( 1UL << 27U )
+ 
+ 
+ #define SYSTEM_MSTPCRD_ADDR			( ( volatile uint32_t  * )0x0008001C )
+ #define SYSTEM_MSTPCRD_MSTPD31_BIT	( 1UL << 31U )
+ 
+ /*
+  * clock wait control register
+  */
+ #define SYSTEM_MOSCWTR_ADDR         ( ( volatile uint32_t  * )0x000800A2 )
+ #define SYSTEM_PLLWTCR_ADDR         ( ( volatile uint32_t  * )0x000800A6 )
+ #define SYSTEM_CLKWAIT_H0   0x0
+ #define SYSTEM_CLKWAIT_H1   0x1
+ #define SYSTEM_CLKWAIT_H2   0x2
+ #define SYSTEM_CLKWAIT_H3   0x3
+ #define SYSTEM_CLKWAIT_H4   0x4
+ #define SYSTEM_CLKWAIT_H5   0x5
+ #define SYSTEM_CLKWAIT_H6   0x6
+ #define SYSTEM_CLKWAIT_H7   0x7
+ #define SYSTEM_CLKWAIT_H8   0x8
+ #define SYSTEM_CLKWAIT_H9   0x9
+ #define SYSTEM_CLKWAIT_HA   0xA
+ #define SYSTEM_CLKWAIT_HB   0xB
+ #define SYSTEM_CLKWAIT_HC   0xC
+ #define SYSTEM_CLKWAIT_HD   0xD
+ #define SYSTEM_CLKWAIT_HE   0xE
+ #define SYSTEM_CLKWAIT_HF   0xF
+ 
+ /*
+  * BUS Register
+  */
+ //CSn control register
+ #define BUS_CS0CR_ADDR ((volatile uint16_t*)0x00083802)
+ #define BUS_CS1CR_ADDR ((volatile uint16_t*)0x00083812)
+ #define BUS_CS2CR_ADDR ((volatile uint16_t*)0x00083822)
+ #define BUS_CS3CR_ADDR ((volatile uint16_t*)0x00083832)
+ #define BUS_CS4CR_ADDR ((volatile uint16_t*)0x00083842)
+ #define BUS_CS5CR_ADDR ((volatile uint16_t*)0x00083852)
+ #define BUS_CS6CR_ADDR ((volatile uint16_t*)0x00083862)
+ #define BUS_CS7CR_ADDR ((volatile uint16_t*)0x00083872)
+ #define BUS_CSNCR_EXENB_EN 0x1
+ #define BUS_CSNCR_EXENB_DIS 0x0
+ #define BUS_CSNCR_BSIZE_16 0x00
+ #define BUS_CSNCR_BSIZE_32 0x10
+ #define BUS_CSNCR_BSIZE_8 0x30
+ #define BUS_CSNCR_EMODE_DIF 0x100
+ #define BUS_CSNCR_EMODE_SAME 0x000
+ #define BUS_CSNCR_MPXEN_ENABLE 0x0x1000
+ #define BUS_CSNCR_MPXEN_DISABLE 0x0x0000
+ //CSn recovery cycle control register
+ #define BUS_CS0REC_ADDR ((volatile uint16_t*)0x0008380A)
+ #define BUS_CS1REC_ADDR ((volatile uint16_t*)0x0008381A)
+ #define BUS_CS2REC_ADDR ((volatile uint16_t*)0x0008382A)
+ #define BUS_CS3REC_ADDR ((volatile uint16_t*)0x0008383A)
+ #define BUS_CS4REC_ADDR ((volatile uint16_t*)0x0008384A)
+ #define BUS_CS5REC_ADDR ((volatile uint16_t*)0x0008385A)
+ #define BUS_CS6REC_ADDR ((volatile uint16_t*)0x0008386A)
+ #define BUS_CS7REC_ADDR ((volatile uint16_t*)0x0008387A)
+ #define BUS_CSNREC_RRCV_0 0x0
+ #define BUS_CSNREC_RRCV_1 0x1
+ #define BUS_CSNREC_RRCV_2 0x2
+ #define BUS_CSNREC_RRCV_3 0x3
+ #define BUS_CSNREC_RRCV_4 0x4
+ #define BUS_CSNREC_RRCV_5 0x5
+ #define BUS_CSNREC_RRCV_6 0x6
+ #define BUS_CSNREC_RRCV_7 0x7
+ #define BUS_CSNREC_RRCV_8 0x8
+ #define BUS_CSNREC_RRCV_9 0x9
+ #define BUS_CSNREC_RRCV_10 0xA
+ #define BUS_CSNREC_RRCV_11 0xB
+ #define BUS_CSNREC_RRCV_12 0xC
+ #define BUS_CSNREC_RRCV_13 0xD
+ #define BUS_CSNREC_RRCV_14 0xE
+ #define BUS_CSNREC_RRCV_15 0xF
+ #define BUS_CSNREC_WRCV_0 0x000
+ #define BUS_CSNREC_WRCV_1 0x100
+ #define BUS_CSNREC_WRCV_2 0x200
+ #define BUS_CSNREC_WRCV_3 0x300
+ #define BUS_CSNREC_WRCV_4 0x400
+ #define BUS_CSNREC_WRCV_5 0x500
+ #define BUS_CSNREC_WRCV_6 0x600
+ #define BUS_CSNREC_WRCV_7 0x700
+ #define BUS_CSNREC_WRCV_8 0x800
+ #define BUS_CSNREC_WRCV_9 0x900
+ #define BUS_CSNREC_WRCV_10 0xA00
+ #define BUS_CSNREC_WRCV_11 0xB00
+ #define BUS_CSNREC_WRCV_12 0xC00
+ #define BUS_CSNREC_WRCV_13 0xD00
+ #define BUS_CSNREC_WRCV_14 0xE00
+ #define BUS_CSNREC_WRCV_15 0xF00
+ //CS recovery cycle insert enable
+ #define BUS_CSRECEN_ADDR ((volatile uint16_t)0x00083880)
+ #define BUS_CSRECEN_RCVEN0 0x1
+ #define BUS_CSRECEN_RCVEN1 0x2
+ #define BUS_CSRECEN_RCVEN2 0x3
+ #define BUS_CSRECEN_RCVEN3 0x4
+ #define BUS_CSRECEN_RCVEN4 0x10
+ #define BUS_CSRECEN_RCVEN5 0x20
+ #define BUS_CSRECEN_RCVEN6 0x40
+ #define BUS_CSRECEN_RCVEN7 0x80
+ #define BUS_CSRECEN_RCVENM0 0x100
+ #define BUS_CSRECEN_RCVENM1 0x200
+ #define BUS_CSRECEN_RCVENM2 0x400
+ #define BUS_CSRECEN_RCVENM3 0x800
+ #define BUS_CSRECEN_RCVENM4 0x1000
+ #define BUS_CSRECEN_RCVENM5 0x2000
+ #define BUS_CSRECEN_RCVENM6 0x4000
+ #define BUS_CSRECEN_RCVENM7 0x8000
+ //CSn mode register
+ #define BUS_CS0MOD_ADDR ((volatile uint16_t*)0x00083002)
+ #define BUS_CS1MOD_ADDR ((volatile uint16_t*)0x00083012)
+ #define BUS_CS2MOD_ADDR ((volatile uint16_t*)0x00083022)
+ #define BUS_CS3MOD_ADDR ((volatile uint16_t*)0x00083032)
+ #define BUS_CS4MOD_ADDR ((volatile uint16_t*)0x00083042)
+ #define BUS_CS5MOD_ADDR ((volatile uint16_t*)0x00083052)
+ #define BUS_CS6MOD_ADDR ((volatile uint16_t*)0x00083062)
+ #define BUS_CS7MOD_ADDR ((volatile uint16_t*)0x00083072)
+ #define BUS_CSNMOD_WRMOD_BYTEST 0x0
+ #define BUS_CSNMOD_WRMOD_1WRST 0x1
+ #define BUS_CSNMOD_EWENB_EN 0x8
+ #define BUS_CSNMOD_EWENB_DIS 0x0
+ #define BUS_CSNMOD_PRENB_EN 0x100
+ #define BUS_CSNMOD_PRENB_DIS 0x0
+ #define BUS_CSNMOD_PWENB_EN 0x200
+ #define BUS_CSNMOD_PWENB_DIS 0x0
+ #define BUS_CSNMOD_PRMOD_NOMAL 0x0
+ #define BUS_CSNMOD_PRMOD_EXSEQ 0x8000
+ 
+ #define BUS_CS0WCR1_ADDR ((volatile uint32_t*)0x00083004)
+ #define BUS_CS1WCR1_ADDR ((volatile uint32_t*)0x00083014)
+ #define BUS_CS2WCR1_ADDR ((volatile uint32_t*)0x00083024)
+ #define BUS_CS3WCR1_ADDR ((volatile uint32_t*)0x00083034)
+ #define BUS_CS4WCR1_ADDR ((volatile uint32_t*)0x00083044)
+ #define BUS_CS5WCR1_ADDR ((volatile uint32_t*)0x00083054)
+ #define BUS_CS6WCR1_ADDR ((volatile uint32_t*)0x00083064)
+ #define BUS_CS7WCR1_ADDR ((volatile uint32_t*)0x00083074)
+ #define BUS_CSNWCR1_CSPWWAIT_0 0x0
+ #define BUS_CSNWCR1_CSPWWAIT_1 0x1
+ #define BUS_CSNWCR1_CSPWWAIT_2 0x2
+ #define BUS_CSNWCR1_CSPWWAIT_3 0x3
+ #define BUS_CSNWCR1_CSPWWAIT_4 0x4
+ #define BUS_CSNWCR1_CSPWWAIT_5 0x5
+ #define BUS_CSNWCR1_CSPWWAIT_6 0x6
+ #define BUS_CSNWCR1_CSPWWAIT_7 0x7
+ #define BUS_CSNWCR1_CSPRWAIT_0 0x000
+ #define BUS_CSNWCR1_CSPRWAIT_1 0x100
+ #define BUS_CSNWCR1_CSPRWAIT_2 0x200
+ #define BUS_CSNWCR1_CSPRWAIT_3 0x300
+ #define BUS_CSNWCR1_CSPRWAIT_4 0x400
+ #define BUS_CSNWCR1_CSPRWAIT_5 0x500
+ #define BUS_CSNWCR1_CSPRWAIT_6 0x600
+ #define BUS_CSNWCR1_CSPRWAIT_7 0x700
+ 
+ #define BUS_CSNWCR1_CSWWAIT_0 0x00000
+ #define BUS_CSNWCR1_CSWWAIT_1 0x10000
+ #define BUS_CSNWCR1_CSWWAIT_2 0x20000
+ #define BUS_CSNWCR1_CSWWAIT_3 0x30000
+ #define BUS_CSNWCR1_CSWWAIT_4 0x40000
+ #define BUS_CSNWCR1_CSWWAIT_5 0x50000
+ #define BUS_CSNWCR1_CSWWAIT_6 0x60000
+ #define BUS_CSNWCR1_CSWWAIT_7 0x70000
+ #define BUS_CSNWCR1_CSWWAIT_8 0x80000
+ #define BUS_CSNWCR1_CSWWAIT_9 0x90000
+ #define BUS_CSNWCR1_CSWWAIT_10 0xA0000
+ #define BUS_CSNWCR1_CSWWAIT_11 0xB0000
+ #define BUS_CSNWCR1_CSWWAIT_12 0xC0000
+ #define BUS_CSNWCR1_CSWWAIT_13 0xD0000
+ #define BUS_CSNWCR1_CSWWAIT_14 0xE0000
+ #define BUS_CSNWCR1_CSWWAIT_15 0xF0000
+ #define BUS_CSNWCR1_CSWWAIT_16 0x100000
+ #define BUS_CSNWCR1_CSWWAIT_17 0x110000
+ #define BUS_CSNWCR1_CSWWAIT_18 0x120000
+ #define BUS_CSNWCR1_CSWWAIT_19 0x130000
+ #define BUS_CSNWCR1_CSWWAIT_20 0x140000
+ #define BUS_CSNWCR1_CSWWAIT_21 0x150000
+ #define BUS_CSNWCR1_CSWWAIT_22 0x160000
+ #define BUS_CSNWCR1_CSWWAIT_23 0x170000
+ #define BUS_CSNWCR1_CSWWAIT_24 0x180000
+ #define BUS_CSNWCR1_CSWWAIT_25 0x190000
+ #define BUS_CSNWCR1_CSWWAIT_26 0x1A0000
+ #define BUS_CSNWCR1_CSWWAIT_27 0x1B0000
+ #define BUS_CSNWCR1_CSWWAIT_28 0x1C0000
+ #define BUS_CSNWCR1_CSWWAIT_29 0x1D0000
+ #define BUS_CSNWCR1_CSWWAIT_30 0x1E0000
+ #define BUS_CSNWCR1_CSWWAIT_31 0x1F0000
+ 
+ #define BUS_CSNWCR1_CSRWAIT_0 0x0000000
+ #define BUS_CSNWCR1_CSRWAIT_1 0x1000000
+ #define BUS_CSNWCR1_CSRWAIT_2 0x2000000
+ #define BUS_CSNWCR1_CSRWAIT_3 0x3000000
+ #define BUS_CSNWCR1_CSRWAIT_4 0x4000000
+ #define BUS_CSNWCR1_CSRWAIT_5 0x5000000
+ #define BUS_CSNWCR1_CSRWAIT_6 0x6000000
+ #define BUS_CSNWCR1_CSRWAIT_7 0x7000000
+ #define BUS_CSNWCR1_CSRWAIT_8 0x8000000
+ #define BUS_CSNWCR1_CSRWAIT_9 0x9000000
+ #define BUS_CSNWCR1_CSRWAIT_10 0xA000000
+ #define BUS_CSNWCR1_CSRWAIT_11 0xB000000
+ #define BUS_CSNWCR1_CSRWAIT_12 0xC000000
+ #define BUS_CSNWCR1_CSRWAIT_13 0xD000000
+ #define BUS_CSNWCR1_CSRWAIT_14 0xE000000
+ #define BUS_CSNWCR1_CSRWAIT_15 0xF000000
+ #define BUS_CSNWCR1_CSRWAIT_16 0x10000000
+ #define BUS_CSNWCR1_CSRWAIT_17 0x11000000
+ #define BUS_CSNWCR1_CSRWAIT_18 0x12000000
+ #define BUS_CSNWCR1_CSRWAIT_19 0x13000000
+ #define BUS_CSNWCR1_CSRWAIT_20 0x14000000
+ #define BUS_CSNWCR1_CSRWAIT_21 0x15000000
+ #define BUS_CSNWCR1_CSRWAIT_22 0x16000000
+ #define BUS_CSNWCR1_CSRWAIT_23 0x17000000
+ #define BUS_CSNWCR1_CSRWAIT_24 0x18000000
+ #define BUS_CSNWCR1_CSRWAIT_25 0x19000000
+ #define BUS_CSNWCR1_CSRWAIT_26 0x1A000000
+ #define BUS_CSNWCR1_CSRWAIT_27 0x1B000000
+ #define BUS_CSNWCR1_CSRWAIT_28 0x1C000000
+ #define BUS_CSNWCR1_CSRWAIT_29 0x1D000000
+ #define BUS_CSNWCR1_CSRWAIT_30 0x1E000000
+ #define BUS_CSNWCR1_CSRWAIT_31 0x1F000000
+ 
+ #define BUS_CS0WCR2_ADDR ((volatile uint32_t*)0x00083008)
+ #define BUS_CS1WCR2_ADDR ((volatile uint32_t*)0x00083018)
+ #define BUS_CS2WCR2_ADDR ((volatile uint32_t*)0x00083028)
+ #define BUS_CS3WCR2_ADDR ((volatile uint32_t*)0x00083038)
+ #define BUS_CS4WCR2_ADDR ((volatile uint32_t*)0x00083048)
+ #define BUS_CS5WCR2_ADDR ((volatile uint32_t*)0x00083058)
+ #define BUS_CS6WCR2_ADDR ((volatile uint32_t*)0x00083068)
+ #define BUS_CS7WCR2_ADDR ((volatile uint32_t*)0x00083078)
+ #define BUS_CSNWCR2_CSROFF_0 0x0
+ #define BUS_CSNWCR2_CSROFF_1 0x1
+ #define BUS_CSNWCR2_CSROFF_2 0x2
+ #define BUS_CSNWCR2_CSROFF_3 0x3
+ #define BUS_CSNWCR2_CSROFF_4 0x4
+ #define BUS_CSNWCR2_CSROFF_5 0x5
+ #define BUS_CSNWCR2_CSROFF_6 0x6
+ #define BUS_CSNWCR2_CSROFF_7 0x7
+ #define BUS_CSNWCR2_CSWOFF_0 0x0
+ #define BUS_CSNWCR2_CSWOFF_1 0x10
+ #define BUS_CSNWCR2_CSWOFF_2 0x20
+ #define BUS_CSNWCR2_CSWOFF_3 0x30
+ #define BUS_CSNWCR2_CSWOFF_4 0x40
+ #define BUS_CSNWCR2_CSWOFF_5 0x50
+ #define BUS_CSNWCR2_CSWOFF_6 0x60
+ #define BUS_CSNWCR2_CSWOFF_7 0x70
+ #define BUS_CSNWCR2_WDOFF_0 0x000
+ #define BUS_CSNWCR2_WDOFF_1 0x100
+ #define BUS_CSNWCR2_WDOFF_2 0x200
+ #define BUS_CSNWCR2_WDOFF_3 0x300
+ #define BUS_CSNWCR2_WDOFF_4 0x400
+ #define BUS_CSNWCR2_WDOFF_5 0x500
+ #define BUS_CSNWCR2_WDOFF_6 0x600
+ #define BUS_CSNWCR2_WDOFF_7 0x700
+ #define BUS_CSNWCR2_AWAIT_0 0x0000
+ #define BUS_CSNWCR2_AWAIT_1 0x1000
+ #define BUS_CSNWCR2_AWAIT_2 0x2000
+ #define BUS_CSNWCR2_AWAIT_3 0x3000
+ #define BUS_CSNWCR2_RDON_0 0x00000
+ #define BUS_CSNWCR2_RDON_1 0x10000
+ #define BUS_CSNWCR2_RDON_2 0x20000
+ #define BUS_CSNWCR2_RDON_3 0x30000
+ #define BUS_CSNWCR2_RDON_4 0x40000
+ #define BUS_CSNWCR2_RDON_5 0x50000
+ #define BUS_CSNWCR2_RDON_6 0x60000
+ #define BUS_CSNWCR2_RDON_7 0x70000
+ #define BUS_CSNWCR2_WRON_0 0x000000
+ #define BUS_CSNWCR2_WRON_1 0x100000
+ #define BUS_CSNWCR2_WRON_2 0x200000
+ #define BUS_CSNWCR2_WRON_3 0x300000
+ #define BUS_CSNWCR2_WRON_4 0x400000
+ #define BUS_CSNWCR2_WRON_5 0x500000
+ #define BUS_CSNWCR2_WRON_6 0x600000
+ #define BUS_CSNWCR2_WRON_7 0x700000
+ #define BUS_CSNWCR2_WDON_0 0x0000000
+ #define BUS_CSNWCR2_WDON_1 0x1000000
+ #define BUS_CSNWCR2_WDON_2 0x2000000
+ #define BUS_CSNWCR2_WDON_3 0x3000000
+ #define BUS_CSNWCR2_WDON_4 0x4000000
+ #define BUS_CSNWCR2_WDON_5 0x5000000
+ #define BUS_CSNWCR2_WDON_6 0x6000000
+ #define BUS_CSNWCR2_WDON_7 0x7000000
+ #define BUS_CSNWCR2_CSON_0 0x00000000
+ #define BUS_CSNWCR2_CSON_1 0x10000000
+ #define BUS_CSNWCR2_CSON_2 0x20000000
+ #define BUS_CSNWCR2_CSON_3 0x30000000
+ #define BUS_CSNWCR2_CSON_4 0x40000000
+ #define BUS_CSNWCR2_CSON_5 0x50000000
+ #define BUS_CSNWCR2_CSON_6 0x60000000
+ #define BUS_CSNWCR2_CSON_7 0x70000000
+ //SDC control register
+ #define BUS_SDCCR_ADDR ((volatile uint8_t*)0x00083C00)
+ #define BUS_SDCCR_EXENB_EN 0x1
+ #define BUS_SDCCR_EXENB_DIS 0x0
+ #define BUS_SDCCR_BSIZE_16 0x00
+ #define BUS_SDCCR_BSIZE_16 0x00
+ #define BUS_SDCCR_BSIZE_32 0x10
+ #define BUS_SDCCR_BSIZE_8 0x20
+ //SDC mode register
+ #define BUS_SDCMOD_ADDR ((volatile uint8_t*)0x00083C01)
+ #define BUS_SDCMOD_EMODE_SAME 0x0
+ #define BUS_SDCMOD_EMODE_DIFF 0x1
+ //SDRAM access mode register
+ #define BUS_SDAMOD_ADDR ((volatile uint8_t*)0x00083C02)
+ #define BUS_SDAMOD_BE_DIS 0x0
+ #define BUS_SDAMOD_BE_EN 0x1
+ //SDRAM self refresh control register
+ #define BUS_ADSELF_ADDR ((volatile uint8_t*)0x00083C10)
+ #define BUS_SDAMOD_SFEN_DIS 0x0
+ #define BUS_SDAMOD_SFEN_EN 0x1
+ //SDRAM refresh control register
+ #define BUS_SFRFCR_ADDR ((volatile uint16_t*)0x00083C14)
+ #define BUS_SFRFCR_REFW_1 0x0000
+ #define BUS_SFRFCR_REFW_2 0x1000
+ #define BUS_SFRFCR_REFW_3 0x2000
+ #define BUS_SFRFCR_REFW_4 0x3000
+ #define BUS_SFRFCR_REFW_5 0x4000
+ #define BUS_SFRFCR_REFW_6 0x5000
+ #define BUS_SFRFCR_REFW_7 0x6000
+ #define BUS_SFRFCR_REFW_8 0x7000
+ #define BUS_SFRFCR_REFW_9 0x8000
+ #define BUS_SFRFCR_REFW_10 0x9000
+ #define BUS_SFRFCR_REFW_11 0xA000
+ #define BUS_SFRFCR_REFW_12 0xB000
+ #define BUS_SFRFCR_REFW_13 0xC000
+ #define BUS_SFRFCR_REFW_14 0xD000
+ #define BUS_SFRFCR_REFW_15 0xE000
+ #define BUS_SFRFCR_REFW_16 0xF000
+ //SDRAM auto refresh control register
+ #define BUS_SDREFEN_ADDR ((volatile uint8_t*)0x00083C16)
+ #define BUS_SDREFEN_RFEN_DIS 0x0
+ #define BUS_SDREFEN_RFEN_EN 0x1
+ //SDRAM initialize sequence control regiset
+ #define BUS_SDICR_ADDR ((volatile uint8_t*)0x00083C20)
+ #define BUS_SDICR_INIRQ_START 0x1
+ //SDRAM initialize register
+ #define BUS_SDIR_ADDR ((volatile uint16_t*)0x00083C24)
+ #define BUS_SDIR_ARFI_3 0x0
+ #define BUS_SDIR_ARFI_4 0x1
+ #define BUS_SDIR_ARFI_5 0x2
+ #define BUS_SDIR_ARFI_6 0x3
+ #define BUS_SDIR_ARFI_7 0x4
+ #define BUS_SDIR_ARFI_8 0x5
+ #define BUS_SDIR_ARFI_9 0x6
+ #define BUS_SDIR_ARFI_10 0x7
+ #define BUS_SDIR_ARFI_11 0x8
+ #define BUS_SDIR_ARFI_12 0x9
+ #define BUS_SDIR_ARFI_13 0xA
+ #define BUS_SDIR_ARFI_14 0xB
+ #define BUS_SDIR_ARFI_15 0xC
+ #define BUS_SDIR_ARFI_16 0xD
+ #define BUS_SDIR_ARFI_17 0xE
+ #define BUS_SDIR_ARFI_18 0xF
+ #define BUS_SDIR_ARFC_1 0x10
+ #define BUS_SDIR_ARFC_2 0x20
+ #define BUS_SDIR_ARFC_3 0x30
+ #define BUS_SDIR_ARFC_4 0x40
+ #define BUS_SDIR_ARFC_5 0x50
+ #define BUS_SDIR_ARFC_6 0x60
+ #define BUS_SDIR_ARFC_7 0x70
+ #define BUS_SDIR_ARFC_8 0x80
+ #define BUS_SDIR_ARFC_9 0x90
+ #define BUS_SDIR_ARFC_10 0xA0
+ #define BUS_SDIR_ARFC_11 0xB0
+ #define BUS_SDIR_ARFC_12 0xC0
+ #define BUS_SDIR_ARFC_13 0xD0
+ #define BUS_SDIR_ARFC_14 0xE0
+ #define BUS_SDIR_ARFC_15 0xF0
+ #define BUS_SDIR_PRC_3 0x000
+ #define BUS_SDIR_PRC_4 0x100
+ #define BUS_SDIR_PRC_5 0x200
+ #define BUS_SDIR_PRC_6 0x300
+ #define BUS_SDIR_PRC_7 0x400
+ #define BUS_SDIR_PRC_8 0x500
+ #define BUS_SDIR_PRC_9 0x600
+ #define BUS_SDIR_PRC_10 0x700
+ //SDRAM address register
+ #define BUS_SDADR_ADDR ((volatile uint8_t*)0x00083C40)
+ #define BUS_SDADR_MXC_8 0x0
+ #define BUS_SDADR_MXC_9 0x1
+ #define BUS_SDADR_MXC_10 0x2
+ #define BUS_SDADR_MXC_11 0x3
+ //SDRAM timing register
+ #define BUS_SDTR_ADDR ((volatile uint32_t*)0x00083C44)
+ #define BUS_SDTR_CL_1 0x1
+ #define BUS_SDTR_CL_2 0x2
+ #define BUS_SDTR_CL_3 0x3
+ #define BUS_SDTR_WR_1 0x0
+ #define BUS_SDTR_WR_2 0x100
+ #define BUS_SDTR_RP_1  0x000
+ #define BUS_SDTR_RP_2  0x200
+ #define BUS_SDTR_RP_3  0x400
+ #define BUS_SDTR_RP_4  0x600
+ #define BUS_SDTR_RP_5  0x800
+ #define BUS_SDTR_RP_6  0xA00
+ #define BUS_SDTR_RP_7  0xC00
+ #define BUS_SDTR_RP_8  0xE00
+ #define BUS_SDTR_RCD_1 0x0000
+ #define BUS_SDTR_RCD_2 0x1000
+ #define BUS_SDTR_RCD_3 0x2000
+ #define BUS_SDTR_RCD_4 0x3000
+ #define BUS_SDTR_RAS_1 0x00000
+ #define BUS_SDTR_RAS_2 0x10000
+ #define BUS_SDTR_RAS_3 0x20000
+ #define BUS_SDTR_RAS_4 0x30000
+ #define BUS_SDTR_RAS_5 0x40000
+ #define BUS_SDTR_RAS_6 0x50000
+ #define BUS_SDTR_RAS_7 0x60000
+ //SDRAM mode register
+ #define BUS_SDMOD_ADDR ((volatile uint16_t*)0x00083C48)
+ //SDRAM status register
+ #define BUS_SDSR_ADDR ((volatile uint8_t*)0x00083C50)
+ #define BUS_SDSR_MRSST 0x1
+ #define BUS_SDSR_INIST 0x10
+ #define BUS_SDSR_SRFST 0x20
+ //bus error status clear register
+ #define BUS_BERCLR_ADDR ((volatile uint8_t*)0x00081300)
+ #define BUS_BERCLR_STSCLR 0x1
+ //bus error moniter enable register
+ #define BUS_BEREN_ADDR ((volatile uint8_t*)0x00081304)
+ #define BUS_BEREN_IGAEN_EN 0x1
+ #define BUS_BEREN_IGAEN_DIS 0x0
+ #define BUS_BEREN_TOEN_EN 0x2
+ #define BUS_BEREN_TOEN_DIS 0x0
+ //bus error status register 1
+ #define BUS_BERSR1_ADDR ((volatile uint8_t*)0x00081308)
+ #define BUS_BERSR1_IA 0x1
+ #define BUS_BERSR1_TO 0x2
+ #define BUS_BERSR1_MST_MASK 0x70
+ #define BUS_BERSR1_MST_CPU 0x00
+ #define BUS_BERSR1_MST_DTC_DMAC 0x30
+ #define BUS_BERSR1_MST_EDMAC 0x60
+ #define BUS_BERSR1_MST_EXDMAC 0x70
+ //bus error status register2
+ 
+ /*
+  * BUS Register
+  */
+ //CSn control register
+ #define BUS_CS0CR_ADDR ((volatile uint16_t*)0x00083802)
+ #define BUS_CS1CR_ADDR ((volatile uint16_t*)0x00083812)
+ #define BUS_CS2CR_ADDR ((volatile uint16_t*)0x00083822)
+ #define BUS_CS3CR_ADDR ((volatile uint16_t*)0x00083832)
+ #define BUS_CS4CR_ADDR ((volatile uint16_t*)0x00083842)
+ #define BUS_CS5CR_ADDR ((volatile uint16_t*)0x00083852)
+ #define BUS_CS6CR_ADDR ((volatile uint16_t*)0x00083862)
+ #define BUS_CS7CR_ADDR ((volatile uint16_t*)0x00083872)
+ #define BUS_CSNCR_EXENB_EN 0x1
+ #define BUS_CSNCR_EXENB_DIS 0x0
+ #define BUS_CSNCR_BSIZE_16 0x00
+ #define BUS_CSNCR_BSIZE_32 0x10
+ #define BUS_CSNCR_BSIZE_8 0x30
+ #define BUS_CSNCR_EMODE_DIF 0x100
+ #define BUS_CSNCR_EMODE_SAME 0x000
+ #define BUS_CSNCR_MPXEN_ENABLE 0x0x1000
+ #define BUS_CSNCR_MPXEN_DISABLE 0x0x0000
+ //CSn recovery cycle control register
+ #define BUS_CS0REC_ADDR ((volatile uint16_t*)0x0008380A)
+ #define BUS_CS1REC_ADDR ((volatile uint16_t*)0x0008381A)
+ #define BUS_CS2REC_ADDR ((volatile uint16_t*)0x0008382A)
+ #define BUS_CS3REC_ADDR ((volatile uint16_t*)0x0008383A)
+ #define BUS_CS4REC_ADDR ((volatile uint16_t*)0x0008384A)
+ #define BUS_CS5REC_ADDR ((volatile uint16_t*)0x0008385A)
+ #define BUS_CS6REC_ADDR ((volatile uint16_t*)0x0008386A)
+ #define BUS_CS7REC_ADDR ((volatile uint16_t*)0x0008387A)
+ #define BUS_CSNREC_RRCV_0 0x0
+ #define BUS_CSNREC_RRCV_1 0x1
+ #define BUS_CSNREC_RRCV_2 0x2
+ #define BUS_CSNREC_RRCV_3 0x3
+ #define BUS_CSNREC_RRCV_4 0x4
+ #define BUS_CSNREC_RRCV_5 0x5
+ #define BUS_CSNREC_RRCV_6 0x6
+ #define BUS_CSNREC_RRCV_7 0x7
+ #define BUS_CSNREC_RRCV_8 0x8
+ #define BUS_CSNREC_RRCV_9 0x9
+ #define BUS_CSNREC_RRCV_10 0xA
+ #define BUS_CSNREC_RRCV_11 0xB
+ #define BUS_CSNREC_RRCV_12 0xC
+ #define BUS_CSNREC_RRCV_13 0xD
+ #define BUS_CSNREC_RRCV_14 0xE
+ #define BUS_CSNREC_RRCV_15 0xF
+ #define BUS_CSNREC_WRCV_0 0x000
+ #define BUS_CSNREC_WRCV_1 0x100
+ #define BUS_CSNREC_WRCV_2 0x200
+ #define BUS_CSNREC_WRCV_3 0x300
+ #define BUS_CSNREC_WRCV_4 0x400
+ #define BUS_CSNREC_WRCV_5 0x500
+ #define BUS_CSNREC_WRCV_6 0x600
+ #define BUS_CSNREC_WRCV_7 0x700
+ #define BUS_CSNREC_WRCV_8 0x800
+ #define BUS_CSNREC_WRCV_9 0x900
+ #define BUS_CSNREC_WRCV_10 0xA00
+ #define BUS_CSNREC_WRCV_11 0xB00
+ #define BUS_CSNREC_WRCV_12 0xC00
+ #define BUS_CSNREC_WRCV_13 0xD00
+ #define BUS_CSNREC_WRCV_14 0xE00
+ #define BUS_CSNREC_WRCV_15 0xF00
+ //CS recovery cycle insert enable
+ #define BUS_CSRECEN_ADDR ((volatile uint16_t)0x00083880)
+ #define BUS_CSRECEN_RCVEN0 0x1
+ #define BUS_CSRECEN_RCVEN1 0x2
+ #define BUS_CSRECEN_RCVEN2 0x3
+ #define BUS_CSRECEN_RCVEN3 0x4
+ #define BUS_CSRECEN_RCVEN4 0x10
+ #define BUS_CSRECEN_RCVEN5 0x20
+ #define BUS_CSRECEN_RCVEN6 0x40
+ #define BUS_CSRECEN_RCVEN7 0x80
+ #define BUS_CSRECEN_RCVENM0 0x100
+ #define BUS_CSRECEN_RCVENM1 0x200
+ #define BUS_CSRECEN_RCVENM2 0x400
+ #define BUS_CSRECEN_RCVENM3 0x800
+ #define BUS_CSRECEN_RCVENM4 0x1000
+ #define BUS_CSRECEN_RCVENM5 0x2000
+ #define BUS_CSRECEN_RCVENM6 0x4000
+ #define BUS_CSRECEN_RCVENM7 0x8000
+ //CSn mode register
+ #define BUS_CS0MOD_ADDR ((volatile uint16_t*)0x00083002)
+ #define BUS_CS1MOD_ADDR ((volatile uint16_t*)0x00083012)
+ #define BUS_CS2MOD_ADDR ((volatile uint16_t*)0x00083022)
+ #define BUS_CS3MOD_ADDR ((volatile uint16_t*)0x00083032)
+ #define BUS_CS4MOD_ADDR ((volatile uint16_t*)0x00083042)
+ #define BUS_CS5MOD_ADDR ((volatile uint16_t*)0x00083052)
+ #define BUS_CS6MOD_ADDR ((volatile uint16_t*)0x00083062)
+ #define BUS_CS7MOD_ADDR ((volatile uint16_t*)0x00083072)
+ #define BUS_CSNMOD_WRMOD_BYTEST 0x0
+ #define BUS_CSNMOD_WRMOD_1WRST 0x1
+ #define BUS_CSNMOD_EWENB_EN 0x8
+ #define BUS_CSNMOD_EWENB_DIS 0x0
+ #define BUS_CSNMOD_PRENB_EN 0x100
+ #define BUS_CSNMOD_PRENB_DIS 0x0
+ #define BUS_CSNMOD_PWENB_EN 0x200
+ #define BUS_CSNMOD_PWENB_DIS 0x0
+ #define BUS_CSNMOD_PRMOD_NOMAL 0x0
+ #define BUS_CSNMOD_PRMOD_EXSEQ 0x8000
+ 
+ #define BUS_CS0WCR1_ADDR ((volatile uint32_t*)0x00083004)
+ #define BUS_CS1WCR1_ADDR ((volatile uint32_t*)0x00083014)
+ #define BUS_CS2WCR1_ADDR ((volatile uint32_t*)0x00083024)
+ #define BUS_CS3WCR1_ADDR ((volatile uint32_t*)0x00083034)
+ #define BUS_CS4WCR1_ADDR ((volatile uint32_t*)0x00083044)
+ #define BUS_CS5WCR1_ADDR ((volatile uint32_t*)0x00083054)
+ #define BUS_CS6WCR1_ADDR ((volatile uint32_t*)0x00083064)
+ #define BUS_CS7WCR1_ADDR ((volatile uint32_t*)0x00083074)
+ #define BUS_CSNWCR1_CSPWWAIT_0 0x0
+ #define BUS_CSNWCR1_CSPWWAIT_1 0x1
+ #define BUS_CSNWCR1_CSPWWAIT_2 0x2
+ #define BUS_CSNWCR1_CSPWWAIT_3 0x3
+ #define BUS_CSNWCR1_CSPWWAIT_4 0x4
+ #define BUS_CSNWCR1_CSPWWAIT_5 0x5
+ #define BUS_CSNWCR1_CSPWWAIT_6 0x6
+ #define BUS_CSNWCR1_CSPWWAIT_7 0x7
+ #define BUS_CSNWCR1_CSPRWAIT_0 0x000
+ #define BUS_CSNWCR1_CSPRWAIT_1 0x100
+ #define BUS_CSNWCR1_CSPRWAIT_2 0x200
+ #define BUS_CSNWCR1_CSPRWAIT_3 0x300
+ #define BUS_CSNWCR1_CSPRWAIT_4 0x400
+ #define BUS_CSNWCR1_CSPRWAIT_5 0x500
+ #define BUS_CSNWCR1_CSPRWAIT_6 0x600
+ #define BUS_CSNWCR1_CSPRWAIT_7 0x700
+ 
+ #define BUS_CSNWCR1_CSWWAIT_0 0x00000
+ #define BUS_CSNWCR1_CSWWAIT_1 0x10000
+ #define BUS_CSNWCR1_CSWWAIT_2 0x20000
+ #define BUS_CSNWCR1_CSWWAIT_3 0x30000
+ #define BUS_CSNWCR1_CSWWAIT_4 0x40000
+ #define BUS_CSNWCR1_CSWWAIT_5 0x50000
+ #define BUS_CSNWCR1_CSWWAIT_6 0x60000
+ #define BUS_CSNWCR1_CSWWAIT_7 0x70000
+ #define BUS_CSNWCR1_CSWWAIT_8 0x80000
+ #define BUS_CSNWCR1_CSWWAIT_9 0x90000
+ #define BUS_CSNWCR1_CSWWAIT_10 0xA0000
+ #define BUS_CSNWCR1_CSWWAIT_11 0xB0000
+ #define BUS_CSNWCR1_CSWWAIT_12 0xC0000
+ #define BUS_CSNWCR1_CSWWAIT_13 0xD0000
+ #define BUS_CSNWCR1_CSWWAIT_14 0xE0000
+ #define BUS_CSNWCR1_CSWWAIT_15 0xF0000
+ #define BUS_CSNWCR1_CSWWAIT_16 0x100000
+ #define BUS_CSNWCR1_CSWWAIT_17 0x110000
+ #define BUS_CSNWCR1_CSWWAIT_18 0x120000
+ #define BUS_CSNWCR1_CSWWAIT_19 0x130000
+ #define BUS_CSNWCR1_CSWWAIT_20 0x140000
+ #define BUS_CSNWCR1_CSWWAIT_21 0x150000
+ #define BUS_CSNWCR1_CSWWAIT_22 0x160000
+ #define BUS_CSNWCR1_CSWWAIT_23 0x170000
+ #define BUS_CSNWCR1_CSWWAIT_24 0x180000
+ #define BUS_CSNWCR1_CSWWAIT_25 0x190000
+ #define BUS_CSNWCR1_CSWWAIT_26 0x1A0000
+ #define BUS_CSNWCR1_CSWWAIT_27 0x1B0000
+ #define BUS_CSNWCR1_CSWWAIT_28 0x1C0000
+ #define BUS_CSNWCR1_CSWWAIT_29 0x1D0000
+ #define BUS_CSNWCR1_CSWWAIT_30 0x1E0000
+ #define BUS_CSNWCR1_CSWWAIT_31 0x1F0000
+ 
+ #define BUS_CSNWCR1_CSRWAIT_0 0x0000000
+ #define BUS_CSNWCR1_CSRWAIT_1 0x1000000
+ #define BUS_CSNWCR1_CSRWAIT_2 0x2000000
+ #define BUS_CSNWCR1_CSRWAIT_3 0x3000000
+ #define BUS_CSNWCR1_CSRWAIT_4 0x4000000
+ #define BUS_CSNWCR1_CSRWAIT_5 0x5000000
+ #define BUS_CSNWCR1_CSRWAIT_6 0x6000000
+ #define BUS_CSNWCR1_CSRWAIT_7 0x7000000
+ #define BUS_CSNWCR1_CSRWAIT_8 0x8000000
+ #define BUS_CSNWCR1_CSRWAIT_9 0x9000000
+ #define BUS_CSNWCR1_CSRWAIT_10 0xA000000
+ #define BUS_CSNWCR1_CSRWAIT_11 0xB000000
+ #define BUS_CSNWCR1_CSRWAIT_12 0xC000000
+ #define BUS_CSNWCR1_CSRWAIT_13 0xD000000
+ #define BUS_CSNWCR1_CSRWAIT_14 0xE000000
+ #define BUS_CSNWCR1_CSRWAIT_15 0xF000000
+ #define BUS_CSNWCR1_CSRWAIT_16 0x10000000
+ #define BUS_CSNWCR1_CSRWAIT_17 0x11000000
+ #define BUS_CSNWCR1_CSRWAIT_18 0x12000000
+ #define BUS_CSNWCR1_CSRWAIT_19 0x13000000
+ #define BUS_CSNWCR1_CSRWAIT_20 0x14000000
+ #define BUS_CSNWCR1_CSRWAIT_21 0x15000000
+ #define BUS_CSNWCR1_CSRWAIT_22 0x16000000
+ #define BUS_CSNWCR1_CSRWAIT_23 0x17000000
+ #define BUS_CSNWCR1_CSRWAIT_24 0x18000000
+ #define BUS_CSNWCR1_CSRWAIT_25 0x19000000
+ #define BUS_CSNWCR1_CSRWAIT_26 0x1A000000
+ #define BUS_CSNWCR1_CSRWAIT_27 0x1B000000
+ #define BUS_CSNWCR1_CSRWAIT_28 0x1C000000
+ #define BUS_CSNWCR1_CSRWAIT_29 0x1D000000
+ #define BUS_CSNWCR1_CSRWAIT_30 0x1E000000
+ #define BUS_CSNWCR1_CSRWAIT_31 0x1F000000
+ 
+ #define BUS_CS0WCR2_ADDR ((volatile uint32_t*)0x00083008)
+ #define BUS_CS1WCR2_ADDR ((volatile uint32_t*)0x00083018)
+ #define BUS_CS2WCR2_ADDR ((volatile uint32_t*)0x00083028)
+ #define BUS_CS3WCR2_ADDR ((volatile uint32_t*)0x00083038)
+ #define BUS_CS4WCR2_ADDR ((volatile uint32_t*)0x00083048)
+ #define BUS_CS5WCR2_ADDR ((volatile uint32_t*)0x00083058)
+ #define BUS_CS6WCR2_ADDR ((volatile uint32_t*)0x00083068)
+ #define BUS_CS7WCR2_ADDR ((volatile uint32_t*)0x00083078)
+ #define BUS_CSNWCR2_CSROFF_0 0x0
+ #define BUS_CSNWCR2_CSROFF_1 0x1
+ #define BUS_CSNWCR2_CSROFF_2 0x2
+ #define BUS_CSNWCR2_CSROFF_3 0x3
+ #define BUS_CSNWCR2_CSROFF_4 0x4
+ #define BUS_CSNWCR2_CSROFF_5 0x5
+ #define BUS_CSNWCR2_CSROFF_6 0x6
+ #define BUS_CSNWCR2_CSROFF_7 0x7
+ #define BUS_CSNWCR2_CSWOFF_0 0x0
+ #define BUS_CSNWCR2_CSWOFF_1 0x10
+ #define BUS_CSNWCR2_CSWOFF_2 0x20
+ #define BUS_CSNWCR2_CSWOFF_3 0x30
+ #define BUS_CSNWCR2_CSWOFF_4 0x40
+ #define BUS_CSNWCR2_CSWOFF_5 0x50
+ #define BUS_CSNWCR2_CSWOFF_6 0x60
+ #define BUS_CSNWCR2_CSWOFF_7 0x70
+ #define BUS_CSNWCR2_WDOFF_0 0x000
+ #define BUS_CSNWCR2_WDOFF_1 0x100
+ #define BUS_CSNWCR2_WDOFF_2 0x200
+ #define BUS_CSNWCR2_WDOFF_3 0x300
+ #define BUS_CSNWCR2_WDOFF_4 0x400
+ #define BUS_CSNWCR2_WDOFF_5 0x500
+ #define BUS_CSNWCR2_WDOFF_6 0x600
+ #define BUS_CSNWCR2_WDOFF_7 0x700
+ #define BUS_CSNWCR2_AWAIT_0 0x0000
+ #define BUS_CSNWCR2_AWAIT_1 0x1000
+ #define BUS_CSNWCR2_AWAIT_2 0x2000
+ #define BUS_CSNWCR2_AWAIT_3 0x3000
+ #define BUS_CSNWCR2_RDON_0 0x00000
+ #define BUS_CSNWCR2_RDON_1 0x10000
+ #define BUS_CSNWCR2_RDON_2 0x20000
+ #define BUS_CSNWCR2_RDON_3 0x30000
+ #define BUS_CSNWCR2_RDON_4 0x40000
+ #define BUS_CSNWCR2_RDON_5 0x50000
+ #define BUS_CSNWCR2_RDON_6 0x60000
+ #define BUS_CSNWCR2_RDON_7 0x70000
+ #define BUS_CSNWCR2_WRON_0 0x000000
+ #define BUS_CSNWCR2_WRON_1 0x100000
+ #define BUS_CSNWCR2_WRON_2 0x200000
+ #define BUS_CSNWCR2_WRON_3 0x300000
+ #define BUS_CSNWCR2_WRON_4 0x400000
+ #define BUS_CSNWCR2_WRON_5 0x500000
+ #define BUS_CSNWCR2_WRON_6 0x600000
+ #define BUS_CSNWCR2_WRON_7 0x700000
+ #define BUS_CSNWCR2_WDON_0 0x0000000
+ #define BUS_CSNWCR2_WDON_1 0x1000000
+ #define BUS_CSNWCR2_WDON_2 0x2000000
+ #define BUS_CSNWCR2_WDON_3 0x3000000
+ #define BUS_CSNWCR2_WDON_4 0x4000000
+ #define BUS_CSNWCR2_WDON_5 0x5000000
+ #define BUS_CSNWCR2_WDON_6 0x6000000
+ #define BUS_CSNWCR2_WDON_7 0x7000000
+ #define BUS_CSNWCR2_CSON_0 0x00000000
+ #define BUS_CSNWCR2_CSON_1 0x10000000
+ #define BUS_CSNWCR2_CSON_2 0x20000000
+ #define BUS_CSNWCR2_CSON_3 0x30000000
+ #define BUS_CSNWCR2_CSON_4 0x40000000
+ #define BUS_CSNWCR2_CSON_5 0x50000000
+ #define BUS_CSNWCR2_CSON_6 0x60000000
+ #define BUS_CSNWCR2_CSON_7 0x70000000
+ //SDC control register
+ #define BUS_SDCCR_ADDR ((volatile uint8_t*)0x00083C00)
+ #define BUS_SDCCR_EXENB_EN 0x1
+ #define BUS_SDCCR_EXENB_DIS 0x0
+ #define BUS_SDCCR_BSIZE_16 0x00
+ #define BUS_SDCCR_BSIZE_16 0x00
+ #define BUS_SDCCR_BSIZE_32 0x10
+ #define BUS_SDCCR_BSIZE_8 0x20
+ //SDC mode register
+ #define BUS_SDCMOD_ADDR ((volatile uint8_t*)0x00083C01)
+ #define BUS_SDCMOD_EMODE_SAME 0x0
+ #define BUS_SDCMOD_EMODE_DIFF 0x1
+ //SDRAM access mode register
+ #define BUS_SDAMOD_ADDR ((volatile uint8_t*)0x00083C02)
+ #define BUS_SDAMOD_BE_DIS 0x0
+ #define BUS_SDAMOD_BE_EN 0x1
+ //SDRAM self refresh control register
+ #define BUS_ADSELF_ADDR ((volatile uint8_t*)0x00083C10)
+ #define BUS_SDAMOD_SFEN_DIS 0x0
+ #define BUS_SDAMOD_SFEN_EN 0x1
+ //SDRAM refresh control register
+ #define BUS_SFRFCR_ADDR ((volatile uint16_t*)0x00083C14)
+ #define BUS_SFRFCR_REFW_1 0x0000
+ #define BUS_SFRFCR_REFW_2 0x1000
+ #define BUS_SFRFCR_REFW_3 0x2000
+ #define BUS_SFRFCR_REFW_4 0x3000
+ #define BUS_SFRFCR_REFW_5 0x4000
+ #define BUS_SFRFCR_REFW_6 0x5000
+ #define BUS_SFRFCR_REFW_7 0x6000
+ #define BUS_SFRFCR_REFW_8 0x7000
+ #define BUS_SFRFCR_REFW_9 0x8000
+ #define BUS_SFRFCR_REFW_10 0x9000
+ #define BUS_SFRFCR_REFW_11 0xA000
+ #define BUS_SFRFCR_REFW_12 0xB000
+ #define BUS_SFRFCR_REFW_13 0xC000
+ #define BUS_SFRFCR_REFW_14 0xD000
+ #define BUS_SFRFCR_REFW_15 0xE000
+ #define BUS_SFRFCR_REFW_16 0xF000
+ //SDRAM auto refresh control register
+ #define BUS_SDREFEN_ADDR ((volatile uint8_t*)0x00083C16)
+ #define BUS_SDREFEN_RFEN_DIS 0x0
+ #define BUS_SDREFEN_RFEN_EN 0x1
+ //SDRAM initialize sequence control regiset
+ #define BUS_SDICR_ADDR ((volatile uint8_t*)0x00083C20)
+ #define BUS_SDICR_INIRQ_START 0x1
+ //SDRAM initialize register
+ #define BUS_SDIR_ADDR ((volatile uint16_t*)0x00083C24)
+ #define BUS_SDIR_ARFI_3 0x0
+ #define BUS_SDIR_ARFI_4 0x1
+ #define BUS_SDIR_ARFI_5 0x2
+ #define BUS_SDIR_ARFI_6 0x3
+ #define BUS_SDIR_ARFI_7 0x4
+ #define BUS_SDIR_ARFI_8 0x5
+ #define BUS_SDIR_ARFI_9 0x6
+ #define BUS_SDIR_ARFI_10 0x7
+ #define BUS_SDIR_ARFI_11 0x8
+ #define BUS_SDIR_ARFI_12 0x9
+ #define BUS_SDIR_ARFI_13 0xA
+ #define BUS_SDIR_ARFI_14 0xB
+ #define BUS_SDIR_ARFI_15 0xC
+ #define BUS_SDIR_ARFI_16 0xD
+ #define BUS_SDIR_ARFI_17 0xE
+ #define BUS_SDIR_ARFI_18 0xF
+ #define BUS_SDIR_ARFC_1 0x10
+ #define BUS_SDIR_ARFC_2 0x20
+ #define BUS_SDIR_ARFC_3 0x30
+ #define BUS_SDIR_ARFC_4 0x40
+ #define BUS_SDIR_ARFC_5 0x50
+ #define BUS_SDIR_ARFC_6 0x60
+ #define BUS_SDIR_ARFC_7 0x70
+ #define BUS_SDIR_ARFC_8 0x80
+ #define BUS_SDIR_ARFC_9 0x90
+ #define BUS_SDIR_ARFC_10 0xA0
+ #define BUS_SDIR_ARFC_11 0xB0
+ #define BUS_SDIR_ARFC_12 0xC0
+ #define BUS_SDIR_ARFC_13 0xD0
+ #define BUS_SDIR_ARFC_14 0xE0
+ #define BUS_SDIR_ARFC_15 0xF0
+ #define BUS_SDIR_PRC_3 0x000
+ #define BUS_SDIR_PRC_4 0x100
+ #define BUS_SDIR_PRC_5 0x200
+ #define BUS_SDIR_PRC_6 0x300
+ #define BUS_SDIR_PRC_7 0x400
+ #define BUS_SDIR_PRC_8 0x500
+ #define BUS_SDIR_PRC_9 0x600
+ #define BUS_SDIR_PRC_10 0x700
+ //SDRAM address register
+ #define BUS_SDADR_ADDR ((volatile uint8_t*)0x00083C40)
+ #define BUS_SDADR_MXC_8 0x0
+ #define BUS_SDADR_MXC_9 0x1
+ #define BUS_SDADR_MXC_10 0x2
+ #define BUS_SDADR_MXC_11 0x3
+ //SDRAM timing register
+ #define BUS_SDTR_ADDR ((volatile uint32_t*)0x00083C44)
+ #define BUS_SDTR_CL_1 0x1
+ #define BUS_SDTR_CL_2 0x2
+ #define BUS_SDTR_CL_3 0x3
+ #define BUS_SDTR_WR_1 0x0
+ #define BUS_SDTR_WR_2 0x100
+ #define BUS_SDTR_RP_1  0x000
+ #define BUS_SDTR_RP_2  0x200
+ #define BUS_SDTR_RP_3  0x400
+ #define BUS_SDTR_RP_4  0x600
+ #define BUS_SDTR_RP_5  0x800
+ #define BUS_SDTR_RP_6  0xA00
+ #define BUS_SDTR_RP_7  0xC00
+ #define BUS_SDTR_RP_8  0xE00
+ #define BUS_SDTR_RCD_1 0x0000
+ #define BUS_SDTR_RCD_2 0x1000
+ #define BUS_SDTR_RCD_3 0x2000
+ #define BUS_SDTR_RCD_4 0x3000
+ #define BUS_SDTR_RAS_1 0x00000
+ #define BUS_SDTR_RAS_2 0x10000
+ #define BUS_SDTR_RAS_3 0x20000
+ #define BUS_SDTR_RAS_4 0x30000
+ #define BUS_SDTR_RAS_5 0x40000
+ #define BUS_SDTR_RAS_6 0x50000
+ #define BUS_SDTR_RAS_7 0x60000
+ //SDRAM mode register
+ #define BUS_SDMOD_ADDR ((volatile uint16_t*)0x00083C48)
+ //SDRAM status register
+ #define BUS_SDSR_ADDR ((volatile uint8_t*)0x00083C50)
+ #define BUS_SDSR_MRSST 0x1
+ #define BUS_SDSR_INIST 0x10
+ #define BUS_SDSR_SRFST 0x20
+ //bus error status clear register
+ #define BUS_BERCLR_ADDR ((volatile uint8_t*)0x00081300)
+ #define BUS_BERCLR_STSCLR 0x1
+ //bus error moniter enable register
+ #define BUS_BEREN_ADDR ((volatile uint8_t*)0x00081304)
+ #define BUS_BEREN_IGAEN_EN 0x1
+ #define BUS_BEREN_IGAEN_DIS 0x0
+ #define BUS_BEREN_TOEN_EN 0x2
+ #define BUS_BEREN_TOEN_DIS 0x0
+ //bus error status register 1
+ #define BUS_BERSR1_ADDR ((volatile uint8_t*)0x00081308)
+ #define BUS_BERSR1_IA 0x1
+ #define BUS_BERSR1_TO 0x2
+ #define BUS_BERSR1_MST_MASK 0x70
+ #define BUS_BERSR1_MST_CPU 0x00
+ #define BUS_BERSR1_MST_DTC_DMAC 0x30
+ #define BUS_BERSR1_MST_EDMAC 0x60
+ #define BUS_BERSR1_MST_EXDMAC 0x70
+ //bus error status register2
+ #define BUS_ADDR_ADDR ((volatile uint16_t*)0x0008130A)
+ //bus priority control register
+ #define BUS_BUSPRI_ADDR ((volatile uint16_t*)0x00081310)
+ #define BUS_BUSPRI_BPRA_CONST 0x0
+ #define BUS_BUSPRI_BPRA_TOGGL 0x1
+ #define BUS_BUSPRI_BPRO_CONST 0x0
+ #define BUS_BUSPRI_BPRO_TOGGL 0x4
+ #define BUS_BUSPRI_BPIB_CONST 0x00
+ #define BUS_BUSPRI_BPIB_TOGGL 0x10
+ #define BUS_BUSPRI_BPGB_CONST 0x00
+ #define BUS_BUSPRI_BPGB_TOGGL 0x40
+ #define BUS_BUSPRI_BPHB_CONST 0x000
+ #define BUS_BUSPRI_BPHB_TOGGL 0x100
+ #define BUS_BUSPRI_BPFB_CONST 0x000
+ #define BUS_BUSPRI_BPFB_TOGGL 0x400
+ #define BUS_BUSPRI_BPEB_CONST 0x0000
+ #define BUS_BUSPRI_BPEB_TOGGL 0x1000
+ 
+ /*
+  * 割り込み要求レジスタ
+  */
+ 
+ #define ICU_IR_BASE 0x00087000
+ #define ICU_IR_BIT				( 1U << 0U )
+ 
+ 
+ /*
+  * 割り込み要求許可レジスタ
+  */
+ #define ICU_IER_BASE 0x00087200
+ 
+ 
+ /*
+  * 割り込み要因プライオリティレジスタi(i=00h〜8Fh)の設定
+  */
+ #define ICU_IPR_BASE  0x00087300
+ #define ICU_IPR00_OFFSET 0
+ #define ICU_IPR01_OFFSET 1
+ #define ICU_IPR02_OFFSET 2
+ #define ICU_IPR03_OFFSET 3
+ #define ICU_IPR04_OFFSET 4
+ #define ICU_IPR05_OFFSET 5
+ #define ICU_IPR06_OFFSET 6
+ #define ICU_IPR07_OFFSET 7
+ #define ICU_IPR08_OFFSET 8
+ #define ICU_IPR09_OFFSET 9
+ #define ICU_IPR0A_OFFSET 10
+ #define ICU_IPR0B_OFFSET 11
+ #define ICU_IPR0C_OFFSET 12
+ #define ICU_IPR0D_OFFSET 13
+ #define ICU_IPR0E_OFFSET 14
+ #define ICU_IPR0F_OFFSET 15
+ #define ICU_IPR10_OFFSET 16
+ #define ICU_IPR11_OFFSET 17
+ #define ICU_IPR12_OFFSET 18
+ #define ICU_IPR13_OFFSET 19
+ #define ICU_IPR14_OFFSET 20
+ #define ICU_IPR15_OFFSET 21
+ #define ICU_IPR16_OFFSET 22
+ #define ICU_IPR17_OFFSET 23
+ #define ICU_IPR18_OFFSET 24
+ #define ICU_IPR19_OFFSET 25
+ #define ICU_IPR1A_OFFSET 26
+ #define ICU_IPR1B_OFFSET 27
+ #define ICU_IPR1C_OFFSET 28
+ #define ICU_IPR1D_OFFSET 29
+ #define ICU_IPR1E_OFFSET 30
+ #define ICU_IPR1F_OFFSET 31
+ #define ICU_IPR20_OFFSET 32
+ #define ICU_IPR21_OFFSET 33
+ #define ICU_IPR22_OFFSET 34
+ #define ICU_IPR23_OFFSET 35
+ #define ICU_IPR24_OFFSET 36
+ #define ICU_IPR25_OFFSET 37
+ #define ICU_IPR26_OFFSET 38
+ #define ICU_IPR27_OFFSET 39
+ #define ICU_IPR28_OFFSET 40
+ #define ICU_IPR29_OFFSET 41
+ #define ICU_IPR2A_OFFSET 42
+ #define ICU_IPR2B_OFFSET 43
+ #define ICU_IPR2C_OFFSET 44
+ #define ICU_IPR2D_OFFSET 45
+ #define ICU_IPR2E_OFFSET 46
+ #define ICU_IPR2F_OFFSET 47
+ #define ICU_IPR30_OFFSET 48
+ #define ICU_IPR31_OFFSET 49
+ #define ICU_IPR32_OFFSET 50
+ #define ICU_IPR33_OFFSET 51
+ #define ICU_IPR34_OFFSET 52
+ #define ICU_IPR35_OFFSET 53
+ #define ICU_IPR36_OFFSET 54
+ #define ICU_IPR37_OFFSET 55
+ #define ICU_IPR38_OFFSET 56
+ #define ICU_IPR39_OFFSET 57
+ #define ICU_IPR3A_OFFSET 58
+ #define ICU_IPR3B_OFFSET 59
+ #define ICU_IPR3C_OFFSET 60
+ #define ICU_IPR3D_OFFSET 61
+ #define ICU_IPR3E_OFFSET 62
+ #define ICU_IPR3F_OFFSET 63
+ #define ICU_IPR40_OFFSET 64
+ #define ICU_IPR41_OFFSET 65
+ #define ICU_IPR42_OFFSET 66
+ #define ICU_IPR43_OFFSET 67
+ #define ICU_IPR44_OFFSET 68
+ #define ICU_IPR45_OFFSET 69
+ #define ICU_IPR46_OFFSET 70
+ #define ICU_IPR47_OFFSET 71
+ #define ICU_IPR48_OFFSET 72
+ #define ICU_IPR49_OFFSET 73
+ #define ICU_IPR4A_OFFSET 74
+ #define ICU_IPR4B_OFFSET 75
+ #define ICU_IPR4C_OFFSET 76
+ #define ICU_IPR4D_OFFSET 77
+ #define ICU_IPR4E_OFFSET 78
+ #define ICU_IPR4F_OFFSET 79
+ #define ICU_IPR50_OFFSET 80
+ #define ICU_IPR51_OFFSET 81
+ #define ICU_IPR52_OFFSET 82
+ #define ICU_IPR53_OFFSET 83
+ #define ICU_IPR54_OFFSET 84
+ #define ICU_IPR55_OFFSET 85
+ #define ICU_IPR56_OFFSET 86
+ #define ICU_IPR57_OFFSET 87
+ #define ICU_IPR58_OFFSET 88
+ #define ICU_IPR59_OFFSET 89
+ #define ICU_IPR5A_OFFSET 90
+ #define ICU_IPR5B_OFFSET 91
+ #define ICU_IPR5C_OFFSET 92
+ #define ICU_IPR5D_OFFSET 93
+ #define ICU_IPR5E_OFFSET 94
+ #define ICU_IPR5F_OFFSET 95
+ #define ICU_IPR60_OFFSET 96
+ #define ICU_IPR61_OFFSET 97
+ #define ICU_IPR62_OFFSET 98
+ #define ICU_IPR63_OFFSET 99
+ #define ICU_IPR64_OFFSET 100
+ #define ICU_IPR65_OFFSET 101
+ #define ICU_IPR66_OFFSET 102
+ #define ICU_IPR67_OFFSET 103
+ #define ICU_IPR68_OFFSET 104
+ #define ICU_IPR69_OFFSET 105
+ #define ICU_IPR6A_OFFSET 106
+ #define ICU_IPR6B_OFFSET 107
+ #define ICU_IPR6C_OFFSET 108
+ #define ICU_IPR6D_OFFSET 109
+ #define ICU_IPR6E_OFFSET 110
+ #define ICU_IPR6F_OFFSET 111
+ #define ICU_IPR70_OFFSET 112
+ #define ICU_IPR71_OFFSET 113
+ #define ICU_IPR72_OFFSET 114
+ #define ICU_IPR73_OFFSET 115
+ #define ICU_IPR74_OFFSET 116
+ #define ICU_IPR75_OFFSET 117
+ #define ICU_IPR76_OFFSET 118
+ #define ICU_IPR77_OFFSET 119
+ #define ICU_IPR78_OFFSET 120
+ #define ICU_IPR79_OFFSET 121
+ #define ICU_IPR7A_OFFSET 122
+ #define ICU_IPR7B_OFFSET 123
+ #define ICU_IPR7C_OFFSET 124
+ #define ICU_IPR7D_OFFSET 125
+ #define ICU_IPR7E_OFFSET 126
+ #define ICU_IPR7F_OFFSET 127
+ #define ICU_IPR80_OFFSET 128
+ #define ICU_IPR81_OFFSET 129
+ #define ICU_IPR82_OFFSET 130
+ #define ICU_IPR83_OFFSET 131
+ #define ICU_IPR84_OFFSET 132
+ #define ICU_IPR85_OFFSET 133
+ #define ICU_IPR86_OFFSET 134
+ #define ICU_IPR87_OFFSET 135
+ #define ICU_IPR88_OFFSET 136
+ #define ICU_IPR89_OFFSET 137
+ #define ICU_IPR8A_OFFSET 138
+ #define ICU_IPR8B_OFFSET 139
+ #define ICU_IPR8C_OFFSET 140
+ #define ICU_IPR8D_OFFSET 141
+ #define ICU_IPR8E_OFFSET 142
+ #define ICU_IPR8F_OFFSET 143
+ #define ICU_IPR90_OFFSET 144
+ #define ICU_IPR91_OFFSET 145
+ #define ICU_IPR92_OFFSET 146
+ #define ICU_IPR93_OFFSET 147
+ #define ICU_IPR94_OFFSET 148
+ #define ICU_IPR95_OFFSET 149
+ #define ICU_IPR96_OFFSET 150
+ #define ICU_IPR97_OFFSET 151
+ #define ICU_IPR98_OFFSET 152
+ #define ICU_IPR99_OFFSET 153
+ #define ICU_IPR9A_OFFSET 154
+ #define ICU_IPR9B_OFFSET 155
+ #define ICU_IPR9C_OFFSET 156
+ #define ICU_IPR9D_OFFSET 157
+ #define ICU_IPR9E_OFFSET 158
+ #define ICU_IPR9F_OFFSET 159
+ #define ICU_IPRA0_OFFSET 160
+ #define ICU_IPRA1_OFFSET 161
+ #define ICU_IPRA2_OFFSET 162
+ #define ICU_IPRA3_OFFSET 163
+ #define ICU_IPRA4_OFFSET 164
+ #define ICU_IPRA5_OFFSET 165
+ #define ICU_IPRA6_OFFSET 166
+ #define ICU_IPRA7_OFFSET 167
+ #define ICU_IPRA8_OFFSET 168
+ #define ICU_IPRA9_OFFSET 169
+ #define ICU_IPRAA_OFFSET 170
+ #define ICU_IPRAB_OFFSET 171
+ #define ICU_IPRAC_OFFSET 172
+ #define ICU_IPRAD_OFFSET 173
+ #define ICU_IPRAE_OFFSET 174
+ #define ICU_IPRAF_OFFSET 175
+ #define ICU_IPRB0_OFFSET 176
+ #define ICU_IPRB1_OFFSET 177
+ #define ICU_IPRB2_OFFSET 178
+ #define ICU_IPRB3_OFFSET 179
+ #define ICU_IPRB4_OFFSET 180
+ #define ICU_IPRB5_OFFSET 181
+ #define ICU_IPRB6_OFFSET 182
+ #define ICU_IPRB7_OFFSET 183
+ #define ICU_IPRB8_OFFSET 184
+ #define ICU_IPRB9_OFFSET 185
+ #define ICU_IPRBA_OFFSET 186
+ #define ICU_IPRBB_OFFSET 187
+ #define ICU_IPRBC_OFFSET 188
+ #define ICU_IPRBD_OFFSET 189
+ #define ICU_IPRBE_OFFSET 190
+ #define ICU_IPRBF_OFFSET 191
+ #define ICU_IPRC0_OFFSET 192
+ #define ICU_IPRC1_OFFSET 193
+ #define ICU_IPRC2_OFFSET 194
+ #define ICU_IPRC3_OFFSET 195
+ #define ICU_IPRC4_OFFSET 196
+ #define ICU_IPRC5_OFFSET 197
+ #define ICU_IPRC6_OFFSET 198
+ #define ICU_IPRC7_OFFSET 199
+ #define ICU_IPRC8_OFFSET 200
+ #define ICU_IPRC9_OFFSET 201
+ #define ICU_IPRCA_OFFSET 202
+ #define ICU_IPRCB_OFFSET 203
+ #define ICU_IPRCC_OFFSET 204
+ #define ICU_IPRCD_OFFSET 205
+ #define ICU_IPRCE_OFFSET 206
+ #define ICU_IPRCF_OFFSET 207
+ #define ICU_IPRD0_OFFSET 208
+ #define ICU_IPRD1_OFFSET 209
+ #define ICU_IPRD2_OFFSET 210
+ #define ICU_IPRD3_OFFSET 211
+ #define ICU_IPRD4_OFFSET 212
+ #define ICU_IPRD5_OFFSET 213
+ #define ICU_IPRD6_OFFSET 214
+ #define ICU_IPRD7_OFFSET 215
+ #define ICU_IPRD8_OFFSET 216
+ #define ICU_IPRD9_OFFSET 217
+ #define ICU_IPRDA_OFFSET 218
+ #define ICU_IPRDB_OFFSET 219
+ #define ICU_IPRDC_OFFSET 220
+ #define ICU_IPRDD_OFFSET 221
+ #define ICU_IPRDE_OFFSET 222
+ #define ICU_IPRDF_OFFSET 223
+ #define ICU_IPRE0_OFFSET 224
+ #define ICU_IPRE1_OFFSET 225
+ #define ICU_IPRE2_OFFSET 226
+ #define ICU_IPRE3_OFFSET 227
+ #define ICU_IPRE4_OFFSET 228
+ #define ICU_IPRE5_OFFSET 229
+ #define ICU_IPRE6_OFFSET 230
+ #define ICU_IPRE7_OFFSET 231
+ #define ICU_IPRE8_OFFSET 232
+ #define ICU_IPRE9_OFFSET 233
+ #define ICU_IPREA_OFFSET 234
+ #define ICU_IPREB_OFFSET 235
+ #define ICU_IPREC_OFFSET 236
+ #define ICU_IPRED_OFFSET 237
+ #define ICU_IPREE_OFFSET 238
+ #define ICU_IPREF_OFFSET 239
+ #define ICU_IPRF0_OFFSET 240
+ #define ICU_IPRF1_OFFSET 241
+ #define ICU_IPRF2_OFFSET 242
+ #define ICU_IPRF3_OFFSET 243
+ #define ICU_IPRF4_OFFSET 244
+ #define ICU_IPRF5_OFFSET 245
+ #define ICU_IPRF6_OFFSET 246
+ #define ICU_IPRF7_OFFSET 247
+ #define ICU_IPRF8_OFFSET 248
+ #define ICU_IPRF9_OFFSET 249
+ #define ICU_IPRFA_OFFSET 250
+ #define ICU_IPRFB_OFFSET 251
+ #define ICU_IPRFC_OFFSET 252
+ #define ICU_IPRFD_OFFSET 253
+ #define ICU_IPRFE_OFFSET 254
+ #define ICU_IPRFF_OFFSET 255
+ #define ICU_IPR_BIT				( 7U << 0U )
+ 
+ /*
+  * DTCER Register
+  */
+ #define ICU_DTCER_BASE 0x00087100
+ #define EN_ICU_DTCER_BIT 0x1
+ #define DIS_ICU_DTCER_BIT 0x0
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ #define ENABLE_ICU_DTCER(intno)  (*((volatile uint8_t *)(ICU_DTCER_BASE + intno)) = EN_ICU_DTCER_BIT)
+ 
+ #define DISABLE_ICU_DTCER(intno) (*((volatile uint8_t *)(ICU_DTCER_BASE + intno)) = DIS_ICU_DTCER_BIT)
+ #endif
+ 
+ 
+ #define ICU_IRQCR_BASE 0x00087500
+ #define SET_ICU_IRQCR(intno, sel_edge) (*((volatile uint8_t *)(ICU_IRQCR_BASE | intno)) = sel_edge)
+ 
+ /*
+  * DTCa address define
+  */
+ 
+ #define DTCA_BASE_ADDR 0x00082400
+ 
+ /*
+  *  各チャンネルのレジスタ及び設定ビット情報
+  */
+ 
+ #define CMT_CMSTR0_ADDR			( ( volatile uint16_t  * )0x00088000 )
+ #define CMT_CMSTR0_STR0_BIT		( 1U << 0U )
+ #define CMT_CMSTR0_STR1_BIT		( 1U << 1U )
+ #define CMT_CMSTR1_ADDR			( ( volatile uint16_t  * )0x00088010 )
+ #define CMT_CMSTR1_STR2_BIT		( 1U << 0U )
+ #define CMT_CMSTR1_STR3_BIT		( 1U << 1U )
+ #define CMT0_CMCR_ADDR			( ( volatile uint16_t  * )0x00088002 )
+ #define CMT0_CMCR_CKS_BIT		( 3U )
+ #define CMT0_CMCR_CMIE_BIT		( 1U << 6U )
+ #define CMT1_CMCR_ADDR			( ( volatile uint16_t  * )0x00088008 )
+ #define CMT1_CMCR_CKS_BIT		( 3U )
+ #define CMT1_CMCR_CMIE_BIT		( 1U << 6U )
+ #define CMT2_CMCR_ADDR			( ( volatile uint16_t  * )0x00088012 )
+ #define CMT2_CMCR_CKS_BIT		( 3U)
+ #define CMT2_CMCR_CMIE_BIT		( 1U << 6U )
+ #define CMT3_CMCR_ADDR			( ( volatile uint16_t  * )0x00088018 )
+ #define CMT3_CMCR_CKS_BIT		( 3U )
+ #define CMT3_CMCR_CMIE_BIT		( 1U << 6U )
+ #define CMT0_CMCNT_ADDR			( ( volatile uint16_t  * )0x00088004 )
+ #define CMT1_CMCNT_ADDR			( ( volatile uint16_t  * )0x0008800A )
+ #define CMT2_CMCNT_ADDR			( ( volatile uint16_t  * )0x00088014 )
+ #define CMT3_CMCNT_ADDR			( ( volatile uint16_t  * )0x0008801A )
+ #define CMT0_CMCOR_ADDR			( ( volatile uint16_t  * )0x00088006 )
+ #define CMT1_CMCOR_ADDR			( ( volatile uint16_t  * )0x0008800C )
+ #define CMT2_CMCOR_ADDR			( ( volatile uint16_t  * )0x00088016 )
+ #define CMT3_CMCOR_ADDR			( ( volatile uint16_t  * )0x0008801C )
+ 
+ #define SCI0_SMR_ADDR			( ( volatile uint8_t  * )0x0008A000 )
+ #define SCI0_BRR_ADDR			( ( volatile uint8_t  * )0x0008A001 )
+ #define SCI0_SCR_ADDR			( ( volatile uint8_t  * )0x0008A002 )
+ #define SCI0_TDR_ADDR			( ( volatile uint8_t  * )0x0008A003 )
+ #define SCI0_SSR_ADDR			( ( volatile uint8_t  * )0x0008A004 )
+ #define SCI0_RDR_ADDR			( ( volatile uint8_t  * )0x0008A005 )
+ #define SCI0_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A006 )
+ #define SCI0_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A007 )
+ #define SCI1_SMR_ADDR			( ( volatile uint8_t  * )0x0008A020 )
+ #define SCI1_BRR_ADDR			( ( volatile uint8_t  * )0x0008A021 )
+ #define SCI1_SCR_ADDR			( ( volatile uint8_t  * )0x0008A022 )
+ #define SCI1_TDR_ADDR			( ( volatile uint8_t  * )0x0008A023 )
+ #define SCI1_SSR_ADDR			( ( volatile uint8_t  * )0x0008A024 )
+ #define SCI1_RDR_ADDR			( ( volatile uint8_t  * )0x0008A025 )
+ #define SCI1_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A026 )
+ #define SCI1_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A027 )
+ #define SCI2_SMR_ADDR			( ( volatile uint8_t  * )0x0008A040 )
+ #define SCI2_BRR_ADDR			( ( volatile uint8_t  * )0x0008A041 )
+ #define SCI2_SCR_ADDR			( ( volatile uint8_t  * )0x0008A042 )
+ #define SCI2_TDR_ADDR			( ( volatile uint8_t  * )0x0008A043 )
+ #define SCI2_SSR_ADDR			( ( volatile uint8_t  * )0x0008A044 )
+ #define SCI2_RDR_ADDR			( ( volatile uint8_t  * )0x0008A045 )
+ #define SCI2_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A046 )
+ #define SCI2_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A047 )
+ #define SCI3_SMR_ADDR			( ( volatile uint8_t  * )0x0008A060 )
+ #define SCI3_BRR_ADDR			( ( volatile uint8_t  * )0x0008A061 )
+ #define SCI3_SCR_ADDR			( ( volatile uint8_t  * )0x0008A062 )
+ #define SCI3_TDR_ADDR			( ( volatile uint8_t  * )0x0008A063 )
+ #define SCI3_SSR_ADDR			( ( volatile uint8_t  * )0x0008A064 )
+ #define SCI3_RDR_ADDR			( ( volatile uint8_t  * )0x0008A065 )
+ #define SCI3_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A066 )
+ #define SCI3_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A067 )
+ #define SCI4_SMR_ADDR			( ( volatile uint8_t  * )0x0008A080 )
+ #define SCI4_BRR_ADDR			( ( volatile uint8_t  * )0x0008A081 )
+ #define SCI4_SCR_ADDR			( ( volatile uint8_t  * )0x0008A082 )
+ #define SCI4_TDR_ADDR			( ( volatile uint8_t  * )0x0008A083 )
+ #define SCI4_SSR_ADDR			( ( volatile uint8_t  * )0x0008A084 )
+ #define SCI4_RDR_ADDR			( ( volatile uint8_t  * )0x0008A085 )
+ #define SCI4_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A086 )
+ #define SCI4_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A087 )
+ #define SCI5_SMR_ADDR			( ( volatile uint8_t  * )0x0008A0A0 )
+ #define SCI5_BRR_ADDR			( ( volatile uint8_t  * )0x0008A0A1 )
+ #define SCI5_SCR_ADDR			( ( volatile uint8_t  * )0x0008A0A2 )
+ #define SCI5_TDR_ADDR			( ( volatile uint8_t  * )0x0008A0A3 )
+ #define SCI5_SSR_ADDR			( ( volatile uint8_t  * )0x0008A0A4 )
+ #define SCI5_RDR_ADDR			( ( volatile uint8_t  * )0x0008A0A5 )
+ #define SCI5_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A0A6 )
+ #define SCI5_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A0A7 )
+ #define SCI6_SMR_ADDR			( ( volatile uint8_t  * )0x0008A0C0 )
+ #define SCI6_BRR_ADDR			( ( volatile uint8_t  * )0x0008A0C1 )
+ #define SCI6_SCR_ADDR			( ( volatile uint8_t  * )0x0008A0C2 )
+ #define SCI6_TDR_ADDR			( ( volatile uint8_t  * )0x0008A0C3 )
+ #define SCI6_SSR_ADDR			( ( volatile uint8_t  * )0x0008A0C4 )
+ #define SCI6_RDR_ADDR			( ( volatile uint8_t  * )0x0008A0C5 )
+ #define SCI6_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A0C6 )
+ #define SCI6_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A0C7 )
+ #define SCI7_SMR_ADDR			( ( volatile uint8_t  * )0x0008A0E0 )
+ #define SCI7_BRR_ADDR			( ( volatile uint8_t  * )0x0008A0E1 )
+ #define SCI7_SCR_ADDR			( ( volatile uint8_t  * )0x0008A0E2 )
+ #define SCI7_TDR_ADDR			( ( volatile uint8_t  * )0x0008A0E3 )
+ #define SCI7_SSR_ADDR			( ( volatile uint8_t  * )0x0008A0E4 )
+ #define SCI7_RDR_ADDR			( ( volatile uint8_t  * )0x0008A0E5 )
+ #define SCI7_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A0E6 )
+ #define SCI7_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A0E7 )
+ #define SCI8_SMR_ADDR			( ( volatile uint8_t  * )0x0008A100 )
+ #define SCI8_BRR_ADDR			( ( volatile uint8_t  * )0x0008A101 )
+ #define SCI8_SCR_ADDR			( ( volatile uint8_t  * )0x0008A102 )
+ #define SCI8_TDR_ADDR			( ( volatile uint8_t  * )0x0008A103 )
+ #define SCI8_SSR_ADDR			( ( volatile uint8_t  * )0x0008A104 )
+ #define SCI8_RDR_ADDR			( ( volatile uint8_t  * )0x0008A105 )
+ #define SCI8_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A106 )
+ #define SCI8_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A107 )
+ #define SCI9_SMR_ADDR			( ( volatile uint8_t  * )0x0008A120 )
+ #define SCI9_BRR_ADDR			( ( volatile uint8_t  * )0x0008A121 )
+ #define SCI9_SCR_ADDR			( ( volatile uint8_t  * )0x0008A122 )
+ #define SCI9_TDR_ADDR			( ( volatile uint8_t  * )0x0008A123 )
+ #define SCI9_SSR_ADDR			( ( volatile uint8_t  * )0x0008A124 )
+ #define SCI9_RDR_ADDR			( ( volatile uint8_t  * )0x0008A125 )
+ #define SCI9_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A126 )
+ #define SCI9_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A127 )
+ #define SCI10_SMR_ADDR			( ( volatile uint8_t  * )0x0008A140 )
+ #define SCI10_BRR_ADDR			( ( volatile uint8_t  * )0x0008A141 )
+ #define SCI10_SCR_ADDR			( ( volatile uint8_t  * )0x0008A142 )
+ #define SCI10_TDR_ADDR			( ( volatile uint8_t  * )0x0008A143 )
+ #define SCI10_SSR_ADDR			( ( volatile uint8_t  * )0x0008A144 )
+ #define SCI10_RDR_ADDR			( ( volatile uint8_t  * )0x0008A145 )
+ #define SCI10_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A146 )
+ #define SCI10_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A147 )
+ #define SCI11_SMR_ADDR			( ( volatile uint8_t  * )0x0008A160 )
+ #define SCI11_BRR_ADDR			( ( volatile uint8_t  * )0x0008A161 )
+ #define SCI11_SCR_ADDR			( ( volatile uint8_t  * )0x0008A162 )
+ #define SCI11_TDR_ADDR			( ( volatile uint8_t  * )0x0008A163 )
+ #define SCI11_SSR_ADDR			( ( volatile uint8_t  * )0x0008A164 )
+ #define SCI11_RDR_ADDR			( ( volatile uint8_t  * )0x0008A165 )
+ #define SCI11_SCMR_ADDR			( ( volatile uint8_t  * )0x0008A166 )
+ #define SCI11_SEMR_ADDR			( ( volatile uint8_t  * )0x0008A167 )
+ #define SCI_SMR_CKS_BIT			( 3U << 0U )
+ #define SCI_SMR_MP_BIT	        ( 1U << 2U )
+ #define SCI_SMR_STOP_BIT		( 1U << 3U )
+ #define SCI_SMR_PM_BIT			( 1U << 4U )
+ #define SCI_SMR_PE_BIT			( 1U << 5U )
+ #define SCI_SMR_CHR_BIT			( 1U << 6U )
+ #define SCI_SMR_CM_BIT			( 1U << 7U )
+ #define SCI_SCR_CKE_BIT			( 3U << 0U )
+ #define SCI_SCR_TEIE_BIT		( 1U << 2U )
+ #define SCI_SCR_MPIE_BIT		( 1U << 3U )
+ #define SCI_SCR_RE_BIT			( 1U << 4U )
+ #define SCI_SCR_TE_BIT			( 1U << 5U )
+ #define SCI_SCR_RIE_BIT			( 1U << 6U )
+ #define SCI_SCR_TIE_BIT			( 1U << 7U )
+ #define SCI_SSR_MPBT_BIT		( 1U << 0U )
+ #define SCI_SSR_MPB_BIT 		( 1U << 1U )
+ #define SCI_SSR_TEND_BIT		( 1U << 2U )
+ #define SCI_SSR_PER_BIT			( 1U << 3U )
+ #define SCI_SSR_FER_BIT			( 1U << 4U )
+ #define SCI_SSR_ORER_BIT		( 1U << 5U )
+ #define SCI_SCMR_SMIF_BIT		( 1U << 0U )
+ #define SCI_SCMR_SINV_BIT		( 1U << 2U )
+ #define SCI_SCMR_SDIR_BIT		( 1U << 3U )
+ #define SCI_SCMR_BCP2_BIT		( 1U << 7U )
+ #define SCI_SEMR_ACS0_BIT		( 1U << 0U )
+ #define SCI_SEMR_ABCS_BIT		( 1U << 4U )
+ #define SCI_SEMR_NFEN_BIT		( 1U << 5U )
+ 
+ /*
+  * Multi function Pin Controler configration define
+  */
+ #define MPC_PWPR_ADDR          ( ( volatile uint8_t  * )0x0008C11F )
+ #define MPC_PWPR_PFSWE_BIT     ( 1U << 6 )
+ #define MPC_PWPR_B0WI_BIT      ( 1U << 7 )
+ #define MPC_PWPR_PFSW_CLEAR    0U
+ 
+ #define MPC_P00PFS_ADDR        ( ( volatile uint8_t  * )0x0008C140 )
+ #define MPC_P01PFS_ADDR        ( ( volatile uint8_t  * )0x0008C141 )
+ #define MPC_P02PFS_ADDR        ( ( volatile uint8_t  * )0x0008C142 )
+ #define MPC_P03PFS_ADDR        ( ( volatile uint8_t  * )0x0008C143 )
+ #define MPC_P05PFS_ADDR        ( ( volatile uint8_t  * )0x0008C145 )
+ #define MPC_P07PFS_ADDR        ( ( volatile uint8_t  * )0x0008C147 )
+ #define MPC_P10PFS_ADDR        ( ( volatile uint8_t  * )0x0008C148 )
+ #define MPC_P11PFS_ADDR        ( ( volatile uint8_t  * )0x0008C149 )
+ #define MPC_P12PFS_ADDR        ( ( volatile uint8_t  * )0x0008C14A )
+ #define MPC_P13PFS_ADDR        ( ( volatile uint8_t  * )0x0008C14B )
+ #define MPC_P14PFS_ADDR        ( ( volatile uint8_t  * )0x0008C14C )
+ #define MPC_P15PFS_ADDR        ( ( volatile uint8_t  * )0x0008C14D )
+ #define MPC_P16PFS_ADDR        ( ( volatile uint8_t  * )0x0008C14E )
+ #define MPC_P17PFS_ADDR        ( ( volatile uint8_t  * )0x0008C14F )
+ #define MPC_P20PFS_ADDR        ( ( volatile uint8_t  * )0x0008C150 )
+ #define MPC_P21PFS_ADDR        ( ( volatile uint8_t  * )0x0008C151 )
+ #define MPC_P22PFS_ADDR        ( ( volatile uint8_t  * )0x0008C152 )
+ #define MPC_P23PFS_ADDR        ( ( volatile uint8_t  * )0x0008C153 )
+ #define MPC_P24PFS_ADDR        ( ( volatile uint8_t  * )0x0008C154 )
+ #define MPC_P25PFS_ADDR        ( ( volatile uint8_t  * )0x0008C155 )
+ #define MPC_P26PFS_ADDR        ( ( volatile uint8_t  * )0x0008C156 )
+ #define MPC_P27PFS_ADDR        ( ( volatile uint8_t  * )0x0008C157 )
+ #define MPC_P30PFS_ADDR        ( ( volatile uint8_t  * )0x0008C158 )
+ #define MPC_P31PFS_ADDR        ( ( volatile uint8_t  * )0x0008C159 )
+ #define MPC_P32PFS_ADDR        ( ( volatile uint8_t  * )0x0008C15A )
+ #define MPC_P33PFS_ADDR        ( ( volatile uint8_t  * )0x0008C15B )
+ #define MPC_P34PFS_ADDR        ( ( volatile uint8_t  * )0x0008C15C )
+ #define MPC_P40PFS_ADDR        ( ( volatile uint8_t  * )0x0008C160 )
+ #define MPC_P41PFS_ADDR        ( ( volatile uint8_t  * )0x0008C161 )
+ #define MPC_P42PFS_ADDR        ( ( volatile uint8_t  * )0x0008C162 )
+ #define MPC_P43PFS_ADDR        ( ( volatile uint8_t  * )0x0008C163 )
+ #define MPC_P44PFS_ADDR        ( ( volatile uint8_t  * )0x0008C164 )
+ #define MPC_P45PFS_ADDR        ( ( volatile uint8_t  * )0x0008C165 )
+ #define MPC_P46PFS_ADDR        ( ( volatile uint8_t  * )0x0008C166 )
+ #define MPC_P47PFS_ADDR        ( ( volatile uint8_t  * )0x0008C167 )
+ #define MPC_P50PFS_ADDR        ( ( volatile uint8_t  * )0x0008C168 )
+ #define MPC_P51PFS_ADDR        ( ( volatile uint8_t  * )0x0008C169 )
+ #define MPC_P52PFS_ADDR        ( ( volatile uint8_t  * )0x0008C16A )
+ #define MPC_P54PFS_ADDR        ( ( volatile uint8_t  * )0x0008C16C )
+ #define MPC_P55PFS_ADDR        ( ( volatile uint8_t  * )0x0008C16D )
+ #define MPC_P56PFS_ADDR        ( ( volatile uint8_t  * )0x0008C16E )
+ #define MPC_P57PFS_ADDR        ( ( volatile uint8_t  * )0x0008C16F )
+ #define MPC_P60PFS_ADDR        ( ( volatile uint8_t  * )0x0008C170 )
+ #define MPC_P61PFS_ADDR        ( ( volatile uint8_t  * )0x0008C171 )
+ #define MPC_P66PFS_ADDR        ( ( volatile uint8_t  * )0x0008C176 )
+ #define MPC_P67PFS_ADDR        ( ( volatile uint8_t  * )0x0008C177 )
+ #define MPC_P70PFS_ADDR        ( ( volatile uint8_t  * )0x0008C178 )
+ #define MPC_P71PFS_ADDR        ( ( volatile uint8_t  * )0x0008C179 )
+ #define MPC_P72PFS_ADDR        ( ( volatile uint8_t  * )0x0008C17A )
+ #define MPC_P73PFS_ADDR        ( ( volatile uint8_t  * )0x0008C17B )
+ #define MPC_P74PFS_ADDR        ( ( volatile uint8_t  * )0x0008C17C )
+ #define MPC_P75PFS_ADDR        ( ( volatile uint8_t  * )0x0008C17D )
+ #define MPC_P76PFS_ADDR        ( ( volatile uint8_t  * )0x0008C17E )
+ #define MPC_P77PFS_ADDR        ( ( volatile uint8_t  * )0x0008C17F )
+ #define MPC_P80PFS_ADDR        ( ( volatile uint8_t  * )0x0008C180 )
+ #define MPC_P81PFS_ADDR        ( ( volatile uint8_t  * )0x0008C181 )
+ #define MPC_P82PFS_ADDR        ( ( volatile uint8_t  * )0x0008C182 )
+ #define MPC_P83PFS_ADDR        ( ( volatile uint8_t  * )0x0008C183 )
+ #define MPC_P86PFS_ADDR        ( ( volatile uint8_t  * )0x0008C186 )
+ #define MPC_P87PFS_ADDR        ( ( volatile uint8_t  * )0x0008C187 )
+ #define MPC_P90PFS_ADDR        ( ( volatile uint8_t  * )0x0008C188 )
+ #define MPC_P91PFS_ADDR        ( ( volatile uint8_t  * )0x0008C189 )
+ #define MPC_P92PFS_ADDR        ( ( volatile uint8_t  * )0x0008C18A )
+ #define MPC_P93PFS_ADDR        ( ( volatile uint8_t  * )0x0008C18B )
+ #define MPC_PA0PFS_ADDR        ( ( volatile uint8_t  * )0x0008C190 )
+ #define MPC_PA1PFS_ADDR        ( ( volatile uint8_t  * )0x0008C191 )
+ #define MPC_PA2PFS_ADDR        ( ( volatile uint8_t  * )0x0008C192 )
+ #define MPC_PA3PFS_ADDR        ( ( volatile uint8_t  * )0x0008C193 )
+ #define MPC_PA4PFS_ADDR        ( ( volatile uint8_t  * )0x0008C194 )
+ #define MPC_PA5PFS_ADDR        ( ( volatile uint8_t  * )0x0008C195 )
+ #define MPC_PA6PFS_ADDR        ( ( volatile uint8_t  * )0x0008C196 )
+ #define MPC_PA7PFS_ADDR        ( ( volatile uint8_t  * )0x0008C197 )
+ #define MPC_PB0PFS_ADDR        ( ( volatile uint8_t  * )0x0008C198 )
+ #define MPC_PB1PFS_ADDR        ( ( volatile uint8_t  * )0x0008C199 )
+ #define MPC_PB2PFS_ADDR        ( ( volatile uint8_t  * )0x0008C19A )
+ #define MPC_PB3PFS_ADDR        ( ( volatile uint8_t  * )0x0008C19B )
+ #define MPC_PB4PFS_ADDR        ( ( volatile uint8_t  * )0x0008C19C )
+ #define MPC_PB5PFS_ADDR        ( ( volatile uint8_t  * )0x0008C19D )
+ #define MPC_PB6PFS_ADDR        ( ( volatile uint8_t  * )0x0008C19E )
+ #define MPC_PB7PFS_ADDR        ( ( volatile uint8_t  * )0x0008C19F )
+ #define MPC_PC0PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A0 )
+ #define MPC_PC1PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A1 )
+ #define MPC_PC2PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A2 )
+ #define MPC_PC3PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A3 )
+ #define MPC_PC4PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A4 )
+ #define MPC_PC5PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A5 )
+ #define MPC_PC6PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A6 )
+ #define MPC_PC7PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A7 )
+ #define MPC_PD0PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A8 )
+ #define MPC_PD1PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1A9 )
+ #define MPC_PD2PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1AA )
+ #define MPC_PD3PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1AB )
+ #define MPC_PD4PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1AC )
+ #define MPC_PD5PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1AD )
+ #define MPC_PD6PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1AE )
+ #define MPC_PD7PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1BF )
+ #define MPC_PE0PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B0 )
+ #define MPC_PE1PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B1 )
+ #define MPC_PE2PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B2 )
+ #define MPC_PE3PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B3 )
+ #define MPC_PE4PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B4 )
+ #define MPC_PE5PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B5 )
+ #define MPC_PE6PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B6 )
+ #define MPC_PE7PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B7 )
+ #define MPC_PF0PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B8 )
+ #define MPC_PF1PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1B9 )
+ #define MPC_PF2PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1BA )
+ #define MPC_PF5PFS_ADDR        ( ( volatile uint8_t  * )0x0008C1BD )
+ #define MPC_PFS_PSEL0          0x0
+ #define MPC_PFS_PSEL1          0x1
+ #define MPC_PFS_PSEL2          0x2
+ #define MPC_PFS_PSEL3          0x3
+ #define MPC_PFS_PSEL4          0x4
+ #define MPC_PFS_PSEL5          0x5
+ #define MPC_PFS_PSEL6          0x6
+ #define MPC_PFS_PSEL7          0x7
+ #define MPC_PFS_PSEL8          0x8
+ #define MPC_PFS_PSEL9          0x9
+ #define MPC_PFS_PSELA          0xA
+ #define MPC_PFS_PSELB          0xB
+ #define MPC_PFS_PSELC          0xC
+ #define MPC_PFS_PSELD          0xD
+ #define MPC_PFS_PSELE          0xE
+ #define MPC_PFS_PSELF          0xF
+ #define MPC_PFS_ISEL           ( 1U << 6 )
+ #define MPC_PFS_ASEL           ( 1U << 7 )
+ 
+ /*
+  *  I/Oポートのレジスタ及び設定ビット情報
+  */
+ #define PORT0_PDR_ADDR			( ( volatile uint8_t  * )0x0008C000 )
+ #define PORT1_PDR_ADDR			( ( volatile uint8_t  * )0x0008C001 )
+ #define PORT2_PDR_ADDR			( ( volatile uint8_t  * )0x0008C002 )
+ #define PORT3_PDR_ADDR			( ( volatile uint8_t  * )0x0008C003 )
+ #define PORT4_PDR_ADDR			( ( volatile uint8_t  * )0x0008C004 )
+ #define PORT5_PDR_ADDR			( ( volatile uint8_t  * )0x0008C005 )
+ #define PORT6_PDR_ADDR			( ( volatile uint8_t  * )0x0008C006 )
+ #define PORT7_PDR_ADDR			( ( volatile uint8_t  * )0x0008C007 )
+ #define PORT8_PDR_ADDR			( ( volatile uint8_t  * )0x0008C008 )
+ #define PORT9_PDR_ADDR			( ( volatile uint8_t  * )0x0008C009 )
+ #define PORTA_PDR_ADDR			( ( volatile uint8_t  * )0x0008C00A )
+ #define PORTB_PDR_ADDR			( ( volatile uint8_t  * )0x0008C00B )
+ #define PORTC_PDR_ADDR			( ( volatile uint8_t  * )0x0008C00C )
+ #define PORTD_PDR_ADDR			( ( volatile uint8_t  * )0x0008C00D )
+ #define PORTE_PDR_ADDR			( ( volatile uint8_t  * )0x0008C00E )
+ #define PORTF_PDR_ADDR			( ( volatile uint8_t  * )0x0008C00F )
+ #define PORTG_PDR_ADDR			( ( volatile uint8_t  * )0x0008C010 )
+ #define PORTJ_PDR_ADDR			( ( volatile uint8_t  * )0x0008C012 )
+ #define PORT_PDR_B0_BIT			( 0x01U << 0U )
+ #define PORT_PDR_B1_BIT			( 0x01U << 1U )
+ #define PORT_PDR_B2_BIT			( 0x01U << 2U )
+ #define PORT_PDR_B3_BIT			( 0x01U << 3U )
+ #define PORT_PDR_B4_BIT			( 0x01U << 4U )
+ #define PORT_PDR_B5_BIT			( 0x01U << 5U )
+ #define PORT_PDR_B6_BIT			( 0x01U << 6U )
+ #define PORT_PDR_B7_BIT			( 0x01U << 7U )
+ #define PORT0_PODR_ADDR			( ( volatile uint8_t  * )0x0008C020 )
+ #define PORT1_PODR_ADDR			( ( volatile uint8_t  * )0x0008C021 )
+ #define PORT2_PODR_ADDR			( ( volatile uint8_t  * )0x0008C022 )
+ #define PORT3_PODR_ADDR			( ( volatile uint8_t  * )0x0008C023 )
+ #define PORT4_PODR_ADDR			( ( volatile uint8_t  * )0x0008C024 )
+ #define PORT5_PODR_ADDR			( ( volatile uint8_t  * )0x0008C025 )
+ #define PORT6_PODR_ADDR			( ( volatile uint8_t  * )0x0008C026 )
+ #define PORT7_PODR_ADDR			( ( volatile uint8_t  * )0x0008C027 )
+ #define PORT8_PODR_ADDR			( ( volatile uint8_t  * )0x0008C028 )
+ #define PORT9_PODR_ADDR			( ( volatile uint8_t  * )0x0008C029 )
+ #define PORTA_PODR_ADDR			( ( volatile uint8_t  * )0x0008C02A )
+ #define PORTB_PODR_ADDR			( ( volatile uint8_t  * )0x0008C02B )
+ #define PORTC_PODR_ADDR			( ( volatile uint8_t  * )0x0008C02C )
+ #define PORTD_PODR_ADDR			( ( volatile uint8_t  * )0x0008C02D )
+ #define PORTE_PODR_ADDR			( ( volatile uint8_t  * )0x0008C02E )
+ #define PORTF_PODR_ADDR			( ( volatile uint8_t  * )0x0008C02F )
+ #define PORTG_PODR_ADDR			( ( volatile uint8_t  * )0x0008C030 )
+ #define PORTH_PODR_ADDR			( ( volatile uint8_t  * )0x0008C032 )
+ #define PORT_PODR_B0_BIT			( 0x01U << 0U )
+ #define PORT_PODR_B1_BIT			( 0x01U << 1U )
+ #define PORT_PODR_B2_BIT			( 0x01U << 2U )
+ #define PORT_PODR_B3_BIT			( 0x01U << 3U )
+ #define PORT_PODR_B4_BIT			( 0x01U << 4U )
+ #define PORT_PODR_B5_BIT			( 0x01U << 5U )
+ #define PORT_PODR_B6_BIT			( 0x01U << 6U )
+ #define PORT_PODR_B7_BIT			( 0x01U << 7U )
+ #define PORT0_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C040 )
+ #define PORT1_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C041 )
+ #define PORT2_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C042 )
+ #define PORT3_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C043 )
+ #define PORT4_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C044 )
+ #define PORT5_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C045 )
+ #define PORT6_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C046 )
+ #define PORT7_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C047 )
+ #define PORT8_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C048 )
+ #define PORT9_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C049 )
+ #define PORTA_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C04A )
+ #define PORTB_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C04B )
+ #define PORTC_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C04C )
+ #define PORTD_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C04D )
+ #define PORTE_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C04E )
+ #define PORTF_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C04F )
+ #define PORTG_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C050 )
+ #define PORTJ_PIDR_ADDR			( ( volatile uint8_t  * )0x0008C052 )
+ #define PORT_PIDR_B0_BIT			( 0x01U << 0U )
+ #define PORT_PIDR_B1_BIT			( 0x01U << 1U )
+ #define PORT_PIDR_B2_BIT			( 0x01U << 2U )
+ #define PORT_PIDR_B3_BIT			( 0x01U << 3U )
+ #define PORT_PIDR_B4_BIT			( 0x01U << 4U )
+ #define PORT_PIDR_B5_BIT			( 0x01U << 5U )
+ #define PORT_PIDR_B6_BIT			( 0x01U << 6U )
+ #define PORT_PIDR_B7_BIT			( 0x01U << 7U )
+ #define PORT0_PMR_ADDR			( ( volatile uint8_t  * )0x0008C060 )
+ #define PORT1_PMR_ADDR			( ( volatile uint8_t  * )0x0008C061 )
+ #define PORT2_PMR_ADDR			( ( volatile uint8_t  * )0x0008C062 )
+ #define PORT3_PMR_ADDR			( ( volatile uint8_t  * )0x0008C063 )
+ #define PORT4_PMR_ADDR			( ( volatile uint8_t  * )0x0008C064 )
+ #define PORT5_PMR_ADDR			( ( volatile uint8_t  * )0x0008C065 )
+ #define PORT6_PMR_ADDR			( ( volatile uint8_t  * )0x0008C066 )
+ #define PORT7_PMR_ADDR			( ( volatile uint8_t  * )0x0008C067 )
+ #define PORT8_PMR_ADDR			( ( volatile uint8_t  * )0x0008C068 )
+ #define PORT9_PMR_ADDR			( ( volatile uint8_t  * )0x0008C068 )
+ #define PORTA_PMR_ADDR			( ( volatile uint8_t  * )0x0008C06A )
+ #define PORTB_PMR_ADDR			( ( volatile uint8_t  * )0x0008C06B )
+ #define PORTC_PMR_ADDR			( ( volatile uint8_t  * )0x0008C06C )
+ #define PORTD_PMR_ADDR			( ( volatile uint8_t  * )0x0008C06D )
+ #define PORTE_PMR_ADDR			( ( volatile uint8_t  * )0x0008C06E )
+ #define PORTF_PMR_ADDR			( ( volatile uint8_t  * )0x0008C06F )
+ #define PORTG_PMR_ADDR			( ( volatile uint8_t  * )0x0008C070 )
+ #define PORTJ_PMR_ADDR			( ( volatile uint8_t  * )0x0008C072 )
+ #define PORT_PMR_B0_BIT			( 0x01U << 0U )
+ #define PORT_PMR_B1_BIT			( 0x01U << 1U )
+ #define PORT_PMR_B2_BIT			( 0x01U << 2U )
+ #define PORT_PMR_B3_BIT			( 0x01U << 3U )
+ #define PORT_PMR_B4_BIT			( 0x01U << 4U )
+ #define PORT_PMR_B5_BIT			( 0x01U << 5U )
+ #define PORT_PMR_B6_BIT			( 0x01U << 6U )
+ #define PORT_PMR_B7_BIT			( 0x01U << 7U )
+ #define PORT0_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C0 )
+ #define PORT1_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C1 )
+ #define PORT2_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C2 )
+ #define PORT3_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C3 )
+ #define PORT4_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C4 )
+ #define PORT5_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C5 )
+ #define PORT6_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C6 )
+ #define PORT7_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C7 )
+ #define PORT8_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C8 )
+ #define PORT9_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0C8 )
+ #define PORTA_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0CA )
+ #define PORTB_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0CB )
+ #define PORTC_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0CC )
+ #define PORTD_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0CD )
+ #define PORTE_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0CE )
+ #define PORTF_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0CF )
+ #define PORTG_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0D0 )
+ #define PORTJ_PCR_ADDR      ( ( volatile uint8_t  * )0x0008C0D2 )
+ #define PORT_PCR_B0_BIT      ( 0x01U << 0U )
+ #define PORT_PCR_B1_BIT      ( 0x01U << 1U )
+ #define PORT_PCR_B2_BIT      ( 0x01U << 2U )
+ #define PORT_PCR_B3_BIT      ( 0x01U << 3U )
+ #define PORT_PCR_B4_BIT      ( 0x01U << 4U )
+ #define PORT_PCR_B5_BIT      ( 0x01U << 5U )
+ #define PORT_PCR_B6_BIT      ( 0x01U << 6U )
+ #define PORT_PCR_B7_BIT      ( 0x01U << 7U )
+ 
+ /*
+  *  UART関連の定義
+  *
+  *  pdicのrx600/rx610_uart.cで使用する．
+  */
+ /*
+  *  シリアルI/Oの個数
+  */
+ 
+ #define TNUM_SIOP			( 7 )
+ 
+ //Ethernte device address
+ //Ethernet mac base address
+ #define ETHERC_BASE_ADDR 0x000C0100
+ 
+ //Ethernet DMAC base address
+ #define EDMAC_BASE_ADDR  0x000C0000
+ #endif	/* TOPPERS_RX72n_H */
+ 
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/rx72n.tf ASPs/asp/arch/rx_gcc/rx72n/rx72n.tf
*** 1.9.1/asp/arch/rx_gcc/rx72n/rx72n.tf	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/rx72n.tf	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,51 ----
+ $ 
+ $		アーキテクチャ依存テンプレート（RX72n用）
+ $ 
+ 
+ 
+ 
+ /*$NL$
+ $SPC$*  Architecture-dependent Definitions (RX72n)$NL$
+ $SPC$*/$NL$
+ $NL$
+ 
+ $ 
+ $  割込み番号と割込みハンドラ番号の定義
+ $ 
+ $  RX610では割込み番号と割込みハンドラ番号が1対1で対応する．
+ $ 
+ 
+ $INTNO_VALID = { 16, 21, 23 ; 27, 28,...,59 ; 62 ; 64, 65,...,79 ; 90, 91,...,93 ; 98 , 102 ; 106, 107,...,113 ; 114; 122, 123,...,167 ; 170, 171,...,203 ; 206, 207,...,210 ; 214, 215,...,253 }$
+ $INHNO_VALID = INTNO_VALID$
+ 
+ $ 
+ $  例外番号の定義
+ $ 
+ $  固定ベクタテーブルのベクタテーブルアドレスの小さい順番に例外番号を割振る．
+ $  (予約領域も含む)
+ $ 
+ 
+ $EXCNO_VALID = { 20, 23, 25, 30, 31 }$
+ 
+ $ 
+ $  INT割込みの番号
+ $ 
+ 
+ $INTNO_INT = { 64, 65,...,79 }$
+ 
+ $ 
+ $  割込み番号，割込みハンドラ番号，例外番号の範囲
+ $ 
+ $ (予約領域も含む)
+ $ 
+ 
+ $INTNO_RANGE = { 0, 1,...,255 }$
+ $INHNO_RANGE = INTNO_RANGE$
+ $EXCNO_RANGE = { 0, 1,...,31 }$
+ 
+ $ 
+ $  プロセッサ依存のテンプレートファイルのインクルード
+ $ 
+ 
+ $INCLUDE"rx_gcc/RX72n/prc.tf"$
+ 
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_config.c ASPs/asp/arch/rx_gcc/rx72n/rx72n_config.c
*** 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_config.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/rx72n_config.c	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,270 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2015- by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ #include <kernel_impl.h>
+ 
+ /*
+  *		プロセッサ依存モジュール（RX72n用）
+  */
+ 
+ #define NULL_OFF 0 //reserved IPR 
+ 
+ volatile uint8_t const ipr_reg_offset[ INHNO_MAX ] = {
+ 	NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF,	/* No.0 - 4   予約 */
+ 	NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF,	/* No.5 - 9   予約 */
+ 	NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF,	/* No.10 - 14 予約 */
+ 	NULL_OFF,							/* No.15  予約 */
+ 	ICU_IPR00_OFFSET,					/* No.16   バスエラー BUSERR  */
+ 	NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF,			/* No.17 - 20 予約 */
+ 	ICU_IPR01_OFFSET,					/* No.21   FCU FIFERR  */
+ 	NULL_OFF,							/* No.22  予約 */
+ 	ICU_IPR02_OFFSET,					/* No.23   FCU FRDYI  */
+ 	NULL_OFF, NULL_OFF, NULL_OFF,		        /* No.24 -26  予約 */
+ 	ICU_IPR03_OFFSET,                 /* No.27  ICU SWINT  */
+ 	ICU_IPR04_OFFSET,					/* No.28   CMTユニット0 CMT0  */
+ 	ICU_IPR05_OFFSET,					/* No.29   CMTユニット0 CMT1  */
+ 	ICU_IPR06_OFFSET,					/* No.30   CMTユニット1 CMT2  */
+ 	ICU_IPR07_OFFSET,					/* No.31   CMTユニット1 CMT3  */
+ 	ICU_IPR20_OFFSET,                 /* No.32   Ether EINT  */
+ 	ICU_IPR21_OFFSET,                 /* No.33   USB D0FIFO0  */
+ 	ICU_IPR22_OFFSET,                 /* No.34   USB D1FIFO0  */
+ 	ICU_IPR23_OFFSET,                 /* No.35   USB USBI0  */
+ 	ICU_IPR24_OFFSET,                 /* No.36   USB D0FIFO1  */
+ 	ICU_IPR25_OFFSET,                 /* No.37   USB D1FIFO1  */
+ 	ICU_IPR26_OFFSET,                 /* No.38   USB USBI1  */
+ 	ICU_IPR27_OFFSET,                 /* No.39   RSPI0 SPRI0  */
+ 	ICU_IPR27_OFFSET,                 /* No.40   RSPI0 SPTI0  */
+ 	ICU_IPR27_OFFSET,                 /* No.41   RSPI0 SPII0  */
+ 	ICU_IPR2A_OFFSET,                 /* No.42   RSPI1 SPRI0  */
+ 	ICU_IPR2A_OFFSET,                 /* No.43   RSPI1 SPTI0  */
+ 	ICU_IPR2A_OFFSET,                 /* No.44   RSPI1 SPII0  */
+ 	ICU_IPR2D_OFFSET,                 /* No.45   RSPI1 SPRI0  */
+ 	ICU_IPR2D_OFFSET,                 /* No.46   RSPI1 SPTI0  */
+ 	ICU_IPR2D_OFFSET,                 /* No.47   RSPI1 SPII0  */
+ 	ICU_IPR30_OFFSET,                 /* NO.48  CAN0 RXF0*/
+ 	ICU_IPR30_OFFSET,                 /* NO.49  CAN0 TXF0*/
+ 	ICU_IPR30_OFFSET,                 /* NO.50  CAN0 RXM0*/
+ 	ICU_IPR30_OFFSET,                 /* NO.51  CAN0 TXM0*/
+ 	ICU_IPR34_OFFSET,                 /* NO.52  CAN1 RXF1*/
+ 	ICU_IPR34_OFFSET,                 /* NO.53  CAN1 TXF1*/
+ 	ICU_IPR34_OFFSET,                 /* NO.54  CAN1 RXM1*/
+ 	ICU_IPR34_OFFSET,                 /* NO.55  CAN1 TXM1*/
+ 	ICU_IPR38_OFFSET,                 /* NO.56  CAN2 RXF2*/
+ 	ICU_IPR38_OFFSET,                 /* NO.57  CAN2 TXF2*/
+ 	ICU_IPR38_OFFSET,                 /* NO.58  CAN2 RXM2*/
+ 	ICU_IPR38_OFFSET,                 /* NO.59  CAN2 TXM2*/
+ 	NULL_OFF, NULL_OFF,                     /* No.60 - 61 予約 */
+ 	ICU_IPR3E_OFFSET,                 /* NO 62 RTC CUP */
+ 	NULL_OFF,						    /* No.63 予約 */
+ 	ICU_IPR40_OFFSET,					/* No.64   外部端子 IRQ0  */
+ 	ICU_IPR41_OFFSET,					/* No.65   外部端子 IRQ1  */
+ 	ICU_IPR42_OFFSET,					/* No.66   外部端子 IRQ2  */
+ 	ICU_IPR43_OFFSET,					/* No.67   外部端子 IRQ3  */
+ 	ICU_IPR44_OFFSET,					/* No.68   外部端子 IRQ4  */
+ 	ICU_IPR45_OFFSET,					/* No.69   外部端子 IRQ5  */
+ 	ICU_IPR46_OFFSET,					/* No.70   外部端子 IRQ6  */
+ 	ICU_IPR47_OFFSET,					/* No.71   外部端子 IRQ7  */
+ 	ICU_IPR48_OFFSET,					/* No.72   外部端子 IRQ8  */
+ 	ICU_IPR49_OFFSET,					/* No.73   外部端子 IRQ9  */
+ 	ICU_IPR4A_OFFSET,					/* No.74   外部端子 IRQ10  */
+ 	ICU_IPR4B_OFFSET,					/* No.75   外部端子 IRQ11  */
+ 	ICU_IPR4C_OFFSET,					/* No.76   外部端子 IRQ12  */
+ 	ICU_IPR4D_OFFSET,					/* No.77   外部端子 IRQ13  */
+ 	ICU_IPR4E_OFFSET,					/* No.78   外部端子 IRQ14  */
+ 	ICU_IPR4F_OFFSET,					/* No.79   外部端子 IRQ15  */
+ 	NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF,	/* No.80 - 84 予約 */
+ 	NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF,	/* No.85 - 89 予約 */
+     ICU_IPR5A_OFFSET,                 /* No.90  USB USBR0  */
+ 	ICU_IPR5B_OFFSET,                 /* No.91  USB USBR1  */
+ 	ICU_IPR5C_OFFSET,                 /* No.92  RTC ALM  */
+ 	ICU_IPR5D_OFFSET,                 /* No.93  RTC PRD  */
+ 	NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF,         /* No.94 - 97  予約 */
+ 	ICU_IPR62_OFFSET,					/* No.98   AD0 ADI0  */
+     NULL_OFF, NULL_OFF, NULL_OFF,               /* No.99 - 101 予約 */
+ 	ICU_IPR66_OFFSET,					/* No.102  S12AD S12ADI0  */
+ 	NULL_OFF, NULL_OFF, NULL_OFF,               /* No.103 - 105 予約 */
+ 	ICU_IPR6A_OFFSET,					/* No.106  ICU GROUP0  */
+ 	ICU_IPR6B_OFFSET,					/* No.107  ICU GROUP1  */
+ 	ICU_IPR6C_OFFSET,					/* No.108  ICU GROUP2  */
+ 	ICU_IPR6D_OFFSET,					/* No.109  ICU GROUP3  */
+ 	ICU_IPR6E_OFFSET,					/* No.110  ICU GROUP4  */
+ 	ICU_IPR6F_OFFSET,					/* No.111  ICU GROUP5  */
+ 	ICU_IPR70_OFFSET,					/* No.112  ICU GROUP6  */
+ 	ICU_IPR71_OFFSET,                           /* No.113 予約 */
+ 	ICU_IPR72_OFFSET,                 /* No.114  ICU Group12  */
+ 	NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF, NULL_OFF,   /* No.115 - 119 予約 */
+ 	NULL_OFF, NULL_OFF,                     /* No.120 - 121 予約 */
+ 	ICU_IPR7A_OFFSET,                 /* No.122  SCI12 SCIX0  */
+ 	ICU_IPR7A_OFFSET,                 /* No.123  SCI12 SCIX1  */
+ 	ICU_IPR7A_OFFSET,                 /* No.124  SCI12 SCIX2  */
+ 	ICU_IPR7A_OFFSET,                 /* No.125  SCI12 SCIX3  */
+ 	ICU_IPR7E_OFFSET,                 /* No.126  TPU0 TGI0A  */
+ 	ICU_IPR7E_OFFSET,                 /* No.127  TPU0 TGI0B  */
+ 	ICU_IPR7E_OFFSET,                 /* No.128  TPU0 TGI0C  */
+ 	ICU_IPR7E_OFFSET,                 /* No.129  TPU0 TGI0D  */
+ 	ICU_IPR82_OFFSET,                 /* No.130  TPU1 TGI1A  */
+ 	ICU_IPR82_OFFSET,                 /* No.131  TPU1 TGI1B  */
+     ICU_IPR84_OFFSET,                 /* No.132  TPU2 TGI2A  */
+     ICU_IPR84_OFFSET,                 /* No.133  TPU2 TGI2B  */
+     ICU_IPR86_OFFSET,                 /* No.134  TPU3 TGI3A  */
+     ICU_IPR86_OFFSET,                 /* No.135  TPU3 TGI3B  */
+     ICU_IPR86_OFFSET,                 /* No.136  TPU3 TGI3C  */
+     ICU_IPR86_OFFSET,                 /* No.137  TPU3 TGI3D  */
+     ICU_IPR8A_OFFSET,                 /* No.138  TPU4 TGI4A  */
+     ICU_IPR8A_OFFSET,                 /* No.139  TPU4 TGI4B  */
+     ICU_IPR8C_OFFSET,                 /* No.140  TPU5 TGI5A  */
+     ICU_IPR8C_OFFSET,                 /* No.141  TPU5 TGI5B  */
+     ICU_IPR8E_OFFSET,                 /* No.142  TPU6 TGI6A, MTU0 TGIA0  */
+     ICU_IPR8E_OFFSET,                 /* No.143  TPU6 TGI6B, MTU0 TGIB0  */
+     ICU_IPR8E_OFFSET,                 /* No.144  TPU6 TGI6C, MTU0 TGIC0  */
+     ICU_IPR8E_OFFSET,                 /* No.145  TPU6 TGI6D, MTU0 TGID0  */
+     ICU_IPR92_OFFSET,                 /* No.146  MTU0 TGIE0  */
+     ICU_IPR92_OFFSET,                 /* No.147  MTU0 TGIF0  */
+     ICU_IPR94_OFFSET,                 /* No.148  TPU7 TGI7A, MTU1 TGIA1  */
+     ICU_IPR94_OFFSET,                 /* No.149  TPU7 TGI7B, MTU1 TGIB1  */
+     ICU_IPR96_OFFSET,                 /* No.150  TPU8 TGI8A, MTU2 TGIA2  */
+     ICU_IPR96_OFFSET,                 /* No.151  TPU8 TGI8B, MTU2 TGIB2  */
+     ICU_IPR98_OFFSET,                 /* No.152  TPU9 TGI9A, MTU3 TGIA3  */
+     ICU_IPR98_OFFSET,                 /* No.153  TPU9 TGI9B, MTU3 TGIB3  */
+     ICU_IPR98_OFFSET,                 /* No.154  TPU9 TGI9C, MTU3 TGIC3  */
+     ICU_IPR98_OFFSET,                 /* No.155  TPU9 TGI9D, MTU3 TGID3  */
+     ICU_IPR9C_OFFSET,                 /* No.156  TPU10 TGI10A, MTU4 TGIA4  */
+     ICU_IPR9C_OFFSET,                 /* No.157  TPU10 TGI10B, MTU4 TGIB4  */
+     ICU_IPR9C_OFFSET,                 /* No.158  MTU4 TGIC4  */
+     ICU_IPR9C_OFFSET,                 /* No.159  MTU4 TGID4  */
+     ICU_IPRA0_OFFSET,                 /* No.160  MTU4 TGIV4  */
+     ICU_IPRA1_OFFSET,                 /* No.161  MTU5 TGIU5  */
+     ICU_IPRA1_OFFSET,                 /* No.162  MTU5 TGIV5  */
+     ICU_IPRA1_OFFSET,                 /* No.163  MTU5 TGIW5  */
+     ICU_IPRA4_OFFSET,                 /* No.164  TPU11 TGI11A  */
+     ICU_IPRA4_OFFSET,                 /* No.165  TPU11 TGI11B  */
+     ICU_IPRA6_OFFSET,                 /* No.166  POE OEI1  */
+     ICU_IPRA6_OFFSET,                 /* No.167  POE OEI2  */
+ 	NULL_OFF, NULL_OFF,                     /* No.168 - 169 予約 */
+     ICU_IPRAA_OFFSET,                 /* No.170  TMR0 CMIA0  */
+     ICU_IPRAA_OFFSET,                 /* No.171  TMR0 CMIB0  */
+     ICU_IPRAA_OFFSET,                 /* No.172  TMR0 OVI0  */
+     ICU_IPRAD_OFFSET,                 /* No.173  TMR1 CMIA1  */
+     ICU_IPRAD_OFFSET,                 /* No.174  TMR1 CMIB1  */
+     ICU_IPRAD_OFFSET,                 /* No.175  TMR1 OVI1  */
+     ICU_IPRB0_OFFSET,                 /* No.176  TMR2 CMIA2  */
+     ICU_IPRB0_OFFSET,                 /* No.177  TMR2 CMIB2  */
+     ICU_IPRB0_OFFSET,                 /* No.178  TMR2 OVI2  */
+     ICU_IPRB3_OFFSET,                 /* No.179  TMR3 CMIA3  */
+     ICU_IPRB3_OFFSET,                 /* No.180  TMR3 CMIB3  */
+     ICU_IPRB3_OFFSET,                 /* No.181  TMR3 OVI3  */
+     ICU_IPRB6_OFFSET,                 /* No.182  RIIC0 EEI0  */
+     ICU_IPRB7_OFFSET,                 /* No.183  RIIC0 RXI0  */
+     ICU_IPRB8_OFFSET,                 /* No.184  RIIC0 TXI0  */
+     ICU_IPRB9_OFFSET,                 /* No.185  RIIC0 TEI0  */
+     ICU_IPRBA_OFFSET,                 /* No.186  RIIC1 EEI1  */
+     ICU_IPRBB_OFFSET,                 /* No.187  RIIC1 RXI1  */
+     ICU_IPRBC_OFFSET,                 /* No.188  RIIC1 TXI1  */
+     ICU_IPRBD_OFFSET,                 /* No.189  RIIC1 TEI1  */
+     ICU_IPRBE_OFFSET,                 /* No.190  RIIC2 EEI2  */
+     ICU_IPRBF_OFFSET,                 /* No.191  RIIC2 RXI2  */
+     ICU_IPRC0_OFFSET,                 /* No.192  RIIC2 TXI2  */
+     ICU_IPRC1_OFFSET,                 /* No.193  RIIC2 TEI2  */
+     ICU_IPRC2_OFFSET,                 /* No.194  RIIC3 EEI3  */
+     ICU_IPRC3_OFFSET,                 /* No.195  RIIC3 RXI3  */
+     ICU_IPRC4_OFFSET,                 /* No.196  RIIC3 TXI3  */
+     ICU_IPRC5_OFFSET,                 /* No.197  RIIC3 TEI3  */
+     ICU_IPRC6_OFFSET,                 /* No.198  DMAC DMAC0I  */
+     ICU_IPRC7_OFFSET,                 /* No.199  DMAC DMAC1I  */
+     ICU_IPRC8_OFFSET,                 /* No.200  DMAC DMAC2I  */
+     ICU_IPRC9_OFFSET,                 /* No.201  DMAC DMAC3I  */
+     ICU_IPRCA_OFFSET,                 /* No.202  EXDMAC EXDMAC0I  */
+     ICU_IPRCB_OFFSET,                 /* No.203  EXDMAC EXDMAC1I  */
+ 	NULL_OFF, NULL_OFF,                     /* No.204 - 205 予約 */
+     ICU_IPRCE_OFFSET,                 /* No.206  DEU DEU0  */
+     ICU_IPRCF_OFFSET,                 /* No.207  DEU DEU0  */
+     ICU_IPRD0_OFFSET,                 /* No.208  PDC PCDFI  */
+     ICU_IPRD1_OFFSET,                 /* No.209  PDC PCFEI  */
+     ICU_IPRD2_OFFSET,                 /* No.210  PDC PCERI  */
+ 	NULL_OFF, NULL_OFF, NULL_OFF,               /* No.211 - 213 予約 */
+     ICU_IPRD6_OFFSET,                 /* No.214  SCI0 RXI0  */
+     ICU_IPRD6_OFFSET,                 /* No.215  SCI0 TXI0  */
+     ICU_IPRD6_OFFSET,                 /* No.216  SCI0 TEI0  */
+     ICU_IPRD9_OFFSET,                 /* No.217  SCI1 RXI1  */
+     ICU_IPRD9_OFFSET,                 /* No.218  SCI1 TXI1  */
+     ICU_IPRD9_OFFSET,                 /* No.219  SCI1 TEI1  */
+     ICU_IPRDC_OFFSET,                 /* No.220  SCI2 RXI2  */
+     ICU_IPRDC_OFFSET,                 /* No.221  SCI2 TXI2  */
+     ICU_IPRDC_OFFSET,                 /* No.222  SCI2 TEI2  */
+     ICU_IPRDF_OFFSET,                 /* No.223  SCI3 RXI3  */
+     ICU_IPRDF_OFFSET,                 /* No.224  SCI3 TXI3  */
+     ICU_IPRDF_OFFSET,                 /* No.225  SCI3 TEI3  */
+     ICU_IPRE2_OFFSET,                 /* No.226  SCI4 RXI4  */
+     ICU_IPRE2_OFFSET,                 /* No.227  SCI4 TXI4  */
+     ICU_IPRE2_OFFSET,                 /* No.228  SCI4 TEI4  */
+     ICU_IPRE5_OFFSET,                 /* No.229  SCI5 RXI5  */
+     ICU_IPRE5_OFFSET,                 /* No.230  SCI5 TXI5  */
+     ICU_IPRE5_OFFSET,                 /* No.231  SCI5 TEI5  */
+     ICU_IPRE8_OFFSET,                 /* No.232  SCI6 RXI6  */
+     ICU_IPRE8_OFFSET,                 /* No.233  SCI6 TXI6  */
+     ICU_IPRE8_OFFSET,                 /* No.234  SCI6 TEI6  */
+     ICU_IPREB_OFFSET,                 /* No.235  SCI7 RXI7  */
+     ICU_IPREB_OFFSET,                 /* No.236  SCI7 TXI7  */
+     ICU_IPREB_OFFSET,                 /* No.237  SCI7 TEI7  */
+     ICU_IPREE_OFFSET,                 /* No.238  SCI8 RXI8  */
+     ICU_IPREE_OFFSET,                 /* No.239  SCI8 TXI8  */
+     ICU_IPREE_OFFSET,                 /* No.240  SCI8 TEI8  */
+     ICU_IPRF1_OFFSET,                 /* No.241  SCI9 RXI9  */
+     ICU_IPRF1_OFFSET,                 /* No.242  SCI9 TXI9  */
+     ICU_IPRF1_OFFSET,                 /* No.243  SCI9 TEI9  */
+     ICU_IPRF4_OFFSET,                 /* No.244  SCI10 RXI10  */
+     ICU_IPRF4_OFFSET,                 /* No.245  SCI10 TXI10  */
+     ICU_IPRF4_OFFSET,                 /* No.246  SCI10 TEI10  */
+     ICU_IPRF7_OFFSET,                 /* No.247  SCI11 RXI11  */
+     ICU_IPRF7_OFFSET,                 /* No.248  SCI11 TXI11  */
+     ICU_IPRF7_OFFSET,                 /* No.249  SCI11 TEI11  */
+     ICU_IPRFA_OFFSET,                 /* No.250  SCI12 RXI12  */
+     ICU_IPRFA_OFFSET,                 /* No.251  SCI12 TXI12  */
+     ICU_IPRFA_OFFSET,                 /* No.252  SCI12 TEI12  */
+     ICU_IPRFD_OFFSET,                 /* No.253  IEB IEBINT  */
+ 	NULL_OFF, NULL_OFF,						/* No.254 - 255 予約 */
+ };
+ 
+ /*
+  * set interrupt priority register
+  */
+ 
+ void set_icu_ipr(INTNO intno, uint8_t pri_num){
+   *((volatile uint8_t *)(ICU_IPR_BASE + ipr_reg_offset[intno])) = pri_num;
+ }
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_config.h ASPs/asp/arch/rx_gcc/rx72n/rx72n_config.h
*** 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_config.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/rx72n_config.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,79 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  *
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  *
+  */
+ 
+ /*
+  *		プロセッサ依存モジュール（RX72n用）
+  *
+  *  このインクルードファイルは，target_config.h（または，そこからインク
+  *  ルードされるファイル）のみからインクルードされる．他のファイルから
+  *  直接インクルードしてはならない．
+  */
+ 
+ 
+ #ifndef TOPPERS_RX72n_CONFIG_H
+ #define TOPPERS_RX72n_CONFIG_H
+ 
+ #define ARCH_RENESAS_RX72n
+ 
+ /*
+  *  割込み要因数
+  */
+ #define	INHNO_MAX	UINT_C( 256 )
+ 
+ 
+ /*
+  *  割込み制御用定義
+  */
+ #define	INVALID_OFFSET				( 0xFFU )
+ #define	INTNO_IRQ( intno )			( ( 64U <= ( intno ) ) && ( ( intno ) <= 79U ) )
+ #define	INTNO_IRQ_OFFSET( intno )	( ( intno ) - 64U )
+ #define	IRQ_MAX						UINT_C( 16 )
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ void set_icu_ipr(INTNO, uint8_t);
+ 
+ #endif
+ 
+ /*
+  *  プロセッサ依存モジュール（RX72n用）
+  */
+ #include "rx_gcc/rx_common/prc_config.h"
+ 
+ #endif	/* TOPPERS_RX72n_CONFIG_H */
+ 
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_elf.ld ASPs/asp/arch/rx_gcc/rx72n/rx72n_elf.ld
*** 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_elf.ld	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/rx72n_elf.ld	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,80 ----
+ MEMORY
+ {
+     FLASH (rx) : ORIGIN = 0xFFF00000, LENGTH = 1024K
+     SRAM (rwx) : ORIGIN = 0x00000000, LENGTH = 64K
+ }
+ 
+ PROVIDE(hardware_init_hook = 0);
+ PROVIDE(software_init_hook = 0);
+ PROVIDE(software_term_hook = 0);
+ STARTUP(start.o)
+ 
+ SECTIONS
+ {
+ 
+ 	.text :
+ 	{
+ 		__text = .;
+ 		*(.vector)
+ 		*(.text)
+ 		*(.text.*)
+ 		*(P)
+ 	} > FLASH
+ 	_etext = .;
+ 	PROVIDE(etext = .);
+ 
+ 	.rodata :
+ 	{
+ 		*(.rodata)
+ 		*(.rodata.*)
+ 		*(C_1)
+ 		*(C_2)
+ 		*(C)
+ 		*(C$VECT)
+ 	} > FLASH
+     __rodata_end = .;
+ 	__exidx_start = .;
+ 	__exidx_end = .;
+ 
+ 	. = 0x0; /*SRAM START ADDRES*/
+ 	.bss : 
+ 	{
+ 		__bss_start  = .;
+         *(DTCA_VECTOR_SEC)
+         __dtca_start = .;
+ 		*(.bss)
+ 		*(.bss.*)
+ 		*(COMMON)
+ 		*(B)
+ 		*(B_1)
+ 		*(B_2)
+ 		*(SI) /* SI is kernel stack section*/
+ 	    __bss_end = .;
+ 	} > SRAM
+ 
+     . = __rodata_end;
+ 	. = ALIGN(4);
+ 	__idata_start = .;
+ 	.data : 
+ 	{
+ 		__data_start = .;
+ 		*(.data)
+ 		*(.data.*)
+ 		*(D)
+ 		*(D_1)
+ 		*(D_2)
+ 	    __data_end = .;
+ 	} > SRAM AT> FLASH
+     
+ 	__idata_end = __idata_start + SIZEOF(.data);
+ 	_edata = .;
+ 	PROVIDE(edata = .);
+     
+ 	. = ALIGN(4);
+     .fvectors 0xFFFFFF80 :
+    {
+       *(.fvect)
+     } > FLASH
+ 	_end = .;
+ 	PROVIDE(end = .);
+ }
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_support.c ASPs/asp/arch/rx_gcc/rx72n/rx72n_support.c
*** 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_support.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/rx72n_support.c	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,55 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2016- by Hisashi Hata, JAPAN
+  *
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  *
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  *
+  */
+ #include <kernel.h>
+ #include <RX72n.h>
+ 
+ void set_init_moudlestop_setting(){
+     /* power management setting*/
+ 	/* unlock register access */
+ 	sil_wrh_mem((void *)(SYSTEM_PRCR_ADDR), SYSTEM_PRKEY | SYSTEM_PRC1);
+ 
+ 	//enable RSPI0
+ 	sil_wrw_mem((void*)SYSTEM_MSTPCRA_ADDR, 0x46FFFFFF); //reset MSTPCRA
+ 	sil_wrw_mem((void*)SYSTEM_MSTPCRB_ADDR, 0xFFFFFFFF); //reset MSTPCRB
+ 	sil_wrw_mem((void*)SYSTEM_MSTPCRC_ADDR, 0xFFFF0000); //reset MSTPCRC
+ 
+ 	//lock register access
+ 	sil_wrh_mem((void *)(SYSTEM_PRCR_ADDR), SYSTEM_PRKEY );
+ 	/* end power management setting */
+ }
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_support.h ASPs/asp/arch/rx_gcc/rx72n/rx72n_support.h
*** 1.9.1/asp/arch/rx_gcc/rx72n/rx72n_support.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/rx72n_support.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,40 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2016- by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ void set_init_moudlestop_setting();
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx72n/start.S ASPs/asp/arch/rx_gcc/rx72n/start.S
*** 1.9.1/asp/arch/rx_gcc/rx72n/start.S	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx72n/start.S	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,93 ----
+ ;*
+ ;*  TOPPERS/ASP Kernel
+ ;*      Toyohashi Open Platform for Embedded Real-Time Systems/
+ ;*      Advanced Standard Profile Kernel
+ ;* 
+ ;*  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+ ;*                              Toyohashi Univ. of Technology, JAPAN
+ ;*  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
+ ;*              Graduate School of Information Science, Nagoya Univ., JAPAN
+ ;*  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+ ;*  Copyright (C) 2015 by Hisashi Hata, JAPAN
+ ;* 
+ ;*  上記著作権者は，Free Software Foundation によって公表されている 
+ ;*  GNU General Public License の Version 2 に記述されている条件か，以
+ ;*  下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェア（本ソフトウェ
+ ;*  アを改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+ ;*  利用と呼ぶ）することを無償で許諾する．
+ ;*  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ ;*      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ ;*      スコード中に含まれていること．
+ ;*  (2) 本ソフトウェアを再利用可能なバイナリコード（リロケータブルオブ
+ ;*      ジェクトファイルやライブラリなど）の形で利用する場合には，利用
+ ;*      に伴うドキュメント（利用者マニュアルなど）に，上記の著作権表示，
+ ;*      この利用条件および下記の無保証規定を掲載すること．
+ ;*  (3) 本ソフトウェアを再利用不可能なバイナリコードの形または機器に組
+ ;*      み込んだ形で利用する場合には，次のいずれかの条件を満たすこと．
+ ;*    (a) 利用に伴うドキュメント（利用者マニュアルなど）に，上記の著作
+ ;*        権表示，この利用条件および下記の無保証規定を掲載すること．
+ ;*    (b) 利用の形態を，別に定める方法によって，上記著作権者に報告する
+ ;*        こと．
+ ;*  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ ;*      害からも，上記著作権者を免責すること．
+ ;* 
+ ;*  本ソフトウェアは，無保証で提供されているものである．上記著作権者は，
+ ;*  本ソフトウェアに関して，その適用可能性も含めて，いかなる保証も行わ
+ ;*  ない．また，本ソフトウェアの利用により直接的または間接的に生じたい
+ ;*  かなる損害に関しても，その責任を負わない．
+ ;* 
+ 
+ #if 1
+ #define TOPPERS_MACRO_ONLY
+ #define UINT_C(val)		(val)		/* uint_t型の定数を作るマクロ */
+ #define ULONG_C(val)	(val)		/* ulong_t型の定数を作るマクロ */
+ #define CAST(type, val)	(val)		/* 型キャストを行うマクロ */
+ #include "kernel_impl.h"
+ 
+ .text
+ .balign 4
+ .global _startw
+ 		
+ _startw:
+ 
+ 	;  可変ベクタテーブルの設定
+ 	;
+ 	mvtc	#__vvector_table, intb			; ベクタテーブルの設定
+ 
+ 	;
+ 	;  ハードウェア固有の初期化ルーチンの呼出し
+ 	;
+ 	mov.l	#_hardware_init_hook, r5
+ 	cmp		#0, r5
+ 	beq.b	init_D
+ 	jsr		r5
+ 
+ 	;
+ 	;  初期値あり変数領域の初期化
+ 	;
+ init_D:
+ 	;
+ 	;  初期値なし変数領域の初期化
+ 	;
+ clear_B:
+ 
+ 	;
+ 	;  software_init_hook を呼出し（0 でない場合）
+ 	;
+ 	;  ソフトウェア環境（特にライブラリ）に依存して必要な初期化処理
+ 	;  がある場合は，software_init_hook という関数を用意すればよい.
+ 	;
+ 	mov.l	#_software_init_hook, r5
+ 	cmp		#0, r5
+ 	beq.b	kernel_link
+ 	jsr		r5
+ 
+ 	;
+ 	;  カーネルスタート
+ 	;
+ kernel_link:
+ 	bra.a	_sta_ker					; --> _sta_ker()
+ 
+ 
+ .end
+ #endif
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/Makefile.prc_common ASPs/asp/arch/rx_gcc/rx_common/Makefile.prc_common
*** 1.9.1/asp/arch/rx_gcc/rx_common/Makefile.prc_common	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/Makefile.prc_common	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,53 ----
+ #
+ #		Makefile のcpu依存部（rx用）
+ #
+ 
+ # 
+ #  CPU依存部ディレクトリ名の定義 
+ # 
+ ARCH_COM_DIR = $(SRCDIR)/arch/rx_$(TOOL)/rx_common
+ 
+ #  コンパイルオプション
+ #
+ INCLUDES := $(INCLUDES) -I$(ARCH_COM_DIR)
+ CDEFS := $(CDEFS)
+ COPTS := $(COPTS)
+ 
+ #
+ #  カーネルに関する定義
+ #
+ KERNEL_DIR := $(KERNEL_DIR) $(ARCH_COM_DIR)
+ KERNEL_ASMOBJS := $(KERNEL_ASMOBJS) prc_test.o
+ KERNEL_COBJS := $(KERNEL_COBJS) 
+ 
+ #
+ #  システムサービスに関する定義
+ #
+ SYSSVC_DIR := $(SYSSVC_DIR)
+ SYSSVC_COBJS := $(SYSSVC_COBJS)
+ 
+ #
+ #  依存関係の定義
+ #
+ $(OBJFILE): $(ARCH_COM_DIR)/prc_check.tf
+ 
+ #
+ #		Makefile のプロセッサ依存部（RX用）
+ #
+ 
+ #
+ #  カーネルに関する定義
+ #
+ KERNEL_DIR := $(KERNEL_DIR) $(COREDIR)
+ KERNEL_ASMOBJS := $(KERNEL_ASMOBJS) prc_support.o
+ KERNEL_COBJS := $(KERNEL_COBJS) prc_config.o
+ 
+ #
+ #  依存関係の定義
+ #
+ cfg1_out.c: $(ARCH_COM_DIR)/prc_def.csv
+ 
+ #
+ #  コンフィギュレータ関係の変数の定義
+ #
+ CFG_TABS := $(CFG_TABS) --cfg1-def-table $(ARCH_COM_DIR)/prc_def.csv  
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/core_offset.tf ASPs/asp/arch/rx_gcc/rx_common/core_offset.tf
*** 1.9.1/asp/arch/rx_gcc/rx_common/core_offset.tf	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/core_offset.tf	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,18 ----
+ $
+ $       オフセットファイル生成用テンプレートファイル (RX用）
+ $
+ 
+ 
+ $
+ $  標準テンプレートファイルのインクルード
+ $
+ 
+ $DEFINE("TCB_tinib", offsetof_TCB_p_tinib)$
+ $DEFINE("TCB_pc", offsetof_TCB_pc)$
+ $DEFINE("TCB_sp", offsetof_TCB_sp)$
+ $DEFINE("TCB_texptn", offsetof_TCB_texptn)$
+ $DEFINE("TINIB_exinf", offsetof_TINIB_exinf)$
+ $DEFINE("TINIB_task", offsetof_TINIB_task)$
+ 
+ $DEFINE_BIT("TCB_enatex", sizeof_TCB,"B")$
+ 
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_asm_config.tf ASPs/asp/arch/rx_gcc/rx_common/prc_asm_config.tf
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_asm_config.tf	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_asm_config.tf	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,13 ----
+ $
+ $     asm_config.inc 生成用
+ $     パス2のアーキテクチャ依存テンプレート（rx用）
+ $
+ 
+ $FILE "asm_config.inc"$
+ 
+ 
+ #define TIPM_LOCK $TAB$$TAB$ $TAB$ $+TIPM_LOCK$ $NL$
+ #define IPL_LOCK $TAB$$TAB$ $TAB$ $+IPL_LOCK$ $NL$
+ #define PSW_I_MASK $TAB$$TAB$ $TAB$ $+PSW_I_MASK$ $NL$
+ #define PSW_IPL_MASK $TAB$$TAB$ $TAB$ $+PSW_IPL_MASK$ $NL$
+ #define EXC_GET_PSW_OFFSET $TAB$$TAB$ $TAB$ $+EXC_GET_PSW_OFFSET$ $NL$
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_cfg1_out.h ASPs/asp/arch/rx_gcc/rx_common/prc_cfg1_out.h
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_cfg1_out.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_cfg1_out.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,49 ----
+ /*
+  *		cfg1_out.cのリンクに必要なスタブの定義
+  */
+ 
+ void sta_ker( void )
+ {
+ }
+ 
+ STK_T *const	_kernel_istkpt = 0x00;
+ 
+ void hardware_init_hook( void )
+ {
+ }
+ 
+ void software_init_hook( void )
+ {
+ }
+ 
+ const SIZE		_kernel_istksz = 0;
+ 
+ STK_T *const	_kernel_istk = NULL;
+ 
+ uint32_t *const _vvector_table = 0x00;
+ 
+ /* 
+  *  オフセットファイルを生成するための定義 
+  */ 
+ const uint8_t   MAGIC_1 = 0x12; 
+ const uint16_t  MAGIC_2 = 0x1234; 
+ const uint32_t  MAGIC_4 = 0x12345678;
+ 
+ const TCB	TCB_enatex = {
+ 	{ NULL, NULL },			/* task_queue */
+ 	NULL,					/* p_tinib */
+ 	0U,						/* tstat */
+ #ifdef TOPPERS_SUPPORT_MUTEX
+ 	0U,						/* bpriority */
+ #endif /* TOPPERS_SUPPORT_MUTEX */
+ 	0U,						/* priority */
+ 	false,					/* acqeue */
+ 	false,					/* wupque */
+ 	true,					/* enatex */
+ 	0U,						/* texprn */
+ 	NULL,					/* p_winifo */
+ #ifdef TOPPERS_SUPPORT_MUTEX
+ 	{ NULL, NULL },			/* mutex_queue */
+ #endif /* TOPPERS_SUPPORT_MUTEX */
+ 	{ NULL, NULL }			/* tskctxb */
+ };
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_check.tf ASPs/asp/arch/rx_gcc/rx_common/prc_check.tf
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_check.tf	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_check.tf	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,56 ----
+ $ 
+ $  TOPPERS/ASP Kernel
+ $      Toyohashi Open Platform for Embedded Real-Time Systems/
+ $      Advanced Standard Profile Kernel
+ $ 
+ $  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+ $  Copyright (C) 2015-  by Hisashi Hata, JAPAN
+ $ 
+ $  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ $  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ $  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ $  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ $      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ $      スコード中に含まれていること．
+ $  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ $      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ $      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ $      の無保証規定を掲載すること．
+ $  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ $      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ $      と．
+ $    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ $        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ $    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ $        報告すること．
+ $  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ $      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ $      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ $      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ $      免責すること．
+ $ 
+ $  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ $  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ $  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ $  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ $  の責任を負わない．
+ $ 
+ 
+ $ 
+ $ 		パス3のプロセッサ依存テンプレート（RX用）
+ $ 
+ 
+ $ 
+ $  チェック方法の指定
+ $ 
+ $CHECK_FUNC_ALIGN = 1$
+ $CHECK_FUNC_NONNULL = 1$
+ $CHECK_STACK_ALIGN = 4$
+ $CHECK_STACK_NONNULL = 1$
+ $CHECK_MPF_ALIGN = 4$
+ $CHECK_MPF_NONNULL = 1$
+ 
+ $ 
+ $  標準テンプレートファイルのインクルード
+ $ 
+ $INCLUDE "kernel/kernel_check.tf"$
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_config.c ASPs/asp/arch/rx_gcc/rx_common/prc_config.c
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_config.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_config.c	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,235 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
+  *              Graduate School of Information Science, Nagoya Univ., JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2015 by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation 
+  *  によって公表されている GNU General Public License の Version 2 に記
+  *  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
+  *  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+  *  利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
+  *  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
+  *  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		プロセッサ依存モジュール（RX610用）
+  */
+ 
+ #include "kernel_impl.h"
+ 
+ 
+ /*
+  *  割込み発生回数を保存する変数
+  */
+ uint16_t	intnest;
+ 
+ /*
+  *  CPUロックフラグ実現のための変数
+  */
+ #if TIPM_LOCK != -15
+ bool_t		lock_flag;		/* CPUロックフラグの値を保持する変数 */
+ uint32_t	saved_ipl;		/* 割込み優先度レベルを保存する変数 */
+ #endif	/* TIPM_LOCK != -15	*/
+ 
+ uint32_t	saved_psw;
+ /*
+  *  プロセッサ依存の初期化
+  */
+ void
+ prc_initialize( void )
+ {
+ 	/*
+ 	 *  割込み発生回数の初期化
+ 	 *
+ 	 *  スタートアップは全割込みロック状態 & 非タスクコンテキスト
+ 	 *  にて動作するため, 非タスクコンテキストに偽装する.
+ 	 */
+ 	intnest = 1U;
+ 
+ #if TIPM_LOCK != -15
+ 	/*
+ 	 *  CPUロックフラグ実現のための変数の初期化
+ 	 */
+ 	lock_flag = true;
+ 	saved_ipl = IPL_ENAALL;
+ #endif	/* TIPM_LOCK != -15	*/
+ }
+ 
+ 
+ /*
+  *  プロセッサ依存の終了処理
+  */
+ void
+ prc_terminate( void )
+ {
+ 	/*
+ 	 *  特に必要な処理はない
+ 	 */
+ }
+ 
+ 
+ /*
+  *  CPU例外の発生状況のログ出力
+  *
+  *  CPU例外ハンドラの中から，CPU例外情報ポインタ（p_excinf）を引数とし
+  *  て呼び出すことで，CPU例外の発生状況をシステムログに出力する．
+  */
+ #ifdef SUPPORT_XLOG_SYS
+ void
+ xlog_sys( void *p_excinf )
+ {
+ 	syslog(LOG_ERROR , "r1 = %u") , *((uint32_t*)((intptr_t)p_excinf + 14));
+ 	syslog(LOG_ERROR , "r2 = %u") , *((uint32_t*)((intptr_t)p_excinf + 15));
+ 	syslog(LOG_ERROR , "r3 = %u") , *((uint32_t*)((intptr_t)p_excinf + 16));
+ 	syslog(LOG_ERROR , "r4 = %u") , *((uint32_t*)((intptr_t)p_excinf + 17));
+ 	syslog(LOG_ERROR , "r5 = %u") , *((uint32_t*)((intptr_t)p_excinf + 18));
+ 	syslog(LOG_ERROR , "r6 = %u") , *((uint32_t*)((intptr_t)p_excinf + 1));
+ 	syslog(LOG_ERROR , "r7 = %u") , *((uint32_t*)((intptr_t)p_excinf + 2));
+ 	syslog(LOG_ERROR , "r8 = %u") , *((uint32_t*)((intptr_t)p_excinf + 3));
+ 	syslog(LOG_ERROR , "r9 = %u") , *((uint32_t*)((intptr_t)p_excinf + 4));
+ 	syslog(LOG_ERROR , "r10 = %u") , *((uint32_t*)((intptr_t)p_excinf + 5));
+ 	syslog(LOG_ERROR , "r11 = %u") , *((uint32_t*)((intptr_t)p_excinf + 6));
+ 	syslog(LOG_ERROR , "r12 = %u") , *((uint32_t*)((intptr_t)p_excinf + 7));
+ 	syslog(LOG_ERROR , "r13 = %u") , *((uint32_t*)((intptr_t)p_excinf + 8));
+ 	syslog(LOG_ERROR , "r14 = %u") , *((uint32_t*)((intptr_t)p_excinf + 12));
+ 	syslog(LOG_ERROR , "r15 = %u") , *((uint32_t*)((intptr_t)p_excinf + 13));
+ 	syslog(LOG_ERROR , "fpsw = %u") , *((uint32_t*)((intptr_t)p_excinf + 11));
+ 	syslog(LOG_ERROR , "acclo = %u") , *((uint32_t*)((intptr_t)p_excinf + 10));
+ 	syslog(LOG_ERROR , "acchi = %u") , *((uint32_t*)((intptr_t)p_excinf + 9));
+ 	syslog(LOG_ERROR , "pc = %x") , *((uint32_t*)((intptr_t)p_excinf + 19));
+ 	syslog(LOG_ERROR , "psw = %x") , *((uint32_t*)((intptr_t)p_excinf + 20));
+ }
+ #endif /* SUPPORT_XLOG_SYS */
+ 
+ 
+ /*
+  *  割込み要求ラインの属性の設定
+  *
+  *  ASPカーネルでの利用を想定して，パラメータエラーはアサーションでチェッ
+  *  クしている．cfg_intサービスコールを設ける場合には，エラーを返すよう
+  *  にすべきであろう．
+  */
+ void
+ x_config_int( INTNO intno, ATR intatr, PRI intpri )
+ {
+ 	uint8_t		irq_offset;
+ 	uint8_t		irq_val;
+ 
+ 	assert( VALID_INTNO_CFGINT(intno) );
+ 
+ 	assert( ( -15 <= intpri ) && ( intpri <= TMAX_INTPRI ) );
+ #if TIPM_LOCK != -15
+ 	if( intatr == TA_NONKERNEL ){
+ 		assert( intpri < TMIN_INTPRI );
+  	}
+ 	else{
+ 		assert( TMIN_INTPRI <= intpri ); 
+ 	}
+ #endif
+ 
+ 	/*
+ 	 *  割込みのマスク
+ 	 *
+ 	 *  割込みを受け付けたまま，レベルトリガ／エッジトリガの設定や，割
+ 	 *  込み優先度の設定を行うのは危険なため，割込み属性にかかわらず，
+ 	 *  一旦マスクする．
+ 	 */
+ 	( void )x_disable_int( intno );
+ 
+ 	/*
+ 	 *  レベルトリガ/エッジトリガの設定
+ 	 *
+ 	 *  IRQのみサポートする
+ 	 */
+ 	if( INTNO_IRQ( intno ) != 0U ){
+ 		irq_offset = INTNO_IRQ_OFFSET( intno );
+ 
+ 		if( ( intatr & TA_POSEDGE ) != 0U ){
+ 			irq_val = IRQ_POSEDGE;
+ 		}
+ 		else if( ( intatr & TA_NEGEDGE ) != 0U ){
+ 			irq_val = IRQ_NEGEDGE;
+ 		}
+ 		else if( ( intatr & TA_BOTHEDGE ) != 0U ){
+ 			irq_val = IRQ_BOTHEDGE;
+ 		}
+ 		else if( ( intatr & TA_LOWLEVEL ) != 0U ){
+ 			irq_val = IRQ_LOWLEVEL;
+ 		}
+ 		else{
+ 			/*
+ 			 *  コンフィギュレータにてチェックしているため,
+ 			 *  ここへくることはありえない.
+ 			 */
+ 			irq_val = 0U;
+ 		}
+ 
+ 		SET_ICU_IRQCR(irq_offset, irq_val);
+ 	}
+ 
+ 	/*
+ 	 *  割込みレベルの設定
+ 	 *
+ 	 *  割込み番号に対応したIPR値を設定する.
+ 	 */
+     set_icu_ipr(intno, cfg_int_table[intno].intpri);
+ 
+ 	/*
+ 	 *  割込みのマスク解除
+  	 */
+ 	if( ( intatr & TA_ENAINT ) != 0U ){
+ 		( void )x_enable_int( intno );
+ 	}
+ }
+ 
+ 
+ #ifndef OMIT_DEFAULT_INT_HANDLER
+ /*
+  *  未登録の割込みが発生した場合に呼び出される
+  */
+ void
+ default_int_handler( uint32_t intno )
+ {
+   syslog(LOG_EMERG, "Unregistered Interrupt occurs. No %d", intno);
+ }
+ #endif /* OMIT_DEFAULT_INT_HANDLER */
+ 
+ #ifndef OMIT_DEFAULT_EXC_HANDLER
+ /*
+  *  未登録の例外が発生した場合に呼び出される
+  */
+ void
+ default_exc_handler( void )
+ {
+ 	syslog(LOG_EMERG, "Unregistered Expevt error occurs.");
+ }
+ #endif /* OMIT_DEFAULT_EXC_HANDLER */
+ 
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_config.h ASPs/asp/arch/rx_gcc/rx_common/prc_config.h
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_config.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_config.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,700 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
+  *              Graduate School of Information Science, Nagoya Univ., JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 205 by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation 
+  *  によって公表されている GNU General Public License の Version 2 に記
+  *  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
+  *  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+  *  利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
+  *  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
+  *  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		プロセッサ依存モジュール（RX用）
+  *
+  *  このインクルードファイルは，target_config.h（または，そこからインク
+  *  ルードされるファイル）のみからインクルードされる．他のファイルから
+  *  直接インクルードしてはならない．
+  */
+ 
+ #ifndef TOPPERS_PRC_CONFIG_H
+ #define TOPPERS_PRC_CONFIG_H
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  プロセッサの特殊命令のインライン関数定義
+  */
+ #include "prc_insn.h"
+ 
+ /*
+  *  非タスクコンテキスト用のスタック初期値
+  */
+ 
+ #define TOPPERS_ISTKPT( istk, istksz ) (( STK_T * )(( char * )( istk ) + ( istksz )))
+ 
+ 
+ /*
+  *  タスクコンテキストブロックの定義
+  */
+ typedef struct task_context_block {
+ 	void	*sp;		/* スタックポインタ */
+ 	FP		pc;			/* プログラムカウンタ */
+ } TSKCTXB;
+ 
+ 
+ /*
+  *  割込み発生回数を保存する変数
+  */
+ extern uint16_t intnest;
+ 
+ 
+ /*
+  *  CPUロック状態での割込み優先度マスク
+  *
+  *  TIPM_LOCKは，CPUロック状態での割込み優先度マスク，すなわち，カーネ
+  *  ル管理外のものを除くすべての割込み要求をマスクする値に定義する．
+  *
+  *  TMIN_INTPRI変更することで管理外割込みの有無を決定する．
+  *  例えばTMIN_INTPRIを-14に設定すると，レベル15の割込みがカーネル管理外と
+  *  なる．TMIN_INTPRIを-15に設定すると，NMI以外にカーネル管理外の割込みを
+  *  設けないことになる（この場合には-15に設定することを推奨する）．
+  */
+ #ifndef TIPM_LOCK
+ #define TIPM_LOCK	TMIN_INTPRI
+ #endif /* TIPM_LOCK */
+ 
+ 
+ /*
+  *  TOPPERS標準割込み処理モデルの実現
+  */
+ /*
+  *  コンテキストの参照
+  *
+  *  RXでは，割込みの戻り先がタスクかどうかを判断するために intnest
+  *  を使用している．これを用いてコンテキストを判断する．
+  */
+ Inline bool_t
+ sense_context( void )
+ {
+ 	/*  ネストカウンタ0より大なら非タスクコンテキスト  */
+ 	return ( intnest > 0U );
+ }
+ 
+ 
+ /*
+  *  CPUロックフラグ実現のための変数
+  *
+  *  これらの変数は，CPUロック状態の時のみ書き換えてよいものとする．
+  */
+ #if TIPM_LOCK != -15
+ extern bool_t	lock_flag;		/* CPUロックフラグの値を保持する変数 */
+ extern uint32_t	saved_ipl;		/* 割込み優先度レベルを保存する変数 */
+ #endif	/* TIPM_LOCK != -15	*/
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ 
+ 
+ /*
+  *  割込み優先度マスクの外部表現と内部表現の変換
+  *
+  *  RX610では，プロセッサステータスワードレジスタ（PSW）の下から
+  *  24〜26ビット目の3ビットに割込み優先度レベル（IPL）が置かれている．
+  *  カーネル管理外割込みを実装する場合にIPLを使用した制御を行う．
+  *  カーネルは割込み優先度マスク（-1から連続した負の値）で管理されて
+  *  いるためIPLとの変換が必要となる．
+  */
+ #define IPL_TO_IPM( ipl )	(-(( PRI )(( ipl ) >> 24U )))		/* IPLをIPMに	*/
+ #define IPM_TO_IPL( ipm )	((( uint32_t )(-( ipm ))) << 24U )	/* IPMをIPLに	*/
+ 
+ 
+ /*
+  *  CPUロック状態での割込み優先度マスクのIPL
+  */
+ #define IPL_LOCK		( IPM_TO_IPL( TIPM_LOCK ) )
+ 
+ /*
+  *  TIPM_ENAALL（割込み優先度マスク全解除）のIPL
+  */
+ #define IPL_ENAALL		( IPM_TO_IPL( TIPM_ENAALL ) )
+ 
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  割込み要因毎のレベル & 属性定義テーブル
+  *  (テンプレートファイルによる出力)
+  */
+ typedef struct cfg_int_info {
+ 	PRI		intpri;
+ 	ATR		intatr;
+ } CFG_INT_INFO;
+ 
+ extern const CFG_INT_INFO cfg_int_table[];
+ 
+ 
+ /*
+  *  割込み番号の範囲の判定
+  *
+  *  割込み番号が有効な値か厳密にチェックするため,
+  *  コンフィギュレータ出力テーブルを参照する.
+  */
+ #define VALID_INTNO( intno )	\
+  				( cfg_int_table[( intno )].intpri > 0 )
+ #define VALID_INTNO_DISINT( intno )	VALID_INTNO( intno )
+ #define VALID_INTNO_CFGINT( intno )	VALID_INTNO( intno )
+ 
+ 
+ /*
+  *  割込み制御レジスタ関連の定義
+  */
+ #define	IRQ_POSEDGE			( 0x08U )
+ #define	IRQ_NEGEDGE			( 0x04U )
+ #define	IRQ_BOTHEDGE		( 0x0CU )
+ #define	IRQ_LOWLEVEL		( 0x00U )
+ 
+ 
+ /*
+  *  CPUロック状態への移行
+  *
+  *  IPM（ハードウェアの割込み優先度マスク）を，saved_iipmに保存し，カー
+  *  ネル管理外のものを除くすべての割込み要求をマスクする値（TIPM_LOCK）
+  *  に設定する．また，lock_flagをTRUEにする．
+  *
+  *  IPMが，最初からTIPM_LOCKと同じかそれより高い場合には，それを
+  *  saved_iipmに保存するのみで，TIPM_LOCKには設定しない．これは，モデル
+  *  上の割込み優先度マスクが，TIPM_LOCKと同じかそれより高いレベルに設定
+  *  されている状態にあたる．
+  *
+  *  この関数は，CPUロック状態（lock_flagがTRUEの状態）で呼ばれることは
+  *  ないものと想定している．
+  */
+ Inline void
+ x_lock_cpu( void )
+ {
+ #if TIPM_LOCK == -15
+ 	disint();
+ #else	/* TIPM_LOCK == -15	*/
+ 	uint32_t	ipl;
+ 
+ 	/*
+ 	 *  current_ipl()の返り値を直接saved_iplに保存せず，一時変数ipl
+ 	 *  を用いているのは，current_ipl()を呼んだ直後に割込みが発生し，
+ 	 *  起動された割込み処理でsaved_iplが変更される可能性があるためで
+ 	 *  ある．
+ 	 */
+ 	ipl = current_ipl();
+ 	if( IPL_LOCK > ipl ){
+ 		set_ipl( IPL_LOCK );
+ 	}
+ 
+ 	saved_ipl = ipl;
+ 	lock_flag = true;
+ #endif	/* TIPM_LOCK == -15	*/
+ }
+ 
+ #define t_lock_cpu()	x_lock_cpu()
+ #define i_lock_cpu()	x_lock_cpu()
+ 
+ 
+ /*
+  *  CPUロック状態の解除
+  *
+  *  lock_flagをFALSEにし，IPM（ハードウェアの割込み優先度マスク）を，
+  *  saved_iipmに保存した値に戻す．
+  *
+  *  この関数は，CPUロック状態（lock_flagがtrueの状態）でのみ呼ばれるも
+  *  のと想定している．
+  */
+ Inline void
+ x_unlock_cpu( void )
+ {
+ #if TIPM_LOCK == -15
+ 	enaint();
+ #else	/* TIPM_LOCK == -15	*/
+ 	lock_flag = false;
+ 	set_ipl( saved_ipl );
+ #endif	/* TIPM_LOCK == -15	*/
+ }
+ 
+ #define t_unlock_cpu()	x_unlock_cpu()
+ #define i_unlock_cpu()	x_unlock_cpu()
+ 
+ 
+ /*
+  *  CPUロック状態の参照
+  */
+ Inline bool_t
+ x_sense_lock( void )
+ {
+ #if TIPM_LOCK == -15
+ 	return (( bool_t )(( current_psw() & PSW_I_MASK) == 0 ));
+ #else	/* TIPM_LOCK == -15	*/
+ 	return lock_flag;
+ #endif	/* TIPM_LOCK == -15	*/
+ }
+ 
+ #define t_sense_lock()	x_sense_lock()
+ #define i_sense_lock()	x_sense_lock()
+ 
+ 
+ /*
+  * （モデル上の）割込み優先度マスクの設定
+  *
+  *  CPUロックフラグがクリアされている時は，ハードウェアの割込み優先度マ
+  *  スクを設定する．CPUロックフラグがセットされている時は，saved_iipm
+  *  を設定し，さらに，ハードウェアの割込み優先度マスクを，設定しようと
+  *  した（モデル上の）割込み優先度マスクとTIPM_LOCKの高い方に設定する．
+  */
+ Inline void
+ x_set_ipm( PRI intpri )
+ {
+ 	uint32_t	ipl = IPM_TO_IPL( intpri );
+ #if TIPM_LOCK == -15
+ 	set_ipl(ipl);
+ #else	/* TIPM_LOCK == -15	*/
+ 	if( !lock_flag ){
+ 		set_ipl(ipl);
+ 	}
+ 	else {
+ 		saved_ipl = ipl;
+ 		set_ipl(ipl > IPL_LOCK ? ipl : IPL_LOCK);
+     }
+ #endif	/* TIPM_LOCK == -15	*/
+ }
+ 
+ #define t_set_ipm( intpri )	x_set_ipm( intpri )
+ #define i_set_ipm( intpri )	x_set_ipm( intpri )
+ 
+ 
+ /*
+  * （モデル上の）割込み優先度マスクの参照
+  *
+  *  CPUロックフラグがクリアされている時はハードウェアの割込み優先度マ
+  *  スクを，セットされている時はsaved_iipmを参照する．
+  */
+ Inline PRI
+ x_get_ipm( void )
+ {
+ 	uint32_t	ipl;
+ #if TIPM_LOCK == -15
+ 	ipl = current_ipl();
+ #else	/* TIPM_LOCK == -15	*/
+ 	if (!lock_flag) {
+ 		ipl = current_ipl();
+ 	}
+ 	else {
+ 		ipl = saved_ipl;
+ 	}
+ #endif	/* TIPM_LOCK == -15	*/
+ 	return IPL_TO_IPM( ipl );
+ }
+ 
+ #define t_get_ipm()		x_get_ipm()
+ #define i_get_ipm()		x_get_ipm()
+ 
+ 
+ /*
+  *  割込み要求禁止フラグのセット
+  *
+  *  割込み属性が設定されていない割込み要求ラインに対して割込み要求禁止
+  *  フラグをセットしようとした場合には，FALSEを返す．
+  */
+ Inline bool_t
+ x_disable_int( INTNO intno )
+ {
+ 	/*
+ 	 *  レベル定義が0である場合はCFG_INTされていない
+ 	 */
+ 	if( cfg_int_table[intno].intpri == 0 ){
+ 		return ( false );
+ 	}
+ 
+     *((volatile uint8_t *)(ICU_IER_BASE+(intno>>3))) &= ~(1 << (intno & 0x7));
+ 
+ 	return ( true );
+ }
+ 
+ #define t_disable_int( intno )	x_disable_int( intno )
+ #define i_disable_int( intno )	x_disable_int( intno )
+ 
+ 
+ /*
+  *  割込み要求禁止フラグのクリア
+  *
+  *  割込み属性が設定されていない割込み要求ラインに対して割込み要求禁止
+  *  フラグをクリアしようとした場合には，FALSEを返す．
+  */
+ Inline bool_t
+ x_enable_int( INTNO intno )
+ {
+ 	/*
+ 	 *  レベル定義が0である場合はCFG_INTされていない
+ 	 */
+ 	if( cfg_int_table[intno].intpri == 0 ){
+ 		return ( false );
+ 	}
+ 
+     *((volatile uint8_t *)(ICU_IER_BASE+(intno>>3))) |= (1 << (intno & 0x7));
+ 
+ 	return ( true );
+ }
+ 
+ #define t_enable_int( intno )	x_enable_int( intno )
+ #define i_enable_int( intno )	x_enable_int( intno )
+ 
+ 
+ /*
+  *  割込み要求のクリア
+  */
+ Inline void
+ x_clear_int( INTNO intno )
+ {
+   *((volatile uint8_t *)(ICU_IR_BASE + intno)) = 0U;
+ }
+ 
+ #define t_clear_int( intno )	x_clear_int( intno )
+ #define i_clear_int( intno )	x_clear_int( intno )
+ 
+ 
+ /*
+  *  割込み要求のチェック
+  */
+ Inline bool_t
+ x_probe_int( INTNO intno )
+ {
+ 	/*
+ 	 *  割込み要求レジスタは0 or 1でしかないため,
+ 	 *  そのままの値を返す.
+ 	 */
+ 	return ( *((volatile uint8_t *)(ICU_IR_BASE + intno)) );
+ }
+ 
+ #define t_probe_int( intno )	x_probe_int( intno )
+ #define i_probe_int( intno )	x_probe_int( intno )
+ 
+ 
+ /*
+  *  割込み要求ラインの属性の設定
+  */
+ extern void	x_config_int( INTNO intno, ATR intatr, PRI intpri );
+ 
+ 
+ /*
+  *  割込みハンドラの入口で必要なIRC操作
+  *
+  */
+ Inline void
+ i_begin_int( INTNO intno )
+ {
+ 	volatile uint8_t	reg;
+ 
+ 	/*
+ 	 *  レベル検出の割込みに対しては割込みステータス
+ 	 *  フラグをクリアする.
+ 	 */
+ 	if( ( cfg_int_table[intno].intatr & TA_LOWLEVEL ) > 0 ){
+ 		if( *((volatile uint8_t *)(ICU_IR_BASE + intno)) > 0U ){
+ 			/*
+ 			 *  外部割込みの場合, IRQ端子がHighに戻っている
+ 			 *  ことを確認する旨が記載されているが, 省略する.
+ 			 */
+ 			*((volatile uint8_t *)(ICU_IR_BASE + intno)) = 0U;
+ 
+ 			/*
+ 			 *  ハードウェアマニュアルに0になったことを
+ 			 *  確認する旨が記載あるため, レジスタ値を読み出す.
+ 			 */
+ 			reg = *((volatile uint8_t *)(ICU_IR_BASE + intno));
+ 		}
+ 	}
+ }
+ 
+ 
+ /*
+  *  割込みハンドラの出口で必要なIRC操作
+  *
+  */
+ Inline void
+ i_end_int( INTNO intno )
+ {
+ 	/* 特に行うべき処理はない */
+ }
+ 
+ 
+ /*
+  *  最高優先順位タスクへのディスパッチ（prc_support.a30）
+  *
+  *  dispatchは，タスクコンテキストから呼び出されたサービスコール処理か
+  *  ら呼び出すべきもので，タスクコンテキスト・CPUロック状態・ディスパッ
+  *  チ許可状態・（モデル上の）割込み優先度マスク全解除状態で呼び出さな
+  *  ければならない．
+  */
+ extern void	dispatch( void );
+ 
+ /*
+  *  ディスパッチャの動作開始（prc_support.a30）
+  *
+  *  start_dispatchは，カーネル起動時に呼び出すべきもので，すべての割込
+  *  みを禁止した状態（全割込みロック状態と同等の状態）で呼び出さなければ
+  *  ならない．
+  */
+ extern void	start_dispatch( void ) NoReturn;
+ 
+ /*
+  *  現在のコンテキストを捨ててディスパッチ（prc_support.a30）
+  *
+  *  exit_and_dispatchは，ext_tskから呼び出すべきもので，タスクコンテキ
+  *  スト・CPUロック状態・ディスパッチ許可状態・（モデル上の）割込み優先
+  *  度マスク全解除状態で呼び出さなければならない．
+  */
+ #define _kernel_exit_and_dispatch();	\
+ 	_exit_and_dispatch();		\
+ 	ercd = E_SYS;
+ 
+ extern void	_exit_and_dispatch( void ) NoReturn;
+ 
+ /*
+  *  カーネルの終了処理の呼出し（prc_support.a30）
+  *
+  *  call_exit_kernelは，カーネルの終了時に呼び出すべきもので，非タスク
+  *  コンテキストに切り換えて，カーネルの終了処理（exit_kernel）を呼び出
+  *  す．
+  */
+ extern void call_exit_kernel( void ) NoReturn;
+ 
+ /*
+  *  タスクコンテキストの初期化
+  *
+  *  タスクが休止状態から実行できる状態に移行する時に呼ばれる．この時点
+  *  でスタック領域を使ってはならない．
+  *
+  *  activate_contextを，インライン関数ではなくマクロ定義としているのは，
+  *  この時点ではTCBが定義されていないためである．
+  */
+ extern void	start_r( void );
+ 
+ #define activate_context( p_tcb )														\
+ {																						\
+ 	{																					\
+ 																						\
+ 		/*  スタックポインタ初期値の設定  */											\
+ 		( p_tcb )->tskctxb.sp = ( void * )((( uint32_t ) ( p_tcb )->p_tinib->stk ) + 	\
+ 								( p_tcb )->p_tinib->stksz );							\
+ 		/* 起動番地の設定 */															\
+ 		( p_tcb )->tskctxb.pc = ( FP ) start_r;											\
+ 	}																					\
+ }
+ 
+ 
+ /*
+  *  calltexは使用しない
+  */
+ #define OMIT_CALLTEX
+ 
+ 
+ /*
+  *  割込みハンドラの設定
+  *
+  *  RX610はROMに割込みベクタを配置するため，本関数は空関数で実装する．
+  */
+ Inline void
+ x_define_inh( INHNO inhno, FP inthdr )
+ {
+ }
+ 
+ 
+ /*
+  *  CPU例外ハンドラの設定
+  *
+  *  RX610はROMに例外ベクタを配置するため，本関数は空関数で実装する．
+  */
+ Inline void
+ x_define_exc( EXCNO excno, FP exchdr )
+ {
+ }
+ 
+ 
+ /*
+  *  割込み/例外ハンドラの入口処理の生成マクロ
+  *
+  *  テンプレートファイルにより生成するため空マクロとする．
+  */
+ #define HDR_ENTRY(hdr, intexc_num , tobejmp)
+ 
+ /*
+  *  割込みハンドラの入口処理の生成マクロ
+  */
+ #define _INT_ENTRY(inhno, inthdr)				_kernel_##inthdr##_##inhno##_entry
+ #define INT_ENTRY(inhno, inthdr)				_INT_ENTRY(inhno , inthdr)
+ 
+ #define _INTHDR_ENTRY(inhno, inhno_num ,inthdr)	\
+ 		extern void _kernel_##inthdr##_##inhno##_entry(void);
+ #define INTHDR_ENTRY(inhno, inhno_num ,inthdr)	_INTHDR_ENTRY(inhno, inhno_num ,inthdr)
+ 
+ 
+ /*
+  *  CPU例外ハンドラの入口処理の生成マクロ
+  */
+ #define _EXC_ENTRY(excno , exchdr)					_kernel_##exchdr##_##excno##_entry
+ #define EXC_ENTRY(excno , exchdr)					_EXC_ENTRY(excno , exchdr)
+ 
+ #define _EXCHDR_ENTRY(excno , excno_num , exchdr)	\
+ 		extern _kernel_##exchdr##_##excno##_entry(void);
+ #define EXCHDR_ENTRY(excno , excno_num , exchdr)	_EXCHDR_ENTRY(excno , excno_num , exchdr)
+ 
+ 
+ /*
+  *  CPU例外の発生した時のコンテキストの参照
+  *
+  *  CPU例外の発生した時のコンテキストが，タスクコンテキストの時にFALSE，
+  *  そうでない時にtrueを返す．
+  */
+ Inline bool_t
+ exc_sense_context( void *p_excinf )
+ {
+ 	/* 
+ 	 *  ネストカウンタが1より大なら非タスクコンテキスト
+ 	 */
+ 	return( intnest > 1U );
+ }
+ 
+ 
+ /*
+  *  CPU例外情報 p_excinf から PSW の値を取得するためのオフセット値
+  *  EXCNO + ACC + FPSW + R1〜R15 + PC
+  */
+ #define EXC_GET_PSW_OFFSET	(4+8+4+60+4)
+ 
+ /*
+  *  CPU例外の発生した時のIPLの参照
+  */
+ Inline uint32_t
+ exc_get_ipl(void *p_excinf)
+ {
+ 	return((*((uint32_t *)((uintptr_t)p_excinf+EXC_GET_PSW_OFFSET)))
+ 			& PSW_IPL_MASK);
+ }
+ 
+ Inline bool_t
+ exc_sense_i(void *p_excinf)
+ {
+ 	return((*(((uint32_t *)((uintptr_t)p_excinf+EXC_GET_PSW_OFFSET)))
+ 			 & PSW_I_MASK) != 0u);
+ }
+ 
+ 
+ /*
+  *  CPU例外の発生した時のコンテキストと割込みのマスク状態の参照
+  *
+  *  CPU例外の発生した時のシステム状態が，カーネル実行中でなく，タスクコ
+  *  ンテキストであり，全割込みロック状態でなく，CPUロック状態でなく，（モ
+  *  デル上の）割込み優先度マスク全解除状態である時にtrue，そうでない時
+  *  にFALSEを返す（CPU例外がカーネル管理外の割込み処理中で発生した場合
+  *  にもFALSEを返す）．
+  *  
+  *  カーネル実行中でない→ (TIPM_LOCK== -15) Iフラグ == 1
+  *                         (else)           IPL < IPL_LOCK
+  *  タスクコンテキストである→intnest == 0
+  *  全割込みロックでない→ Iフラグ == 1
+  *  割込み優先度マスクが全解除→IPL == 0
+  *  
+  *  
+  */
+ Inline bool_t
+ exc_sense_intmask(void *p_excinf)
+ {
+ 	return((!exc_sense_context(p_excinf))
+ 			&& exc_sense_i(p_excinf)
+ 			&& (exc_get_ipl(p_excinf) == IPL_ENAALL));
+ }
+ 
+ /*
+  *  CPU例外の発生した時のコンテキストと割込み／CPUロック状態の参照
+  *
+  *  CPU例外の発生した時のシステム状態が，カーネル実行中でなく，タスクコ
+  *  ンテキストであり，全割込みロック状態でなく，CPUロック状態でない時に
+  *  true，そうでない時にfalseを返す（CPU例外がカーネル管理外の割込み処
+  *  理中で発生した場合にもfalseを返す）．
+  *  
+  *  カーネル実行中でない→ (TIPM_LOCK== -15) Iフラグ == 1
+  *                         (else)           IPL < TIPM_LOCK
+  *  タスクコンテキストである→intnest < 1 
+  *  全割込みロックでない→ Iフラグ == 1
+  *  CPUロック状態でない→(TIPM_LOCK== -15) Iフラグ == 1
+  *                         (else)           IPL < TIPM_LOCK
+  */
+ Inline bool_t
+ exc_sense_unlock(void *p_excinf)
+ {
+ #if TIPM_LOCK == -15
+ 	return((!exc_sense_context(p_excinf))
+ 			&& exc_sense_i(p_excinf));
+ #else
+ 	return((!exc_sense_context(p_excinf))
+ 			&& exc_sense_i(p_excinf)
+ 			&& exc_get_ipl(p_excinf) < IPL_LOCK);
+ #endif
+ }
+ 
+ 
+ /*
+  *  プロセッサ依存の初期化
+  */
+ extern void	prc_initialize( void );
+ 
+ /*
+  *  プロセッサ依存の終了時処理
+  */
+ extern void	prc_terminate( void );
+ 
+ 
+ #ifndef OMIT_DEFAULT_INT_HANDLER
+ /*
+  *  未登録の割込みが発生した場合に呼び出される
+  */
+ void default_int_handler( uint32_t intno );
+ #endif /* OMIT_DEFAULT_INT_HANDLER */
+ 
+ #ifndef OMIT_DEFAULT_EXC_HANDLER
+ /*
+  *  未登録の例外が発生した場合に呼び出される
+  */
+ void default_exc_handler( void );
+ #endif /* OMIT_DEFAULT_EXC_HANDLER */
+ 
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ 
+ #endif /* TOPPERS_PRC_CONFIG_H */
+ 
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_def.csv ASPs/asp/arch/rx_gcc/rx_common/prc_def.csv
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_def.csv	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_def.csv	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,13 ----
+ TA_LOWLEVEL,TA_LOWLEVEL
+ TA_BOTHEDGE,TA_BOTHEDGE
+ TA_NEGEDGE,TA_NEGEDGE
+ TIPM_LOCK,TIPM_LOCK,signed
+ IPL_LOCK,IPL_LOCK
+ PSW_I_MASK,PSW_I_MASK
+ PSW_IPL_MASK,PSW_IPL_MASK
+ EXC_GET_PSW_OFFSET,EXC_GET_PSW_OFFSET
+ sizeof_TCB,sizeof(TCB)
+ offsetof_TCB_p_tinib,"offsetof(TCB,p_tinib)"
+ offsetof_TCB_texptn,"offsetof(TCB,texptn)"
+ offsetof_TCB_sp,"offsetof(TCB,tskctxb.sp)"
+ offsetof_TCB_pc,"offsetof(TCB,tskctxb.pc)"
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_insn.h ASPs/asp/arch/rx_gcc/rx_common/prc_insn.h
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_insn.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_insn.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,150 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
+  *              Graduate School of Information Science, Nagoya Univ., JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2015 by Hisashi Hata, JAPAN
+  *
+  *  上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation
+  *  によって公表されている GNU General Public License の Version 2 に記
+  *  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
+  *  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+  *  利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
+  *  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
+  *  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
+  *
+  */
+ 
+ /*
+  *		プロセッサの特殊命令のインライン関数定義（RX用）
+  */
+ 
+ #ifndef	TOPPERS_PRC_INSN_H
+ #define	TOPPERS_PRC_INSN_H
+ 
+ 
+ static uint32_t current_psw( void );
+ static void set_psw( uint32_t psw );
+ Inline uint32_t current_ipl( void );
+ Inline void set_ipl( uint32_t ipl );
+ static void disint( void );
+ static void enaint( void );
+ static uint16_t rev_endian_uint16( uint16_t data );
+ static uint32_t rev_endian_uint32( uint32_t data );
+ 
+ 
+ /*
+  *  Iフラグ, IPLを取得するためのマクロ定義
+  */
+ #define PSW_I_MASK		( 0x00010000UL )
+ #define PSW_IPL_MASK	( 0x0F000000UL )
+ 
+ 
+ /*
+  *  プロセッサステータスレジスタ(PSW)の現在値の読出し
+  */
+ static uint32_t
+ current_psw( void )
+ {
+   uint32_t load_psw;
+   __asm__("mvfc	psw, %0" : "=r"(load_psw) :);
+   return load_psw;
+ }
+ 
+ 
+ /*
+  *  プロセッサステータスレジスタ(PSW)へ設定
+  */
+ static void
+ set_psw( uint32_t psw )
+ {
+   __asm__("mvtc	%0, psw"::"r"(psw));
+ }
+ 
+ 
+ /*
+  *  IPLの現在値の読出し
+  */
+ Inline uint32_t
+ current_ipl( void )
+ {
+ 	return ( uint32_t )( current_psw() & PSW_IPL_MASK );
+ }
+ 
+ 
+ /*
+  *  IPLへ設定
+  */
+ Inline void
+ set_ipl( uint32_t ipl )
+ {
+ 	set_psw( ( current_psw() & ( ~PSW_IPL_MASK ) ) | ipl );
+ }
+ 
+ 
+ /*
+  *  NMIを除くすべての割込みの禁止
+  */
+ static void
+ disint( void )
+ {
+   __asm__("clrpsw	I");
+ }
+ 
+ 
+ /*
+  *  NMIを除くすべての割込みの許可
+  */
+ static void
+ enaint( void )
+ {
+   __asm__("setpsw	I");
+ }
+ 
+ 
+ /*
+  *  エンディアン変換 16bit
+  */
+ static uint16_t
+ rev_endian_uint16( uint16_t data )
+ {
+   __asm__("revw	%0, %1":"=r"(data):"r"(data));
+   return data;
+ }
+ 
+ /*
+  *  エンディアン変換 32bit
+  */
+ static uint32_t
+ rev_endian_uint32( uint32_t data )
+ {
+   __asm__("revl	%1, %0":"=r"(data):"r"(data));
+   return data;
+ }
+ 
+ 
+ #endif /* TOPPERS_PRC_INSN_H */
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_kernel.h ASPs/asp/arch/rx_gcc/rx_common/prc_kernel.h
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_kernel.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_kernel.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,92 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2015- by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		kernel.hのプロセッサ依存部（RX用）
+  *
+  *  このインクルードファイルは，target_kernel.h（または，そこからインク
+  *  ルードされるファイル）のみからインクルードされる．他のファイルから
+  *  直接インクルードしてはならない．
+  */
+ 
+ #ifndef TOPPERS_PRC_KERNEL_H
+ #define TOPPERS_PRC_KERNEL_H
+ 
+ /*
+  *  サポートする機能の定義
+  */
+ #define TOPPERS_TARGET_SUPPORT_DIS_INT		/* dis_intをサポートする */
+ #define TOPPERS_TARGET_SUPPORT_ENA_INT		/* ena_intをサポートする */
+ 
+ 
+ /*
+  *  カーネル管理の割込み優先度の範囲
+  *
+  *  TMIN_INTPRIの定義を変更することで，どのレベルよりも高い割込み優先度
+  *  を持つものをカーネル管理外の割込みとするかを変更できる．
+  *
+  *  TMIN_INTPRIに設定できる値は，-15〜-1の範囲である．例えばTMIN_INTPRI
+  *  を-14に設定すると，NMIに加えてレベル15の割込みがカーネル管理外となる．
+  *  TMIN_INTPRIを-7に設定すると，NMI以外にカーネル管理外の割込みを
+  *  設けないことになる．
+  */
+ #ifndef TMIN_INTPRI
+ #define TMIN_INTPRI		( -15 )		/* 割込み優先度の最小値（最高値）*/
+ #endif /* TMIN_INTPRI */
+ #define TMAX_INTPRI		( -1 )		/* 割込み優先度の最大値（最低値） */
+ 
+ 
+ /*
+  *  割込み属性の定義
+  */
+ #define	TA_POSEDGE		TA_EDGE			/* ポジティブエッジトリガ */
+ #define	TA_NEGEDGE		UINT_C( 0x04 )	/* ネガティブエッジトリガ */
+ #define	TA_BOTHEDGE		UINT_C( 0x08 )	/* 両エッジトリガ */
+ 
+ #define	TA_LOWLEVEL		UINT_C( 0x10 )	/* Lレベル */
+ 
+ 
+ /*
+  *  デフォルトの割込み/例外ハンドラの有無
+  */
+ /*#define	OMIT_DEFAULT_INT_HANDLER*/
+ /*#define	OMIT_DEFAULT_EXC_HANDLER*/
+ 
+ 
+ #endif /* TOPPERS_PRC_KERNEL_H */
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_rename.def ASPs/asp/arch/rx_gcc/rx_common/prc_rename.def
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_rename.def	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_rename.def	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,21 ----
+ # prc_config.c
+ intnest
+ lock_flag
+ saved_ipl
+ prc_initialize
+ prc_terminate
+ x_config_int
+ default_int_handler
+ default_exc_handler
+ 
+ # prc_support.src
+ dispatch
+ start_dispatch
+ exit_and_dispatch
+ call_exit_kernel
+ start_r
+ interrupt
+ exception
+ 
+ # kernel_cfg.c
+ cfg_int_table
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_rename.h ASPs/asp/arch/rx_gcc/rx_common/prc_rename.h
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_rename.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_rename.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,79 ----
+ /* This file is generated from prc_rename.def by genrename. */
+ 
+ #ifndef TOPPERS_PRC_RENAME_H
+ #define TOPPERS_PRC_RENAME_H
+ 
+ /*
+  *  prc_config.c
+  */
+ #define intnest						_kernel_intnest
+ #define lock_flag					_kernel_lock_flag
+ #define saved_ipl					_kernel_saved_ipl
+ #define saved_psw					_kernel_saved_psw
+ #define prc_initialize				_kernel_prc_initialize
+ #define prc_terminate				_kernel_prc_terminate
+ #define x_config_int				_kernel_x_config_int
+ #define default_int_handler			_kernel_default_int_handler
+ #define default_exc_handler			_kernel_default_exc_handler
+ 
+ /*
+  *  prc_support.src
+  */
+ #define dispatch					_kernel_dispatch
+ #define start_dispatch				_kernel_start_dispatch
+ #define exit_and_dispatch			_kernel_exit_and_dispatch
+ #define call_exit_kernel			_kernel_call_exit_kernel
+ #define start_r						_kernel_start_r
+ #define interrupt					_kernel_interrupt
+ #define exception					_kernel_exception
+ 
+ /*
+  *  kernel_cfg.c
+  */
+ #define cfg_int_table				_kernel_cfg_int_table
+ 
+ #ifdef TOPPERS_LABEL_ASM
+ 
+ /*
+  *  prc_config.c
+  */
+ #define _intnest					__kernel_intnest
+ #define _lock_flag					__kernel_lock_flag
+ #define _saved_ipl					__kernel_saved_ipl
+ #define _saved_psw					__kernel_saved_psw
+ 
+ #define _prc_initialize				__kernel_prc_initialize
+ #define _prc_terminate				__kernel_prc_terminate
+ #define _x_config_int				__kernel_x_config_int
+ #define _default_int_handler		__kernel_default_int_handler
+ #define _default_exc_handler		__kernel_default_exc_handler
+ 
+ /*
+  *  prc_support.src
+  */
+ #define _dispatch					__kernel_dispatch
+ #define _start_dispatch				__kernel_start_dispatch
+ #define _exit_and_dispatch			__kernel_exit_and_dispatch
+ #define _call_exit_kernel			__kernel_call_exit_kernel
+ #define _start_r					__kernel_start_r
+ #define _interrupt					__kernel_interrupt
+ #define _exception					__kernel_exception
+ 
+ 
+ /*
+  *  rx63n_config.c
+  */
+ #define _ipr_reg_addr				__kernel_ipr_reg_addr
+ #define _ier_reg_addr				__kernel_ier_reg_addr
+ #define _ir_reg_addr				__kernel_ir_reg_addr
+ #define _irqcr_reg_addr				__kernel_irqcr_reg_addr
+ 
+ /*
+  *  kernel_cfg.c
+  */
+ #define _cfg_int_table				__kernel_cfg_int_table
+ 
+ #endif /* TOPPERS_LABEL_ASM */
+ 
+ 
+ #endif /* TOPPERS_PRC_RENAME_H */
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_sil.h ASPs/asp/arch/rx_gcc/rx_common/prc_sil.h
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_sil.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_sil.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,112 ----
+ /*
+  *  TOPPERS Software
+  *      Toyohashi Open Platform for Embedded Real-Time Systems
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2015 by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		sil.hのプロセッサ依存部（RX用）
+  */
+ 
+ #ifndef TOPPERS_PRC_SIL_H
+ #define TOPPERS_PRC_SIL_H
+ 
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ #include "prc_insn.h"
+ 
+ 
+ /*
+  *  全割込み禁止
+  */
+ Inline uint32_t
+ TOPPERS_disint( void )
+ {
+ 	volatile uint32_t	TOPPERS_psw;
+ 
+ 	TOPPERS_psw = current_psw();
+ 	disint();
+ 
+ 	return( TOPPERS_psw );
+ }
+ 
+ 
+ /*
+  *  全割込み許可
+  */
+ Inline void
+ TOPPERS_enaint( uint32_t TOPPERS_psw )
+ {
+ 	if( TOPPERS_psw & PSW_I_MASK ){
+ 		enaint();
+ 	}
+ }
+ 
+ 
+ /*
+  *  全割込みロック状態の制御
+  */
+ #define SIL_PRE_LOC		uint32_t TOPPERS_i_psw;
+ #define SIL_LOC_INT()	( ( void )( TOPPERS_i_psw = TOPPERS_disint() ) )
+ #define SIL_UNL_INT()	( TOPPERS_enaint( TOPPERS_i_psw ) )
+ 
+ 
+ /*
+  *  エンディアンの反転
+  *
+  *  本開発環境ではエンディアン変換命令が存在するため,
+  *  アーキテクチャ依存部にてマクロを上書きする.
+  */
+ #define TOPPERS_SIL_REV_ENDIAN_UINT16( data )	\
+  								rev_endian_uint16( data )
+ #define TOPPERS_SIL_REV_ENDIAN_UINT32( data )	\
+  								rev_endian_uint32( data )
+ 
+ 
+ /*
+  *  微少時間待ち
+  */
+ extern void sil_dly_nse( ulong_t dlytim );
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ 
+ 
+ /*
+  *  プロセッサのエンディアン
+  */
+ #define SIL_ENDIAN_LITTLE			/* リトルエンディアン */
+ 
+ 
+ #endif /* TOPPERS_PRC_SIL_H */
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_support.S ASPs/asp/arch/rx_gcc/rx_common/prc_support.S
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_support.S	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_support.S	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,878 ----
+ ;
+ ;   TOPPERS/ASP Kernel
+ ;       Toyohashi Open Platform for Embedded Real-Time Systems/
+ ;       Advanced Standard Profile Kernel
+ ;
+ ;   Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+ ;                               Toyohashi Univ. of Technology, JAPAN
+ ;   Copyright (C) 2007      by Embedded and Real-Time Systems Laboratory
+ ;               Graduate School of Information Science, Nagoya Univ., JAPAN
+ ;
+ ;   Copyright (C) 2010 by Witz Corporation, JAPAN
+ ;   Copyright (C) 2015-  by Hisashi Hata, JAPAN
+ ;   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ ;   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ ;   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ ;   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ ;       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ ;       スコード中に含まれていること．
+ ;   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ ;       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ ;       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ ;       の無保証規定を掲載すること．
+ ;   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ ;       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ ;       と．
+ ;     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ ;         作権表示，この利用条件および下記の無保証規定を掲載すること．
+ ;     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ ;         報告すること．
+ ;   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ ;       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ ;       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ ;       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ ;       免責すること．
+ ;
+ ;   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ ;   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ ;   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ ;   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ ;   の責任を負わない．
+ ;
+ ;
+ 
+ ;
+ ;  プロセッサ依存モジュール アセンブリ言語部（RX用）
+ ;
+ 
+ ;
+ ;  ディスパッチャおよび割込み(CPU例外)出入り口のルール:
+ ;	動作モードを以下のように定義する.
+ ;		ディスパッチャモード:
+ ;			CPUロック状態, 割込み優先度マスク全解除状態,
+ ;			タスクコンテキスト(intnest = 0), タスクスタック
+ ;		割込み(CPU例外)処理モード
+ ;			全割込みロック状態(PSWレジスタIビット = 0),
+ ;			割込み優先度マスク全解除でない状態(IPL != 0)
+ ;			割込みコンテキスト(intnest != 0), 割込みスタック
+ ;
+ ;	カーネル管理外割込みのサポート有無と, CPUロック状態, 割込み優先度
+ ;	マスク全解除状態の関係は以下の通りである.
+ ;		カーネル管理外割込み未サポート時:
+ ;			CPUロック状態(PSWレジスタIビット = 0)
+ ;			割込み優先度マスク全解除状態(IPL = 0)
+ ;		カーネル管理外割込みサポート時:
+ ;			CPUロック状態
+ ;				(PSWレジスタIビット = 0, IPL = IPL_LOCK, lock_flag = true)
+ ;			割込み優先度マスク全解除状態(saved_ipl = 0)
+ ;
+ ;	各構造体ポインタを以下のように各レジスタにアサインする.
+ ;		r15 = p_runtsk	ただしディスパッチャの各出口では無効
+ ;		r14 = *p_runtsk	dispatcher の中では p_runtsk 確定時に再取得する
+ ;	各入り口から最初に変数アクセスするときに上記レジスタに保存する.
+ ;
+ ;	構造体アライメントへの対応
+ ;		構造体アライメントが4Byte(アンパック)の場合:
+ ;			一般的なレジスタ相対アドレッシングが可能
+ ;				例:	mov.l	#__kernel_p_runtsk, r15
+ ;					mov.l  	r0, TCB_sp[r15]
+ ;		構造体アライメントが4Byteではない(パック)の場合:
+ ;			mov.lのようにロングサイズ指定の場合、相対値は4の倍数のみ有効
+ ;			このため, 一度対象アドレスを求めてからアクセスする必要がある
+ ;				例:	mov.l	#__kernel_p_runtsk, r15
+ ;					add		#TCB_sp, r15, r5
+ ;					mov.l  	r0, [r5]
+ ;		各オフセット値を判断し, 条件アセンブルによりコードを切り替える
+ ;
+ 
+ ;
+ ;  構造体アクセスのオフセット定義
+ ;
+ #define TOPPERS_MACRO_ONLY
+ ; RENESAS RX72N BSP使用の場合
+ #define RENESAS_RX72N_BSP
+ 
+ #include "offset.h"
+ #include "asm_config.inc"
+ 
+ .text
+ .balign 4
+ ;
+ ;  各種EQU定義(Hファイルの#define定義)
+ ;
+ 
+ 	.extern	__kernel_istkpt
+     .extern _istack
+ 
+ 	.extern	__kernel_p_runtsk
+ 	.extern	__kernel_p_schedtsk
+ 	.extern	__kernel_reqflg
+ 	.extern	__kernel_dspflg
+ 
+ 	.global	__kernel_dispatch
+ 	.global	__exit_and_dispatch
+ 	.global	__kernel_start_r
+ 	.extern	__kernel_call_texrtn
+ 	.global	_kernel_interrupt
+ 	.global	_kernel_exception
+ 	.extern	__kernel_intnest
+ 	.global	__kernel_call_exit_kernel
+ 	.global	__kernel_start_dispatch
+ 
+ 	.extern	_ext_tsk
+ 	.extern	__kernel_exit_kernel
+ 
+ .if	TIPM_LOCK <> -15
+ 	.extern	__kernel_lock_flag
+ 	.extern	__kernel_saved_ipl
+ .endif
+ 
+ 	.global	_sil_dly_nse
+ 
+ .if LOG_INH_ENTER == 1
+ 	.extern	__kernel_log_inh_enter
+ .endif	; LOG_INH_ENTER == 1
+ .if LOG_INH_LEAVE == 1
+ 	.extern	__kernel_log_inh_leave
+ .endif	; LOG_INH_LEAVE == 1
+ .if LOG_EXC_ENTER == 1
+ 	.extern	__kernel_log_exc_enter
+ .endif	; LOG_EXC_ENTER == 1
+ .if LOG_EXC_LEAVE == 1
+ 	.extern	__kernel_log_exc_leave
+ .endif	; LOG_EXC_LEAVE == 1
+ .if LOG_DSP_ENTER == 1
+ 	.extern	__kernel_log_dsp_enter
+ .endif	; LOG_DSP_ENTER == 1
+ .if LOG_DSP_LEAVE == 1
+ 	.extern	__kernel_log_dsp_leave
+ .endif	; LOG_DSP_LEAVE == 1
+ 
+ ;
+ ;  TCB_sp への書込みマクロ
+ ;
+ .macro st_TCB_sp src, tcb, tmp
+ .if (TCB_sp % 4) == 0
+ 	mov.l	\src, TCB_sp[\tcb]
+ .else
+ 	add		#TCB_sp, \tcb, \tmp
+ 	mov.l	\src, [\tmp]
+ .endif
+ .endm
+ 
+ ;
+ ;  TCB_sp からの読出しマクロ
+ ;
+ .macro ld_TCB_sp dst, tcb, tmp
+ .if (TCB_sp % 4) == 0
+ 	mov.l	TCB_sp[\tcb], \dst
+ .else
+ 	add		#TCB_sp, \tcb, \tmp
+ 	mov.l	[\tmp], \dst
+ .endif
+ .endm
+ 
+ ;
+ ;  TCB_pc への書込みマクロ
+ ;
+ .macro st_TCB_pc src, tcb, tmp
+ .if (TCB_pc % 4) == 0
+ 	mov.l	\src, TCB_pc[\tcb]
+ .else
+ 	add		#TCB_pc, \tcb, \tmp
+ 	mov.l	\src, [\tmp]
+ .endif
+ .endm
+ 
+ ;
+ ;  TCB_pc からの読出しマクロ
+ ;
+ .macro ld_TCB_pc dst, tcb, tmp
+ .if (TCB_pc % 4) == 0
+ 	mov.l	TCB_pc[\tcb], \dst
+ .else
+ 	add		#TCB_pc, \tcb, \tmp
+ 	mov.l	[\tmp], \dst
+ .endif
+ .endm
+ 
+ ;
+ ;  TCB_texptn からの読出しマクロ
+ ;
+ .macro ld_TCB_texptn dst, tcb, tmp
+ .if (TCB_texptn % 4) == 0
+ 	mov.l	TCB_texptn[\tcb], \dst
+ .else
+ 	add		#TCB_texptn, \tcb, \tmp
+ 	mov.l	[\tmp], \dst
+ .endif
+ .endm
+ 
+ ;
+ ;  TCB_tinib からの読出しマクロ
+ ;
+ .macro ld_TCB_tinib dst, tcb, tmp
+ .if (TCB_tinib % 4) == 0
+ 	mov.l	TCB_tinib[\tcb], \dst
+ .else
+ 	add		#TCB_tinib, \tcb, \tmp
+ 	mov.l	[\tmp], \dst
+ .endif
+ .endm
+ 
+ ;
+ ;  TINIB_exinf からの読出しマクロ
+ ;
+ .macro ld_TINIB_exinf dst, tinib, tmp
+ .if (TINIB_exinf % 4) == 0
+ 	mov.l	TINIB_exinf[\tinib], \dst
+ .else
+ 	add		#TINIB_exinf, \tinib, \tmp
+ 	mov.l	[\tmp], \dst
+ .endif
+ .endm
+ 
+ ;
+ ;  TINIB_task からの読出しマクロ
+ ;
+ .macro ld_TINIB_task dst, tinib, tmp
+ .if (TINIB_task % 4) ==0
+ 	mov.l	TINIB_task[\tinib], \dst
+ .else
+ 	add		#TINIB_task, \tinib, \tmp
+ 	mov.l	[\tmp], \dst
+ .endif
+ .endm
+ 
+ 
+ ;
+ ;  APIからのタスクディスパッチャ入口
+ ;
+ ;  呼び出し条件:
+ ;	・ディスパッチャモード(ファイルヘッダ参照)
+ ;
+ ;  ここでは, コンテキストの退避と, 実行再開番地の設定をする.
+ ;
+ __kernel_dispatch:
+ 	pushm	r6-r13						; 非スクラッチレジスタ保存
+ 	mov.l	#__kernel_p_runtsk, r15
+ 	mov.l	[r15], r14
+ 	st_TCB_sp	r0, r14, r5				; スタックポインタをTCBに保存
+ 	st_TCB_pc	#dispatch_r, r14, r5	; 実行再開番地をTCBに保存
+ 	bra		dispatcher
+ 
+ ;
+ ;  APIへのタスクディスパッチャ出口
+ ;
+ ;  呼び出し条件:
+ ;	・ディスパッチャモード(ファイルヘッダ参照)
+ ;
+ ;  ここでは, タスク例外ハンドラ呼出しと, コンテキストの復帰をする.
+ ;
+ dispatch_r:
+ 	btst 	#TCB_enatex_bit, TCB_enatex[r14].B	; タスク例外処理許可
+ 	bz   	dispatch_r_rts
+ 	ld_TCB_texptn	r5, r14, r4			; 保留例外要因があるか？
+ 	cmp		#0, r5
+ 	bz   	dispatch_r_rts
+ 	bsr		__kernel_call_texrtn		; タスク例外ハンドラ呼出し処理実行
+ dispatch_r_rts:
+ 	popm 	r6-r13						; 非スクラッチレジスタ復帰
+ 	rts  	                        	; dispatch 呼び出し元へ戻る.
+ 
+ ;
+ ;  タスク起動処理(タスク先頭へのタスクディスパッチャ出口)
+ ;
+ ;  呼び出し条件:
+ ;	・ディスパッチャモード(ファイルヘッダ参照)
+ ;
+ ;  ここでは, CPUロック解除状態にし, タスクを起動する.
+ ;
+ __kernel_start_r:
+ 	mov.l 	#_ext_tsk, r5
+ 	push.l	r5							; 戻り番地をスタックに積む
+ 	ld_TCB_tinib	r5, r14, r4
+ 	ld_TINIB_exinf	r1, r5, r4			; 拡張情報を第一引数に設定
+ 	ld_TINIB_task	r5, r5, r4			; タスクの起動番地を取得
+ .if TIPM_LOCK == -15
+     setpsw i
+ .else
+     mov.l	#__kernel_lock_flag, r4		; CPUロック解除状態へ
+ 	mov.l	#0, [r4]					; ここに来るときは必ず saved_ipl の
+ 	mvtc	#0x00010000, psw				; 値は 0 のため, 直値を設定する.
+ 								; 全割込みロック解除状態( I = 1 )
+ 								; 割込み優先度マスク全解除状態( IPL = 0 )
+ .endif
+ 	jmp		r5
+ 
+ ;
+ ;  カーネル起動からのタスクディスパッチャ入口
+ ;
+ ;  このルーチンは，カーネル起動時に，すべての割込みを禁止した状態
+ ; （割込みロック状態と同等）で呼び出される．また，割込みモード（非
+ ;  タスクコンテキストと同等）で呼び出されることを想定している．
+ ;
+ ;  呼び出し条件:
+ ;	・割込み(CPU例外)処理モード(ファイルヘッダ参照)
+ ;
+ ;  ここでは, ディスパッチャモードに変更する.
+ ;
+ __kernel_start_dispatch:
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	#0, [r5]					; タスクコンテキストに切換え
+ .if	TIPM_LOCK <> -15
+ 	mvtc	#(IPL_LOCK | 0x00010000), psw	; 全割込みロック解除状態
+ 										; 割込み優先度マスク全解除でない状態
+ .endif
+ 
+ ;
+ ; タスク終了(現在のコンテキストを捨てる)からのタスクディスパッチャ入口
+ ;
+ ;  呼び出し条件:
+ ;	・ディスパッチャモード(ファイルヘッダ参照)
+ ;
+ ;  ここでは, 何もすることはない.
+ ;  なお, p_runtsk のアドレス取得だけは行なう.
+ ;
+ __exit_and_dispatch:
+ 	mov.l	#__kernel_p_runtsk, r15
+ 
+ ;
+ ; ディスパッチャ本体
+ ;
+ ;  呼び出し条件:
+ ;	・すべてのタスクのコンテキストは保存されている.
+ ;
+ ;  dispatcher 呼出時のスタック:
+ ;	・__kernel_dispatch からきた場合			: タスクスタック
+ ;	・exit_and_dispatch からきた場合:
+ ;		exit_task からきた場合					: タスクスタック
+ ;		カーネル起動時(__kernel_start_dispatch)	: 割込みスタック
+ ;	・ret_int からきた場合						: タスクスタック
+ ;	・dispatcher_idle_loop からきた場合			: 割込みスタック
+ ;
+ dispatcher:
+ .if LOG_DSP_ENTER == 1
+ 	push.l	r15
+ 	mov.l	r14, r1						; 引数(ディスパッチ元TCB)を設定
+ 	bsr		__kernel_log_dsp_enter
+ 	pop	    r15
+ .endif
+ 	mov.l	#__kernel_p_schedtsk, r5
+ 	mov.l	[r5], [r15]					; p_schedtsk を p_runtsk に
+ 	mov.l	[r15], r14
+ 	cmp		#0, r14
+ 	bz		dispatcher_pre_idle			; schedtsk がなければアイドルループへ
+ 	ld_TCB_sp	r0, r14, r5				; タスクスタックポインタを復帰
+ .if LOG_DSP_LEAVE == 1
+ 	push.l	r14
+ 	mov.l	r14, r1						; 引数(ディスパッチ先TCB)を設定
+ 	bsr		__kernel_log_dsp_leave
+ 	pop     r14
+ .endif
+ 	ld_TCB_pc	r5, r14, r4
+ 	jmp		r5					; 実行再開番地へジャンプ
+ 
+ ;
+ ;  schdedtskがNULLの場合はアイドルループに入る
+ ;  アイドルループは割込み処理モードで動作させる
+ ;
+ ;  ここで割込みモードに切り換えるのは，ここで発生する割込み処理に
+ ;  どのスタックを使うかという問題の解決と，割込みハンドラ内でのタ
+ ;  スクディスパッチの防止という2つの意味がある．
+ ;
+ dispatcher_pre_idle:
+ #ifdef RENESAS_RX72N_BSP
+     mov.l   #_istack,r0
+ #else
+ 	mov.l	#__kernel_istkpt,r5
+ 	mov.l	[r5], r0					; 割込み用のスタックへ切替え
+ #endif
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	#1, [r5]					; 非タスクコンテキストに切換え
+ .if	TIPM_LOCK <> -15
+ 	mov.l	#__kernel_lock_flag, r5		; CPUロック解除状態へ
+ 	mov.l	#0, [r5]
+ 	mvtc	#0, psw						; 優先度0の割込み処理中を偽装
+ .endif
+ 
+ dispatcher_idle_loop:
+ 	setpsw	i							; 全割込み許可
+ 	clrpsw	i							; 全割込み禁止
+ 
+ 	mov.l	#__kernel_reqflg, r5		; reqflg が FALSE なら
+ 	mov.l	[r5], r4
+ 	cmp		#0, r4
+ 	bz   	dispatcher_idle_loop		; アイドルループを繰り返す
+ 	mov.l	#0, [r5]					; reqflgがtrueならfalseにする
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	#0, [r5]					; タスクコンテキストに切換え
+ .if	TIPM_LOCK <> -15
+ 	mov.l	#__kernel_lock_flag, r5		; CPUロック状態へ
+ 	mov.l	#1, [r5]
+ 	mov.l	#__kernel_saved_ipl, r5
+ 	mov.l	#0, [r5]
+ 	mvtc	#(IPL_LOCK | PSW_I_MASK), psw	; 全割込みロック解除状態
+ 										; 割込み優先度マスク全解除でない状態
+ .endif
+ 	bra		dispatcher					; dispatcher へ戻る
+ 
+ 
+ ;
+ ; カーネルの終了処理の呼出し
+ ;
+ ; モードとスタックを非タスクコンテキスト用に切り替え．
+ ;
+ __kernel_call_exit_kernel:
+ .if	TIPM_LOCK <> -15
+ 	clrpsw	i							; 全割込み禁止
+ 	mov.l	#__kernel_lock_flag, r5		; CPUロック解除状態へ
+ 	mov.l	#0, [r5]
+ .endif
+ #ifdef RENESAS_RX72N_BSP
+     mov.l   #_istack,r0
+ #else
+ 	mov.l	#__kernel_istkpt,r5
+ 	mov.l	[r5], r0					; 割込み用のスタックへ切替え
+ #endif
+ 
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	#1, [r5]					; 非タスクコンテキストに切換え
+ 	bsr		__kernel_exit_kernel
+ 	bra		__kernel_call_exit_kernel
+ 
+ 
+ ;
+ ;  割込み(CPU例外)からのタスクディスパッチャ入口
+ ;
+ ;	呼出し条件:
+ ;	・全割込みロック状態(PSWレジスタIビット = 0)
+ ;	・割込み優先度マスク全解除でない状態(IPL != 0)
+ ;	・タスクコンテキスト(intnest=0)
+ ;	・使用スタックはタスクスタック
+ ;	・reqflg = true
+ ;
+ ;  ここでは, ディスパッチャモードに変更し, reqflgをOFFにしてから,
+ ;  遅延ディスパッチの有無を判断する.
+ ;
+ 
+ ;
+ ;  ret_int先頭でスタックに積まれているPSWレジスタへのオフセット
+ ;  ACC + FPSW + R14--R15 + R1--R5 + PC
+ ;
+ .equ RET_INT_GET_PSW_OFFSET, (8+4+28+4)
+ 
+ ret_int:
+ .if	TIPM_LOCK == -15
+ 	mov.l	RET_INT_GET_PSW_OFFSET[r0], r5	; 割込み/CPU例外発生前のIPL値取得
+ 	and		#PSW_IPL_MASK, r5
+ 	mvtc	r5, psw						; 全割込みロック(CPUロック)状態
+ 										; 割込み/CPU例外発生前の割込み優先度
+ .else
+ 	mov.l	#__kernel_lock_flag, r5		; CPUロック状態へ
+ 	mov.l	#1, [r5]
+ 	mov.l	RET_INT_GET_PSW_OFFSET[r0], r5	; 割込み/CPU例外発生前のIPL値取得
+ 	and		#PSW_IPL_MASK, r5
+ 	mov.l	#__kernel_saved_ipl, r4
+ 	mov.l	r5, [r4]
+ 	mvtc	#(IPL_LOCK | PSW_I_MASK), psw	; 全割込みロック解除状態
+ 										; 割込み優先度マスク全解除でない状態
+ .endif
+ 	mov.l	#__kernel_reqflg, r5
+ 	mov.l	#0, [r5]					; reqflg <--- FALSE
+ 	mov.l	#__kernel_p_runtsk, r15
+ 	mov.l	[r15], r14
+ 	mov.l	#__kernel_dspflg, r5		; dspflg が FALSE なら ret_int_r へ
+ 	mov.l	[r5], r5
+ 	cmp		#0, r5
+ 	bz   	ret_int_r_call_tex
+ 	mov.l	#__kernel_p_schedtsk, r5
+ 	mov.l	[r5], r5
+ 	cmp		r5, r14						; p_schedtsk と p_runtsk が同じなら
+ 	beq  	ret_int_r_call_tex			; ret_int_r_call_tex へ
+ 	pushm	r6-r13						; 非スクラッチレジスタ保存
+ 	st_TCB_sp	r0, r14, r5				; スタックポインタをTCBに保存
+ 	st_TCB_pc	#ret_int_r, r14, r5		; 実行再開番地をTCBに保存
+ 	bra		dispatcher
+ 
+ ;
+ ;  割込み(CPU例外)へのタスクディスパッチャ出口
+ ;
+ ;  呼び出し条件:
+ ;	・ディスパッチャモード(ファイルヘッダ参照)
+ ;
+ ;  ここでは, タスク例外ハンドラ呼出しと, 割込み(CPU例外)処理モードへの
+ ;  変更と, コンテキストの復帰を行い, 割込み(CUP例外)発生元へ戻る.
+ ;
+ ret_int_r:
+ 	popm 	r6-r13						; 非スクラッチレジスタ復帰
+ ret_int_r_call_tex:
+ 	btst 	#TCB_enatex_bit, TCB_enatex[r14].B	; タスク例外処理許可
+ 	bz   	ret_int_r_rte
+ 	ld_TCB_texptn	r5, r14, r4			; 保留例外要因があるか？
+ 	cmp		#0, r5
+ 	bz   	ret_int_r_rte
+ 	bsr		__kernel_call_texrtn		; タスク例外ハンドラ呼出し処理実行
+ ret_int_r_rte:
+ .if	TIPM_LOCK <> -15
+ 	clrpsw	i							; 全割込み禁止
+ 	mov.l	#__kernel_lock_flag, r5		; CPUロック解除状態へ
+ 	mov.l	#0, [r5]
+ .endif
+ 	popm	r4-r5						; アキュムレータ復帰
+ 	mvtaclo	r5							; ACC最下位16bitは0で復帰
+ 	mvtachi	r4
+ 	popc	fpsw						; FPUステータスレジスタ復帰
+ 	popm	r14-r15						; レジスタ復帰
+ 	popm	r1-r5
+ 	rte									; 割込み前の処理に戻る
+ 
+ 
+ ;
+ ;  割込みの出入口処理(アセンブリ言語記述部分)
+ ;
+ ;  呼出し条件:
+ ;  ・割込み発生時のH/W処理により, PSWレジスタのIビット=0, IPLは受付け
+ ;    た割込みのIPL.
+ ;  ・スタックは多重割り込みなら割込みスタック, そうでなければ
+ ;    タスクスタック
+ ;  ・割込み発生時のH/W処理により,スタックに割込みからの復帰PCとPSWが
+ ;    保存されている.
+ ;  ・ベクタテーブルに登録された個別の入り口処理により, スタックに
+ ;    スクラッチレジスタ(R1-R5)が保存されている.
+ ;
+ ;  引数:
+ ;  ・r1:割込み要因番号
+ ;  ・r2:割込みハンドラのアドレス
+ ;
+ ;  レジスタがスタック上にどのように保存されているかを以下に示す.
+ ;  この図では上が低位, 下が高位のアドレスで, スタックは下から
+ ;  上方向に向かって積み上げられるものとする.
+ ;
+ ;	-------------------------
+ ;	|       ACC-HI(4byte)   |
+ ;	-------------------------(SP + 0)
+ ;	|       ACC-LO(4byte)   |
+ ;	-------------------------(SP + 4)
+ ;	|       FPSW(4byte)     |
+ ;	-------------------------(SP + 8)
+ ;	|       R14(4byte)      |
+ ;	-------------------------(SP + 12)
+ ;	|       R15(4byte)      |
+ ;	-------------------------(SP + 16)
+ ;	|       R1(4byte)       |
+ ;	-------------------------(SP + 20)
+ ;	|       R2(4byte)       |
+ ;	-------------------------(SP + 24)
+ ;	|       R3(4byte)       |
+ ;	-------------------------(SP + 28)
+ ;	|       R4(4byte)       |
+ ;	-------------------------(SP + 32)
+ ;	|       R5(4byte)       |
+ ;	-------------------------(SP + 36)
+ ;	|       PC(4byte)       |
+ ;	-------------------------(SP + 40)
+ ;	|       PSW(4byte)      |
+ ;	-------------------------(SP + 44)
+ ;
+ ;  ここでは, 割込み処理モードに変更してハンドラを実行する.
+ ;
+ ;  ハンドラからリターンした後は, 多重割込みでなく, かつ reqflg が
+ ;  TRUE になった時に，ret_int へ分岐(遅延ディスパッチ)する．
+ ;
+ ;  多重割込みかどうかは割込みネストカウンタの値で判定する.
+ ;  intnest != 0 ならば多重割込みであると判定する.
+ ;
+ ;  reqflg はCPUロック状態でチェックする. そうでないと，
+ ;  reqflg チェック後に起動された割込みハンドラ内で
+ ;  ディスパッチが要求された場合に，ディスパッチされない.
+ ;
+ _kernel_interrupt:
+ 	pushm	r14-r15						; スクラッチレジスタを退避
+ 	pushc	fpsw						; FPUステータスレジスタ退避
+ 	mvfacmi	r5
+ 	shll	#16, r5						; ACC最下位16bitは0とする
+ 	mvfachi	r4
+ 	pushm	r4-r5						; アキュムレータ退避
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	[r5], r4
+ 	add		#1, r4						; ネスト回数をインクリメント
+ 	mov.w	r4, [r5]
+ 	cmp		#1, r4						; 多重割り込みかどうか
+ 	bnz		interrupt_from_int			; 加算前が0でなければ多重割込み
+ 						; 初段の割込み
+ 	mov.l	r0, r3						; スタックポインタを取り出し
+ #ifdef RENESAS_RX72N_BSP
+     mov.l   #_istack,r0
+ #else
+ 	mov.l	#__kernel_istkpt,r5
+ 	mov.l	[r5], r0					; 割込み用のスタックへ切替え
+ #endif
+ 
+ 	push.l	r3							; タスクスタックを保持
+ interrupt_from_int:		; 多重割込み
+ 	setpsw	i							; 割込み許可(CPUロック解除状態)
+ 
+ .if LOG_INH_LEAVE == 1
+ 	push.l	r1							; ログトレースの引数を保持
+ .endif
+ 
+ .if	LOG_INH_ENTER == 1
+ 	push.l	r2
+ 	bsr		__kernel_log_inh_enter		; ログトレース関数の呼出し
+ 							; 引数の割込み要因番号は既にr1に入っている
+ 	pop		r2
+ .endif
+ 
+ 	jsr  	r2							; Cルーチン呼び出し
+ 
+ .if	LOG_INH_LEAVE == 1
+ 	pop		r1							; 引数に割込み要因番号を設定
+ 	bsr		__kernel_log_inh_leave		; ログトレース関数の呼出し
+ .endif
+ 
+ 	clrpsw	i							; 割込み禁止(CPUロック状態)
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	[r5], r4
+ 	sub		#1, r4						; ネスト回数をデクリメント
+ 	mov.w	r4, [r5]
+ 	cmp		#0, r4						; 多重割り込みかどうか
+ 	bnz		interrupt_return			; 多重割り込みならリターン
+ 	; 初段の割込み
+ 	pop		r0							; タスクのスタックに戻す
+ 	mov.l	#__kernel_reqflg, r5		; ディスパッチ要求がないか?
+ 	mov.l	[r5], r5
+ 	cmp		#1, r5
+ 	bz		ret_int						; あれば ret_int へジャンプ
+ interrupt_return:
+ 	popm	r4-r5						; アキュムレータ復帰
+ 	mvtaclo	r5							; ACC最下位16bitは0で復帰
+ 	mvtachi	r4
+ 	popc	fpsw						; FPUステータスレジスタ復帰
+ 	popm	r14-r15						; レジスタ復帰
+ 	popm	r1-r5
+ 	rte									; 割込み前の処理に戻る
+ 
+ 
+ ;
+ ;  CPU例外の出入口処理(アセンブリ言語記述部分)
+ ;
+ ;  呼出し条件:
+ ;  ・CPU例外発生時のH/W処理により, PSWレジスタのIビット=0, IPL=0.
+ ;  ・スタックは多重割り込みなら割込みスタック, そうでなければ
+ ;    タスクスタック
+ ;  ・CPU例外発生時のH/W処理により,スタックにCPU例外からの復帰PCと
+ ;    PSWが保存されている.
+ ;  ・ベクタテーブルに登録された個別の入り口処理により, スタックに
+ ;    スクラッチレジスタ(R1-R5)が保存されている.
+ ;
+ ;  引数:
+ ;  ・r1:CPU例外要因番号
+ ;  ・r2:CPU例外ハンドラのアドレス
+ ;
+ ;  レジスタがスタック上にどのように保存されているかを以下に示す.
+ ;  この図では上が低位, 下が高位のアドレスで, スタックは下から
+ ;  上方向に向かって積み上げられるものとする.
+ ;  なお, CPU例外要因番号とR6-R13はCPU例外ハンドラ内で情報を取得
+ ;  する目的で退避しており, 出口処理では保存内容を破棄すればよい.
+ ;
+ ;	-------------------------
+ ;	|    CPU例外要因番号    | <----- p_excinf
+ ;	------------------------- (intptr_t)(p_excinf + 0)
+ ;	|       R6(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 4)
+ ;	|       R7(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 8)
+ ;	|       R8(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 12)
+ ;	|       R9(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 16)
+ ;	|       R10(4byte)      |
+ ;	------------------------- (intptr_t)(p_excinf + 20)
+ ;	|       R11(4byte)      |
+ ;	------------------------- (intptr_t)(p_excinf + 24)
+ ;	|       R12(4byte)      |
+ ;	------------------------- (intptr_t)(p_excinf + 28)
+ ;	|       R13(4byte)      |
+ ;	------------------------- (intptr_t)(p_excinf + 32)
+ ;	|       ACC-HI(4byte)   |
+ ;	------------------------- (intptr_t)(p_excinf + 36)
+ ;	|       ACC-LO(4byte)   |
+ ;	------------------------- (intptr_t)(p_excinf + 40)
+ ;	|       FPSW(4byte)     |
+ ;	------------------------- (intptr_t)(p_excinf + 44)
+ ;	|       R14(4byte)      |
+ ;	------------------------- (intptr_t)(p_excinf + 48)
+ ;	|       R15(4byte)      |
+ ;	------------------------- (intptr_t)(p_excinf + 52)
+ ;	|       R1(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 56)
+ ;	|       R2(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 60)
+ ;	|       R3(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 64)
+ ;	|       R4(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 68)
+ ;	|       R5(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 72)
+ ;	|       PC(4byte)       |
+ ;	------------------------- (intptr_t)(p_excinf + 76)
+ ;	|       PSW(4byte)      |
+ ;	------------------------- (intptr_t)(p_excinf + 80)
+ ;
+ ;  ここでは, 割込み処理モードに変更してハンドラを実行する.
+ ;  CPU例外ハンドラに渡すVP型の変数 p_excinf としてISPの値渡す．
+ ;
+ ;  ハンドラからリターンした後は, 多重割込みでなく, かつ reqflg が
+ ;  TRUE になった時に，ret_int へ分岐(遅延ディスパッチ)する．
+ ;
+ ;  多重割込みかどうかは割込みネストカウンタの値で判定する.
+ ;  intnest != 0 ならば多重割込みであると判定する.
+ ;
+ ;  reqflg はCPUロック状態でチェックする. そうでないと，
+ ;  reqflg チェック後に起動された割込みハンドラ内で
+ ;  ディスパッチが要求された場合に，ディスパッチされない.
+ ;
+ ;
+ ;  CPU例外入口処理
+ ;
+ ;  ここでは, 割込み処理モードに変更してハンドラを実行する.
+ ;
+ 
+ ;
+ ;  CPU例外ハンドラ呼出し後に不要となるスタック情報のサイズ
+ ;  EXCNO + R6--R13
+ ;
+ 	.equ EXCINF_REG_SIZE, (4+32)
+ 
+ _kernel_exception:
+ 	pushm	r14-r15						; スクラッチレジスタを退避
+ 	pushc	fpsw
+ 	mvfacmi	r5
+ 	shll	#16, r5						; ACC最下位16bitは0とする
+ 	mvfachi	r4
+ 	pushm	r4-r5						; アキュムレータ退避
+ 	pushm	r6-r13						; 非スクラッチレジスタ保存
+ 	push.l	r1							; CPU例外要因番号を保持
+ 	mov.l	r0, r3						; スタックポインタを取り出し
+ 	mov.l	EXC_GET_PSW_OFFSET[r3], r5
+ 	and		#PSW_I_MASK, r5
+ 	bz		exception_nonkernel			; 全割込み禁止(CPUロック)状態なら管理外
+ .if	TIPM_LOCK <> -15
+ 	mov.l	EXC_GET_PSW_OFFSET[r3], r5
+ 	and		#PSW_IPL_MASK, r5
+ 	cmp		#IPL_LOCK, r5
+ 	bgt	exception_nonkernel			; IPLがCPUロックレベル以上なら管理外
+ .endif
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	[r5], r4
+ 	add		#1, r4						; ネスト回数をインクリメント
+ 	mov.w	r4, [r5]
+ 	cmp		#1, r4						; 多重割り込みかどうか
+ 	bnz		exception_from_int			; 加算前が0でなければ多重割込み
+ 						; 初段の割込み
+ #ifdef RENESAS_RX72N_BSP
+     mov.l   #_istack,r0
+ #else
+ 	mov.l	#__kernel_istkpt,r5
+ 	mov.l	[r5], r0					; 割込み用のスタックへ切替え
+ #endif
+ 
+ 	push.l	r3							; タスクスタックを保持
+ exception_from_int:		; 多重割込み
+ 	mov.l	EXC_GET_PSW_OFFSET[r3], r5
+ 	mvtc	r5, psw						; CPU例外発生前の状態に戻す
+ .if	LOG_EXC_LEAVE == 1
+ 	push.l	r1							; ログトレースの引数を保持
+ .endif
+ 
+ .if LOG_EXC_ENTER == 1
+ 	pushm	r2-r3
+ 	bsr		__kernel_log_exc_enter		; ログトレース関数の呼出し
+ 							; 引数の割込み要因番号は既にr1に入っている
+ 	popm	r2-r3
+ .endif
+ 
+ 	mov.l	r3, r1						; 引数のp_excinfを設定
+ 	jsr  	r2							; Cルーチン呼び出し
+ 
+ .if	LOG_EXC_LEAVE == 1
+ 	pop		r1							; 引数に割込み要因番号を設定
+ 	bsr		__kernel_log_exc_leave		; ログトレース関数の呼出し
+ .endif
+ 
+ 	clrpsw	i							; ここからは必ず割込み禁止
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	[r5], r4
+ 	sub		#1, r4						; ネスト回数をデクリメント
+ 	mov.w	r4, [r5]
+ 	cmp		#0, r4						; 多重割り込みかどうか
+ 	bnz		exception_return			; 多重割り込みならリターン
+ 	; 初段の割込み
+ 	pop		r0							; タスクのスタックに戻す
+ 	mov.l	#__kernel_reqflg, r5		; ディスパッチ要求がないか?
+ 	mov.l	[r5], r5
+ 	cmp		#1, r5
+ 	bnz		exception_return			; なければリターン
+ 	add		#EXCINF_REG_SIZE, r0		; CPU例外情報の破棄
+ 	bra		ret_int						; あれば ret_int へジャンプ
+ 
+ exception_nonkernel:
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	[r5], r4
+ 	add		#1, r4						; ネスト回数をインクリメント
+ 	mov.w	r4, [r5]
+ 	cmp		#1, r4						; 多重割り込みかどうか
+ 	bnz		exception_from_nonkernelint	; 加算前が0でなければ多重割込み
+ 						; 初段の割込み
+ #ifdef RENESAS_RX72N_BSP
+     mov.l   #_istack,r0
+ #else
+ 	mov.l	#__kernel_istkpt,r5
+ 	mov.l	[r5], r0					; 割込み用のスタックへ切替え
+ #endif
+ 
+ 	push.l	r3							; タスクスタックを保持
+ exception_from_nonkernelint:	; 多重割込み
+ 	mov.l	EXC_GET_PSW_OFFSET[r3], r5
+ 	mvtc	r5, psw						; CPU例外発生前の状態に戻す
+ 
+ 	mov.l	r3, r1						; 引数のp_excinfを設定
+ 	jsr  	r2							; Cルーチン呼び出し
+ 
+ 	clrpsw	i							; ここからは必ず割込み禁止
+ 	mov.l	#__kernel_intnest, r5
+ 	mov.w	[r5], r4
+ 	sub		#1, r4						; ネスト回数をデクリメント
+ 	mov.w	r4, [r5]
+ 	cmp		#0, r4						; 多重割り込みかどうか
+ 	bnz		exception_return			; 多重割り込みならリターン
+ 	; 初段の割込み
+ 	pop		r0							; タスクのスタックに戻す
+ 
+ exception_return:
+ 	add		#EXCINF_REG_SIZE, r0		; CPU例外情報の破棄
+ 	popm	r4-r5						; アキュムレータ復帰
+ 	mvtaclo	r5							; ACC最下位16bitは0で復帰
+ 	mvtachi	r4
+ 	popc	fpsw						; FPUステータスレジスタ復帰
+ 	popm	r14-r15						; レジスタ復帰
+ 	popm	r1-r5
+ 	rte									; 割込み前の処理に戻る
+ 
+ 
+ ;
+ ;  微少時間待ち
+ ;
+ _sil_dly_nse:
+ 	mov.l	#SIL_DLY_TIM1, r5
+ 	sub		r5, r1
+ 	ble		sil_dly_nse_ret
+ sil_dly_nse_loop:
+ 	mov.l	#SIL_DLY_TIM2, r5
+ 	sub		r5, r1
+ 	bgt		sil_dly_nse_loop
+ sil_dly_nse_ret:
+ 	rts
+ 
+ 	.end
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_test.S ASPs/asp/arch/rx_gcc/rx_common/prc_test.S
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_test.S	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_test.S	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,53 ----
+ ;*
+ ;*  TOPPERS/ASP Kernel
+ ;*      Toyohashi Open Platform for Embedded Real-Time Systems/
+ ;*      Advanced Standard Profile Kernel
+ ;* 
+ ;*  Copyright (C) 2010 by Witz Corporation, JAPAN
+ ;* 
+ ;*  上記著作権者は，Free Software Foundation によって公表されている 
+ ;*  GNU General Public License の Version 2 に記述されている条件か，以
+ ;*  下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェア（本ソフトウェ
+ ;*  アを改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+ ;*  利用と呼ぶ）することを無償で許諾する．
+ ;*  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ ;*      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ ;*      スコード中に含まれていること．
+ ;*  (2) 本ソフトウェアを再利用可能なバイナリコード（リロケータブルオブ
+ ;*      ジェクトファイルやライブラリなど）の形で利用する場合には，利用
+ ;*      に伴うドキュメント（利用者マニュアルなど）に，上記の著作権表示，
+ ;*      この利用条件および下記の無保証規定を掲載すること．
+ ;*  (3) 本ソフトウェアを再利用不可能なバイナリコードの形または機器に組
+ ;*      み込んだ形で利用する場合には，次のいずれかの条件を満たすこと．
+ ;*    (a) 利用に伴うドキュメント（利用者マニュアルなど）に，上記の著作
+ ;*        権表示，この利用条件および下記の無保証規定を掲載すること．
+ ;*    (b) 利用の形態を，別に定める方法によって，上記著作権者に報告する
+ ;*        こと．
+ ;*  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ ;*      害からも，上記著作権者を免責すること．
+ ;* 
+ ;*  本ソフトウェアは，無保証で提供されているものである．上記著作権者は，
+ ;*  本ソフトウェアに関して，その適用可能性も含めて，いかなる保証も行わ
+ ;*  ない．また，本ソフトウェアの利用により直接的または間接的に生じたい
+ ;*  かなる損害に関しても，その責任を負わない．
+ ;* 
+ 
+    .text
+ 
+ 	.global	_trigger_cpu_exception
+ 
+ _trigger_cpu_exception:
+ 	;
+ 	;  CPU例外の発生
+ 	;
+ 	;  ゼロ割り算を行うことで, 浮動小数点例外を
+ 	;  発生させる.
+ 	;
+ 	mvtc	#0x00001000, fpsw
+ 	mov.l	#1, r5
+ 	fdiv	#0, r5
+ 	mvtc	#0x00000000, fpsw
+ 	rts
+ 
+ 	.end
+ 
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_test.h ASPs/asp/arch/rx_gcc/rx_common/prc_test.h
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_test.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_test.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,51 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		テストプログラムのターゲット依存定義（RX610用）
+  */
+ 
+ #ifndef TOPPERS_PRC_TEST_H
+ #define TOPPERS_PRC_TEST_H
+ 
+ #define CPUEXC1					25		/* 浮動小数点例外 */
+ #define RAISE_CPU_EXCEPTION		trigger_cpu_exception()
+ 
+ extern void trigger_cpu_exception( void );
+ 
+ #endif /* TOPPERS_PRC_TEST_H */
diff -cr --new-file 1.9.1/asp/arch/rx_gcc/rx_common/prc_unrename.h ASPs/asp/arch/rx_gcc/rx_common/prc_unrename.h
*** 1.9.1/asp/arch/rx_gcc/rx_common/prc_unrename.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/arch/rx_gcc/rx_common/prc_unrename.h	Fri Dec  9 13:53:57 2022
***************
*** 0 ****
--- 1,87 ----
+ /* This file is generated from prc_rename.def by genrename. */
+ 
+ #ifndef TOPPERS_PRC_RENAME_H
+ #define TOPPERS_PRC_RENAME_H
+ 
+ /*
+  *  prc_config.c
+  */
+ #undef intnest
+ #undef lock_flag
+ #undef saved_ipl
+ #undef saved_psw
+ 
+ #undef prc_initialize
+ #undef prc_terminate
+ #undef x_config_int
+ #undef default_int_handler
+ #undef default_exc_handler
+ 
+ /*
+  *  prc_support.src
+  */
+ #undef dispatch
+ #undef start_dispatch
+ #undef exit_and_dispatch
+ #undef call_exit_kernel
+ #undef start_r
+ #undef interrupt
+ #undef exception
+ 
+ /*
+  *  rx_config
+  */
+ #undef ipr_reg_addr
+ #undef ier_reg_addr
+ #undef ir_reg_addr
+ #undef irqcr_reg_addr
+ 
+ /*
+  *  kernel_cfg.c
+  */
+ #undef cfg_int_table
+ 
+ #ifdef TOPPERS_LABEL_ASM
+ 
+ /*
+  *  prc_config.c
+  */
+ #undef _intnest
+ #undef _lock_flag
+ #undef _saved_ipl
+ #undef _saved_psw
+ 
+ #undef _prc_initialize
+ #undef _prc_terminate
+ #undef _x_config_int
+ #undef _default_int_handler
+ #undef _default_exc_handler
+ 
+ /*
+  *  prc_support.src
+  */
+ #undef _dispatch
+ #undef _start_dispatch
+ #undef _exit_and_dispatch
+ #undef _call_exit_kernel
+ #undef _start_r
+ #undef _interrupt
+ #undef _exception
+ 
+ /*
+  *  rx63n_config.c
+  */
+ #undef _ipr_reg_addr
+ #undef _ier_reg_addr
+ #undef _ir_reg_addr
+ #undef _irqcr_reg_addr
+ 
+ /*
+  *  kernel_cfg.c
+  */
+ #undef _cfg_int_table
+ 
+ #endif /* TOPPERS_LABEL_ASM */
+ 
+ 
+ #endif /* TOPPERS_PRC_RENAME_H */
Binary files 1.9.1/asp/cfg/cfg/cfg.exe and ASPs/asp/cfg/cfg/cfg.exe differ
diff -cr --new-file 1.9.1/asp/configure ASPs/asp/configure
*** 1.9.1/asp/configure	Sun Nov 11 17:23:28 2012
--- ASPs/asp/configure	Fri Dec  9 13:53:56 2022
***************
*** 8,89 ****
  #  Copyright (C) 2006-2012 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! #  ܥեȥѤΤޤࡥʲƱˤѡʣ
! #  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! #  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! #      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! #      ˴ޤޤƤ뤳ȡ
! #  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! #      ѤǤǺۤˤϡۤȼɥȡ
! #      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! #      ̵ݾڵǺܤ뤳ȡ
! #  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! #      ѤǤʤǺۤˤϡΤ줫ξ
! #      ȡ
! #    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! #        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! #    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! #        𤹤뤳ȡ
! #  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! #      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! #      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! #      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! #      դ뤳ȡ
  # 
! #  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! #  TOPPERSץȤϡܥեȥ˴ؤơλŪ
! #  ФŬޤơʤݾڤԤʤޤܥեȥ
! #  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! #  Ǥʤ
  # 
  #  @(#) $Id: configure 2424 2012-11-11 08:23:22Z ertl-hiro $
  # 
  
  use Getopt::Std;
  
! #  ץ
  #
! #  -T <target>			å̾ɬܡ
! #  -A <applname>		ץꥱץ̾ʥǥեȤsample1
! #  -a <appldir>			ץꥱΥǥ쥯ȥ̾
! #  -U <applobjs>		¾Υץꥱץե
! #						.oե̾ǻꡥʣġ
! #  -S <syssvcobjs>		ƥॵӥΥץե
! #						.oե̾ǻꡥʣġ
! #  -L <kernel_lib>		ͥ饤֥libkernel.aˤΥǥ쥯ȥ̾
! #						ʾά硤ͥ饤֥make
! #  -f					ͥؿñ̤ǥѥ뤹뤫ɤλ
! #  -D <srcdir>			ͥΥ֤Ƥǥ쥯ȥ
! #  -l <srclang>			ץߥ󥰸ʸǤcc++Τߥݡȡ
! #  -t <templatedir>		ƥץ졼ȥǥ쥯ȥλʥǥեȤsample
! #  -m <makefile>		ƥץ졼Makefile̾λʥǥեȤMakefile
! #  -d <dbgenv>			¹ԴĶ̾
! #  -r					ȥ졼ϿΥץ륳ɤѤ뤫ɤ
! #						λ
! #  -p <perl>			perlΥѥ̾Ū˻ꤹ
! #  -g <cfg>				ե졼cfgˤΥѥ̾
! #  -P <num>				ץåʥޥץåбͥξ
! #  -o <options>			̥ѥ륪ץCOPTSɲá
! #  -O <options>			̥ܥץCDEFSɲá
! #  -k <options>			̥󥫥ץLDFLAGSɲá
  
! #  (1)
  #
  #  % ../configure -T dve68k_gcc -D GDB_STUB -A perf1 -a ../test -U histogram.o
  #
! #  (2)
  #
  #  % ../configure -T macosx_gcc -L .
! #	ץꥱץ sample1 ˤʤ롥
  
  #
! #  ץν
  #
  getopt("TAaUSLDltmdpgPoOk");
  
  #
! #  ѿν
  #
  
  $target = $opt_T;
--- 8,89 ----
  #  Copyright (C) 2006-2012 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  �嵭����Ԥϡ��ʲ���(1)��(4)�ξ������������˸¤ꡤ�ܥ��եȥ���
! #  �����ܥ��եȥ���������Ѥ�����Τ�ޤࡥ�ʲ�Ʊ���ˤ���ѡ�ʣ������
! #  �ѡ������ۡʰʲ������ѤȸƤ֡ˤ��뤳�Ȥ�̵���ǵ������롥
! #  (1) �ܥ��եȥ������򥽡��������ɤη������Ѥ�����ˤϡ��嵭������
! #      ��ɽ�����������Ѿ�浪��Ӳ�����̵�ݾڵ��꤬�����Τޤޤη��ǥ���
! #      ����������˴ޤޤ�Ƥ��뤳�ȡ�
! #  (2) �ܥ��եȥ������򡤥饤�֥������ʤɡ�¾�Υ��եȥ�������ȯ�˻�
! #      �ѤǤ�����Ǻ����ۤ�����ˤϡ������ۤ�ȼ���ɥ�����ȡ�����
! #      �ԥޥ˥奢��ʤɡˤˡ��嵭�����ɽ�����������Ѿ�浪��Ӳ���
! #      ��̵�ݾڵ����Ǻܤ��뤳�ȡ�
! #  (3) �ܥ��եȥ������򡤵�����Ȥ߹���ʤɡ�¾�Υ��եȥ�������ȯ�˻�
! #      �ѤǤ��ʤ����Ǻ����ۤ�����ˤϡ����Τ����줫�ξ�����������
! #      �ȡ�
! #    (a) �����ۤ�ȼ���ɥ�����ȡ����Ѽԥޥ˥奢��ʤɡˤˡ��嵭����
! #        �ɽ�����������Ѿ�浪��Ӳ�����̵�ݾڵ����Ǻܤ��뤳�ȡ�
! #    (b) �����ۤη��֤��̤�������ˡ�ˤ�äơ�TOPPERS�ץ������Ȥ�
! #        ��𤹤뤳�ȡ�
! #  (4) �ܥ��եȥ����������Ѥˤ��ľ��Ū�ޤ��ϴ���Ū�������뤤���ʤ�»
! #      ������⡤�嵭����Ԥ����TOPPERS�ץ������Ȥ����դ��뤳�ȡ�
! #      �ޤ����ܥ��եȥ������Υ桼���ޤ��ϥ���ɥ桼������Τ����ʤ���
! #      ͳ�˴�Ť����ᤫ��⡤�嵭����Ԥ����TOPPERS�ץ������Ȥ�
! #      ���դ��뤳�ȡ�
  # 
! #  �ܥ��եȥ������ϡ�̵�ݾڤ��󶡤���Ƥ����ΤǤ��롥�嵭����Ԥ�
! #  ���TOPPERS�ץ������Ȥϡ��ܥ��եȥ������˴ؤ��ơ�����λ�����Ū
! #  ���Ф���Ŭ������ޤ�ơ������ʤ��ݾڤ�Ԥ�ʤ����ޤ����ܥ��եȥ���
! #  �������Ѥˤ��ľ��Ū�ޤ��ϴ���Ū�������������ʤ�»���˴ؤ��Ƥ⡤��
! #  ����Ǥ�����ʤ���
  # 
  #  @(#) $Id: configure 2424 2012-11-11 08:23:22Z ertl-hiro $
  # 
  
  use Getopt::Std;
  
! #  ���ץ��������
  #
! #  -T <target>			�������å�̾��ɬ�ܡ�
! #  -A <applname>		���ץꥱ�������ץ����̾�ʥǥե���Ȥ�sample1��
! #  -a <appldir>			���ץꥱ�������Υǥ��쥯�ȥ�̾
! #  -U <applobjs>		¾�Υ��ץꥱ�������ץ����ե�����
! #						��.o�ե�����̾�ǻ��ꡥʣ������ġ�
! #  -S <syssvcobjs>		�����ƥॵ���ӥ��Υץ����ե�����
! #						��.o�ե�����̾�ǻ��ꡥʣ������ġ�
! #  -L <kernel_lib>		�����ͥ�饤�֥���libkernel.a�ˤΥǥ��쥯�ȥ�̾
! #						�ʾ�ά������硤�����ͥ�饤�֥���make�����
! #  -f					�����ͥ��ؿ�ñ�̤ǥ���ѥ��뤹�뤫�ɤ����λ���
! #  -D <srcdir>			�����ͥ����Υ��������֤���Ƥ���ǥ��쥯�ȥ�
! #  -l <srclang>			�ץ���ߥ󥰸���ʸ������Ǥ�c��c++�Τߥ��ݡ��ȡ�
! #  -t <templatedir>		�ƥ�ץ졼�ȥǥ��쥯�ȥ�λ���ʥǥե���Ȥ�sample��
! #  -m <makefile>		�ƥ�ץ졼��Makefile̾�λ���ʥǥե���Ȥ�Makefile��
! #  -d <dbgenv>			�¹ԴĶ���̾��
! #  -r					�ȥ졼������Ͽ�Υ���ץ륳���ɤ���Ѥ��뤫�ɤ���
! #						�λ���
! #  -p <perl>			perl�Υѥ�̾������Ū�˻��ꤹ�����
! #  -g <cfg>				����ե�����졼����cfg�ˤΥѥ�̾
! #  -P <num>				�ץ��å����ʥޥ���ץ��å��б������ͥ�ξ���
! #  -o <options>			���̥���ѥ��륪�ץ�����COPTS���ɲá�
! #  -O <options>			���̥���ܥ�������ץ�����CDEFS���ɲá�
! #  -k <options>			���̥�󥫥��ץ�����LDFLAGS�����ɲá�
  
! #  ������(1)
  #
  #  % ../configure -T dve68k_gcc -D GDB_STUB -A perf1 -a ../test -U histogram.o
  #
! #  ������(2)
  #
  #  % ../configure -T macosx_gcc -L .
! #	���ץꥱ�������ץ����� sample1 �ˤʤ롥
  
  #
! #  ���ץ����ν���
  #
  getopt("TAaUSLDltmdpgPoOk");
  
  #
! #  �ѿ��ν����
  #
  
  $target = $opt_T;
***************
*** 103,109 ****
  $ldflags = $opt_k ? $opt_k : "";
  
  #
! #  ֥ȥե̾γĥҤ֤
  #
  sub get_objext {
  	if ($^O eq 'cygwin') {
--- 103,109 ----
  $ldflags = $opt_k ? $opt_k : "";
  
  #
! #  ���֥������ȥե�����̾�γ�ĥ�Ҥ��֤�
  #
  sub get_objext {
  	if ($^O eq 'cygwin') {
***************
*** 115,121 ****
  }
  
  #
! #  ץξ򸡺
  #
  sub get_path {
  	my($progname, @pathlist) = @_;
--- 115,121 ----
  }
  
  #
! #  �ץ����ξ��򸡺�����
  #
  sub get_path {
  	my($progname, @pathlist) = @_;
***************
*** 130,136 ****
  }
  
  #
! #  եѴ
  #
  sub convert {
  	my($infile, $outfile) = @_;
--- 130,136 ----
  }
  
  #
! #  �ե�������Ѵ�����
  #
  sub convert {
  	my($infile, $outfile) = @_;
***************
*** 164,170 ****
  }
  
  #
! #  ץ򸫤Ĥƥե
  #
  sub generate {
  	my($file, $mandatory) = @_;
--- 164,170 ----
  }
  
  #
! #  ����ץ�򸫤Ĥ��ƥե��������������
  #
  sub generate {
  	my($file, $mandatory) = @_;
***************
*** 183,189 ****
  }
  
  #
! #  ǥ쥯ȥ̾Ф
  #
  $pwd = `pwd`; chop $pwd;
  if ($opt_D) {
--- 183,189 ----
  }
  
  #
! #  �������ǥ��쥯�ȥ�̾����Ф�
  #
  $pwd = `pwd`; chop $pwd;
  if ($opt_D) {
***************
*** 208,214 ****
  $templatedir = $opt_t ? $opt_t : $srcdir."/sample";
  
  #
! #  -Tץγǧ
  #
  unless ($opt_T) {
  	print STDERR "configure: -T option is mandatory\n";
--- 208,214 ----
  $templatedir = $opt_t ? $opt_t : $srcdir."/sample";
  
  #
! #  -T���ץ����γ�ǧ
  #
  unless ($opt_T) {
  	print STDERR "configure: -T option is mandatory\n";
***************
*** 221,227 ****
  }
  
  #
! #  ѿơ֥κ
  #
  %vartable = ();
  $vartable{"TARGET"} = $target;
--- 221,227 ----
  }
  
  #
! #  �ѿ��ơ��֥�κ���
  #
  %vartable = ();
  $vartable{"TARGET"} = $target;
***************
*** 246,252 ****
  $vartable{"LDFLAGS"} = $ldflags;
  
  #
! #  åȥǥ쥯ȥΥå
  #
  
  if (! -d $srcdir."/target/".$target) {
--- 246,252 ----
  $vartable{"LDFLAGS"} = $ldflags;
  
  #
! #  �������åȥǥ��쥯�ȥ�Υ����å�
  #
  
  if (! -d $srcdir."/target/".$target) {
***************
*** 255,261 ****
  }
  
  #
! #  Makefile ȥץꥱե
  #
  
  generate($makefile, 1);
--- 255,261 ----
  }
  
  #
! #  Makefile �ȥ��ץꥱ�������ե����������
  #
  
  generate($makefile, 1);
***************
*** 265,271 ****
  generate($applname.".cfg", 0);
  
  #
! #  cfg ǤƤ뤫Υå
  #
  
  if (!(-x ($objext eq "" ? $cfgfile : $cfgfile.".".$objext))) {
--- 265,271 ----
  generate($applname.".cfg", 0);
  
  #
! #  cfg ���Ǥ��Ƥ��뤫�Υ����å�
  #
  
  if (!(-x ($objext eq "" ? $cfgfile : $cfgfile.".".$objext))) {
diff -cr --new-file 1.9.1/asp/driver/include/mmc_sdcard.h ASPs/asp/driver/include/mmc_sdcard.h
*** 1.9.1/asp/driver/include/mmc_sdcard.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/include/mmc_sdcard.h	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,73 ----
+ /*
+  * Copyright (c) 2016- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ #include <target_board.h>
+ 
+ /* Status of Disk Functions */
+ typedef uint8_t DSTATUS;
+ 
+ /* Results of Disk Functions */
+ typedef enum {
+ 	RES_OK = 0,		/* 0: Successful */
+ 	RES_ERROR,		/* 1: R/W Error */
+ 	RES_WRPRT,		/* 2: Write Protected */
+ 	RES_NOTRDY,		/* 3: Not Ready */
+ 	RES_PARERR		/* 4: Invalid Parameter */
+ } DRESULT;
+ 
+ 
+ typedef struct mmc_function_t{
+   DSTATUS (*mmc_disk_initialize)(void* stat);
+   DSTATUS (*mmc_disk_status)(void* stat);
+   DRESULT (*mmc_disk_read)(void* stat, uint8_t* buff, uint32_t sector, uint32_t count);
+   DRESULT (*mmc_disk_write)(void* stat, const uint8_t* buf, uint32_t sector, uint32_t count);
+   DRESULT (*mmc_disk_ioctl)(void* stat, uint8_t cmd, void* buff);
+ }mmc_func_t;
+   
+ /* Disk Status Bits (DSTATUS) */
+ 
+ #define STA_NOINIT		0x01	/* Drive not initialized */
+ #define STA_NODISK		0x02	/* No medium in the drive */
+ #define STA_PROTECT		0x04	/* Write protected */
+ 
+ 
+ /* Command code for disk_ioctrl fucntion */
+ 
+ /* Generic command (Used by FatFs) */
+ #define CTRL_SYNC			0	/* Complete pending write process (needed at _FS_READONLY == 0) */
+ #define GET_SECTOR_COUNT	1	/* Get media size (needed at _USE_MKFS == 1) */
+ #define GET_SECTOR_SIZE		2	/* Get sector size (needed at _MAX_SS != _MIN_SS) */
+ #define GET_BLOCK_SIZE		3	/* Get erase block size (needed at _USE_MKFS == 1) */
+ #define CTRL_TRIM			4	/* Inform device that the data on the block of sectors is no longer used (needed at _USE_TRIM == 1) */
+ 
+ /* Generic command (Not used by FatFs) */
+ #define CTRL_POWER			5	/* Get/Set power status */
+ #define CTRL_LOCK			6	/* Lock/Unlock media removal */
+ #define CTRL_EJECT			7	/* Eject media */
+ #define CTRL_FORMAT			8	/* Create physical format on the media */
+ 
+ /* MMC/SDC specific ioctl command */
+ #define MMC_GET_TYPE		10	/* Get card type */
+ #define MMC_GET_CSD			11	/* Get CSD */
+ #define MMC_GET_CID			12	/* Get CID */
+ #define MMC_GET_OCR			13	/* Get OCR */
+ #define MMC_GET_SDSTAT		14	/* Get SD status */
+ 
+ /* ATA/CF specific ioctl command */
+ #define ATA_GET_REV			20	/* Get F/W revision */
+ #define ATA_GET_MODEL		21	/* Get model name */
+ #define ATA_GET_SN			22	/* Get serial number */
+ 
+ /* MMC card type flags (MMC_GET_TYPE) */
+ #define CT_MMC          0x01            /* MMC ver 3 */
+ #define CT_SD1          0x02            /* SD ver 1 */
+ #define CT_SD2          0x04            /* SD vdr 2 */
+ #define CT_SDC          (CT_SD1|CT_SD2) /* SD */
+ #define CT_BLOCK        0x08            /* Block addressing */
+ 
+ extern const dnode_id pdrv_to_dev[];
+ 
+ #define _USE_WRITE 1
+ #define _USE_IOCTL 1
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/CMTW.c ASPs/asp/driver/rx_gcc/CMTW.c
*** 1.9.1/asp/driver/rx_gcc/CMTW.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/CMTW.c	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,53 ----
+ /*
+  * Copyright (c) 2018- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ 
+ #include <kernel_impl.h>
+ #include <driver/rx_gcc/CMTW.h>
+ //#include <sil.h>
+ //#include <target_board.h>
+ 
+ #define CMTW_CMWSTR_OFFSET 0x0
+ #define CMTW_CMWCR_OFFSET 0x4
+ #define CMTW_CMWIOR_OFFSET 0x8
+ #define CMTW_CMWCNT_OFFSET 0x10
+ #define CMTW_CMWCOR_OFFSET 0x14
+ #define CMTW_CMWICR0_OFFSET 0x18
+ #define CMTW_CMWICR1_OFFSET 0x1C
+ #define CMTW_CMWOCR0_OFFSET 0x20
+ #define CMTW_CMWOCR1_OFFSET 0x24
+ //CMSTR
+ #define CMTW_CMWSTR_STR_BIT 0x1
+ 
+ static inline void write_cmtw_reg(dnode_id stat_id, uint32_t offset, uint16_t val){
+   cmtw_dstat *cmtw_stat = (cmtw_dstat*)GET_DEV_STAT(stat_id);
+   DEV_WRH(cmtw_stat->baddr, offset, val);
+ }
+ 
+ void cmtw_count_start(dnode_id stat_id){
+   write_cmtw_reg(stat_id, CMTW_CMWSTR_OFFSET, CMTW_CMWSTR_STR_BIT);
+ }
+ 
+ void cmtw_count_stop(dnode_id stat_id){
+   write_cmtw_reg(stat_id, CMTW_CMWSTR_OFFSET, 0);
+ }
+ 
+ void config_cmwcr_count_mode(dnode_id stat_id, uint16_t config_val){
+   write_cmtw_reg(stat_id, CMTW_CMWCR_OFFSET, config_val);
+ }
+ 
+ void config_cmwcr_io_mode(dnode_id stat_id, uint16_t config_val){
+   write_cmtw_reg(stat_id, CMTW_CMWIOR_OFFSET, config_val);
+ }
+ 
+ uint32_t cmtw_get_count(dnode_id stat_id){
+   return DEV_REW(((cmtw_dstat*) GET_DEV_STAT(stat_id))->baddr, CMTW_CMWCNT_OFFSET);
+ }
+ 
+ void cmtw_init(dnode_id stat_id){
+   cmtw_dstat *cmtw_stat = (cmtw_dstat*)GET_DEV_STAT(stat_id);
+   DEV_WRH(cmtw_stat->baddr, CMTW_CMWCR_OFFSET, 0);
+   DEV_WRH(cmtw_stat->baddr, CMTW_CMWIOR_OFFSET, 0);
+ }
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/CMTW.h ASPs/asp/driver/rx_gcc/CMTW.h
*** 1.9.1/asp/driver/rx_gcc/CMTW.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/CMTW.h	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,69 ----
+ /*
+  * Copyright (c) 2018- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ #ifndef RX_GCC_DRIVER_CMTW_H
+ #define RX_GCC_DRIVER_CMTW_H
+ 
+ #include <target_board.h>
+ 
+ typedef struct cmtw_dev_status_type{
+   uint32_t baddr; //base address
+ } cmtw_dstat;
+ 
+ 
+ #define CMWCR_CKS_DIV8 0x0
+ #define CMWCR_CKS_DIV32 0x1
+ #define CMWCR_CKS_DIV128 0x2
+ #define CMWCR_CKS_DIV512 0x3
+ #define CMWCR_CMWIE_EN 0x8
+ #define CMWCR_CMWIE_DIS 0x0
+ #define CMWCR_IC0IE_EN 0x10
+ #define CMWCR_IC0IE_DIS 0x0
+ #define CMWCR_IC1IE_EN 0x20
+ #define CMWCR_IC1IE_DIS 0x0
+ #define CMWCR_OC0IE_EN 0x40
+ #define CMWCR_OC0IE_DIS 0x0
+ #define CMWCR_OC1IE_EN 0x80
+ #define CMWCR_OC1IE_DIS 0x0
+ #define CMWCR_CMS_16BIT 0x200
+ #define CMWCR_CMS_32BIT 0x0
+ #define CMWCR_CCLR_CLR_DIS 0x2000
+ #define CMWCR_CCLR_CMWICR0_INTCLR 0x8000
+ #define CMWCR_CCLR_CMWICR1_INTCLR 0xA000
+ #define CMWCR_CCLR_CMWOCR0_COMCLR 0xC000
+ #define CMWCR_CCLR_CMWOCR1_COMCLR 0xE000
+ 
+ 
+ #define CMTW_CMWIOR_IC0_RISE 0x1
+ #define CMTW_CMWIOR_IC0_FALL 0x2
+ #define CMTW_CMWIOR_IC0_DUAL 0x3
+ #define CMTW_CMWIOR_IC1_RISE 0x4
+ #define CMTW_CMWIOR_IC1_FALL 0x8
+ #define CMTW_CMWIOR_IC1_DUAL 0xC
+ #define CMTW_CMWIOR_IC0E_EN 0x10
+ #define CMTW_CMWIOR_IC0E_DIS 0x0
+ #define CMTW_CMWIOR_IC1E_EN 0x20
+ #define CMTW_CMWIOR_IC1E_DIS 0x0
+ #define CMTW_CMWIOR_OC0_OUT_RETENT 0x0
+ #define CMTW_CMWIOR_OC0_H_TOGGLE 0x100
+ #define CMTW_CMWIOR_OC0_L_TOGGLE 0x300
+ #define CMTW_CMWIOR_OC1_OUT_RETENT 0x0
+ #define CMTW_CMWIOR_OC1_H_TOGGLE 0x400
+ #define CMTW_CMWIOR_OC1_L_TOGGLE 0xC00
+ #define CMTW_CMWIOR_OC0E_EN 0x1000
+ #define CMTW_CMWIOR_OC0E_DIS 0x0
+ #define CMTW_CMWIOR_OC1E_EN 0x2000
+ #define CMTW_CMWIOR_OC1E_DIS 0x0
+ #define CMTW_CMWIOR_CMWE_EN 0x8000
+ #define CMTW_CMWIOR_CMWE_DIS 0x0
+ 
+ void cmtw_count_start(dnode_id stat_id);
+ void cmtw_count_stop(dnode_id stat_id);
+ void config_cmwcr_count_mode(dnode_id stat_id, uint16_t config_val);
+ void config_cmwcr_io_mode(dnode_id stat_id, uint16_t config_val);
+ uint32_t cmtw_get_count(dnode_id stat_id);
+ void cmtw_init(dnode_id stat_id);;
+ 
+ #endif
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/DTCa.c ASPs/asp/driver/rx_gcc/DTCa.c
*** 1.9.1/asp/driver/rx_gcc/DTCa.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/DTCa.c	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,125 ----
+ /*
+  * Copyright (c) 2015- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ #include <kernel_impl.h>
+ #include <driver/rx_gcc/DTCa.h>
+ 
+ //DTC register define
+ //#define DID_DTCA     //defined in target_device_id.h
+ #define DTC_DTCCR (DTCA_BASE_ADDR+0x0)
+ #define DTC_DTCVBR (DTCA_BASE_ADDR+0x4)
+ #define DTC_DTCADMOD (DTCA_BASE_ADDR+0x8)
+ #define DTC_DTCST (DTCA_BASE_ADDR+0xC)
+ #define DTC_DTCSTS (DTCA_BASE_ADDR+0xE)
+ 
+ extern dtca_descriptor *dtca_vect[];
+ 
+ void set_vecter_table(uint8_t intno, dtca_descriptor *vecter){
+   dtca_vect[intno] = vecter;
+ }
+ 
+ //
+ // DTCA Macro Controll
+ //
+ #define DTCA_MODE_ENABLE 0x1
+ #define DTCA_MODE_DISABLE 0x0
+ 
+ void dtca_enable(){
+   sil_wrb_mem((uint8_t*)DTC_DTCST, DTCA_MODE_ENABLE);
+   while(sil_reb_mem((uint8_t*)DTC_DTCST) == DTCA_MODE_DISABLE);
+ }
+ 
+ void dtca_disable(){
+   sil_wrb_mem((uint8_t*)DTC_DTCST, DTCA_MODE_DISABLE);
+ }
+ 
+ //Set DTCER to accept irq.
+ void dtcer_irq_enable(uint8_t intno){
+   ENABLE_ICU_DTCER(intno);
+ }
+ 
+ void dtcer_irq_disable(uint8_t intno){
+   DISABLE_ICU_DTCER(intno);
+ }
+ 
+ //Deccriptor control
+ 
+ #define ENTRY_HALF_MASK 0xFFFF
+ #define DESC_MAX_ENTRY 32
+ #define DESC_ENTRY_HALF (DESC_MAX_ENTRY >> 1)
+ 
+ static uint32_t reserved_desc_entry;
+ extern dtca_descriptor dtca_desc_table[NUM_DTCA_DESC];
+ 
+ uint8_t desc_bit2id(uint32_t desc_entry_flg){
+   uint32_t current_mask, current_flg;
+   uint8_t que_id, current_offset;
+ 
+   que_id =0;
+   current_offset = DESC_ENTRY_HALF;
+   current_mask = ENTRY_HALF_MASK;
+   current_flg = desc_entry_flg;
+ 
+   if(!desc_entry_flg)
+     return 0;
+ 
+   while(current_offset){
+     if(!(current_flg & current_mask)){
+       que_id+= current_offset;
+       current_flg = current_flg >> current_offset;
+     }
+     current_offset = current_offset >> 1;
+     current_mask = current_mask >> current_offset;
+   }
+   return que_id+1;
+ }
+ 
+ static inline uint32_t assign_buff(uint8_t len){
+   uint8_t i;
+   uint32_t free_entry, seq_free_entry;
+   i=1;
+   seq_free_entry = free_entry = ~reserved_desc_entry;
+   while(i != len){
+     seq_free_entry &= (free_entry << i);
+     i++;
+   }
+ 
+   seq_free_entry &= (~seq_free_entry+1);
+   return seq_free_entry >> (len-1);
+ }
+ 
+ int8_t dtca_get_desc_buff(desc_buff* dbuff, uint8_t len){
+   uint8_t que_id, i;
+   uint32_t assigned_entry;
+ 
+   if(!(assigned_entry = assign_buff(len))){
+     dbuff->desc = 0;
+     return DESC_ER;
+   }
+ 
+   que_id = desc_bit2id(assigned_entry);
+ 
+   dbuff->buff_entry = 0;
+   for(i=0; i<len; i++){
+     dbuff->buff_entry |= (assigned_entry << i);
+   }
+   reserved_desc_entry |= dbuff->buff_entry;
+ 
+   dbuff->desc = &dtca_desc_table[que_id-1];
+   return DESC_OK;
+ }
+ 
+ int8_t dtca_rel_desc_buff(desc_buff* dbuff){
+   reserved_desc_entry &= (~dbuff->buff_entry);
+ }
+ 
+ void dtca_init(){
+   //init descriptor entry
+   reserved_desc_entry = 0;
+ 
+   //init descriptor base address
+   sil_wrw_lem((uint32_t *)DTC_DTCVBR, (uint32_t)dtca_vect);
+ }
+ 
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/DTCa.h ASPs/asp/driver/rx_gcc/DTCa.h
*** 1.9.1/asp/driver/rx_gcc/DTCa.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/DTCa.h	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,93 ----
+ /*
+  * Copyright (c) 2015- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ 
+ #ifndef RENESAS_RX_DTCA_DRIVER
+ #define RENESAS_RX_DTCA_DRIVER
+ 
+ #ifndef DTCA_MACRO_ONLY
+ #include "target_device/target_device.h"
+ 
+ //DTC discripeter table
+ typedef struct dtca_discripter_table {
+   volatile uint16_t reserv;
+   volatile uint8_t mrb;
+   volatile uint8_t mra;
+   volatile uint32_t sar;
+   volatile uint32_t dar;
+   volatile uint16_t crb;
+   volatile uint16_t cra;
+ }dtca_descriptor;
+ 
+ typedef struct desc_buff_t{
+   dtca_descriptor *desc;
+   uint32_t buff_entry;
+ } desc_buff;
+ 
+ void dtca_init();
+ void set_vecter_table(uint8_t intno, dtca_descriptor *vecter);
+ //descriptor buff control
+ int8_t dtca_get_desc_buff(desc_buff* dbuff, uint8_t len);
+ int8_t dtca_rel_desc_buff(desc_buff* dbuff);
+ 
+ 
+ //
+ // DTCA Macro Controll
+ //
+ void dtca_enable();
+ void dtca_disable();
+ 
+ //Set DTCER to accept irq.
+ void dtcer_irq_enable(uint8_t intno);
+ void dtcer_irq_disable(uint8_t intno);
+ 
+ //Descriptor buff control
+ #define DESC_OK 0
+ #define DESC_ER -1
+ 
+ //DTC register define
+ //#define DID_DTCA     //defined in target_device_id.h
+ #define DTC_DTCCR (DTCA_BASE_ADDR+0x0)
+ #define DTC_DTCVBR (DTCA_BASE_ADDR+0x4)
+ #define DTC_DTCADMOD (DTCA_BASE_ADDR+0x8)
+ #define DTC_DTCST (DTCA_BASE_ADDR+0xC)
+ #define DTC_DTCSTS (DTCA_BASE_ADDR+0xE)
+ 
+ //MRA mode bit
+ #define MRA_SM_CONST_SAR 0x0
+ #define MRA_SM_INC_SAR 0x8
+ #define MRA_SM_DEC_SAR 0xC
+ 
+ #define MRA_SZ_BYTE 0x00
+ #define MRA_SZ_WORD 0x10
+ #define MRA_SZ_LONG 0x20
+ 
+ #define MRA_MD_NORMAL 0x00
+ #define MRA_MD_REPEAT 0x40
+ #define MRA_MD_BLOCK 0x80
+ 
+ //MRB mode bit
+ #define MRB_DM_CONST_DAR 0x0
+ #define MRB_DM_INC_DAR 0x8
+ #define MRB_DM_DEC_DAR 0xC
+ 
+ #define MRB_DTS_SOURCE 0x10
+ #define MRB_DTS_DIST 0x00
+ 
+ #define MRB_MISEL_END_IRQ_REQ 0x00
+ #define MRB_MISEL_TRAN_IRQ_REQ 0x20
+ 
+ #define MRB_CHNS_SEQ 0x00
+ #define MRB_CHNS_CHNG 0x40
+ 
+ #define MRB_CHNE_DIS 0x00
+ #define MRB_CHNE_EN 0x80
+ 
+ #endif //DTCA_MACRO_ONLY
+ 
+ #define DTCA_DESC_SIZE 16 //seize of dtca_descriptor
+ #define NUM_DTCA_DESC 8
+ 
+ #endif
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/ELC.h ASPs/asp/driver/rx_gcc/ELC.h
*** 1.9.1/asp/driver/rx_gcc/ELC.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/ELC.h	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,34 ----
+ /*
+  * Copyright (c) 2018- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ #ifndef RX_GCC_DRIVER_ELC_H
+ #define RX_GCC_DRIVER_ELC_H
+ 
+ #include <target_board.h>
+ 
+ #define ELC_ECLF_OFFSET 0x0
+ #define ELC_ELSR_OFFSET 0x1
+ #define ELC_ELOPA_OFFSET 0x1F
+ #define ELC_ELOPB_OFFSET 0x20
+ #define ELC_ELOPC_OFFSET 0x21
+ #define ELC_ELOPD_OFFSET 0x22
+ #define ELC_ELOPF_OFFSET 0x3F
+ #define ELC_ELOPH_OFFSET 0x41
+ #define ELC_ELOPI_OFFSET 0x42
+ #define ELC_ELOPJ_OFFSET 0x43
+ #define ELC_PGR1_OFFSET 0x23
+ #define ELC_PGR2_OFFSET 0x24
+ #define ELC_PGC1_OFFSET 0x25
+ #define ELC_PGC2_OFFSET 0x26
+ #define ELC_PDBF1_OFFSET 0x27
+ #define ELC_PDBF2_OFFSET 0x28
+ #define ELC_PEL0_OFFSET 0x29
+ #define ELC_PEL1_OFFSET 0x2A
+ #define ELC_PEL2_OFFSET 0x2B
+ #define ELC_PEL3_OFFSET 0x2C
+ #define ELC_ELSEGR_OFFSET 0x2D
+ 
+ 
+ #endif
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/EPTPC.c ASPs/asp/driver/rx_gcc/EPTPC.c
*** 1.9.1/asp/driver/rx_gcc/EPTPC.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/EPTPC.c	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,345 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2017- by Hisashi Hata, JAPAN
+  *
+  * The above copyright holders grant permission gratis to use,
+  * duplicate, modify, or redistribute (hereafter called use) this
+  * software (including the one made by modifying this software),
+  * provided that the following four conditions (1) through (4) are
+  * satisfied.
+  *
+  * (1) When this software is used in the form of source code, the above
+  *     copyright notice, this use conditions, and the disclaimer shown
+  *     below must be retained in the source code without modification.
+  *
+  * (2) When this software is redistributed in the forms usable for the
+  *     development of other software, such as in library form, the above
+  *     copyright notice, this use conditions, and the disclaimer shown
+  *     below must be shown without modification in the document provided
+  *     with the redistributed software, such as the user manual.
+  *
+  * (3) When this software is redistributed in the forms unusable for the
+  *     development of other software, such as the case when the software
+  *     is embedded in a piece of equipment, either of the following two
+  *     conditions must be satisfied:
+  *
+  *   (a) The above copyright notice, this use conditions, and the
+  *       disclaimer shown below must be shown without modification in
+  *       the document provided with the redistributed software, such as
+  *     the user manual.
+  *
+  *   (b) How the software is to be redistributed must be reported to the
+  *       TOPPERS Project according to the procedure described
+  *       separately.
+  *
+  * (4) The above copyright holders and the TOPPERS Project are exempt
+  *     from responsibility for any type of damage directly or indirectly
+  *     caused from the use of this software and are indemnified by any
+  *     users or end users of this software from any and all causes of
+  *     action whatsoever.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS." THE ABOVE COPYRIGHT HOLDERS AND
+  * THE TOPPERS PROJECT DISCLAIM ANY EXPRESS OR IMPLIED WARRANTIES,
+  * INCLUDING, BUT NOT LIMITED TO, ITS APPLICABILITY TO A PARTICULAR
+  * PURPOSE. IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS AND THE
+  * TOPPERS PROJECT BE LIABLE FOR ANY TYPE OF DAMAGE DIRECTLY OR
+  * INDIRECTLY CAUSED FROM THE USE OF THIS SOFTWARE.
+  */
+ 
+ #include <kernel_impl.h>
+ #include <driver/rx_gcc/EPTPC.h>
+ 
+ static void init_synfp(PTPINI* pini);
+ 
+ #define EPTPC_RESET 0
+ #define EPTPC_OPERATION 1
+ 
+ static uint8_t eptpc_state = EPTPC_RESET;
+   
+ uint32_t get_port_base(PTPINI* pini){
+   if(pini->port->ptp_mode & EPTPC_MODE_PORT0){
+     return EPTPC_PORT0_BASEADDR;
+   }
+   else{
+     return EPTPC_PORT1_BASEADDR;
+   }
+ }
+ 
+ void eptpc_reset(){
+   volatile uint32_t i;
+   //enable EPTP reset
+   sil_wrw_mem((uint32_t*)EPTPC_PTRSTR_ADDR, EPTPC_PTRSTR_RESET);
+   //wait more than 64 PCLK cycle */
+   for(i=64; i>0; i--);
+   //relese reset
+   sil_wrw_mem((uint32_t*)EPTPC_PTRSTR_ADDR, 0);
+   eptpc_state = EPTPC_RESET;
+ }
+ 
+ void eptpc_init(PTPINI* pini){
+   uint32_t port_mode;
+   uint32_t port_base;
+   //reset eptpc
+   eptpc_reset();
+ 
+   port_mode = pini->port->ptp_mode;
+   port_base = get_port_base(pini);
+   //select use port
+   if(port_mode & EPTPC_MODE_PORT0){
+     //port0 select
+     sil_wrw_mem((uint32_t*)EPTPC_STCHSELR_ADDR, 0);
+   }
+   else if(port_mode & EPTPC_MODE_PORT1){
+     //port1 select
+     sil_wrw_mem((uint32_t*)EPTPC_STCHSELR_ADDR, EPTPC_STCHSELR_SYSEL);
+   }
+ 
+   //set eptpc intterupt mask. disable all
+   sil_wrw_mem((uint32_t*)EPTPC_MIEIPR_ADDR, 0);
+   sil_wrw_mem((uint32_t*)EPTPC_STIPR_ADDR, 0);
+   sil_wrw_mem((uint32_t*)EPTPC_PRIPR_ADDR, 0);
+   sil_wrw_mem((uint32_t*)(EPTPC_SYIPR_OFFSET+port_base), 0);
+ 
+   init_synfp(pini);
+ 
+   //set PTP reception filters. support only ordinary e2e clock
+   //config port 0
+   
+   if(port_mode & EPTPC_MODE_P2P){
+     ;//P2P mode not support
+   }
+   else{
+     if(port_mode & EPTPC_MODE_MASTER){
+       //master port
+       sil_wrw_mem((uint32_t*)(EPTPC_SYRFL1R_OFFSET + port_base), 0x00004000);
+       sil_wrw_mem((uint32_t*)(EPTPC_SYRFL2R_OFFSET + port_base), 0x00000000);
+       sil_wrw_mem((uint32_t*)(EPTPC_SYCONFR_OFFSET + port_base), 0x00000028);
+     }
+     else{
+       //slave port
+       sil_wrw_mem((uint32_t*)(EPTPC_SYRFL1R_OFFSET + port_base), 0x00040440);
+       sil_wrw_mem((uint32_t*)(EPTPC_SYRFL2R_OFFSET + port_base), 0x00000000);
+       sil_wrw_mem((uint32_t*)(EPTPC_SYCONFR_OFFSET + port_base), 0x00000028);
+     }
+   }
+ 
+ 
+   sil_wrw_mem((uint32_t*)(EPTPC_SYRVLDR_OFFSET+port_base), 0x00000007);
+ 
+   //set transfer mode
+   sil_wrw_mem((uint32_t*)EPTPC_TRNMR_ADDR, 0x0); //stor and forward mode
+ 
+   //set intterupt
+   sil_wrw_mem((uint32_t*)EPTPC_MIESR_ADDR, 0x3F0000);
+   sil_wrw_mem((uint32_t*)EPTPC_STSR_ADDR, (EPTPC_STSR_SYNC | EPTPC_STSR_SYNCOUT | EPTPC_STSR_SYNTOUT | EPTPC_STSR_W10D));
+   sil_wrw_mem((uint32_t*)EPTPC_PRSR_ADDR, (EPTPC_PRSR_URE1 | EPTPC_PRSR_URE0 | EPTPC_PRSR_MACE |
+                                EPTPC_PRSR_OVRE3 | EPTPC_PRSR_OVRE2 | EPTPC_PRSR_OVRE1 |
+                                 EPTPC_PRSR_OVRE0) );
+   sil_wrw_mem((uint32_t*)(EPTPC_SYSR_OFFSET+port_base), 0x00035277);
+ 
+   
+   sil_wrw_mem((uint32_t*)(EPTPC_SYIPR_OFFSET+port_base), 0x0);
+   //interrupt disable
+   sil_wrw_mem((uint32_t*)EPTPC_MIEIPR_ADDR, 0);
+   eptpc_state = EPTPC_OPERATION;
+ }
+ 
+ static void init_synfp(PTPINI* pini){
+   PTP_PORT* pc;
+   uint32_t port_base;
+   pc = pini->port;
+ 
+   port_base = get_port_base(pini);
+ 
+   //config messeage flag
+   sil_wrw_mem((uint32_t*)(EPTPC_ANFR_OFFSET + port_base), PTP_CFG_ANNOUNCE_FLAG);
+   sil_wrw_mem((uint32_t*)(EPTPC_SYNFR_OFFSET + port_base), PTP_CFG_SYNC_FLAG);
+   sil_wrw_mem((uint32_t*)(EPTPC_DYRQFR_OFFSET + port_base), PTP_CFG_DYRQFR_FLAG);
+   sil_wrw_mem((uint32_t*)(EPTPC_DYRPFR_OFFSET + port_base), PTP_CFG_DYRPFR_FLAG);
+   //set clock id
+   //only support EUI48
+   sil_wrw_mem((uint32_t*)(EPTPC_SYCIDRU_OFFSET + port_base), pc->self_clkid[0]);
+   sil_wrw_mem((uint32_t*)(EPTPC_SYCIDRL_OFFSET + port_base), pc->self_clkid[1]);
+   //set port number
+   //portnumber shall be 1, 2, ....
+   if(pc->ptp_mode & EPTPC_MODE_PORT0)
+     sil_wrw_mem((uint32_t*)(EPTPC_SYPNUMR_OFFSET + port_base), 1);
+   else
+     sil_wrw_mem((uint32_t*)(EPTPC_SYPNUMR_OFFSET + port_base), 2);
+   //synfp transmit enable register
+   sil_wrw_mem((uint32_t*)(EPTPC_SYTRENR_OFFSET + port_base), 0x0); //disable all
+   //set master clock portidentity
+   sil_wrw_mem((uint32_t*)(EPTPC_MTCIDU_OFFSET + port_base), pc->master_clkid[0]);
+   sil_wrw_mem((uint32_t*)(EPTPC_MTCIDL_OFFSET + port_base), pc->master_clkid[1]);
+   sil_wrw_mem((uint32_t*)(EPTPC_MTPID_OFFSET + port_base), pc->master_portnum);
+   //config transmission interval
+   sil_wrw_mem((uint32_t*)(EPTPC_SYTLIR_OFFSET + port_base), (PTP_CFG_TRANCE_ANNOUNCE_INTERVAL
+                                  | (PTP_CFG_TRANCE_SYNC_INTERVAL << 8)
+                                  | (PTP_CFG_TRANCE_DREQ_INTERVAL << 16)));
+   //set Announce message parameer
+   //grandmaster priority
+   sil_wrw_mem((uint32_t*)(EPTPC_GMPR_OFFSET + port_base), (PTP_CFG_GM_PRIORITY_2 | (PTP_CFG_GM_PRIORITY_1 << 16))) ;
+   //grandmaster clockquality
+   sil_wrw_mem((uint32_t*)(EPTPC_GMCQR_OFFSET + port_base), PTP_CFG_GM_CLKQUALITY);
+   //grandmaster port id
+   sil_wrw_mem((uint32_t*)(EPTPC_GMIDRU_OFFSET + port_base), pc->grand_master_clkid[0]);
+   sil_wrw_mem((uint32_t*)(EPTPC_GMIDRL_OFFSET + port_base), pc->grand_master_clkid[1]);
+ 
+   sil_wrw_mem((uint32_t*)(EPTPC_CUOTSR_OFFSET + port_base), ((CURRENT_UTC_OFFSET << 16) | TIME_SOURCE_INTERNAL_OSCILLATOR));
+   sil_wrw_mem((uint32_t*)(EPTPC_SRR_OFFSET + port_base), 0);
+   //Set PTP address
+   sil_wrw_mem((uint32_t*)(EPTPC_PPMACRU_OFFSET + port_base), AE_PDELAY_MECHANISM_MSG_U);  //
+   sil_wrw_mem((uint32_t*)(EPTPC_PPMACRL_OFFSET + port_base), AE_PDELAY_MECHANISM_MSG_L);  //
+   sil_wrw_mem((uint32_t*)(EPTPC_PDMACRU_OFFSET + port_base), PDELAY_MECHANISM_MSG_U);  //
+   sil_wrw_mem((uint32_t*)(EPTPC_PDMACRL_OFFSET + port_base), PDELAY_MECHANISM_MSG_L);  //
+   sil_wrw_mem((uint32_t*)(EPTPC_PETYPER_OFFSET + port_base), PTP_ETHERTYPE );  //
+   //set UDP PTP parameter
+   sil_wrw_mem((uint32_t*)(EPTPC_PPIPR_OFFSET + port_base), IPV4_PTP_PRIMARY); //ip address setting
+   sil_wrw_mem((uint32_t*)(EPTPC_PDIPR_OFFSET + port_base), IPV4_PTP_PDELAY);  //ip address setting
+   sil_wrw_mem((uint32_t*)(EPTPC_PETOSR_OFFSET + port_base), UDP_PTP_EVENT_TOS);  //tos setting
+   sil_wrw_mem((uint32_t*)(EPTPC_PGTOSR_OFFSET + port_base), UDP_PTP_GENERAL_TOS);
+   sil_wrw_mem((uint32_t*)(EPTPC_PPTTLR_OFFSET + port_base), UDP_PTP_PRIMARY_TTL); //ttl setting
+   sil_wrw_mem((uint32_t*)(EPTPC_PDTTLR_OFFSET + port_base), UDP_PTP_PDELAY_TTL);
+   //filter setting
+   sil_wrw_mem((uint32_t*)(EPTPC_FFLTR_OFFSET + port_base), 0); //filter is disable
+   //set udp port number
+   sil_wrw_mem((uint32_t*)(EPTPC_PEUDPR_OFFSET + port_base), UDP_PTP_EVENT_PORT_NUM);
+   sil_wrw_mem((uint32_t*)(EPTPC_PGUDPR_OFFSET + port_base), UDP_PTP_MCAST_PORT_NUM);
+   //set asymmetric delay. (have to set 0x0)
+   sil_wrw_mem((uint32_t*)(EPTPC_DASYMRU_OFFSET + port_base), 0x0);
+   sil_wrw_mem((uint32_t*)(EPTPC_DASYMRL_OFFSET + port_base), 0x0);
+   //set timestamp latency
+   sil_wrw_mem((uint32_t*)(EPTPC_TSLATR_OFFSET + port_base), ((((uint32_t)pc->inport_delay) << 16)| ((uint32_t)pc->outport_delay)));
+   //set SYNFP frame format. This driver support only ehternet type
+   sil_wrw_mem((uint32_t*)(EPTPC_SYFORMR_OFFSET + port_base), 0x0);
+   //init reception timeout of PTP messages
+   sil_wrw_mem((uint32_t*)(EPTPC_RSTOUTR_OFFSET + port_base),  0x200000); //approx 2s
+ }
+ 
+ 
+ ER eptpc_get_clock(PTPCLK *p_clk){
+   sil_wrw_mem((uint32_t*)EPTPC_GETINFOR_ADDR, EPTPC_GETINFOR_INFO);
+   while(sil_rew_mem((uint32_t*)EPTPC_GETINFOR_ADDR) == EPTPC_GETINFOR_INFO);
+ 
+   p_clk->nano_sec = sil_rew_mem((uint32_t*)EPTPC_LCCVRL_ADDR);
+   p_clk->sec_l = sil_rew_mem((uint32_t*)EPTPC_LCCVRM_ADDR);
+   p_clk->sec_h = sil_rew_mem((uint32_t*)EPTPC_LCCVRU_ADDR);
+   return E_OK;
+ }
+ 
+ ER eptpc_set_clock(PTPCLK *p_clk){
+   sil_wrw_mem((uint32_t*)EPTPC_LCIVRL_ADDR, p_clk->nano_sec);
+   sil_wrw_mem((uint32_t*)EPTPC_LCIVRM_ADDR, p_clk->sec_l);
+   sil_wrw_mem((uint32_t*)EPTPC_LCIVRU_ADDR, p_clk->sec_h);
+   sil_wrw_mem((uint32_t*)EPTPC_GETINFOR_ADDR, EPTPC_GETINFOR_INFO);
+   return E_OK;
+ }
+ 
+ //implement R_PTP_Stop r_ptp.c 1504
+ ER set_w10_times(uint32_t w10_time){
+   sil_wrw_mem((uint32_t*)EPTPC_LCIVRU_ADDR, (w10_time & (sil_rew_mem((uint32_t*)EPTPC_STMR_ADDR) & EPTPC_STMR_WINT_MASK)));
+   return E_OK;
+ }
+ 
+ ER ptp_sync_start(PTPINI* pini){
+   uint32_t port_mode, wait_count;
+   uint32_t port_base;
+ 
+   if(eptpc_state == EPTPC_RESET)
+ 	  return EPTPC_UN_INIT;
+   port_base = get_port_base(pini);
+   port_mode = pini->port->ptp_mode;
+ 
+   //set PTP reception filters. support only ordinary e2e clock
+   //config port 0
+   if(port_mode & EPTPC_MODE_P2P){
+     ;//P2P mode not support
+   }
+   else{ //E2E port
+     if(port_mode & EPTPC_MODE_MASTER){
+       //master port
+       sil_wrw_mem((uint32_t*)(EPTPC_SYTRENR_OFFSET + port_base), 0x00000010);
+     }
+     else{
+       //slave port
+       sil_wrw_mem((uint32_t*)(EPTPC_SYTRENR_OFFSET + port_base), 0x00000100);
+       wait_count = 0;
+       //wait offset count update
+       while((sil_rew_mem((uint32_t*)(EPTPC_SYSR_OFFSET+port_base))&EPTPC_SYSR_OFMUD) == 0){
+         if(wait_count > 10){
+           return 0;
+         }
+         wait_count++;
+         dly_tsk(1000);
+       }
+ 
+     }
+   }
+ 
+   sil_wrw_mem((uint32_t*)(EPTPC_SYRVLDR_OFFSET +port_base), 0x00000007);
+ 
+   if(port_mode & EPTPC_MODE_SLAVE){
+     sil_wrw_mem((uint32_t*)EPTPC_SYNSTARTR_ADDR, EPTPC_SYNSTARTR_STR);
+   }
+ 
+   return EPTPC_OK;
+ }
+ 
+ void eptpc_target_config(uint8_t* mac_ad, uint32_t ipclk_conf, uint32_t stca_sel, uint32_t port_mode){
+   uint32_t mac_half;
+   //set mac address
+   if(port_mode & EPTPC_MODE_PORT0){
+     mac_half = (mac_ad[0] << 16) | (mac_ad[1] << 8) | mac_ad[2];
+     sil_wrw_mem((uint32_t*)EPTPC_PRMACRU0_ADDR, mac_half);
+     sil_wrw_mem((uint32_t*)EPTPC_SYMACRU0_ADDR, mac_half);
+     mac_half = (mac_ad[3] << 16) | (mac_ad[4] << 8) | mac_ad[5];
+     sil_wrw_mem((uint32_t*)EPTPC_PRMACRL0_ADDR, mac_half);
+     sil_wrw_mem((uint32_t*)EPTPC_SYMACRL0_ADDR, mac_half);
+   }
+   else{
+     mac_half = (mac_ad[0] << 16) | (mac_ad[1] << 8) | mac_ad[2];
+     sil_wrw_mem((uint32_t*)EPTPC_PRMACRU1_ADDR, mac_half);
+     mac_half = (mac_ad[3] << 16) | (mac_ad[4] << 8) | mac_ad[5];
+     sil_wrw_mem((uint32_t*)EPTPC_PRMACRL1_ADDR, mac_half);
+   }
+   //set ptp port
+   if(port_mode & EPTPC_MODE_PORT0)
+     sil_wrw_mem((uint32_t*)EPTPC_TRNDISR_ADDR, (EPTPC_TRNDISR_TDIS_ETH0 & sil_rew_mem((uint32_t*)EPTPC_TRNDISR_ADDR)));
+   else
+     sil_wrw_mem((uint32_t*)EPTPC_TRNDISR_ADDR, (EPTPC_TRNDISR_TDIS_ETH1 & sil_rew_mem((uint32_t*)EPTPC_TRNDISR_ADDR)));
+   sil_wrw_mem((uint32_t*)EPTPC_SYNTDARU_ADDR, 0x1);
+   sil_wrw_mem((uint32_t*)EPTPC_SYNTDARL_ADDR, 0x1);
+   sil_wrw_mem((uint32_t*)EPTPC_SYNTDBRU_ADDR, 0x2);
+   sil_wrw_mem((uint32_t*)EPTPC_SYNTDARL_ADDR, 0x0);
+   sil_wrw_mem((uint32_t*)EPTPC_SYNTDARU_ADDR, 0x1);
+   //clock config
+   sil_wrw_mem((uint32_t*)EPTPC_STCSELR_ADDR, ipclk_conf);
+   sil_wrw_mem((uint32_t*)EPTPC_STCFR_ADDR, stca_sel);
+   if(port_mode & EPTPC_MODE_PORT0){
+     if(port_mode & EPTPC_MODE_MASTER){
+       //default time of clock TBD
+         sil_wrw_mem((uint32_t*)EPTPC_LCIVRU_ADDR, 0);
+         sil_wrw_mem((uint32_t*)EPTPC_LCIVRM_ADDR, 0);
+         sil_wrw_mem((uint32_t*)EPTPC_LCIVRL_ADDR, 0);
+         sil_wrw_mem((uint32_t*)EPTPC_LCIVLDR_ADDR, EPTPC_LCIVLDR_LOAD);
+     }
+     else
+       sil_wrw_mem((uint32_t*)EPTPC_SYNTOR_ADDR, EPTPC_CFG_SYNC_TOUT);
+   }
+   sil_wrw_mem((uint32_t*)EPTPC_IPTSELR_ADDR, 0);
+   sil_wrw_mem((uint32_t*)EPTPC_MITSELR_ADDR, 0);
+   sil_wrw_mem((uint32_t*)EPTPC_ELTSELR_ADDR, 0);  
+ 
+   sil_wrw_mem((uint32_t*)EPTPC_SYNSTARTR_ADDR, 0);
+ 
+   if(port_mode & EPTPC_MODE_PORT0){
+ 	  sil_wrw_mem((uint32_t*)(EPTPC_SYRVLDR0_ADDR), 0x00000007);
+   }
+   else{
+ 	  sil_wrw_mem((uint32_t*)(EPTPC_SYRVLDR1_ADDR), 0x00000007);
+   }
+ }
+ 
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/EPTPC.h ASPs/asp/driver/rx_gcc/EPTPC.h
*** 1.9.1/asp/driver/rx_gcc/EPTPC.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/EPTPC.h	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,199 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2017- by Hisashi Hata, JAPAN
+  *
+  * The above copyright holders grant permission gratis to use,
+  * duplicate, modify, or redistribute (hereafter called use) this
+  * software (including the one made by modifying this software),
+  * provided that the following four conditions (1) through (4) are
+  * satisfied.
+  *
+  * (1) When this software is used in the form of source code, the above
+  *     copyright notice, this use conditions, and the disclaimer shown
+  *     below must be retained in the source code without modification.
+  *
+  * (2) When this software is redistributed in the forms usable for the
+  *     development of other software, such as in library form, the above
+  *     copyright notice, this use conditions, and the disclaimer shown
+  *     below must be shown without modification in the document provided
+  *     with the redistributed software, such as the user manual.
+  *
+  * (3) When this software is redistributed in the forms unusable for the
+  *     development of other software, such as the case when the software
+  *     is embedded in a piece of equipment, either of the following two
+  *     conditions must be satisfied:
+  *
+  *   (a) The above copyright notice, this use conditions, and the
+  *       disclaimer shown below must be shown without modification in
+  *       the document provided with the redistributed software, such as
+  *     the user manual.
+  *
+  *   (b) How the software is to be redistributed must be reported to the
+  *       TOPPERS Project according to the procedure described
+  *       separately.
+  *
+  * (4) The above copyright holders and the TOPPERS Project are exempt
+  *     from responsibility for any type of damage directly or indirectly
+  *     caused from the use of this software and are indemnified by any
+  *     users or end users of this software from any and all causes of
+  *     action whatsoever.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS." THE ABOVE COPYRIGHT HOLDERS AND
+  * THE TOPPERS PROJECT DISCLAIM ANY EXPRESS OR IMPLIED WARRANTIES,
+  * INCLUDING, BUT NOT LIMITED TO, ITS APPLICABILITY TO A PARTICULAR
+  * PURPOSE. IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS AND THE
+  * TOPPERS PROJECT BE LIABLE FOR ANY TYPE OF DAMAGE DIRECTLY OR
+  * INDIRECTLY CAUSED FROM THE USE OF THIS SOFTWARE.
+  */
+ 
+ 
+ #ifndef RX_GCC_DRIVER_EPTPC_H
+ #define RX_GCC_DRIVER_EPTPC_H
+ 
+ #include <driver/rx_gcc/EPTPC_reg.h>
+ 
+ #define EPTPC_TIMEOUT -1
+ #define EPTPC_UN_INIT -2
+ #define EPTPC_OK 1
+ 
+ typedef struct eptp_init_cons_t {
+   uint32_t ipclk_conf;
+   uint32_t stca_sel;
+ } PTPSYS;
+ 
+ typedef struct eptp_port_conf_t{
+   uint32_t ptp_mode;
+   uint32_t self_clkid[2];
+   uint32_t master_clkid[2];
+   uint32_t grand_master_clkid[2];
+   uint32_t master_portnum;
+   uint16_t inport_delay;   //for TSLATR INGP
+   uint16_t outport_delay;  //for TSLATR EGP
+ } PTP_PORT;
+ 
+ 
+ typedef struct eptp_port_init_t {
+   PTPSYS *sys;
+   PTP_PORT *port;
+ } PTPINI;
+ 
+ typedef struct PTPCLK_T{
+   uint32_t nano_sec;
+   uint32_t sec_l;
+   uint32_t sec_h;
+ }PTPCLK;
+ 
+ //Port mode setting
+ #define EPTPC_MODE_P2P 0x1
+ #define EPTPC_MODE_E2E 0x2
+ #define EPTPC_MODE_MASTER 0x4
+ #define EPTPC_MODE_SLAVE 0x8
+ #define EPTPC_MODE_PORT0 0x10
+ #define EPTPC_MODE_PORT1 0x20
+ //target depend function
+ void eptpc_target_config(uint8_t* mac_ad, uint32_t ipclk_conf, uint32_t stca_sel, uint32_t port_mode);
+ void eptpc_init(PTPINI* pini);
+ ER ptp_sync_start(PTPINI* pini);
+ 
+ //SYNC timeout
+ #define EPTPC_CFG_SYNC_TOUT (0x03938700)
+ 
+ #define PTP_CFG_ANNOUNCE_FLAG 0x0
+ #define PTP_CFG_SYNC_FLAG 0x0
+ #define PTP_CFG_DYRQFR_FLAG 0x0
+ #define PTP_CFG_DYRPFR_FLAG 0x0
+ //transmmission interval
+ #define PTP_CFG_TRANCE_ANNOUNCE_INTERVAL 0 //1 sec
+ #define PTP_CFG_TRANCE_SYNC_INTERVAL 0xFE //250msex
+ #define PTP_CFG_TRANCE_DREQ_INTERVAL 0x5 //32 sec
+ //current clock param
+ #define PTP_CFG_CUR_UTC_OFFSET 10
+ #define PTP_CFG_TIME_SOURCE
+ 
+ //grandmaster clock property config (TBD, currently dummy)
+ #define PTP_CFG_GM_PRIORITY_1 0x0
+ #define PTP_CFG_GM_PRIORITY_2 0x0
+ #define PTP_CFG_GM_CLKQUALITY 0x0
+ #define PTP_CFG_GM_PORTID_U 0x100203FF
+ #define PTP_CFG_GM_PORTID_L 0xFE040506
+ 
+ //PTP define
+ #define CURRENT_UTC_OFFSET (0x0008) /* approx. 1588 spec AnnexB B.2 */
+ #define PTP2NTP_OFFSET (2208988800) /* 2,208,988,800 sec */
+ #define NTP_SEC (3668572800) /* NTP(Network Time Protocol) second, 2016/03/31 08:00:00, 3,668,572,800 sec */
+ #define PTP_SEC (NTP_SEC - PTP2NTP_OFFSET + CURRENT_UTC_OFFSET) /* PTP second */
+ //timeSource enumeration
+ #define TIME_SOURCE_ATOMIC_CLK 0x10
+ #define TIME_SOURCE_GPS 0x20
+ #define TIME_SOURCE_TERRESTRIAL_RADIO 0x30
+ #define TIME_SOURCE_PTP 0x40
+ #define TIME_SOURCE_NTP 0x50
+ #define TIME_SOURCE_HAND_SET 0x60
+ #define TIME_SOURCE_OTHER 0x90
+ #define TIME_SOURCE_INTERNAL_OSCILLATOR 0xA0
+ 
+ //Ethertype define (Annex F.2)
+ #define PTP_ETHERTYPE 0x88F7
+ //PTP MAC address define(Annex F.3)
+ //All except peer delay mechanism messages
+ #define AE_PDELAY_MECHANISM_MSG_U 0x00011B19
+ #define AE_PDELAY_MECHANISM_MSG_L 0x00000000
+ //Peer delay mechanism messages
+ #define PDELAY_MECHANISM_MSG_U 0x000180C2
+ #define PDELAY_MECHANISM_MSG_L 0x0000000E
+ //PTP UDP IP define(Annex D.3)
+ //PTP-primary
+ #define IPV4_PTP_PRIMARY  0xE0000181 //224.0.1.129
+ //PTP-pdelay
+ #define IPV4_PTP_PDELAY 0xE000006B //224.0.0.107
+ //PTP TOS TTL(Annex D.4)
+ #define UDP_PTP_EVENT_TOS 0x0
+ #define UDP_PTP_GENERAL_TOS 0x0
+ //udp pdelay ttl (Annex D.3)
+ #define UDP_PTP_PDELAY_TTL 0x1
+ //udp primary ttl
+ #define UDP_PTP_PRIMARY_TTL 0x80 //128
+ //udp port number(annex D.2)
+ #define UDP_PTP_EVENT_PORT_NUM 319
+ #define UDP_PTP_MCAST_PORT_NUM 320
+ 
+ //Time stamp delay parameter(TSLATR config)
+ #define TSLATR_EGP_MII100_STCA20 590
+ #define TSLATR_EGP_MII100_STCA25 625
+ #define TSLATR_EGP_MII100_STCA50 695
+ #define TSLATR_EGP_MII100_STCA100 730
+ #define TSLATR_EGP_MII10_STCA20 7430
+ #define TSLATR_EGP_MII10_STCA25 7465
+ #define TSLATR_EGP_MII10_STCA50 7535
+ #define TSLATR_EGP_MII10_STCA100 7570
+ #define TSLATR_EGP_RMII100_STCA20 770
+ #define TSLATR_EGP_RMII100_STCA25 805
+ #define TSLATR_EGP_RMII100_STCA50 875
+ #define TSLATR_EGP_RMII100_STCA100 910
+ #define TSLATR_EGP_RMII10_STCA20 9230
+ #define TSLATR_EGP_RMII10_STCA25 9265
+ #define TSLATR_EGP_RMII10_STCA50 9335
+ #define TSLATR_EGP_RMII10_STCA100 9370
+ #define TSLATR_INGP_MII100_STCA20 980
+ #define TSLATR_INGP_MII100_STCA25 945
+ #define TSLATR_INGP_MII100_STCA50 875
+ #define TSLATR_INGP_MII100_STCA100 840
+ #define TSLATR_INGP_MII10_STCA20 8180
+ #define TSLATR_INGP_MII10_STCA25 8145
+ #define TSLATR_INGP_MII10_STCA50 8075
+ #define TSLATR_INGP_MII10_STCA100 8015
+ #define TSLATR_INGP_RMII100_STCA20 1060
+ #define TSLATR_INGP_RMII100_STCA25 1025
+ #define TSLATR_INGP_RMII100_STCA50 955
+ #define TSLATR_INGP_RMII100_STCA100 920
+ #define TSLATR_INGP_RMII10_STCA20 8980
+ #define TSLATR_INGP_RMII10_STCA25 8945
+ #define TSLATR_INGP_RMII10_STCA50 8875
+ #define TSLATR_INGP_RMII10_STCA100 8815
+ 
+ #define EPTPC_CFG_W10_TIME 32
+ 
+ #endif
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/EPTPC_reg.h ASPs/asp/driver/rx_gcc/EPTPC_reg.h
*** 1.9.1/asp/driver/rx_gcc/EPTPC_reg.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/EPTPC_reg.h	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,531 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2017- by Hisashi Hata, JAPAN
+  *
+  * The above copyright holders grant permission gratis to use,
+  * duplicate, modify, or redistribute (hereafter called use) this
+  * software (including the one made by modifying this software),
+  * provided that the following four conditions (1) through (4) are
+  * satisfied.
+  *
+  * (1) When this software is used in the form of source code, the above
+  *     copyright notice, this use conditions, and the disclaimer shown
+  *     below must be retained in the source code without modification.
+  *
+  * (2) When this software is redistributed in the forms usable for the
+  *     development of other software, such as in library form, the above
+  *     copyright notice, this use conditions, and the disclaimer shown
+  *     below must be shown without modification in the document provided
+  *     with the redistributed software, such as the user manual.
+  *
+  * (3) When this software is redistributed in the forms unusable for the
+  *     development of other software, such as the case when the software
+  *     is embedded in a piece of equipment, either of the following two
+  *     conditions must be satisfied:
+  *
+  *   (a) The above copyright notice, this use conditions, and the
+  *       disclaimer shown below must be shown without modification in
+  *       the document provided with the redistributed software, such as
+  *     the user manual.
+  *
+  *   (b) How the software is to be redistributed must be reported to the
+  *       TOPPERS Project according to the procedure described
+  *       separately.
+  *
+  * (4) The above copyright holders and the TOPPERS Project are exempt
+  *     from responsibility for any type of damage directly or indirectly
+  *     caused from the use of this software and are indemnified by any
+  *     users or end users of this software from any and all causes of
+  *     action whatsoever.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS." THE ABOVE COPYRIGHT HOLDERS AND
+  * THE TOPPERS PROJECT DISCLAIM ANY EXPRESS OR IMPLIED WARRANTIES,
+  * INCLUDING, BUT NOT LIMITED TO, ITS APPLICABILITY TO A PARTICULAR
+  * PURPOSE. IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS AND THE
+  * TOPPERS PROJECT BE LIABLE FOR ANY TYPE OF DAMAGE DIRECTLY OR
+  * INDIRECTLY CAUSED FROM THE USE OF THIS SOFTWARE.
+  */
+ 
+ 
+ #ifndef RX_GCC_DRIVER_EPTPC_REG_H
+ #define RX_GCC_DRIVER_EPTPC_REG_H
+ 
+ #define EPTPC_BASEADDR 0x000C4000
+ #define EPTPC_MIESR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x0))
+ #define EPTPC_MIESR_CYC5 ((uint32_t)(0x1 << 21))
+ #define EPTPC_MIESR_CYC4 ((uint32_t)(0x1 << 20))
+ #define EPTPC_MIESR_CYC3 ((uint32_t)(0x1 << 19))
+ #define EPTPC_MIESR_CYC2 ((uint32_t)(0x1 << 18))
+ #define EPTPC_MIESR_CYC1 ((uint32_t)(0x1 << 17))
+ #define EPTPC_MIESR_CYC0 ((uint32_t)(0x1 << 16))
+ #define EPTPC_MIESR_PRC ((uint32_t)(0x1 << 3))
+ #define EPTPC_MIESR_SY1 ((uint32_t)(0x1 << 2))
+ #define EPTPC_MIESR_SY0 ((uint32_t)(0x1 << 1))
+ #define EPTPC_MIESR_ST ((uint32_t)0x1)
+ #define EPTPC_MIEIPR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x4))
+ #define EPTPC_MIEIPR_CYC5 ((uint32_t)(0x1 << 21))
+ #define EPTPC_MIEIPR_CYC4 ((uint32_t)(0x1 << 20))
+ #define EPTPC_MIEIPR_CYC3 ((uint32_t)(0x1 << 19))
+ #define EPTPC_MIEIPR_CYC2 ((uint32_t)(0x1 << 18))
+ #define EPTPC_MIEIPR_CYC1 ((uint32_t)(0x1 << 17))
+ #define EPTPC_MIEIPR_CYC0 ((uint32_t)(0x1 << 16))
+ #define EPTPC_MIEIPR_PR ((uint32_t)(0x1 << 3))
+ #define EPTPC_MIEIPR_SY1 ((uint32_t)(0x1 << 2))
+ #define EPTPC_MIEIPR_SY0 ((uint32_t)(0x1 << 1))
+ #define EPTPC_MIEIPR_ST ((uint32_t)0x1)
+ #define EPTPC_ELIPPR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x10))
+ #define EPTPC_ELIPPR_PLSN ((uint32_t)(0x1 << 24))
+ #define EPTPC_ELIPPR_PLSP ((uint32_t)(0x1 << 16))
+ #define EPTPC_ELIPPR_CYCN5 ((uint32_t)(0x1 << 13))
+ #define EPTPC_ELIPPR_CYCN4 ((uint32_t)(0x1 << 12))
+ #define EPTPC_ELIPPR_CYCN3 ((uint32_t)(0x1 << 11))
+ #define EPTPC_ELIPPR_CYCN2 ((uint32_t)(0x1 << 10))
+ #define EPTPC_ELIPPR_CYCN1 ((uint32_t)(0x1 << 9))
+ #define EPTPC_ELIPPR_CYCN0 ((uint32_t)(0x1 << 8))
+ #define EPTPC_ELIPPR_CYCP5 ((uint32_t)(0x1 << 5))
+ #define EPTPC_ELIPPR_CYCP4 ((uint32_t)(0x1 << 4))
+ #define EPTPC_ELIPPR_CYCP3 ((uint32_t)(0x1 << 3))
+ #define EPTPC_ELIPPR_CYCP2 ((uint32_t)(0x1 << 2))
+ #define EPTPC_ELIPPR_CYCP1 ((uint32_t)(0x1 << 1))
+ #define EPTPC_ELIPPR_CYCP0 ((uint32_t)0x1)
+ #define EPTPC_ELIPACR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x14))
+ #define EPTPC_ELIPACR_PLSN ((uint32_t)(0x1 << 24))
+ #define EPTPC_ELIPACR_PLSP ((uint32_t)(0x1 << 16))
+ #define EPTPC_ELIPACR_CYCN5 ((uint32_t)(0x1 << 13))
+ #define EPTPC_ELIPACR_CYCN4 ((uint32_t)(0x1 << 12))
+ #define EPTPC_ELIPACR_CYCN3 ((uint32_t)(0x1 << 11))
+ #define EPTPC_ELIPACR_CYCN2 ((uint32_t)(0x1 << 10))
+ #define EPTPC_ELIPACR_CYCN1 ((uint32_t)(0x1 << 9))
+ #define EPTPC_ELIPACR_CYCN0 ((uint32_t)(0x1 << 8))
+ #define EPTPC_ELIPACR_CYCP5 ((uint32_t)(0x1 << 5))
+ #define EPTPC_ELIPACR_CYCP4 ((uint32_t)(0x1 << 4))
+ #define EPTPC_ELIPACR_CYCP3 ((uint32_t)(0x1 << 3))
+ #define EPTPC_ELIPACR_CYCP2 ((uint32_t)(0x1 << 2))
+ #define EPTPC_ELIPACR_CYCP1 ((uint32_t)(0x1 << 1))
+ #define EPTPC_ELIPACR_CYCP0 ((uint32_t)0x1)
+ #define EPTPC_STSR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x40))
+ #define EPTPC_STSR_W10D ((uint32_t)(0x1 << 4))
+ #define EPTPC_STSR_SYNTOUT ((uint32_t)(0x1 << 3))
+ #define EPTPC_STSR_SYNCOUT ((uint32_t)(0x1 << 1))
+ #define EPTPC_STSR_SYNC ((uint32_t)0x1)
+ #define EPTPC_STIPR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x44))
+ #define EPTPC_STIPR_W10D ((uint32_t)(0x1 << 4))
+ #define EPTPC_STIPR_SYNTOUT ((uint32_t)(0x1 << 3))
+ #define EPTPC_STIPR_SYNCOUT ((uint32_t)(0x1 << 1))
+ #define EPTPC_STIPR_SYNC ((uint32_t)0x1)
+ #define EPTPC_STCFR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x50))
+ #define EPTPC_STCFR_STCF_20M ((uint32_t)0x0)
+ #define EPTPC_STCFR_STCF_25M ((uint32_t)0x1)
+ #define EPTPC_STCFR_STCF_50M ((uint32_t)0x2)
+ #define EPTPC_STCFR_STCF_100M ((uint32_t)0x3)
+ #define EPTPC_STMR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x54))
+ #define EPTPC_STMR_ALEN1 ((uint32_t)(0x1 << 29))
+ #define EPTPC_STMR_ALEN0 ((uint32_t)(0x1 << 28))
+ #define EPTPC_STMR_DVTH ((uint32_t)(0x1 << 20))
+ #define EPTPC_STMR_SYTH ((uint32_t)(0x1 << 16))
+ #define EPTPC_STMR_W10S ((uint32_t)(0x1 << 15))
+ #define EPTPC_STMR_CMOD ((uint32_t)(0x1 << 13))
+ #define EPTPC_STMR_WINT_MASK ((uint32_t)0xff)
+ #define EPTPC_SYNTOR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x58))
+ #define EPTPC_IPTSELR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x60))
+ #define EPTPC_IPTSELR_IPTSEL5 ((uint32_t)(0x1 << 5))
+ #define EPTPC_IPTSELR_IPTSEL4 ((uint32_t)(0x1 << 4))
+ #define EPTPC_IPTSELR_IPTSEL3 ((uint32_t)(0x1 << 3))
+ #define EPTPC_IPTSELR_IPTSEL2 ((uint32_t)(0x1 << 2))
+ #define EPTPC_IPTSELR_IPTSEL1 ((uint32_t)(0x1 << 1))
+ #define EPTPC_IPTSELR_IPTSEL0 ((uint32_t)0x1)
+ #define EPTPC_MITSELR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x64))
+ #define EPTPC_MITSELR_MINTEN5 ((uint32_t)(0x1 << 5))
+ #define EPTPC_MITSELR_MINTE4 ((uint32_t)(0x1 << 4))
+ #define EPTPC_MITSELR_MINTE3 ((uint32_t)(0x1 << 3))
+ #define EPTPC_MITSELR_MINTE2 ((uint32_t)(0x1 << 2))
+ #define EPTPC_MITSELR_MINTE1 ((uint32_t)(0x1 << 1))
+ #define EPTPC_MITSELR_MNTE0 ((uint32_t)0x1)
+ #define EPTPC_ELTSELR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x68))
+ #define EPTPC_ELTSELR_ELTDIS5 ((uint32_t)(0x1 << 5))
+ #define EPTPC_ELTSELR_ELTDIS4 ((uint32_t)(0x1 << 4))
+ #define EPTPC_ELTSELR_ELTDIS3 ((uint32_t)(0x1 << 3))
+ #define EPTPC_ELTSELR_ELTDIS2 ((uint32_t)(0x1 << 2))
+ #define EPTPC_ELTSELR_ELTDIS1 ((uint32_t)(0x1 << 1))
+ #define EPTPC_ELTSELR_ELTDIS0 ((uint32_t)0x1)
+ #define EPTPC_STCHSELR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x6c))
+ #define EPTPC_STCHSELR_SYSEL ((uint32_t)0x1)
+ #define EPTPC_SYNSTARTR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x80))
+ #define EPTPC_SYNSTARTR_STR ((uint32_t)0x1)
+ #define EPTPC_LCIVLDR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x84))
+ #define EPTPC_LCIVLDR_LOAD ((uint32_t)0x1)
+ #define EPTPC_SYNTDARU_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x90))
+ #define EPTPC_SYNTDARL_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x94))
+ #define EPTPC_SYNTDBRU_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x98))
+ #define EPTPC_SYNTDBRL_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x9c))
+ #define EPTPC_LCIVRU_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0xb0))
+ #define EPTPC_LCIVRM_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0xb4))
+ #define EPTPC_LCIVRL_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0xb8))
+ #define EPTPC_GETW10R_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x124))
+ #define EPTPC_GETW10R_GW10 ((uint32_t)0x1)
+ #define EPTPC_PLIMITRU_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x128))
+ #define EPTPC_PLIMITRM_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x12c))
+ #define EPTPC_PLIMTRL_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x130))
+ #define EPTPC_MLIMITRU_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x134))
+ #define EPTPC_MLIMITRM_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x138))
+ #define EPTPC_MLIMITRL_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x13c))
+ #define EPTPC_GETINFOR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x140))
+ #define EPTPC_GETINFOR_INFO ((uint32_t)0x1)
+ #define EPTPC_LCCVRU_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x170))
+ #define EPTPC_LCCVRM_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x174))
+ #define EPTPC_LCCVRL_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x178))
+ #define EPTPC_PW10VRU_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x210))
+ #define EPTPC_PW10VRM_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x214))
+ #define EPTPC_PW10VRL_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x218))
+ #define EPTPC_MW10RU_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x2d0))
+ #define EPTPC_MW10RM_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x2d4))
+ #define EPTPC_MW10RL_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x2d8))
+ #define EPTPC_TMSTTRU0_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x300))
+ #define EPTPC_TMSTTRL0_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x304))
+ #define EPTPC_TMSTTRU1_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x310))
+ #define EPTPC_TMSTTRL1_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x314))
+ #define EPTPC_TMSTTRU2_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x320))
+ #define EPTPC_TMSTTRL2_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x324))
+ #define EPTPC_TMSTTRU3_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x330))
+ #define EPTPC_TMSTTRL3_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x334))
+ #define EPTPC_TMSTTRU4_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x340))
+ #define EPTPC_TMSTTRL4_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x344))
+ #define EPTPC_TMSTTRU5_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x50))
+ #define EPTPC_TMSTTRL5_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x54))
+ #define EPTPC_TMCYCR0_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x308))
+ #define EPTPC_TMCYCR1_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x318))
+ #define EPTPC_TMCYCR2_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x328))
+ #define EPTPC_TMCYCR3_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x338))
+ #define EPTPC_TMCYCR4_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x348))
+ #define EPTPC_TMCYCR5_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x358))
+ #define EPTPC_TMPLSR0_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x30c))
+ #define EPTPC_TMPLSR1_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x31c))
+ #define EPTPC_TMPLSR2_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x32c))
+ #define EPTPC_TMPLSR3_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x33c))
+ #define EPTPC_TMPLSR4_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x34c))
+ #define EPTPC_TMPLSR5_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x35c))
+ #define EPTPC_TMSTARTR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x37c))
+ #define EPTPC_TMSTARTR_EN5 ((uint32_t)(0x1 << 5))
+ #define EPTPC_TMSTARTR_EN4 ((uint32_t)(0x1 << 4))
+ #define EPTPC_TMSTARTR_EN3 ((uint32_t)(0x1 << 3))
+ #define EPTPC_TMSTARTR_EN2 ((uint32_t)(0x1 << 2))
+ #define EPTPC_TMSTARTR_EN1 ((uint32_t)(0x1 << 1))
+ #define EPTPC_TMSTARTR_EN0 ((uint32_t)0x1)
+ #define EPTPC_PRSR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x400))
+ #define EPTPC_PRSR_URE1 ((uint32_t)(0x1 << 29))
+ #define EPTPC_PRSR_URE0 ((uint32_t)(0x1 << 28))
+ #define EPTPC_PRSR_MACE ((uint32_t)(0x1 << 8))
+ #define EPTPC_PRSR_OVRE3 ((uint32_t)(0x1 << 3))
+ #define EPTPC_PRSR_OVRE2 ((uint32_t)(0x1 << 2))
+ #define EPTPC_PRSR_OVRE1 ((uint32_t)(0x1 << 1))
+ #define EPTPC_PRSR_OVRE0 ((uint32_t)0x1)
+ #define EPTPC_PRIPR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x404))
+ #define EPTPC_PRIPR_URE1 ((uint32_t)(0x1 << 29))
+ #define EPTPC_PRIPR_URE0 ((uint32_t)(0x1 << 28))
+ #define EPTPC_PRIPR_MACE ((uint32_t)(0x1 << 8))
+ #define EPTPC_PRIPR_OVRE3 ((uint32_t)(0x1 << 3))
+ #define EPTPC_PRIPR_OVRE2 ((uint32_t)(0x1 << 2))
+ #define EPTPC_PRIPR_OVRE1 ((uint32_t)(0x1 << 1))
+ #define EPTPC_PRIPR_OVRE0 ((uint32_t)0x1)
+ #define EPTPC_PRMACRU0_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x410))
+ #define EPTPC_PRMACRL0_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x414))
+ #define EPTPC_PRMACRU1_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x418))
+ #define EPTPC_PRMACRL1_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x41c))
+ #define EPTPC_TRNDISR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x420))
+ #define EPTPC_TRNDISR_TDIS_BOTH ((uint32_t)0x1)
+ #define EPTPC_TRNDISR_TDIS_ETH0 ((uint32_t)0x1)
+ #define EPTPC_TRNDISR_TDIS_ETH1 ((uint32_t)0x2)
+ #define EPTPC_TRNMR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x430))
+ #define EPTPC_TRNMR_FWD1 ((uint32_t)(0x1 << 9))
+ #define EPTPC_TRNMR_FWD0 ((uint32_t)(0x1 << 8))
+ #define EPTPC_TRNMR_MOD ((uint32_t)0x1)
+ #define EPTPC_TRNCTTDR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0x434))
+ #define EPTPC_TRNCTTDR_THVAL_MASK ((uint32_t)0x7ff)
+ #define EPTPC_PTRSTR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0xc0500))
+ #define EPTPC_PTRSTR_RESET ((uint32_t)0x1)
+ #define EPTPC_STCSELR_ADDR ((volatile uint32_t*)(EPTPC_BASEADDR + 0xc0504))
+ #define EPTPC_STCSELR_SCLKSEL_PCLKA_DIV_1_6 ((uint32_t)(0x0 << 8))
+ #define EPTPC_STCSELR_SCLKSEL_REF50CK0 ((uint32_t)(0x2 << 8))
+ #define EPTPC_STCSELR_SCLKSEL_REF50CK1 ((uint32_t)(0x3 << 8))
+ #define EPTPC_STCSELR_SCLKDIV_DIV1 ((uint32_t)0x1)
+ #define EPTPC_STCSELR_SCLKDIV_DIV2 ((uint32_t)0x2)
+ #define EPTPC_STCSELR_SCLKDIV_DIV3 ((uint32_t)0x3)
+ #define EPTPC_STCSELR_SCLKDIV_DIV4 ((uint32_t)0x4)
+ #define EPTPC_STCSELR_SCLKDIV_DIV5 ((uint32_t)0x5)
+ #define EPTPC_STCSELR_SCLKDIV_DIV6 ((uint32_t)0x6)
+ 
+ #define EPTPC_PORT0_BASEADDR 0x000C4800
+ #define EPTPC_PORT1_BASEADDR 0x000C4C00
+ 
+ #define EPTPC_SYSR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x0))
+ #define EPTPC_SYSR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x0))
+ #define EPTPC_SYSR_OFFSET (0x0)
+ #define EPTPC_SYSR_GENDN ((uint32_t)(0x1 << 17))
+ #define EPTPC_SYSR_RESDN ((uint32_t)(0x1 << 16))
+ #define EPTPC_SYSR_INFABT ((uint32_t)(0x1 << 14))
+ #define EPTPC_SYSR_RECLP ((uint32_t)(0x1 << 12))
+ #define EPTPC_SYSR_DRQOVR ((uint32_t)(0x1 << 6))
+ #define EPTPC_SYSR_INTDEEV ((uint32_t)(0x1 << 5))
+ #define EPTPC_SYSR_DRPTO ((uint32_t)(0x1 << 4))
+ #define EPTPC_SYSR_MPDUD ((uint32_t)(0x1 << 2))
+ #define EPTPC_SYSR_INTCHG ((uint32_t)(0x1 << 1))
+ #define EPTPC_SYSR_OFMUD ((uint32_t)0x1)
+ #define EPTPC_SYIPR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x4))
+ #define EPTPC_SYIPR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x4))
+ #define EPTPC_SYIPR_OFFSET (0x4)
+ #define EPTPC_SYIPR_GENDN ((uint32_t)(0x1 << 17))
+ #define EPTPC_SYIPR_RESDN ((uint32_t)(0x1 << 16))
+ #define EPTPC_SYIPR_INFABT ((uint32_t)(0x1 << 14))
+ #define EPTPC_SYIPR_RECLP ((uint32_t)(0x1 << 12))
+ #define EPTPC_SYIPR_DRQOVR ((uint32_t)(0x1 << 6))
+ #define EPTPC_SYIPR_INTDEEV ((uint32_t)(0x1 << 5))
+ #define EPTPC_SYIPR_DRPTO ((uint32_t)(0x1 << 4))
+ #define EPTPC_SYIPR_MPDUD ((uint32_t)(0x1 << 2))
+ #define EPTPC_SYIPR_INTCHG ((uint32_t)(0x1 << 1))
+ #define EPTPC_SYIPR_OFMUD ((uint32_t)0x1)
+ #define EPTPC_SYMACRU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x10))
+ #define EPTPC_SYMACRU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x10))
+ #define EPTPC_SYMACRU_OFFSET (0x10)
+ #define EPTPC_SYMACRL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x14))
+ #define EPTPC_SYMACRL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x14))
+ #define EPTPC_SYMACRL_OFFSET (0x14)
+ #define EPTPC_SYIPADDRR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x1c))
+ #define EPTPC_SYIPADDRR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x1c))
+ #define EPTPC_SYIPRADDR_OFFSET (0x1c)
+ #define EPTPC_SYSPVRR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x40))
+ #define EPTPC_SYSPVRR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x40))
+ #define EPTPC_SYSPVRR_OFFSET (0x40)
+ #define EPTPC_SYSPVRR_TRSP ((uint32_t)(0x0 << 4))
+ #define EPTPC_SYSPVRR_VER ((uint32_t)0x2)
+ #define EPTPC_SYDOMR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x44))
+ #define EPTPC_SYDOMR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x44))
+ #define EPTPC_SYDOMR_OFFSET (0x44)
+ #define EPTPC_SYDOMR_DNUM_MASK ((uint32_t)(0x1 << 255))
+ #define EPTPC_ANFR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x50))
+ #define EPTPC_ANFR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x50))
+ #define EPTPC_ANFR_OFFSET (0x50)
+ #define EPTPC_ANFR_FLAG14 ((uint32_t)(0x1 << 14))
+ #define EPTPC_ANFR_FLAG13 ((uint32_t)(0x1 << 13))
+ #define EPTPC_ANFR_FLAG10 ((uint32_t)(0x1 << 10))
+ #define EPTPC_ANFR_FLAG8 ((uint32_t)(0x1 << 8))
+ #define EPTPC_ANFR_FLAG5 ((uint32_t)(0x1 << 5))
+ #define EPTPC_ANFR_FLAG4 ((uint32_t)(0x1 << 4))
+ #define EPTPC_ANFR_FLAG3 ((uint32_t)(0x1 << 3))
+ #define EPTPC_ANFR_FLAG2 ((uint32_t)(0x1 << 2))
+ #define EPTPC_ANFR_FLAG1 ((uint32_t)(0x1 << 1))
+ #define EPTPC_ANFR_FLAG0 ((uint32_t)0x1)
+ #define EPTPC_SYNFR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x54))
+ #define EPTPC_SYNFR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x54))
+ #define EPTPC_SYNFR_OFFSET (0x54)
+ #define EPTPC_SYNFR_FLAG14 ((uint32_t)(0x1 << 14))
+ #define EPTPC_SYNFR_FLAG13 ((uint32_t)(0x1 << 13))
+ #define EPTPC_SYNFR_FLAG10 ((uint32_t)(0x1 << 10))
+ #define EPTPC_SYNFR_FLAG9 ((uint32_t)(0x1 << 9))
+ #define EPTPC_SYNFR_FLAG8 ((uint32_t)(0x1 << 8))
+ #define EPTPC_DYRQFR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x58))
+ #define EPTPC_DYRQFR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x58))
+ #define EPTPC_DYRQFR_OFFSET (0x58)
+ #define EPTPC_DYRQFR_FLAG14 ((uint32_t)(0x1 << 14))
+ #define EPTPC_DYRQFR_FLAG13 ((uint32_t)(0x1 << 13))
+ #define EPTPC_DYRQFR_FLAG10 ((uint32_t)(0x1 << 10))
+ #define EPTPC_DYRPFR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x5c))
+ #define EPTPC_DYRPFR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x5c))
+ #define EPTPC_DYRPFR_OFFSET (0x5c)
+ #define EPTPC_DYRPFR_FLAG14 ((uint32_t)(0x1 << 14))
+ #define EPTPC_DYRPFR_FLAG13 ((uint32_t)(0x1 << 13))
+ #define EPTPC_DYRPFR_FLAG10 ((uint32_t)(0x1 << 10))
+ #define EPTPC_DYRPFR_FLAG9 ((uint32_t)(0x1 << 9))
+ #define EPTPC_DYRPFR_FLAG8 ((uint32_t)(0x1 << 8))
+ #define EPTPC_SYCIDRU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x60))
+ #define EPTPC_SYCIDRU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x60))
+ #define EPTPC_SYCIDRU_OFFSET (0x60)
+ #define EPTPC_SYCIDRL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x64))
+ #define EPTPC_SYCIDRL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x64))
+ #define EPTPC_SYCIDRL_OFFSET (0x64)
+ #define EPTPC_SYPNUMR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x68))
+ #define EPTPC_SYPNUMR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x68))
+ #define EPTPC_SYPNUMR_OFFSET (0x68)
+ #define EPTPC_SYRVLDR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x80))
+ #define EPTPC_SYRVLDR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x80))
+ #define EPTPC_SYRVLDR_OFFSET (0x80)
+ #define EPTPC_SYRVLDR_ANUP ((uint32_t)(0x1 << 2))
+ #define EPTPC_SYRVLDR_STUP ((uint32_t)(0x1 << 1))
+ #define EPTPC_SYRVLDR_BMUP ((uint32_t)0x1)
+ #define EPTPC_SYRFL1R0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x90))
+ #define EPTPC_SYRFL1R1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x90))
+ #define EPTPC_SYRFL1R_OFFSET (0x90)
+ #define EPTPC_SYRFL1R_PDFUP_SYNFP ((uint32_t)(0x1 << 30))
+ #define EPTPC_SYRFL1R_PDFUP_PRC_TC ((uint32_t)(0x1 << 29))
+ #define EPTPC_SYRFL1R_PDFUP_PTPEDMAC ((uint32_t)(0x1 << 28))
+ #define EPTPC_SYRFL1R_PDRP_SYNFP ((uint32_t)(0x1 << 26))
+ #define EPTPC_SYRFL1R_PDRP_PRC_TC ((uint32_t)(0x1 << 25))
+ #define EPTPC_SYRFL1R_PDRP_PTPEDMAC ((uint32_t)(0x1 << 24))
+ #define EPTPC_SYRFL1R_PDRQ_SYNFP ((uint32_t)(0x1 << 22))
+ #define EPTPC_SYRFL1R_PDRQ_PRC_TC ((uint32_t)(0x1 << 21))
+ #define EPTPC_SYRFL1R_PDRQ_PTPEDMAC ((uint32_t)(0x1 << 20))
+ #define EPTPC_SYRFL1R_DRP_SYNFP ((uint32_t)(0x1 << 18))
+ #define EPTPC_SYRFL1R_DRP_PRC_TC ((uint32_t)(0x1 << 17))
+ #define EPTPC_SYRFL1R_DRP_PTPEDMAC ((uint32_t)(0x1 << 16))
+ #define EPTPC_SYRFL1R_DRQ_SYNFP ((uint32_t)(0x1 << 14))
+ #define EPTPC_SYRFL1R_DRQ_PRC_TC ((uint32_t)(0x1 << 13))
+ #define EPTPC_SYRFL1R_DRQ_PTPEDMAC ((uint32_t)(0x1 << 12))
+ #define EPTPC_SYRFL1R_FUP_SYNFP ((uint32_t)(0x1 << 10))
+ #define EPTPC_SYRFL1R_FUP_PRC_TC ((uint32_t)(0x1 << 9))
+ #define EPTPC_SYRFL1R_FUP_PTPEDMAC ((uint32_t)(0x1 << 8))
+ #define EPTPC_SYRFL1R_SYNC_SYNFP ((uint32_t)(0x1 << 6))
+ #define EPTPC_SYRFL1R_SYNC_PRC_TC ((uint32_t)(0x1 << 5))
+ #define EPTPC_SYRFL1R_SYNC_PTPEDMAC ((uint32_t)(0x1 << 4))
+ #define EPTPC_SYRFL1R_ANCE_PRC_TC ((uint32_t)(0x1 << 1))
+ #define EPTPC_SYRFL1R_ANCE_PTPEDMAC ((uint32_t)0x1)
+ #define EPTPC_SYRFL2R0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x94))
+ #define EPTPC_SYRFL2R1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x94))
+ #define EPTPC_SYRFL2R_OFFSET (0x94)
+ #define EPTPC_SYRFL2R_ILL_PRC_TC ((uint32_t)(0x1 << 29))
+ #define EPTPC_SYRFL2R_ILL_PTPEDMAC ((uint32_t)(0x1 << 28))
+ #define EPTPC_SYRFL2R_SIG_PRC_TC ((uint32_t)(0x1 << 5))
+ #define EPTPC_SYRFL2R_SIG_PTPEDMAC ((uint32_t)(0x1 << 4))
+ #define EPTPC_SYRFL2R_MAN_PRC_TC ((uint32_t)(0x1 << 1))
+ #define EPTPC_SYRFL2R_MAN_PTPEDMAC ((uint32_t)0x1)
+ #define EPTPC_SYTRENR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x98))
+ #define EPTPC_SYTRENR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x98))
+ #define EPTPC_SYTRENR_OFFSET (0x98)
+ #define EPTPC_SYTRENR_PDRQ ((uint32_t)(0x1 << 12))
+ #define EPTPC_SYTRENR_DRQ ((uint32_t)(0x1 << 8))
+ #define EPTPC_SYTRENR_SYNC ((uint32_t)(0x1 << 4))
+ #define EPTPC_SYTRENR_ANCE ((uint32_t)0x1)
+ #define EPTPC_MTCIDU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xa0))
+ #define EPTPC_MTCIDU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xa0))
+ #define EPTPC_MTCIDU_OFFSET (0xa0)
+ #define EPTPC_MTCIDL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xa4))
+ #define EPTPC_MTCIDL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xa4))
+ #define EPTPC_MTCIDL_OFFSET (0xa4)
+ #define EPTPC_MTPID0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xa8))
+ #define EPTPC_MTPID1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xa8))
+ #define EPTPC_MTPID_OFFSET (0xa8)
+ #define EPTPC_MTPID_PNUM_MASK ((uint32_t)0xffff)
+ #define EPTPC_SYTLIR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xc0))
+ #define EPTPC_SYTLIR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xc0))
+ #define EPTPC_SYTLIR_OFFSET (0xc0)
+ #define EPTPC_SYRLIR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xc4))
+ #define EPTPC_SYRLIR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xc4))
+ #define EPTPC_SYRLIR_OFFSET (0xc4)
+ #define EPTPC_OFMRU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xc8))
+ #define EPTPC_OFMRU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xc8))
+ #define EPTPC_OFMRU_OFFSET (0xc8)
+ #define EPTPC_OFMRL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xcc))
+ #define EPTPC_OFMRL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xcc))
+ #define EPTPC_OFMRL_OFFSET (0xcc)
+ #define EPTPC_MPDRU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xd0))
+ #define EPTPC_MPDRU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xd0))
+ #define EPTPC_MPDRU_OFFSET (0xd0)
+ #define EPTPC_MPDRL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xd4))
+ #define EPTPC_MPDRL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xd4))
+ #define EPTPC_MPDRL_OFFSET (0xd4)
+ #define EPTPC_GMPR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xe0))
+ #define EPTPC_GMPR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xe0))
+ #define EPTPC_GMPR_OFFSET (0xe0)
+ #define EPTPC_GMCQR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xe4))
+ #define EPTPC_GMCQR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xe4))
+ #define EPTPC_GMCQR_OFFSET (0xe4)
+ #define EPTPC_GMIDRU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xe8))
+ #define EPTPC_GMIDRU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xe8))
+ #define EPTPC_GMIDRU_OFFSET (0xe8)
+ #define EPTPC_GMIDRL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xec))
+ #define EPTPC_GMIDRL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xec))
+ #define EPTPC_GMIDRL_OFFSET (0xec)
+ #define EPTPC_CUOTSR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xf0))
+ #define EPTPC_CUOTSR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xf0))
+ #define EPTPC_CUOTSR_OFFSET (0xf0)
+ #define EPTPC_SRR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0xf4))
+ #define EPTPC_SRR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0xf4))
+ #define EPTPC_SRR_OFFSET (0xf4)
+ #define EPTPC_PPMACRU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x100))
+ #define EPTPC_PPMACRU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x100))
+ #define EPTPC_PPMACRU_OFFSET (0x100)
+ #define EPTPC_PPMACRL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x104))
+ #define EPTPC_PPMACRL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x104))
+ #define EPTPC_PPMACRL_OFFSET (0x104)
+ #define EPTPC_PDMACRU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x108))
+ #define EPTPC_PDMACRU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x108))
+ #define EPTPC_PDMACRU_OFFSET (0x108)
+ #define EPTPC_PDMACRL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x10c))
+ #define EPTPC_PDMACRL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x10c))
+ #define EPTPC_PDMACRL_OFFSET (0x10c)
+ #define EPTPC_PETYPER0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x110))
+ #define EPTPC_PETYPER1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x110))
+ #define EPTPC_PETYPER_OFFSET (0x110)
+ #define EPTPC_PPIPR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x120))
+ #define EPTPC_PPIPR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x120))
+ #define EPTPC_PPIPR_OFFSET (0x120)
+ #define EPTPC_PDIPR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x124))
+ #define EPTPC_PDIPR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x124))
+ #define EPTPC_PDIPR_OFFSET (0x124)
+ #define EPTPC_PETOSR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x128))
+ #define EPTPC_PETOSR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x128))
+ #define EPTPC_PETOSR_OFFSET (0x128)
+ #define EPTPC_PGTOSR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x12c))
+ #define EPTPC_PGTOSR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x12c))
+ #define EPTPC_PGTOSR_OFFSET (0x12c)
+ #define EPTPC_PPTTLR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x130))
+ #define EPTPC_PPTTLR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x130))
+ #define EPTPC_PPTTLR_OFFSET (0x130)
+ #define EPTPC_PDTTLR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x134))
+ #define EPTPC_PDTTLR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x134))
+ #define EPTPC_PDTTLR_OFFSET (0x134)
+ #define EPTPC_PEUDPR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x138))
+ #define EPTPC_PEUDPR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x138))
+ #define EPTPC_PEUDPR_OFFSET (0x138)
+ #define EPTPC_PGUDPR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x13c))
+ #define EPTPC_PGUDPR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x13c))
+ #define EPTPC_PGUDPR_OFFSET (0x13c)
+ #define EPTPC_FFLTR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x140))
+ #define EPTPC_FFLTR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x140))
+ #define EPTPC_FFLTR_OFFSET (0x140)
+ #define EPTPC_FFLTR_EXTPRM_NORMAL ((uint32_t)(0x0 << 16))
+ #define EPTPC_FFLTR_EXTPRM_EXPCAST ((uint32_t)(0x1 << 16))
+ #define EPTPC_FFLTR_ENB ((uint32_t)(0x1 << 2))
+ #define EPTPC_FFLTR_PRT ((uint32_t)(0x1 << 1))
+ #define EPTPC_FFLTR_SEL ((uint32_t)0x1)
+ #define EPTPC_FMAC0RU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x160))
+ #define EPTPC_FMAC0RU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x160))
+ #define EPTPC_FMAC0RU_OFFSET (0x160)
+ #define EPTPC_FMAC0RL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x164))
+ #define EPTPC_FMAC0RL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x164))
+ #define EPTPC_FMAC0RL_OFFSET (0x164)
+ #define EPTPC_FMAC1RU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x168))
+ #define EPTPC_FMAC1RU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x168))
+ #define EPTPC_FMAC1RU_OFFSET (0x168)
+ #define EPTPC_FMAC1RL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x16c))
+ #define EPTPC_FMAC1RL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x16c))
+ #define EPTPC_FMAC1RL_OFFSET (0x16c)
+ #define EPTPC_DASYMRU0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x1c0))
+ #define EPTPC_DASYMRU1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x1c0))
+ #define EPTPC_DASYMRU_OFFSET (0x1c0)
+ #define EPTPC_DASYMRL0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x1c4))
+ #define EPTPC_DASYMRL1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x1c4))
+ #define EPTPC_DASYMRL_OFFSET (0x1c4)
+ #define EPTPC_TSLATR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x1c8))
+ #define EPTPC_TSLATR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x1c8))
+ #define EPTPC_TSLATR_OFFSET (0x1c8)
+ #define EPTPC_SYCONFR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x1cc))
+ #define EPTPC_SYCONFR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x1cc))
+ #define EPTPC_SYCONFR_OFFSET (0x1cc)
+ #define EPTPC_SYCONFR_TCMOD_E2E ((uint32_t)(0x0 << 20))
+ #define EPTPC_SYCONFR_TCMOD_P2P ((uint32_t)(0x1 << 20))
+ #define EPTPC_SYCONFR_FILDIS ((uint32_t)(0x1 << 16))
+ #define EPTPC_SYCONFR_SBDIS ((uint32_t)(0x1 << 12))
+ #define EPTPC_SYCONFR_TCYC_MASK ((uint32_t)0xff)
+ #define EPTPC_SYFORMR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x1d0))
+ #define EPTPC_SYFORMR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x1d0))
+ #define EPTPC_SYFORMR_OFFSET (0x1d0)
+ #define EPTPC_SYFORMR_FROM1_PTP_ETHER ((uint32_t)(0x0 << 1))
+ #define EPTPC_SYFORMR_FROM1_PTP_UDP_IPV4 ((uint32_t)(0x1 << 1))
+ #define EPTPC_SYFORMR_FORM0 ((uint32_t)0x0)
+ #define EPTPC_RSTOUTR0_ADDR ((volatile uint32_t*)(EPTPC_PORT0_BASEADDR + 0x1d4))
+ #define EPTPC_RSTOUTR1_ADDR ((volatile uint32_t*)(EPTPC_PORT1_BASEADDR + 0x1d4))
+ #define EPTPC_RSTOUTR_OFFSET (0x1d4)
+ 
+ #endif
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile.CMTW ASPs/asp/driver/rx_gcc/Makefile.CMTW
*** 1.9.1/asp/driver/rx_gcc/Makefile.CMTW	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile.CMTW	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,6 ----
+ #
+ #		Driver Makefile (CMTW)
+ #
+ 
+ 
+ DRIVER_COBJS :=  $(DRIVER_COBJS) CMTW.o
\ No newline at end of file
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile.DTCa ASPs/asp/driver/rx_gcc/Makefile.DTCa
*** 1.9.1/asp/driver/rx_gcc/Makefile.DTCa	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile.DTCa	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,6 ----
+ #
+ #		Driver Makefile (DTCa)
+ #
+ 
+ 
+ DRIVER_COBJS :=  $(DRIVER_COBJS) DTCa.o
\ No newline at end of file
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile.EPTPC ASPs/asp/driver/rx_gcc/Makefile.EPTPC
*** 1.9.1/asp/driver/rx_gcc/Makefile.EPTPC	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile.EPTPC	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,6 ----
+ #
+ #		Driver Makefile (EPTPC)
+ #
+ 
+ 
+ DRIVER_COBJS :=  $(DRIVER_COBJS) EPTPC.o
\ No newline at end of file
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile.RSPI ASPs/asp/driver/rx_gcc/Makefile.RSPI
*** 1.9.1/asp/driver/rx_gcc/Makefile.RSPI	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile.RSPI	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,6 ----
+ #
+ #		Driver Makefile (RSPI)
+ #
+ 
+ 
+ DRIVER_COBJS :=  $(DRIVER_COBJS) RSPI.o
\ No newline at end of file
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile.SCIc ASPs/asp/driver/rx_gcc/Makefile.SCIc
*** 1.9.1/asp/driver/rx_gcc/Makefile.SCIc	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile.SCIc	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,12 ----
+ #
+ # Copyright (c) 2016- Hisashi Hata
+ # Released under the toppers license
+ # https://www.toppers.jp/license.html
+ #
+ 
+ #
+ #		Driver Makefile (SCIc)
+ #
+ 
+ 
+ DRIVER_COBJS :=  $(DRIVER_COBJS) SCIc.o
\ No newline at end of file
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile.SCIg ASPs/asp/driver/rx_gcc/Makefile.SCIg
*** 1.9.1/asp/driver/rx_gcc/Makefile.SCIg	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile.SCIg	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,12 ----
+ #
+ # Copyright (c) 2016- Hisashi Hata
+ # Released under the toppers license
+ # https://www.toppers.jp/license.html
+ #
+ 
+ #
+ #		Driver Makefile (SCIg)
+ #
+ 
+ 
+ DRIVER_COBJS :=  $(DRIVER_COBJS) SCIg.o
\ No newline at end of file
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile.mmc_gpio ASPs/asp/driver/rx_gcc/Makefile.mmc_gpio
*** 1.9.1/asp/driver/rx_gcc/Makefile.mmc_gpio	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile.mmc_gpio	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,5 ----
+ #
+ #		Driver Makefile (mmc_gpio)
+ #
+ 
+ DRIVER_COBJS :=  $(DRIVER_COBJS) mmc_gpio.o
\ No newline at end of file
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile.mmc_rspi ASPs/asp/driver/rx_gcc/Makefile.mmc_rspi
*** 1.9.1/asp/driver/rx_gcc/Makefile.mmc_rspi	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile.mmc_rspi	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,5 ----
+ #
+ #		Driver Makefile (mmc_rspi)
+ #
+ 
+ DRIVER_COBJS :=  $(DRIVER_COBJS) mmc_rspi.o
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile_rx63n.driver ASPs/asp/driver/rx_gcc/Makefile_rx63n.driver
*** 1.9.1/asp/driver/rx_gcc/Makefile_rx63n.driver	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile_rx63n.driver	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,23 ----
+ 
+ DRIVER_COBJS =
+ 
+ ifeq ($(USE_RSPI_0),true)
+ include $(DRIVERDIR)/Makefile.RSPI
+ endif
+ 
+ ifeq ($(USE_MMC_RSPI_0),true)
+ include $(DRIVERDIR)/Makefile.mmc_rspi
+ endif
+ 
+ include $(DRIVERDIR)/Makefile.mmc_gpio
+ ifeq ($(USE_MMC_GPIO_0),true)
+ endif
+ 
+ ifeq ($(USE_DTCA_0),true)
+ include $(DRIVERDIR)/Makefile.DTCa
+ endif
+ 
+ ifeq ($(USE_SCIC_0),true)
+ include $(DRIVERDIR)/Makefile.SCIc
+ endif
+ 
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/Makefile_rx64m.driver ASPs/asp/driver/rx_gcc/Makefile_rx64m.driver
*** 1.9.1/asp/driver/rx_gcc/Makefile_rx64m.driver	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/Makefile_rx64m.driver	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,30 ----
+ 
+ DRIVER_COBJS =
+ 
+ ifeq ($(USE_RSPI_0),true)
+ include $(DRIVERDIR)/Makefile.RSPI
+ endif
+ 
+ ifeq ($(USE_MMC_RSPI_0),true)
+ include $(DRIVERDIR)/Makefile.mmc_rspi
+ endif
+ 
+ include $(DRIVERDIR)/Makefile.mmc_gpio
+ ifeq ($(USE_MMC_GPIO_0),true)
+ endif
+ 
+ ifeq ($(USE_DTCA_0),true)
+ include $(DRIVERDIR)/Makefile.DTCa
+ endif
+ 
+ ifeq ($(USE_SCIG_0),true)
+ include $(DRIVERDIR)/Makefile.SCIg
+ endif
+ 
+ ifeq ($(USE_EPTPC_0),true)
+ include $(DRIVERDIR)/Makefile.EPTPC
+ endif
+ 
+ ifeq ($(USE_CMTW_0),true)
+ include $(DRIVERDIR)/Makefile.CMTW
+ endif
\ No newline at end of file
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/RSPI.c ASPs/asp/driver/rx_gcc/RSPI.c
*** 1.9.1/asp/driver/rx_gcc/RSPI.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/RSPI.c	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,435 ----
+ /*
+  * Copyright (c) 2015- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ 
+ #include <kernel_impl.h>
+ #include <driver/rx_gcc/RSPI.h>
+ #include <driver/rx_gcc/DTCa.h>
+ 
+ #define SPCR_OFFSET 0x0
+ #define SSLP_OFFSET 0x1
+ #define SPPCR_OFFSET 0x2
+ #define SPSR_OFFSET 0x3
+ #define SPDR_OFFSET 0x4
+ #define SPSCR_OFFSET 0x8
+ #define SPSSR_OFFSET 0x9
+ #define SPBR_OFFSET 0xA
+ #define SPDCR_OFFSET 0xB
+ #define SPCKD_OFFSET 0xC
+ #define SSLND_OFFSET 0xD
+ #define SPND_OFFSET 0xE
+ #define SPCR2_OFFSET 0xF
+ #define SPCMD_OFFSET 0x10
+ 
+ //interrupt wait type
+ #define RSPI_TX_START_WAIT 0x1
+ #define RSPI_RX_START_WAIT 0x2
+ #define RSPI_TX_END_WAIT 0x4
+ #define RSPI_RX_END_WAIT 0x8
+ 
+ 
+ void rspi_slave_select(void *v_rspi_stat, uint8_t sel){
+   uint8_t st;
+   uint32_t base_addr;
+   rspi_dstat *rspi_stat;
+   rspi_stat = v_rspi_stat;
+   
+   base_addr = rspi_stat->baddr;
+   st = DEV_REB(base_addr, SSLP_OFFSET);
+   DEV_WRB(base_addr, SSLP_OFFSET, st & ~sel);
+ }
+   
+ 
+ void rspi_slave_unselect(void *v_rspi_stat, uint8_t unsel){
+   uint8_t st;
+   uint32_t base_addr;
+   rspi_dstat *rspi_stat;
+   rspi_stat = v_rspi_stat;
+   
+   base_addr = rspi_stat->baddr;
+   st = DEV_REB(base_addr, SSLP_OFFSET);
+   DEV_WRB(base_addr, SSLP_OFFSET, st | unsel);
+ }
+ 
+ //
+ //trs_freq is bit rate
+ //if bit rate is 400 khz, set 400000;
+ void rspi_init(void *v_rspi_stat, rspi_param_t* params){
+   uint32_t base_addr;
+   rspi_dstat *rspi_stat;
+   rspi_stat = v_rspi_stat;
+   
+   base_addr = rspi_stat->baddr;
+   DEV_WRB(base_addr, SPCR_OFFSET, 0); //disable RSPI
+   DEV_WRB(base_addr, SSLP_OFFSET, params->sslp);
+   DEV_WRB(base_addr, SPPCR_OFFSET, params->sppcr);
+   DEV_WRB(base_addr, SPSCR_OFFSET, params->spscr);
+   DEV_WRB(base_addr, SPDCR_OFFSET, params->spdcr);
+   DEV_WRH(base_addr, SPCMD_OFFSET, params->spcmd0);  //Set Transfar length 8bit
+   DEV_WRB(base_addr, SPBR_OFFSET, (F_PCLKB/2/(params->bit_rate) -1));
+   DEV_WRB(base_addr, SPCR_OFFSET, params->spcr); //Enable RSPI 
+ }
+ 
+ void rspi_disable(void *v_rspi_stat){
+   uint32_t base_addr;
+   rspi_dstat *rspi_stat;
+   uint8_t rd;
+   rspi_stat = v_rspi_stat;
+   
+   base_addr = rspi_stat->baddr;
+   rd = DEV_REB(base_addr, SPCR_OFFSET);
+   DEV_WRB(base_addr, SPCR_OFFSET, rd & ~SPCR_SPE); //disable RSPI
+ }
+   
+ void rspi_enable(void *v_rspi_stat){
+   uint32_t base_addr;
+   uint8_t rd;
+   rspi_dstat *rspi_stat;
+   rspi_stat = v_rspi_stat;
+   
+   base_addr = rspi_stat->baddr;
+   rd = DEV_REB(base_addr, SPCR_OFFSET);
+   DEV_WRB(base_addr, SPCR_OFFSET, rd | SPCR_SPE); //disable RSPI
+ }
+ 
+ //Bit rate controll register
+ void rspi_chg_bit_rate(void *v_rspi_stat, uint8_t bit_rate){
+   rspi_dstat *rspi_stat;
+   rspi_stat = v_rspi_stat;
+ 
+   DEV_WRB(rspi_stat->baddr, SPBR_OFFSET, bit_rate);
+ }
+ 
+ //SEND/RECIVE DATA REGISTER
+ /*
+ void rspi_dtc_send_w();
+ void rspi_dtc_send_b();
+ void rspi_dtc_send_clock();
+ */
+ 
+ void rspi_send_w(void *v_rspi_stat, uint32_t dat){
+   DEV_WRW(((rspi_dstat*)v_rspi_stat)->baddr, SPDR_OFFSET, dat);
+ }
+ 
+ void rspi_send_h(void *v_rspi_stat, uint16_t dat){
+   DEV_WRW(((rspi_dstat*)v_rspi_stat)->baddr, SPDR_OFFSET, (uint32_t)dat);
+ }
+ 
+ void rspi_send_b(void *v_rspi_stat, uint8_t dat){
+   DEV_WRW(((rspi_dstat*)v_rspi_stat)->baddr, SPDR_OFFSET, (uint32_t)dat);
+ }
+ 
+ void rspi_send_clock();
+ 
+ void rcv_w_with_dtc();
+ void rcv_b_with_dtc();
+ 
+ uint32_t rspi_rcv_w(void *v_rspi_stat){
+   return DEV_REW(((rspi_dstat*)v_rspi_stat)->baddr, SPDR_OFFSET);
+ }
+ 
+ uint16_t rspi_rcv_h(void *v_rspi_stat){
+   return (uint16_t)DEV_REW(((rspi_dstat*)v_rspi_stat)->baddr, SPDR_OFFSET);
+ }
+ 
+ uint8_t rspi_rcv_b(void *v_rspi_stat){
+   return (uint8_t) DEV_REW(((rspi_dstat*)v_rspi_stat)->baddr, SPDR_OFFSET);
+ };
+ 
+ inline void rspi_int_sem_init(rspi_dstat *rspi_stat){
+   T_RSEM pk_rsem;
+   if(ref_sem(rspi_stat->int_sync_sem, &pk_rsem) == E_OK){
+ 	if(pk_rsem.semcnt == 1){
+       wai_sem(rspi_stat->int_sync_sem);
+     }
+   }
+ }
+ 
+ void rspi_set_spcr_flg_b(uint8_t* baddr, uint8_t set_flg){
+   uint8_t st;
+   uint8_t *spcr_p;
+ 
+   spcr_p = baddr + SPCR_OFFSET;
+   st = sil_reb_mem(spcr_p);
+   sil_wrb_mem(spcr_p, st | set_flg );
+ }
+ 
+ void rspi_clr_spcr_flg_b(uint8_t* baddr, uint8_t clr_flg){
+   uint8_t st;
+   uint8_t *spcr_p;
+ 
+   spcr_p = baddr + SPCR_OFFSET;
+   st = sil_reb_mem(spcr_p);
+   sil_wrb_mem(spcr_p, (st & ~clr_flg));
+ }
+ 
+ uint32_t rspi_xchg_rw (void *v_rspi_stat,  uint32_t dat){
+   rspi_dstat *rspi_stat;
+   uint32_t baddr;
+   uint32_t* spdr_addr;
+ 
+   rspi_stat = (rspi_dstat*)v_rspi_stat;
+   baddr = rspi_stat->baddr;
+   spdr_addr = (uint32_t*)(baddr + SPDR_OFFSET);
+   rspi_int_sem_init(rspi_stat);
+ 
+   //set rx intterupt wait mode
+   rspi_stat->interrupt_wait_flg = RSPI_RX_END_WAIT;
+   //enable rx interrupt
+   rspi_set_spcr_flg_b((uint8_t*)baddr, SPCR_SPRIE);
+   //write data
+   sil_wrw_mem(spdr_addr, dat);
+ 
+   //waint interrupt
+   twai_sem(rspi_stat->int_sync_sem, 1000);
+   //clear interrupt request
+   x_clear_int(rspi_stat->spri);
+   //disable rx interrupt
+   rspi_clr_spcr_flg_b((uint8_t*)baddr, SPCR_SPRIE);
+   return sil_rew_mem(spdr_addr);
+ }
+ 
+ 
+ uint8_t rspi_status(void *v_rspi_stat){
+   return DEV_REB(((rspi_dstat*)v_rspi_stat)->baddr, SPSR_OFFSET);
+ }
+ 
+ void rspi_set_cmd(void *v_rspi_stat, uint8_t cmd_buff_num, uint8_t cmd){
+   DEV_WRB(((rspi_dstat*)v_rspi_stat)->baddr, SPCMD_OFFSET+(cmd_buff_num<<1), cmd );
+ }
+ 
+ void rspi_chg_dwidth(void *v_rspi_stat, uint8_t cmd_buff_num, uint32_t width){
+   uint16_t current;
+   uint32_t cmd_offset;
+   uint32_t base_addr;
+   rspi_dstat *rspi_stat;
+   rspi_stat = v_rspi_stat;
+ 
+   cmd_offset = SPCMD_OFFSET+(cmd_buff_num<<1);
+   base_addr = rspi_stat->baddr;
+   current = DEV_REB(base_addr, cmd_offset);
+   DEV_WRH(base_addr, cmd_offset, (current & ~SPCMD_SPB_MASK)|width);
+ }
+ 
+ 
+ void rspi_get_right(void *v_rspi_stat){
+   wai_sem(((rspi_dstat*)v_rspi_stat)->ip_lock_sem);
+ }
+   
+ 
+ void rspi_relese_right(void *v_rspi_stat){
+   sig_sem(((rspi_dstat*)v_rspi_stat)->ip_lock_sem);
+ }
+   
+ 
+ #include <driver/rx_gcc/DTCa.h>
+ 
+ /*
+  * define dtca buffer and table
+  */
+ 
+ //tx dummy data
+ const uint32_t rspi_tx_dummy = 0xffffffff;
+ 
+ /****************************************************
+  *  DTCa transfer function                          *
+  *    size of transfer data must be aligned 4 byte. *
+  *                                                  *
+  ****************************************************/
+ desc_buff dbuff;
+ dtca_descriptor *tx_dtca_desc;
+ dtca_descriptor *rx_dtca_desc;
+ 
+ void rspi_recieve_by_dtca(void *v_rspi_stat, uint32_t* s_buff, uint32_t s_size){
+   rspi_dstat *rspi_stat;
+   uint8_t spdcr_config ;
+   uint32_t tx_int_no, rx_int_no, baddr, block_count, i;
+ 
+   rspi_stat = (rspi_dstat*)v_rspi_stat;
+   tx_int_no = rspi_stat->spti;
+   rx_int_no = rspi_stat->spri;
+   baddr = rspi_stat->baddr;
+   block_count = s_size /(4*4); //transfer size/(word_size(4byte) * stack_size(4word))
+ 
+   rspi_int_sem_init(rspi_stat);
+   //set spdcr to 4 flame buffer
+   spdcr_config = sil_reb_mem((uint8_t*)(baddr+SPDCR_OFFSET));
+   sil_wrb_mem((uint8_t*)(baddr+SPDCR_OFFSET), (spdcr_config & ~SPDCR_SPFC_MASK) | SPDCR_SPFC_4);
+ 
+   if(block_count != 1){
+     dtca_get_desc_buff(&dbuff, 2);
+     rx_dtca_desc = dbuff.desc;
+     tx_dtca_desc = dbuff.desc+1;
+ 
+     //set dtca descriptor
+     //  blobk transfer mode: block count is 4;
+ 
+     rx_dtca_desc->mra = MRA_MD_BLOCK | MRA_SZ_LONG | MRA_SM_CONST_SAR;
+     //    rx_dtca_desc->mrb = MRB_CHNE_DIS | MRB_DTS_SOURCE | MRB_DM_INC_DAR;
+     rx_dtca_desc->mrb = MRB_CHNE_EN | MRB_DTS_SOURCE | MRB_DM_INC_DAR ;    
+     rx_dtca_desc->sar = (baddr + SPDR_OFFSET);
+     rx_dtca_desc->dar = (uint32_t)s_buff;
+     rx_dtca_desc->cra = 0x0404;
+     rx_dtca_desc->crb = block_count-1;
+     
+     tx_dtca_desc->mra = MRA_MD_BLOCK | MRA_SZ_LONG | MRA_SM_CONST_SAR;
+     tx_dtca_desc->mrb = MRB_CHNE_DIS | MRB_DTS_DIST | MRB_DM_CONST_DAR;
+     tx_dtca_desc->sar = (uint32_t)&rspi_tx_dummy;
+     tx_dtca_desc->dar = (baddr + SPDR_OFFSET);
+     tx_dtca_desc->cra = 0x0404;
+     tx_dtca_desc->crb = block_count-1;
+     //disable rspi interface and tx interrupt
+     rspi_clr_spcr_flg_b((uint8_t*)baddr, SPCR_SPTIE|SPCR_SPRIE|SPCR_SPE);
+ 
+     //dtca config
+     //    set_vecter_table(tx_int_no, tx_dtca_desc);
+     set_vecter_table(rx_int_no, rx_dtca_desc);
+     dtcer_irq_enable(tx_int_no);
+     dtcer_irq_enable(rx_int_no);
+     dtca_enable();
+     //set tx intterupt wait mode
+     rspi_stat->interrupt_wait_flg = (RSPI_RX_START_WAIT | RSPI_RX_END_WAIT);
+     //enable rspi inerface, tx interrupt, rx interrupt
+     //  tx interrupt will occur when SPTI and SPE are set same time.
+   //rspi_set_spcr_flg_b((uint8_t*)(baddr), SPCR_SPTIE|SPCR_SPRIE|SPCR_SPE);
+ 	rspi_set_spcr_flg_b((uint8_t*)(baddr), SPCR_SPRIE|SPCR_SPE);    
+ 
+     for(i=0; i<4; i++)
+       sil_wrw_mem((uint32_t*)(baddr+SPDR_OFFSET), rspi_tx_dummy);
+ 
+     //wait rx end
+     twai_sem(rspi_stat->int_sync_sem, 1000);
+     
+     for(i=((block_count-1)*4); i<block_count*4; i++)
+       s_buff[i] = sil_rew_mem((uint32_t*)(baddr+SPDR_OFFSET));
+     
+     //clear interrupt request
+     x_clear_int(tx_int_no);
+     x_clear_int(rx_int_no);
+     
+     dtca_rel_desc_buff(&dbuff);
+   }
+   else{
+     rspi_stat->interrupt_wait_flg = RSPI_RX_END_WAIT;
+     for(i=0; i<4; i++)
+       sil_wrw_mem((uint32_t*)(baddr+SPDR_OFFSET), rspi_tx_dummy);
+     rspi_set_spcr_flg_b((uint8_t*)(baddr), SPCR_SPRIE); //enable rx intterupt
+     
+     twai_sem(rspi_stat->int_sync_sem, 1000);
+     x_clear_int(rx_int_no);
+     for(i=0; i<4; i++)
+       s_buff[i] = sil_rew_mem((uint32_t*)(baddr+SPDR_OFFSET));
+   }
+ 
+   //disable rspi interrupt
+   rspi_clr_spcr_flg_b((uint8_t*)baddr, SPCR_SPTIE|SPCR_SPRIE);
+ 
+   //restore SPDCR
+   sil_wrb_mem((uint8_t*)(baddr+SPDCR_OFFSET), spdcr_config);
+ 
+ }
+ 
+ 
+ void rspi_send_by_dtca(void *v_rspi_stat, uint32_t* s_buff, uint32_t s_size){
+   rspi_dstat *rspi_stat;
+   uint8_t spdcr_config ;
+   uint32_t tx_int_no, baddr, block_count, i;
+   ER check;
+ 
+ 
+   rspi_stat = (rspi_dstat*)v_rspi_stat;
+   tx_int_no = rspi_stat->spti;
+   baddr = rspi_stat->baddr;
+   block_count = s_size /(4*4); //transfer size/(word_size(4byte) * stack_size(4word))
+ 
+   rspi_int_sem_init(rspi_stat);
+ 
+   //set spdcr to 4 flame buffer
+   spdcr_config = sil_reb_mem((uint8_t*)(baddr+SPDCR_OFFSET));
+   sil_wrb_mem((uint8_t*)(baddr+SPDCR_OFFSET), (spdcr_config & ~SPDCR_SPFC_MASK) | SPDCR_SPFC_4);
+ 
+   if(block_count != 1){
+     dtca_get_desc_buff(&dbuff, 1);
+     tx_dtca_desc = dbuff.desc;
+     //set dtca descriptor
+     //  blobk transfer mode: block count is 4;
+     tx_dtca_desc->mra = MRA_MD_BLOCK | MRA_SZ_LONG | MRA_SM_INC_SAR;
+     tx_dtca_desc->mrb = MRB_CHNE_DIS | MRB_DTS_DIST | MRB_DM_CONST_DAR;
+     tx_dtca_desc->sar = (uint32_t)s_buff;
+     tx_dtca_desc->dar = (baddr + SPDR_OFFSET);
+     tx_dtca_desc->cra = 0x0404;
+     tx_dtca_desc->crb = block_count;
+   
+     //set tx intterupt wait mode
+     rspi_stat->interrupt_wait_flg = (RSPI_TX_START_WAIT| RSPI_TX_END_WAIT);
+     //disable rspi interface and tx interrupt
+     rspi_clr_spcr_flg_b((uint8_t*)baddr, SPCR_SPTIE|SPCR_SPE|SPCR_TXMD);
+ 
+     //dtca config
+     set_vecter_table(tx_int_no, tx_dtca_desc);
+     dtcer_irq_enable(tx_int_no);
+     dtca_enable();
+ 
+     //enable rspi inerface and tx interrupt
+     //  tx interrupt will occur when SPTI and SPE are set same time.
+ 	rspi_set_spcr_flg_b((uint8_t*)(baddr), SPCR_SPTIE|SPCR_TXMD|SPCR_SPE);
+     //waint interrupt
+     check = twai_sem(rspi_stat->int_sync_sem, 1000);
+ 
+     dtca_rel_desc_buff(&dbuff);
+   }
+   else{
+     //set tx intterupt wait mode
+     rspi_stat->interrupt_wait_flg |= RSPI_TX_END_WAIT;
+     for(i=0; i<4; i++)
+       sil_wrw_mem((uint32_t*)(baddr+SPDR_OFFSET), s_buff[i]);
+     rspi_set_spcr_flg_b((uint8_t*)(baddr), SPCR_SPTIE|SPCR_TXMD);
+     //waint interrupt
+     twai_sem(rspi_stat->int_sync_sem, 100000);
+   }
+ 
+   //clear interrupt request
+   x_clear_int(tx_int_no);
+   //disable rspi tx interrupt
+   while (rspi_status(rspi_stat) & SPSR_IDLNF);
+   rspi_clr_spcr_flg_b((uint8_t*)baddr, SPCR_SPTIE|SPCR_TXMD);
+ 
+   //restore SPDCR
+   sil_wrb_mem((uint8_t*)(baddr+SPDCR_OFFSET), spdcr_config);
+ 
+ }
+ 
+ void rspi_tx_int_handler(intptr_t exinf){
+   rspi_dstat *rspi_stat;
+   uint16_t wait_flg;
+ 
+   rspi_stat = (rspi_dstat*)GET_DEV_STAT((dnode_id) exinf);
+   wait_flg = rspi_stat->interrupt_wait_flg;  
+   if(wait_flg & RSPI_TX_START_WAIT){
+     wait_flg &=  (~RSPI_TX_START_WAIT);
+   }else if(wait_flg & RSPI_TX_END_WAIT){
+     isig_sem(rspi_stat->int_sync_sem);
+   }
+   rspi_stat->interrupt_wait_flg = wait_flg;
+ }
+ 
+ void rspi_rx_int_handler(intptr_t exinf){
+   rspi_dstat *rspi_stat;
+   uint16_t wait_flg;
+   
+   rspi_stat = (rspi_dstat*)GET_DEV_STAT((dnode_id) exinf);
+   wait_flg = rspi_stat->interrupt_wait_flg;
+   
+   if(wait_flg & RSPI_RX_START_WAIT){
+     wait_flg &=  (~RSPI_RX_START_WAIT);
+   }
+   else if(wait_flg & RSPI_RX_END_WAIT){
+     wait_flg &=  (~RSPI_RX_END_WAIT);
+     isig_sem(rspi_stat->int_sync_sem);
+   }
+   rspi_stat->interrupt_wait_flg = wait_flg;
+ }
+ 
+ 
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/RSPI.cfg ASPs/asp/driver/rx_gcc/RSPI.cfg
*** 1.9.1/asp/driver/rx_gcc/RSPI.cfg	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/RSPI.cfg	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,17 ----
+ 
+ #include <driver/rx_gcc/RSPI.h>
+ 
+ #ifdef USE_RSPI_0
+ /* To use RSPI semaphore */
+ CRE_SEM(RSPI_0_IP_LOCK_SEM, {TA_TPRI, 1, 1 });
+ /* sync innterupt*/
+ CRE_SEM(RSPI_0_INT_SYNC_SEM, {TA_TPRI, 0, 1});
+ 
+ /* tx intterupt */
+ ATT_ISR({TA_NULL, DEV_RSPI0, RSPI_0_TX_INT_NO, rspi_tx_int_handler, 6 });
+ CFG_INT(RSPI_0_TX_INT_NO, {RSPI_INT_ATR, -6});
+ 
+ /* rx intterupt */
+ ATT_ISR({TA_NULL, DEV_RSPI0, RSPI_0_RX_INT_NO, rspi_rx_int_handler, 6 });
+ CFG_INT(RSPI_0_RX_INT_NO, {RSPI_INT_ATR, -6});
+ #endif
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/RSPI.h ASPs/asp/driver/rx_gcc/RSPI.h
*** 1.9.1/asp/driver/rx_gcc/RSPI.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/RSPI.h	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,208 ----
+ /*
+  * Copyright (c) 2015- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ #ifndef RX_GCC_DRIVER_RSPI_H
+ #define RX_GCC_DRIVER_RSPI_H
+ 
+ #include <target_board.h>
+ #include <target_device/device_init/RSPI_init.h>
+ 
+ //target defined parameter
+ #ifdef USE_RSPI_0
+   #ifndef RSPI_0_TX_INT_NO
+     "plese define TX int number in target initilize code"
+     "ex. #define RSPI_0_TX_INT_NO 0"
+   #endif
+   #ifndef RSPI_0_RX_INT_NO
+     "plese define RX int number in target initilize code"
+     "ex. #define RSPI_0_RX_INT_NO 0"
+   #endif
+ #endif
+ #ifdef USE_RSPI_1
+   #ifndef RSPI_1_TX_INT_NO
+     "plese define TX int number in target initilize code"
+     "ex. #define RSPI_1_TX_INT_NO 0"
+   #endif
+   #ifndef RSPI_1_RX_INT_NO2
+     "plese define RX int number in target initilize code"
+     "ex. #define RSPI_1_RX_INT_NO 0"
+   #endif
+ #endif
+ #ifdef USE_RSPI_2
+   #ifndef RSPI_2_TX_INT_NO
+     "plese define TX int number in target initilize code"
+     "ex. #define RSPI_2_TX_INT_NO 0"
+   #endif
+   #ifndef RSPI_2_RX_INT_NO
+     "plese define RX int number in target initilize code"
+     "ex. #define RSPI_2_RX_INT_NO 0"
+   #endif
+ #endif
+ #ifdef USE_RSPI_3
+   #ifndef RSPI_3_TX_INT_NO
+     "plese define TX int number in target initilize code"
+     "ex. #define RSPI_3_TX_INT_NO 0"
+   #endif
+   #ifndef RSPI_3_RX_INT_NO
+     "plese define RX int number in target initilize code"
+     "ex. #define RSPI_3_RX_INT_NO 0"
+   #endif
+ #endif
+   
+ //device node type
+ //rspi node's api is null
+ 
+ //device node status
+ typedef struct rspi_dev_status_type{
+   uint32_t baddr; //base address
+   uint16_t interrupt_wait_flg; //define sort of interrupt(tx or rx)
+   uint8_t spri; //int number of spri
+   uint8_t spti; //int number of spti
+   ID ip_lock_sem; //ip lock semaphore id
+   ID int_sync_sem; //interrupt sync semaphore id
+ } rspi_dstat;
+ 
+ #define RSPI_INT_ATR TA_ENAINT| TA_EDGE
+ 
+ //SPCR BIT Define
+ #define SPCR_SPMS 0x1
+ #define SPCR_TXMD 0x2
+ #define SPCR_MODFEN 0x4
+ #define SPCR_MSTR 0x8
+ #define SPCR_SPEIE 0x10
+ #define SPCR_SPTIE 0x20
+ #define SPCR_SPE 0x40
+ #define SPCR_SPRIE  0x80
+ 
+ //SSLP BIT Define
+ #define SSLP_SSL0P 0x1
+ #define SSLP_SSL1P 0x2
+ #define SSLP_SSL2P 0x4
+ #define SSLP_SSL3P 0x8
+ 
+ //SPPCR BIT Define
+ #define SPPCR_SPLP 0x1
+ #define SPPCR_SPLP2_ 0x2
+ #define SPPCR_MOIFV 0x10
+ #define SPPCR_MOIFE 0x20
+ 
+ //SPSR BIT Define
+ #define SPSR_OVRF 0x1
+ #define SPSR_IDLNF 0x2
+ #define SPSR_MODF 0x4
+ #define SPSR_PERF 0x8
+ 
+ //SPSCR BIT Define
+ #define SPSCR_SPSLN_1 0x0
+ #define SPSCR_SPSLN_2 0x1
+ #define SPSCR_SPSLN_3 0x2
+ #define SPSCR_SPSLN_4 0x3
+ #define SPSCR_SPSLN_5 0x4
+ #define SPSCR_SPSLN_6 0x5
+ #define SPSCR_SPSLN_7 0x6
+ #define SPSCR_SPSLN_8 0x7
+ 
+ //SPDCR BIT Define
+ #define SPDCR_SPFC_MASK 0x3
+ #define SPDCR_SPFC_1 0x0
+ #define SPDCR_SPFC_2 0x1
+ #define SPDCR_SPFC_3 0x2
+ #define SPDCR_SPFC_4 0x3
+ #define SPDCR_SPRDTD 0x10
+ #define SPDCR_SPLW 0x20
+ 
+ //SPCR2 BIT Define
+ #define SPCR2_SPPE 0x1
+ #define SPCR2_SPOE 0x2
+ #define SPCR2_SPIIE 0x4
+ #define SPCR2_PTE 0x8
+ 
+ //SPCMD BIT Define
+ #define SPCMD_CPHA 0x1
+ #define SPCMD_CPOL 0x2
+ #define SPCMD_BRDV_MASK 0xC
+ #define SPCMD_BRDV_0 0x0
+ #define SPCMD_BRDV_1 0x4
+ #define SPCMD_BRDV_2 0x8
+ #define SPCMD_BRDV_3 0xC
+ #define SPCMD_SSLA_MASK 0x70
+ #define SPCMD_SSLA_SSL0 0x0
+ #define SPCMD_SSLA_SSL1 0x10
+ #define SPCMD_SSLA_SSL2 0x20
+ #define SPCMD_SSLA_SSL3 0x30
+ #define SPCMD_SSLKP 0x80
+ #define SPCMD_SPB_MASK 0xF00
+ #define SPCMD_SPB_8 0x700
+ #define SPCMD_SPB_9 0x800
+ #define SPCMD_SPB_10 0x900
+ #define SPCMD_SPB_11 0xA00
+ #define SPCMD_SPB_12 0xB00
+ #define SPCMD_SPB_13 0xC00
+ #define SPCMD_SPB_14 0xD00
+ #define SPCMD_SPB_15 0xE00
+ #define SPCMD_SPB_16 0xF00
+ #define SPCMD_SPB_20 0x000
+ #define SPCMD_SPB_24 0x100
+ #define SPCMD_SPB_32 0x200
+ #define SPCMD_LSBF 0x1000
+ #define SPCMD_LSBF_MSB 0x0
+ #define SPCMD_LSBF_LSB 0x1000
+ 
+ //rspi_param_t is argument of rspi_init
+ typedef struct rspi_param_type{
+   uint8_t spcr;
+   uint8_t sslp;
+   uint8_t sppcr;
+   uint8_t spscr;
+   uint32_t bit_rate;
+   uint8_t spdcr;
+   uint16_t spcmd0;
+ } rspi_param_t;
+ 
+ void rspi_init(void *, rspi_param_t* );
+ 
+ void rspi_disable(void *);
+ void rspi_enable(void *);
+ 
+ //bit rate config
+ void rspi_chg_bit_rate(void *, uint8_t );
+ 
+ //SEND/RECIVE data function
+ //  read or write spdr register
+ void rspi_send_w(void *, uint32_t);
+ void rspi_send_h(void *, uint16_t);
+ void rspi_send_b(void *, uint8_t);
+ uint32_t rspi_rcv_w(void *);
+ uint16_t rspi_rcv_h(void *);
+ uint8_t rspi_rcv_b(void *);
+ 
+ #ifdef USE_DTCA_0
+ //read or write data block by dtca
+ void rspi_send_by_dtca(void *v_rspi_stat, uint32_t* s_buff, uint32_t s_size);
+ void rspi_recieve_by_dtca(void *v_rspi_stat, uint32_t* s_buff, uint32_t s_size);
+ #endif
+ 
+ //send dat and return recive data
+ //  this fucntion is used interrupt.
+ uint32_t rspi_xchg_rw(void *v_rspi_stat,  uint32_t dat);
+ 
+ //read rspi status
+ // return spsr register
+ uint8_t rspi_status(void *);
+ 
+ 
+ void rspi_set_cmd(void *, uint8_t, uint8_t);
+ 
+ //change data width of transfer
+ void rspi_chg_dwidth(void *, uint8_t, uint32_t);
+ 
+ //lock rspi device
+ void rspi_get_right(void *v_rspi_stat);
+ void rspi_relese_right(void *v_rspi_stat);
+ 
+ //interrupt handler
+ void rspi_tx_int_handler(intptr_t exinf);
+ void rspi_rx_int_handler(intptr_t exinf);
+ #endif
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/SCIc.c ASPs/asp/driver/rx_gcc/SCIc.c
*** 1.9.1/asp/driver/rx_gcc/SCIc.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/SCIc.c	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,309 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ 
+ /*
+  *   Renesas SCIc(UART)用 簡易SIOドライバ
+  */
+ 
+ #include <kernel.h>
+ #include <t_syslog.h>
+ #include "target_syssvc.h"
+ #include "SCIc.h"
+ 
+ /* シリアルモードレジスタ（SMR) */
+ #define CKS			UINT_C(0x03)
+ #define STOP		UINT_C(0x08)
+ #define PM			UINT_C(0x10)
+ #define PE			UINT_C(0x20)
+ #define CHR			UINT_C(0x40)
+ #define CM			UINT_C(0x80)
+ #define ASYNC_7BIT	UINT_C(0x00)
+ #define ASYNC_8BIT	UINT_C(0x40)
+ 
+ /* シリアルコントロールレジスタ（SCR) */
+ #define CKE			UINT_C(0x03)
+ #define TEIE		UINT_C(0x04)
+ #define RE			UINT_C(0x10)
+ #define TE			UINT_C(0x20)
+ #define RIE			UINT_C(0x40)
+ #define TIE			UINT_C(0x80)
+ 
+ /* シリアルステータスレジスタ（SSR） */
+ #define TEND		UINT_C(0x04)
+ #define PER			UINT_C(0x08)
+ #define FER			UINT_C(0x10)
+ #define ORER		UINT_C(0x20)
+ 
+ /* シリアル拡張モードレジスタ（SEMR) */
+ #define ACS0		UINT_C(0x01)
+ #define ABCS		UINT_C(0x10)
+ 
+ #define SCI_SCR_FLG_ENABLE	(RE | TE)
+ #define SCI_SMR_FLG_ENABLE	(STOP | PM | PE | CHR | CM)
+ 
+ /*
+  *  シリアルI/OポートIDから管理ブロックを取り出すためのマクロ
+  */
+ 
+ #define get_siopinib(siopcb_stat) (siopcb_stat->p_siopinib)
+ 
+ /*
+  * enable transmit
+  */
+ void
+ scic_uart_trans_enable(void* p_siopcb_v){
+ 	SIOPCB          *p_siopcb;
+ 	const SIOPINIB  *p_siopinib;
+ 
+ 	p_siopcb = (SIOPCB*) p_siopcb_v;
+ 	p_siopinib = p_siopcb->p_siopinib;
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg,
+ 					(uint8_t)(sil_reb_mem((void *)p_siopinib->ctlreg) | TE));
+ }
+ /*
+  *  SIOドライバのシリアルモードレジスタ(SMR)
+  */
+ void
+ scic_uart_setmode(const SIOPINIB *p_siopinib, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	uint8_t i;
+ 
+ 	/*
+ 	 *  SCIドライバの初期化ルーチン
+ 	 */
+ 
+ 	/*
+ 	 *  割り込み要求先レジスタの設定(ISELRi)
+ 	 *
+ 	 *  リセット値と同じ値を設定することになるため,
+ 	 *  処理は省略する.
+ 	 */
+ 
+ 	/* 送受信禁止, SCKn端子は入出力ポートとして使用 */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 0x00U);
+ 
+ 	/* クロック選択ビット(SMR.CKS[1:0]ビットを設定) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 					sil_reb_mem((void *)p_siopinib->modereg) | clksrc);
+ 
+ 	/* SMRに送信／ 受信フォーマットを設定) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 			sil_reb_mem((void *)p_siopinib->modereg) & (~SCI_SMR_FLG_ENABLE));
+ 
+ 	/* ビットレートを設定 */
+ 	sil_wrb_mem((void *)p_siopinib->bitratereg, bitrate);
+ 
+ 	/* ビット期間(基本クロック16サイクルの期間が1ビット期間となる) */
+ 	while(i < 16){
+ 		i++;
+ 	}
+ 
+ 	/* 送受信許可 */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 			(sil_reb_mem((void *)p_siopinib->ctlreg) | SCI_SCR_FLG_ENABLE));
+ }
+ 
+ /*
+  *  シリアルI/Oポートのオープン
+  */
+ void
+ scic_uart_opn_por
+ 	(void* p_siopcb_v, intptr_t exinf, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb;
+ 	const SIOPINIB  *p_siopinib;
+ 
+ 	p_siopcb = (SIOPCB*) p_siopcb_v;
+ 	p_siopinib = p_siopcb->p_siopinib;
+ 
+ 	/*
+ 	 *  ハードウェアの初期化
+ 	 *
+ 	 *  既に初期化している場合は, 二重に初期化しない.
+ 	 */
+ 	if(!(p_siopcb->is_initialized)){
+ 		scic_uart_setmode(p_siopinib, bitrate, clksrc);
+ 		p_siopcb->is_initialized = true;
+ 	}
+ 
+ 	p_siopcb->exinf = exinf;
+ 	p_siopcb->getready = p_siopcb->putready = false;
+ 	p_siopcb->openflag = true;
+ 
+ }
+ 
+ /*
+  *  シリアルI/Oポートのクローズ
+  */
+ void
+ scic_uart_cls_por(void *p_siopcb_v)
+ {
+ 	/*
+ 	 *  UART停止
+ 	 */
+   SIOPCB *p_siopcb;
+   p_siopcb = p_siopcb_v;
+   sil_wrh_mem((void *)p_siopcb->p_siopinib->ctlreg, 0x00U);
+   p_siopcb->openflag = false;
+   p_siopcb->is_initialized = false;
+ }
+ 
+ /*
+  *  シリアルI/Oポートへの文字送信
+  */
+ bool_t
+ scic_uart_snd_chr(void *p_siopcb_v, char c)
+ {
+ 	bool_t ercd = false;
+     SIOPCB *p_siopcb;
+ 
+     p_siopcb = (SIOPCB *)p_siopcb_v;
+ 	if((sil_reb_mem((void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0){
+ 		sil_wrb_mem((void *)p_siopcb->p_siopinib->tdreg, (uint8_t)c);
+ 		ercd = true;
+ 	}
+ 
+ 	return ercd;
+ }
+ 
+ /*
+  *  シリアルI/Oポートからの文字受信
+  */
+ int_t
+ scic_uart_rcv_chr(void *p_siopcb_v)
+ {
+ 	int_t c = -1;
+     SIOPCB *p_siopcb;
+ 
+     p_siopcb = (SIOPCB *)p_siopcb_v;
+ 
+ 	/*
+ 	 *  受信フラグがONのときのみ受信バッファから文字を取得する.
+ 	 *  これは, ポーリング受信に対応するためである.
+ 	 *  しかし, SCICでは受信フラグがないこと, システムサービス
+ 	 *  では受信割込みの中からしかデータを受信しに来ないことから, 常に
+ 	 *  受信バッファから文字を取得する.
+ 	 */
+ 	c = (int)(sil_reb_mem((void *)p_siopcb->p_siopinib->rdreg));
+ 
+ 	return c;
+ }
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの許可
+  */
+ void
+ scic_uart_ena_cbr(void *p_siopcb_v, uint_t cbrtn)
+ {
+     SIOPCB *p_siopcb;
+ 
+     p_siopcb = (SIOPCB *)p_siopcb_v;
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_TEIE_BIT));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_RIE_BIT));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの禁止
+  */
+ void
+ scic_uart_dis_cbr(void *p_siopcb_v, uint_t cbrtn)
+ {
+     SIOPCB *p_siopcb;
+ 
+     p_siopcb = (SIOPCB *)p_siopcb_v;
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_TEIE_BIT)));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_RIE_BIT)));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  SIOの割込みサービスルーチン
+  */
+ void
+ scic_uart_tx_isr(dnode_id sio_did)
+ {
+   SIOPCB *p_siopcb = GET_DEV_STAT(sio_did);
+ 
+   if((sil_reb_mem(
+        (void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0U){
+     /*
+      *  送信可能コールバックルーチンを呼び出す．
+      */
+     scic_uart_irdy_snd(p_siopcb->exinf);
+   }
+ }
+ 
+ void
+ scic_uart_rx_isr(dnode_id sio_did)
+ {
+   SIOPCB	*p_siopcb = (SIOPCB*)GET_DEV_STAT(sio_did);
+ 
+   /*
+    *  受信フラグがONのときのみ受信通知コールバックルーチンを呼び出す.
+    *  しかし, SCICでは受信フラグがないため, 常に受信通知
+    *  コールバックルーチンを呼び出す.
+    *  ここでは受信割込みの発生を信じる.
+    */
+   /*
+    *  受信通知コールバックルーチンを呼び出す．
+    */
+   scic_uart_irdy_rcv(p_siopcb->exinf);
+ }
+ 
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/SCIc.h ASPs/asp/driver/rx_gcc/SCIc.h
*** 1.9.1/asp/driver/rx_gcc/SCIc.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/SCIc.h	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,154 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *  RX610 UART用 簡易SIOドライバ
+  */
+ 
+ #ifndef TOPPERS_RX_UART_H
+ #define TOPPERS_RX_UART_H
+ 
+ #include <sil.h>
+ #include <target_device/target_device.h>
+ /* 指定可能なクロックソース */
+ #define CLK_F1	UINT_C(0x00)
+ #define CLK_F4	UINT_C(0x01)
+ #define CLK_F16	UINT_C(0x02)
+ #define CLK_F64	UINT_C(0x03)
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックの定義
+  */
+ /*
+  *  シリアルI/Oポート初期化ブロックの定義
+  */
+ typedef struct sio_port_initialization_block {
+ 	volatile uint8_t	*ctlreg;		/* シリアルコントロールレジスタ（SCR) */
+ 	volatile uint8_t	*modereg;		/* シリアルモードレジスタ（SMR) */
+ 	volatile uint8_t	*extmodereg;	/* シリアル拡張モードレジスタ（SEMR) */	
+ 	volatile uint8_t	*statusreg;		/* シリアルステータスレジスタ（SSR） */
+ 	volatile uint8_t	*tdreg;			/* トランスミットデータレジスタ（TDR)*/
+ 	volatile uint8_t	*rdreg;			/* レシーブデータレジスタ（RDR) */
+ 	volatile uint8_t	*bitratereg;	/* ビットレートレジスタ（BRR) */
+ 	volatile uint8_t	*ssrreg;		/* ステータスレジスタ */
+ 	uint8_t				tx_intno;		/* 送信（データエンプティ）割り込み番号 */
+ 	uint8_t				rx_intno;		/* 受信（データフル）割り込み番号 */
+ 	uint8_t				te_intno;		/* 送信（終了）割り込み番号 */
+ } SIOPINIB;
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックの定義
+  */
+ struct sio_port_control_block {
+ 	const SIOPINIB	*p_siopinib; 				/* シリアルI/Oポート初期化ブロック */
+ 	intptr_t 	exinf;			 				/* 拡張情報 */
+ 	bool_t		openflag;						/* オープン済みフラグ */
+ 	bool_t		sendflag;						/* 送信割込みイネーブルフラグ */
+ 	bool_t		getready;						/* 文字を受信した状態 */
+ 	bool_t		putready;						/* 文字を送信できる状態 */
+ 	bool_t		is_initialized; 				/* デバイス初期化済みフラグ */
+ };
+ 
+ typedef struct sio_port_control_block	SIOPCB;
+ 
+ /*
+  *  コールバックルーチンの識別番号
+  */
+ #define SIO_RDY_SND    (1U)        /* 送信可能コールバック */
+ #define SIO_RDY_RCV    (2U)        /* 受信通知コールバック */
+ 
+ /*
+  *  シリアルI/Oポートのオープン
+  */
+ extern void scic_uart_opn_por
+ 	(void* p_siopcb_v, intptr_t exinf , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  シリアルI/Oポートのクローズ
+  */
+ extern void scic_uart_cls_por(void *p_siopcb);
+ 
+ /*
+  *  シリアルI/Oポートへの文字送信
+  */
+ extern bool_t scic_uart_snd_chr(void *p_siopcb, char c);
+ 
+ /*
+  *  シリアルI/Oポートからの文字受信
+  */
+ extern int_t scic_uart_rcv_chr(void *p_siopcb);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの許可
+  */
+ extern void  scic_uart_ena_cbr(void *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの禁止
+  */
+ extern void scic_uart_dis_cbr(void *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  SIOの割込みサービスルーチン
+  */
+ extern void scic_uart_tx_isr(dnode_id sio_did);
+ extern void scic_uart_rx_isr(dnode_id sio_did);
+ 
+ /*
+  *  シリアルI/Oポートからの送信可能コールバック
+  */
+ extern void scic_uart_irdy_snd(intptr_t exinf);
+ 
+ /*
+  *  シリアルI/Oポートからの受信通知コールバック
+  */
+ extern void scic_uart_irdy_rcv(intptr_t exinf);
+ 
+ /*
+  * enable transmit
+  */
+ void
+ scic_uart_trans_enable(void* p_siopcb_v);
+ 
+ void
+ scic_uart_setmode(const SIOPINIB *p_siopinib, uint8_t bitrate, uint8_t clksrc);
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ #endif /* TOPPERS_RX610_UART_H */
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/SCIg.c ASPs/asp/driver/rx_gcc/SCIg.c
*** 1.9.1/asp/driver/rx_gcc/SCIg.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/SCIg.c	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,277 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2016 by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ 
+ /*
+  *   Renesas SCIc(UART)用 簡易SIOドライバ
+  */
+ 
+ #include <kernel.h>
+ #include <t_syslog.h>
+ #include "target_syssvc.h"
+ #include "SCIg.h"
+ 
+ #define SCI_SCR_FLG_ENABLE	(SCIG_SCR_RE | SCIG_SCR_TE)
+ #define SCI_SMR_FLG_ENABLE	(SCIG_SMR_STOP | SCIG_SMR_PM | SCIG_SMR_PE | SCIG_SMR_CHR | SCIG_SMR_CM)
+ 
+ /*
+  *  シリアルI/OポートIDから管理ブロックを取り出すためのマクロ
+  */
+ 
+ #define get_siopinib(siopcb_stat) (siopcb_stat->p_siopinib)
+ 
+ /*
+  * enable transmit
+  */
+ void
+ scic_uart_trans_enable(void* p_siopcb_v){
+ 	SIOPCB          *p_siopcb;
+ 	const SIOPINIB  *p_siopinib;
+ 
+ 	p_siopcb = (SIOPCB*) p_siopcb_v;
+ 	p_siopinib = p_siopcb->p_siopinib;
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg,
+ 					(uint8_t)(sil_reb_mem((void *)p_siopinib->ctlreg) | SCIG_SCR_TE));
+ }
+ /*
+  *  SIOドライバのシリアルモードレジスタ(SMR)
+  */
+ void
+ scic_uart_setmode(const SIOPINIB *p_siopinib, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	uint8_t i;
+ 
+ 	/*
+ 	 *  SCIドライバの初期化ルーチン
+ 	 */
+ 
+ 	/*
+ 	 *  割り込み要求先レジスタの設定(ISELRi)
+ 	 *
+ 	 *  リセット値と同じ値を設定することになるため,
+ 	 *  処理は省略する.
+ 	 */
+ 
+ 	/* 送受信禁止, SCKn端子は入出力ポートとして使用 */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 0x00U);
+ 
+ 	/* クロック選択ビット(SMR.CKS[1:0]ビットを設定) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 					 clksrc);
+ 	/* ビットレートを設定 */
+ 	sil_wrb_mem((void *)p_siopinib->bitratereg, bitrate);
+ 
+ 	/* ビット期間(基本クロック16サイクルの期間が1ビット期間となる) */
+ 	while(i < 16){
+ 		i++;
+ 	}
+ 
+ 	/* 送受信許可 */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 			(sil_reb_mem((void *)p_siopinib->ctlreg) | SCI_SCR_FLG_ENABLE));
+ }
+ 
+ /*
+  *  シリアルI/Oポートのオープン
+  */
+ void
+ scic_uart_opn_por
+ 	(void* p_siopcb_v, intptr_t exinf, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb;
+ 	const SIOPINIB  *p_siopinib;
+ 
+ 	p_siopcb = (SIOPCB*) p_siopcb_v;
+ 	p_siopinib = p_siopcb->p_siopinib;
+ 
+ 	/*
+ 	 *  ハードウェアの初期化
+ 	 *
+ 	 *  既に初期化している場合は, 二重に初期化しない.
+ 	 */
+ 	if(!(p_siopcb->is_initialized)){
+ 		scic_uart_setmode(p_siopinib, bitrate, clksrc);
+ 		p_siopcb->is_initialized = true;
+ 	}
+ 
+ 	p_siopcb->exinf = exinf;
+ 	p_siopcb->getready = p_siopcb->putready = false;
+ 	p_siopcb->openflag = true;
+ 
+ }
+ 
+ /*
+  *  シリアルI/Oポートのクローズ
+  */
+ void
+ scic_uart_cls_por(void *p_siopcb_v)
+ {
+ 	/*
+ 	 *  UART停止
+ 	 */
+   SIOPCB *p_siopcb;
+   p_siopcb = p_siopcb_v;
+   sil_wrh_mem((void *)p_siopcb->p_siopinib->ctlreg, 0x00U);
+   p_siopcb->openflag = false;
+   p_siopcb->is_initialized = false;
+ }
+ 
+ /*
+  *  シリアルI/Oポートへの文字送信
+  */
+ bool_t
+ scic_uart_snd_chr(void *p_siopcb_v, char c)
+ {
+ 	bool_t ercd = false;
+     SIOPCB *p_siopcb;
+ 
+     p_siopcb = (SIOPCB *)p_siopcb_v;
+ 	if((sil_reb_mem((void *)p_siopcb->p_siopinib->ssrreg) & SCIG_SSR_TEND) != 0){
+ 		sil_wrb_mem((void *)p_siopcb->p_siopinib->tdreg, (uint8_t)c);
+ 		ercd = true;
+ 	}
+ 
+ 	return ercd;
+ }
+ 
+ /*
+  *  シリアルI/Oポートからの文字受信
+  */
+ int_t
+ scic_uart_rcv_chr(void *p_siopcb_v)
+ {
+ 	int_t c = -1;
+     SIOPCB *p_siopcb;
+ 
+     p_siopcb = (SIOPCB *)p_siopcb_v;
+ 
+ 	/*
+ 	 *  受信フラグがONのときのみ受信バッファから文字を取得する.
+ 	 *  これは, ポーリング受信に対応するためである.
+ 	 *  しかし, SCICでは受信フラグがないこと, システムサービス
+ 	 *  では受信割込みの中からしかデータを受信しに来ないことから, 常に
+ 	 *  受信バッファから文字を取得する.
+ 	 */
+ 	c = (int)(sil_reb_mem((void *)p_siopcb->p_siopinib->rdreg));
+ 
+ 	return c;
+ }
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの許可
+  */
+ void
+ scic_uart_ena_cbr(void *p_siopcb_v, uint_t cbrtn)
+ {
+     SIOPCB *p_siopcb;
+ 
+     p_siopcb = (SIOPCB *)p_siopcb_v;
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCIG_SCR_TIE));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCIG_SCR_RIE));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの禁止
+  */
+ void
+ scic_uart_dis_cbr(void *p_siopcb_v, uint_t cbrtn)
+ {
+     SIOPCB *p_siopcb;
+ 
+     p_siopcb = (SIOPCB *)p_siopcb_v;
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCIG_SCR_TIE)));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCIG_SCR_RIE)));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  SIOの割込みサービスルーチン
+  */
+ void
+ scic_uart_tx_isr(dnode_id sio_did)
+ {
+   SIOPCB *p_siopcb = GET_DEV_STAT(sio_did);
+ 
+   if((sil_reb_mem(
+        (void *)p_siopcb->p_siopinib->ssrreg) & SCIG_SSR_TEND) != 0U){
+     /*
+      *  送信可能コールバックルーチンを呼び出す．
+      */
+     scic_uart_irdy_snd(p_siopcb->exinf);
+   }
+ }
+ 
+ void
+ scic_uart_rx_isr(dnode_id sio_did)
+ {
+   SIOPCB	*p_siopcb = (SIOPCB*)GET_DEV_STAT(sio_did);
+ 
+   /*
+    *  受信フラグがONのときのみ受信通知コールバックルーチンを呼び出す.
+    *  しかし, SCICでは受信フラグがないため, 常に受信通知
+    *  コールバックルーチンを呼び出す.
+    *  ここでは受信割込みの発生を信じる.
+    */
+   /*
+    *  受信通知コールバックルーチンを呼び出す．
+    */
+   scic_uart_irdy_rcv(p_siopcb->exinf);
+ }
+ 
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/SCIg.h ASPs/asp/driver/rx_gcc/SCIg.h
*** 1.9.1/asp/driver/rx_gcc/SCIg.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/SCIg.h	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,212 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *  RX64M UART用 簡易SIOドライバ
+  */
+ 
+ #ifndef TOPPERS_RX_SCIG_H
+ #define TOPPERS_RX_SCIG_H
+ 
+ #include <sil.h>
+ #include <target_device/target_device.h>
+ 
+ /* Register offset */
+ #define SCIG_SMR_OFFSET 0x0
+ #define SCIG_BRR_OFFSET 0x1
+ #define SCIG_SCR_OFFSET 0x2
+ #define SCIG_TDR_OFFSET 0x3
+ #define SCIG_SSR_OFFSET 0x4
+ #define SCIG_RDR_OFFSET 0x5
+ #define SCIG_SCMR_OFFSET 0x6
+ #define SCIG_SEMR_OFFSET 0x7
+ #define SCIG_SNFR_OFFSET 0x8
+ #define SCIG_SIMR1_OFFSET 0x9
+ #define SCIG_SIMR2_OFFSET 0xA
+ #define SCIG_SIMR3_OFFSET 0xB
+ #define SCIG_SISR_OFFSET 0xC
+ #define SCIG_SPMR_OFFSET 0xD
+ #define SCIG_TDRH_OFFSET 0xE
+ #define SCIG_TDRL_OFFSET 0xF
+ #define SCIG_TDRHL_OFFSET 0xE
+ #define SCIG_RDRH_OFFSET 0x10
+ #define SCIG_RDRL_OFFSET 0x11
+ #define SCIG_RDRHL_OFFSET 0x10
+ #define SCIG_MDDR_OFFSET 0x12
+ 
+ /* シリアルモードレジスタ（SMR) */
+ #define SCIG_SMR_CKS			UINT_C(0x03)
+ #define SCIG_SMR_STOP		UINT_C(0x08)
+ #define SCIG_SMR_PM			UINT_C(0x10)
+ #define SCIG_SMR_PE			UINT_C(0x20)
+ #define SCIG_SMR_CHR			UINT_C(0x40)
+ #define SCIG_SMR_CM			UINT_C(0x80)
+ #define SCIG_SMR_ASYNC_7BIT	UINT_C(0x00)
+ #define SCIG_SMR_ASYNC_8BIT	UINT_C(0x40)
+ 
+ /* シリアルコントロールレジスタ（SCR) */
+ #define SCIG_SCR_CKE			UINT_C(0x03)
+ #define SCIG_SCR_TEIE		UINT_C(0x04)
+ #define SCIG_SCR_RE			UINT_C(0x10)
+ #define SCIG_SCR_TE			UINT_C(0x20)
+ #define SCIG_SCR_RIE			UINT_C(0x40)
+ #define SCIG_SCR_TIE			UINT_C(0x80)
+ 
+ /* シリアルステータスレジスタ（SSR） */
+ #define SCIG_SSR_TEND UINT_C(0x04)
+ #define SCIG_SSR_PER UINT_C(0x08)
+ #define SCIG_SSR_FER UINT_C(0x10)
+ #define SCIG_SSR_ORER UINT_C(0x20)
+ 
+ #define SCIG_SCMR_SMIF UINT_C(0x1)
+ #define SCIG_SCMR_SINV UINT_C(0x4)
+ #define SCIG_SCMR_SDIR UINT_C(0x8)
+ #define SCIG_SCMR_CHR1 UINT_C(0x10)
+ #define SCIG_SCMR_BCP2 UINT_C(0x80)
+ #define SCIG_SCMR_RESERVE UINT_C(0x62)
+ 
+ /* シリアル拡張モードレジスタ（SEMR) */
+ #define SCIG_SEMR_ACS0		UINT_C(0x01)
+ #define SCIG_SEMR_ABCS		UINT_C(0x10)
+ 
+ /* 指定可能なクロックソース */
+ #define CLK_F1	UINT_C(0x00)
+ #define CLK_F4	UINT_C(0x01)
+ #define CLK_F16	UINT_C(0x02)
+ #define CLK_F64	UINT_C(0x03)
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックの定義
+  */
+ /*
+  *  シリアルI/Oポート初期化ブロックの定義
+  */
+ typedef struct sio_port_initialization_block {
+ 	volatile uint8_t	*ctlreg;		/* シリアルコントロールレジスタ（SCR) */
+ 	volatile uint8_t	*modereg;		/* シリアルモードレジスタ（SMR) */
+ 	volatile uint8_t	*extmodereg;	/* シリアル拡張モードレジスタ（SEMR) */	
+ 	volatile uint8_t	*statusreg;		/* シリアルステータスレジスタ（SSR） */
+ 	volatile uint8_t	*tdreg;			/* トランスミットデータレジスタ（TDR)*/
+ 	volatile uint8_t	*rdreg;			/* レシーブデータレジスタ（RDR) */
+ 	volatile uint8_t	*bitratereg;	/* ビットレートレジスタ（BRR) */
+ 	volatile uint8_t	*ssrreg;		/* ステータスレジスタ */
+ 	uint8_t				tx_intno;		/* 送信（データエンプティ）割り込み番号 */
+ 	uint8_t				rx_intno;		/* 受信（データフル）割り込み番号 */
+ } SIOPINIB;
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックの定義
+  */
+ struct sio_port_control_block {
+ 	const SIOPINIB	*p_siopinib; 				/* シリアルI/Oポート初期化ブロック */
+ 	intptr_t 	exinf;			 				/* 拡張情報 */
+ 	bool_t		openflag;						/* オープン済みフラグ */
+ 	bool_t		sendflag;						/* 送信割込みイネーブルフラグ */
+ 	bool_t		getready;						/* 文字を受信した状態 */
+ 	bool_t		putready;						/* 文字を送信できる状態 */
+ 	bool_t		is_initialized; 				/* デバイス初期化済みフラグ */
+ };
+ 
+ typedef struct sio_port_control_block	SIOPCB;
+ 
+ /*
+  *  コールバックルーチンの識別番号
+  */
+ #define SIO_RDY_SND    (1U)        /* 送信可能コールバック */
+ #define SIO_RDY_RCV    (2U)        /* 受信通知コールバック */
+ 
+ /*
+  *  シリアルI/Oポートのオープン
+  */
+ extern void scic_uart_opn_por
+ 	(void* p_siopcb_v, intptr_t exinf , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  シリアルI/Oポートのクローズ
+  */
+ extern void scic_uart_cls_por(void *p_siopcb);
+ 
+ /*
+  *  シリアルI/Oポートへの文字送信
+  */
+ extern bool_t scic_uart_snd_chr(void *p_siopcb, char c);
+ 
+ /*
+  *  シリアルI/Oポートからの文字受信
+  */
+ extern int_t scic_uart_rcv_chr(void *p_siopcb);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの許可
+  */
+ extern void  scic_uart_ena_cbr(void *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの禁止
+  */
+ extern void scic_uart_dis_cbr(void *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  SIOの割込みサービスルーチン
+  */
+ extern void scic_uart_tx_isr(dnode_id sio_did);
+ extern void scic_uart_rx_isr(dnode_id sio_did);
+ 
+ /*
+  *  シリアルI/Oポートからの送信可能コールバック
+  */
+ extern void scic_uart_irdy_snd(intptr_t exinf);
+ 
+ /*
+  *  シリアルI/Oポートからの受信通知コールバック
+  */
+ extern void scic_uart_irdy_rcv(intptr_t exinf);
+ 
+ /*
+  * enable transmit
+  */
+ void
+ scic_uart_trans_enable(void* p_siopcb_v);
+ 
+ void
+ scic_uart_setmode(const SIOPINIB *p_siopinib, uint8_t bitrate, uint8_t clksrc);
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ #endif /* TOPPERS_RX_SCIG_H */
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/driver.cfg ASPs/asp/driver/rx_gcc/driver.cfg
*** 1.9.1/asp/driver/rx_gcc/driver.cfg	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/driver.cfg	Fri Dec  9 13:53:58 2022
***************
*** 0 ****
--- 1,4 ----
+ #include <target_board.h>
+ 
+ INCLUDE("driver/rx_gcc/mmc_rspi.cfg");
+ INCLUDE("driver/rx_gcc/RSPI.cfg");
\ No newline at end of file
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/mmc_gpio.c ASPs/asp/driver/rx_gcc/mmc_gpio.c
*** 1.9.1/asp/driver/rx_gcc/mmc_gpio.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/mmc_gpio.c	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,38 ----
+ /*
+  * Copyright (c) 2015- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ 
+ #include <driver/rx_gcc/mmc_gpio.h>
+ 
+ //return sdcard status
+ //  not 0 : card is inserted
+ //  0     : card isn't inserted
+ 
+ uint8_t check_ins_sw(void *v_gpio_stat){
+   mmc_gpio_dstat *gpio_stat;
+   uint8_t io_val;
+   gpio_stat = (mmc_gpio_dstat*)v_gpio_stat;
+   io_val =sil_reb_mem(gpio_stat->cd_pidr_baddr);
+   if((io_val & gpio_stat->cd_bit_mask) == gpio_stat->cd_bit_val)
+ 	return 1;
+   else
+     return 0;
+ }
+ 
+ void deselect_gpio_cs(void *v_gpio_stat){
+   mmc_gpio_dstat *gpio_stat;
+   uint8_t current;
+   gpio_stat = (mmc_gpio_dstat*)v_gpio_stat;
+   current = sil_reb_mem(gpio_stat->cs_podr_baddr) | gpio_stat->cs_bit_mask;
+   sil_wrb_mem(gpio_stat->cs_podr_baddr, current);
+ }
+ 
+ void select_gpio_cs(void *v_gpio_stat){
+   mmc_gpio_dstat *gpio_stat;
+   uint8_t current;
+   gpio_stat = (mmc_gpio_dstat*)v_gpio_stat;
+   current = sil_reb_mem(gpio_stat->cs_podr_baddr) & ~(gpio_stat->cs_bit_mask);
+   sil_wrb_mem(gpio_stat->cs_podr_baddr, current);
+ }
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/mmc_gpio.h ASPs/asp/driver/rx_gcc/mmc_gpio.h
*** 1.9.1/asp/driver/rx_gcc/mmc_gpio.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/mmc_gpio.h	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,26 ----
+ /*
+  * Copyright (c) 2015- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ 
+ #ifndef MMC_GPIO_DEF_H
+ #define MMC_GPIO_DEF_H
+ 
+ #include <target_board.h>
+ 
+ 
+ //rspi_mmc_node's status
+ typedef struct mmc_gpio_status_type{
+   uint8_t *cd_pidr_baddr;
+   uint8_t cd_bit_mask;
+   uint8_t cd_bit_val;
+   uint8_t *cs_podr_baddr;
+   uint8_t cs_bit_mask;
+ } mmc_gpio_dstat;
+ 
+ uint8_t check_ins_sw(void*);
+ void select_gpio_cs(void *v_gpio_stat);
+ void deselect_gpio_cs(void *v_gpio_stat);
+ 
+ #endif
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/mmc_rspi.c ASPs/asp/driver/rx_gcc/mmc_rspi.c
*** 1.9.1/asp/driver/rx_gcc/mmc_rspi.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/mmc_rspi.c	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,776 ----
+ /*------------------------------------------------------------------------*/
+ /* FRK-RX62N: MMCv3/SDv1/SDv2 (SPI mode) Control Module                   */
+ /*------------------------------------------------------------------------*/
+ /*
+ /  Copyright (C) 2014, ChaN, all right reserved.
+ /                2016, modified by Hisashi Hata
+ /
+ / * This software is a free software and there is NO WARRANTY.
+ / * No restriction on use. You can use, modify and redistribute it for
+ /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
+ / * Redistributions of source code must retain the above copyright notice.
+ /
+ /-------------------------------------------------------------------------*/
+ 
+ #include <kernel.h>
+ #include <sil.h>
+ #include <driver/rx_gcc/mmc_rspi.h>
+ #include <driver/rx_gcc/mmc_gpio.h>
+ 
+ #define	WP			0 						/* Write protect switch (Protected:True, Enabled:False) */
+ 
+ #define SCLK_FAST	12000000UL	/* SCLK frequency (R/W) */
+ #define	SCLK_SLOW	400000UL	/* SCLK frequency (Init) */
+ 
+ static inline uint32_t LDDW( uint32_t data )
+ {
+   __asm__("revl	%1, %0":"=r"(data):"r"(data));
+   return data;
+ }
+ 
+ #ifdef RSPI_MMC_DTCA_TRANS
+ #include <driver/rx_gcc/DTCa.h>
+ 
+ /*
+  * define dtca buffer
+  */
+ uint32_t rspi_mmc_dtca_buffer[128]; //512byte
+ 
+ #endif
+ 
+ /*--------------------------------------------------------------------------
+ 
+    Module Private Functions
+ 
+ ---------------------------------------------------------------------------*/
+ 
+ /* MMC/SD command */
+ #define CMD0	(0)			/* GO_IDLE_STATE */
+ #define CMD1	(1)			/* SEND_OP_COND (MMC) */
+ #define	ACMD41	(0x80+41)	/* SEND_OP_COND (SDC) */
+ #define CMD8	(8)			/* SEND_IF_COND */
+ #define CMD9	(9)			/* SEND_CSD */
+ #define CMD10	(10)		/* SEND_CID */
+ #define CMD12	(12)		/* STOP_TRANSMISSION */
+ #define ACMD13	(0x80+13)	/* SD_STATUS (SDC) */
+ #define CMD16	(16)		/* SET_BLOCKLEN */
+ #define CMD17	(17)		/* READ_SINGLE_BLOCK */
+ #define CMD18	(18)		/* READ_MULTIPLE_BLOCK */
+ #define CMD23	(23)		/* SET_BLOCK_COUNT (MMC) */
+ #define	ACMD23	(0x80+23)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
+ #define CMD24	(24)		/* WRITE_BLOCK */
+ #define CMD25	(25)		/* WRITE_MULTIPLE_BLOCK */
+ #define CMD32	(32)		/* ERASE_ER_BLK_START */
+ #define CMD33	(33)		/* ERASE_ER_BLK_END */
+ #define CMD38	(38)		/* ERASE */
+ #define CMD55	(55)		/* APP_CMD */
+ #define CMD58	(58)		/* READ_OCR */
+ 
+ //time out flag
+ #define DATA_TRANS_TIME 0x1
+ #define WAIT_TIME 0x2
+ 
+ //time out flag management function
+ inline void clear_timeout_timer(mmc_rspi_stat_t *mmc_stat, uint8_t flg_bit){
+   mmc_stat->tout_flg &= ~flg_bit;
+ }
+ 
+ inline uint8_t is_timeout(mmc_rspi_stat_t *mmc_stat, uint8_t flg_bit){
+   return mmc_stat->tout_flg & flg_bit;
+ }
+ 
+ void fast_clk_mode(rspi_dstat* rspi_stat){
+     rspi_disable(rspi_stat);
+     rspi_chg_bit_rate(rspi_stat, F_PCLKB/2/SCLK_FAST-1);
+     rspi_enable(rspi_stat);
+ }
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Control SPI module                                                    */
+ /*-----------------------------------------------------------------------*/
+ /* Only these five functions are platform dependent. Any other functions */
+ /* are portable to different system.                                     */
+ 
+ /*---------------------------------*/
+ /* Enable SPI and MMC/SDC controls */
+ /*---------------------------------*/
+ static
+ void power_on (mmc_rspi_stat_t* mmc_stat)
+ {
+ 
+   rspi_param_t rspi_param;
+   rspi_dstat* rspi_stat;
+ 
+   rspi_stat = (rspi_dstat*)GET_DEV_STAT(mmc_stat->mmc_drv_id);
+   
+   /* Initialize RSPI module */
+   rspi_param.spcr = (SPCR_SPE | SPCR_MSTR | SPCR_SPMS); //enable rspi, set master mode, s clock synchronized mode
+   rspi_param.sslp = 0;
+   rspi_param.sppcr = 0;
+   rspi_param.spscr = 0;
+   rspi_param.bit_rate = SCLK_SLOW;
+   rspi_param.spdcr = SPDCR_SPLW; //access type is long word(32 bit)
+   rspi_param.spcmd0 = SPCMD_SPB_8; //8bit transfer mode
+   
+   rspi_init(rspi_stat, &rspi_param);
+ }
+ 
+ 
+ /*---------------------*/
+ /*    Disable SPI      */
+ /*---------------------*/
+ static
+ void power_off (mmc_rspi_stat_t* mmc_stat)	/* Disable MMC/SDC interface */
+ {
+   rspi_disable((rspi_dstat*)GET_DEV_STAT(mmc_stat->mmc_drv_id));
+   //RSPI.SPCR.BYTE = 0;		/* Stop RSPI module */
+ }
+ 
+ 
+ /*---------------------*/
+ /* Send/Receive a byte */
+ /*---------------------*/
+ static
+ uint32_t xchg_spi (
+                   mmc_rspi_stat_t *mmc_stat,
+                   uint32_t dat	/* Data to send */
+                   )
+ {
+   rspi_dstat *rspi_stat;
+ 
+   rspi_stat = (rspi_dstat*)GET_DEV_STAT(mmc_stat->mmc_drv_id);
+   return rspi_xchg_rw(rspi_stat, dat);
+ }
+ 
+ 
+ #ifdef RSPI_MMC_DTCA_TRANS
+ /*-------------------------------------*/
+ /* Send multiple bytes by dtca write */
+ /*-------------------------------------*/
+ static
+ void xmit_spi_multi (
+                      mmc_rspi_stat_t *mmc_stat,
+                      const uint8_t *buff,	/* Pointer to the data */
+                      uint32_t btx			/* Number of bytes to send (multiple of 4) */
+                      )
+ {
+   const uint32_t *lp = (const uint32_t*)buff;
+   uint32_t i;
+   rspi_dstat *rspi_stat;
+ 
+   rspi_stat = (rspi_dstat*)GET_DEV_STAT(mmc_stat->mmc_drv_id);
+   rspi_chg_dwidth(rspi_stat, 0, SPCMD_SPB_32);	/* Set 32-bit mode */
+ 
+   for(i=0; i<(btx/4); i++){
+     rspi_mmc_dtca_buffer[i] = LDDW(*(lp + i));
+   }
+ 
+   rspi_send_by_dtca(rspi_stat, rspi_mmc_dtca_buffer, btx);
+ 
+   rspi_chg_dwidth(rspi_stat, 0, SPCMD_SPB_8);	/* Set 8-bit mode */
+ }
+ 
+ #else
+ /*-------------------------------------*/
+ /* Send multiple bytes by single write */
+ /*-------------------------------------*/
+ static
+ void xmit_spi_multi (
+                      mmc_rspi_stat_t *mmc_stat,
+                      const uint8_t *buff,	/* Pointer to the data */
+                      uint32_t btx			/* Number of bytes to send (multiple of 4) */
+                      )
+ {
+   const uint32_t *lp = (const uint32_t*)buff;
+   rspi_dstat *rspi_stat;
+ 
+   rspi_stat = (rspi_dstat*)GET_DEV_STAT(mmc_stat->mmc_drv_id);
+   rspi_chg_dwidth(rspi_stat, 0, SPCMD_SPB_32);	/* Set 32-bit mode */
+   
+   do {
+     rspi_send_w(rspi_stat, LDDW(*lp++));	/* Send four data bytes */
+     while (rspi_status(rspi_stat) & SPSR_IDLNF) ;	/* Wait for end of transfer */
+     rspi_rcv_w(rspi_stat);					/* Discard four received bytes */
+   } while (btx -= 4);					/* Repeat until all data sent */
+   
+   rspi_chg_dwidth(rspi_stat, 0, SPCMD_SPB_8);	/* Set 8-bit mode */
+ }
+ 
+ #endif
+ /*------------------------*/
+ /* Receive multiple bytes */
+ /*------------------------*/
+ #ifdef RSPI_MMC_DTCA_TRANS
+ static
+ void rcvr_spi_multi (
+                      mmc_rspi_stat_t *mmc_stat,
+                      uint8_t *buff,		/* Pointer to data buffer */
+                      uint32_t btr		/* Number of bytes to receive (multiple of 4) */
+                      )
+ {
+   uint32_t *lp = (uint32_t*)buff;
+   uint32_t i;
+   rspi_dstat *rspi_stat;
+ 
+   rspi_stat = (rspi_dstat*)GET_DEV_STAT(mmc_stat->mmc_drv_id);
+ 
+   rspi_chg_dwidth(rspi_stat, 0, SPCMD_SPB_32);	/* Set 32-bit mode */
+ 
+   rspi_recieve_by_dtca(rspi_stat, lp, btr);
+ 
+   for(i=0; i<(btr/4); i++){
+     lp[i] = LDDW(lp[i]);
+   }
+ 
+   rspi_chg_dwidth(rspi_stat, 0, SPCMD_SPB_8);	/* Set 8-bit mode */
+ }
+ 
+ #else
+ static
+ void rcvr_spi_multi (
+                      mmc_rspi_stat_t *mmc_stat,
+                      uint8_t *buff,		/* Pointer to data buffer */
+                      uint32_t btr		/* Number of bytes to receive (multiple of 4) */
+                      )
+ {
+   uint32_t *lp = (uint32_t*)buff;
+   rspi_dstat *rspi_stat;
+ 
+   rspi_stat = (rspi_dstat*)GET_DEV_STAT(mmc_stat->mmc_drv_id);
+ 
+   rspi_chg_dwidth(rspi_stat, 0, SPCMD_SPB_32);	/* Set 32-bit mode */
+   
+   do {
+     rspi_send_w(rspi_stat, 0xFFFFFFFF);	/* Send four 0xFFs */
+     while (rspi_status(rspi_stat) & SPSR_IDLNF);/* Wait for end of transfer */
+     *lp++ = LDDW(rspi_rcv_w(rspi_stat));	/* Store four received bytes */
+   } while (btr -= 4);					/* Repeat until all data received */
+   
+   rspi_chg_dwidth(rspi_stat, 0, SPCMD_SPB_8);	/* Set 8-bit mode */
+ }
+ #endif
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Wait for card ready                                                   */
+ /*-----------------------------------------------------------------------*/
+ 
+ static
+ int wait_ready (	/* 1:Ready, 0:Timeout */
+                 mmc_rspi_stat_t *mmc_stat,
+                 uint32_t wt			/* Timeout [ms] */
+                     )
+ {
+   clear_timeout_timer(mmc_stat, WAIT_TIME);
+   sta_alm(mmc_stat-> tout_task_id_1, wt);
+   
+   do {
+     if (xchg_spi(mmc_stat, 0xFF) == 0xFF){
+     	/* Card goes ready */
+     	stp_alm(mmc_stat-> tout_task_id_1);
+     	return 1;
+     }
+     /* This loop takes a time. Insert rot_rdq() here for multitask envilonment. */
+     //rot_rdq();
+   } while (!is_timeout(mmc_stat, WAIT_TIME));    /* Wait until card goes ready or timeout */
+   stp_alm(mmc_stat-> tout_task_id_1);
+   
+   return 0;	/* Timeout occured */
+ }
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Deselect card and release SPI                                         */
+ /*-----------------------------------------------------------------------*/
+ 
+ static
+ void deselect (mmc_rspi_stat_t *mmc_stat)
+ {
+   deselect_gpio_cs(GET_DEV_STAT(mmc_stat->mmc_ins_id)); /* Set CS# high */
+   xchg_spi(mmc_stat, 0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
+ }
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Select card and wait for ready                                        */
+ /*-----------------------------------------------------------------------*/
+ 
+ static
+ int select (mmc_rspi_stat_t* mmc_stat)	/* 1:OK, 0:Timeout */
+ {
+     
+   select_gpio_cs(GET_DEV_STAT(mmc_stat->mmc_ins_id)); //set cs# low
+   xchg_spi(mmc_stat, 0xFF);	/* Dummy clock (force DO enabled) */
+   
+   if (wait_ready(mmc_stat, 1000)) return 1;	/* Wait for card ready */
+   
+   deselect(mmc_stat);
+   return 0;	/* Failed to select the card due to timeout */
+ }
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Receive a data packet from the MMC                                    */
+ /*-----------------------------------------------------------------------*/
+ 
+ static
+ int rcvr_datablock (	/* 1:OK, 0:Error */
+                     mmc_rspi_stat_t *mmc_stat,
+                     uint8_t *buff,			/* Data buffer */
+                     uint32_t btr			/* Data block length (byte) */
+                         )
+ {
+   uint8_t token;
+ 
+   clear_timeout_timer(mmc_stat, DATA_TRANS_TIME);
+   sta_alm(mmc_stat-> tout_task_id_0, 1000);
+   do {							/* Wait for DataStart token in timeout of 200ms */
+     token = xchg_spi(mmc_stat, 0xFF);
+     /* This loop will take a time. Insert rot_rdq() here for multitask envilonment. */
+   } while ((token == 0xFF) && (!is_timeout(mmc_stat, DATA_TRANS_TIME)));
+   stp_alm(mmc_stat-> tout_task_id_0);
+ 
+   if (token != 0xFE) return 0;	/* Function fails if invalid DataStart token or timeout */
+   rcvr_spi_multi(mmc_stat, buff, btr);		/* Store trailing data to the buffer */
+   xchg_spi(mmc_stat, 0xFF); xchg_spi(mmc_stat, 0xFF);	/* Discard CRC */
+     
+   return 1;						/* Function succeeded */
+ }
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Send a data packet to the MMC                                         */
+ /*-----------------------------------------------------------------------*/
+ 
+ #if _USE_WRITE
+ static
+ int xmit_datablock (	/* 1:OK, 0:Failed */
+                     void *v_stat,
+                     const uint8_t *buff,	/* Ponter to 512 byte data to be sent */
+                     uint8_t token			/* Token */
+ )
+ {
+ 	uint8_t resp;
+     mmc_rspi_stat_t *mmc_stat;
+ 
+ 	mmc_stat = (mmc_rspi_stat_t*)v_stat;
+ 
+ 	if (!wait_ready(mmc_stat, 1000)) return 0;		/* Wait for card ready */
+ 
+ 	xchg_spi(mmc_stat, token);					/* Send token */
+ 	if (token != 0xFD) {				/* Send data if token is other than StopTran */
+       xmit_spi_multi(mmc_stat, buff, 512);		/* Data */
+       xchg_spi(mmc_stat, 0xFF); xchg_spi(mmc_stat, 0xFF);	/* Dummy CRC */
+       
+       resp = xchg_spi(mmc_stat, 0xFF);			/* Receive data resp */
+       if ((resp & 0x1F) != 0x05){		/* Function fails if the data packet was not accepted */
+         return 0;
+       }
+ 	}
+ 
+ 	return 1;
+ }
+ #endif /* _USE_WRITE */
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Send a command packet to the MMC                                      */
+ /*-----------------------------------------------------------------------*/
+ 
+ static
+ uint8_t send_cmd (		/* Return value: R1 resp (bit7==1:Failed to send) */
+                   mmc_rspi_stat_t *mmc_stat,
+                   uint8_t cmd,		/* Command index */
+                   uint32_t arg		/* Argument */
+                         )
+ {
+ 	uint8_t n, res;
+ 
+ 	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
+ 		cmd &= 0x7F;
+ 		res = send_cmd(mmc_stat, CMD55, 0);
+ 		if (res > 1) return res;
+ 	}
+ 
+ 	/* Select the card and wait for ready except to stop multiple block read */
+ 	if (cmd != CMD12) {
+ 		deselect(mmc_stat);
+ 		if (!select(mmc_stat)) return 0xFF;
+ 	}
+ 
+ 	/* Send command packet */
+ 	xchg_spi(mmc_stat, 0x40 | cmd);			/* Start + command index */
+ 	xchg_spi(mmc_stat, (uint8_t)(arg >> 24));	/* Argument[31..24] */
+ 	xchg_spi(mmc_stat, (uint8_t)(arg >> 16));	/* Argument[23..16] */
+ 	xchg_spi(mmc_stat, (uint8_t)(arg >> 8));		/* Argument[15..8] */
+ 	xchg_spi(mmc_stat, (uint8_t)arg);			/* Argument[7..0] */
+ 	n = 0x01;						/* Dummy CRC + Stop */
+ 	if (cmd == CMD0) n = 0x95;		/* Valid CRC for CMD0(0) */
+ 	if (cmd == CMD8) n = 0x87;		/* Valid CRC for CMD8(0x1AA) */
+ 	xchg_spi(mmc_stat, n);
+ 
+ 	/* Receive command resp */
+ 	if (cmd == CMD12) xchg_spi(mmc_stat, 0xFF);	/* Diacard stuff byte on CMD12 */
+ 	n = 10;							/* Wait for response (10 bytes max) */
+ 	do
+       res = xchg_spi(mmc_stat, 0xFF);
+ 	while ((res & 0x80) && --n);
+ 
+ 	return res;						/* Return received response */
+ }
+ 
+ 
+ 
+ /*--------------------------------------------------------------------------
+ 
+    Public Functions
+ 
+ ---------------------------------------------------------------------------*/
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Initialize disk drive                                                 */
+ /*-----------------------------------------------------------------------*/
+ 
+ DSTATUS rspi_disk_initialize (
+ 	void *v_stat		/* mmc_rspi status */
+ )
+ {
+ 	uint8_t n, cmd, ty, ocr[4];
+     mmc_rspi_stat_t *mmc_stat;
+     mmc_stat = (mmc_rspi_stat_t *)v_stat;
+     rspi_get_right(GET_DEV_STAT(mmc_stat->mmc_drv_id));
+ 
+     if (check_ins_sw(GET_DEV_STAT(DEV_MMC_GPIO0)))    /* Card is in socket */
+       mmc_stat->Stat = STA_NOINIT;
+     else        /* Socket empty */
+       mmc_stat->Stat = (STA_NODISK | STA_NOINIT);
+ 
+     mmc_stat->CardType = 0; 
+     mmc_stat->tout_flg = 0; //clear condition of time out.
+     
+ 	power_on(mmc_stat);							/* Initialize RSPI */
+ 	for (n = 10; n; n--) xchg_spi(mmc_stat, 0xFF);/* Send 80 dummy clocks */
+     
+ 	ty = 0;
+ 	if (send_cmd(mmc_stat, CMD0, 0) == 1) {			/* Put the card SPI/Idle state */
+       clear_timeout_timer(mmc_stat, DATA_TRANS_TIME);
+       sta_alm(mmc_stat-> tout_task_id_0, 10000); /* Initialization timeout = 1 sec */
+       if (send_cmd(mmc_stat, CMD8, 0x1AA) == 1) {	/* SDv2? */
+         for (n = 0; n < 4; n++) ocr[n] = xchg_spi(mmc_stat, 0xFF);	/* Get 32 bit return value of R7 resp */
+         if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* Is the card supports vcc of 2.7-3.6V? */
+           while (!is_timeout(mmc_stat, DATA_TRANS_TIME) && send_cmd(mmc_stat, ACMD41, 1UL << 30)) ;	/* Wait for end of initialization with ACMD41(HCS) */
+           if (!is_timeout(mmc_stat, DATA_TRANS_TIME) && send_cmd(mmc_stat, CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
+             for (n = 0; n < 4; n++) ocr[n] = xchg_spi(mmc_stat, 0xFF);
+             ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* Card id SDv2 */
+           }
+         }
+       } else {	/* Not SDv2 card */
+         if (send_cmd(mmc_stat, ACMD41, 0) <= 1) 	{	/* SDv1 or MMC? */
+           ty = CT_SD1; cmd = ACMD41;	/* SDv1 (ACMD41(0)) */
+         } else {
+           ty = CT_MMC; cmd = CMD1;	/* MMCv3 (CMD1(0)) */
+         }
+         while (!is_timeout(mmc_stat, DATA_TRANS_TIME) && send_cmd(mmc_stat, cmd, 0)) ;		/* Wait for end of initialization */
+         if (is_timeout(mmc_stat, DATA_TRANS_TIME) || send_cmd(mmc_stat, CMD16, 512) != 0)	/* Set block length: 512 */
+           ty = 0;
+       }
+       stp_alm(mmc_stat-> tout_task_id_0);
+ 	}
+ 	mmc_stat->CardType = ty;	/* Card type */
+ 	deselect(mmc_stat);
+     
+ 	if (ty) {			/* OK */
+       fast_clk_mode(GET_DEV_STAT(mmc_stat->mmc_drv_id));			/* Set fast clock */
+       mmc_stat->Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
+ 	} else {			/* Failed */
+       power_off(mmc_stat);
+       mmc_stat->Stat = STA_NOINIT;
+ 	}
+     
+     rspi_relese_right(GET_DEV_STAT(mmc_stat->mmc_drv_id));
+ 	return mmc_stat->Stat;
+ }
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Get disk status                                                       */
+ /*-----------------------------------------------------------------------*/
+ 
+ DSTATUS rspi_disk_status (
+ 	void* v_stat		/* mmc_rspi status */
+ )
+ {
+     mmc_rspi_stat_t *mmc_stat;
+     mmc_stat = (mmc_rspi_stat_t *)v_stat;
+ 
+ 	return mmc_stat->Stat;	/* Return disk status */
+ }
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Read sector(s)                                                        */
+ /*-----------------------------------------------------------------------*/
+ 
+ DRESULT rspi_disk_read (
+ 	void* v_stat,		/* Status of mmc rspi */
+ 	uint8_t *buff,		/* Pointer to the data buffer to store read data */
+ 	uint32_t sector,	/* Start sector number (LBA) */
+ 	uint32_t count		/* Number of sectors to read (1..128) */
+ )
+ {
+     mmc_rspi_stat_t *mmc_stat;
+ 
+     mmc_stat = (mmc_rspi_stat_t *)v_stat;
+     
+ 	if (!count) return RES_PARERR;		/* Check parameter */
+ 	if (mmc_stat->Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
+     
+     rspi_get_right(GET_DEV_STAT(mmc_stat->mmc_drv_id));
+     
+ 	if (!(mmc_stat->CardType & CT_BLOCK)) sector *= 512;	/* LBA ot BA conversion (byte addressing cards) */
+     
+ 	if (count == 1) {	/* Single sector read */
+       if ((send_cmd(mmc_stat, CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
+           && rcvr_datablock(mmc_stat, buff, 512))
+         count = 0;
+ 	}
+ 	else {				/* Multiple sector read */
+       if (send_cmd(mmc_stat, CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
+         do {
+           if (!rcvr_datablock(mmc_stat, buff, 512)) break;
+           buff += 512;
+         } while (--count);
+         send_cmd(mmc_stat, CMD12, 0);				/* STOP_TRANSMISSION */
+       }
+ 	}
+ 	deselect(mmc_stat);
+     rspi_relese_right(GET_DEV_STAT(mmc_stat->mmc_drv_id));
+ 	return count ? RES_ERROR : RES_OK;	/* Return result */
+ }
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Write sector(s)                                                       */
+ /*-----------------------------------------------------------------------*/
+ 
+ #if _USE_WRITE
+ DRESULT rspi_disk_write (
+ 	void* v_stat,		/* Status of mmc rspi */
+ 	const uint8_t *buff,	/* Ponter to the data to write */
+ 	uint32_t sector,		/* Start sector number (LBA) */
+ 	uint32_t count			/* Number of sectors to write (1..128) */
+ )
+ {
+     mmc_rspi_stat_t *mmc_stat;
+     
+     mmc_stat = (mmc_rspi_stat_t *)v_stat;
+ 	if (!count) return RES_PARERR;		/* Check parameter */
+ 	if (mmc_stat->Stat & STA_NOINIT) return RES_NOTRDY;	/* Check drive status */
+ 
+     if (WP) return RES_WRPRT;                           /* Check write protect (check is disable)*/
+ //	if (mmc_stat->Stat & STA_PROTECT) return RES_WRPRT;	/* Check write protect */
+ 
+     rspi_get_right(GET_DEV_STAT(mmc_stat->mmc_drv_id));
+ 
+ 	if (!(mmc_stat->CardType & CT_BLOCK)) sector *= 512;	/* LBA ==> BA conversion (byte addressing cards) */
+     
+ 	if (count == 1) {	/* Single sector write */
+       if ((send_cmd(mmc_stat, CMD24, sector) == 0)	/* WRITE_BLOCK */
+           && xmit_datablock(mmc_stat, buff, 0xFE))
+         count = 0;
+ 	}
+ 	else {				/* Multiple sector write */
+       if (mmc_stat->CardType & CT_SDC) send_cmd(mmc_stat, ACMD23, count);
+       if (send_cmd(mmc_stat, CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
+ 			do {
+               if (!xmit_datablock(mmc_stat, buff, 0xFC)) break;
+               buff += 512;
+ 			} while (--count);
+ 			if (!xmit_datablock(mmc_stat, 0, 0xFD))	/* STOP_TRAN token */
+               count = 1;
+       }
+ 	}
+ 	deselect(mmc_stat);
+     
+     rspi_relese_right(GET_DEV_STAT(mmc_stat->mmc_drv_id));
+ 	return count ? RES_ERROR : RES_OK;	/* Return result */
+ }
+ #endif /* _USE_WRITE */
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Miscellaneous drive controls other than data read/write               */
+ /*-----------------------------------------------------------------------*/
+ 
+ #if _USE_IOCTL
+ DRESULT rspi_disk_ioctl (
+ 	void* v_stat,		/* Status of mmc rspi */
+ 	uint8_t ctrl,		/* Control command code */
+ 	void *buff		/* Pointer to the conrtol data */
+ )
+ {
+ 	DRESULT res;
+ 	uint8_t n, csd[16], *ptr = buff;
+ 	uint32_t *dp, st, ed, csz;
+     mmc_rspi_stat_t *mmc_stat;
+ 
+     mmc_stat = (mmc_rspi_stat_t *)v_stat;
+ 	if (mmc_stat->Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
+ 
+     rspi_get_right(GET_DEV_STAT(mmc_stat->mmc_drv_id));
+     
+ 	res = RES_ERROR;
+ 
+ 	switch (ctrl) {
+ 	case CTRL_SYNC :		/* Wait for end of internal write process of the drive */
+       if (select(mmc_stat)) res = RES_OK;
+       break;
+       
+ 	case GET_SECTOR_COUNT :	/* Get drive capacity in unit of sector (uint32_t) */
+       if ((send_cmd(mmc_stat, CMD9, 0) == 0) && rcvr_datablock(mmc_stat, csd, 16)) {
+         if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
+           csz = csd[9] + ((uint16_t)csd[8] << 8) + ((uint32_t)(csd[7] & 63) << 16) + 1;
+           *(uint32_t*)buff = csz << 10;
+         } else {					/* SDC ver 1.XX or MMC ver 3 */
+           n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
+           csz = (csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1;
+           *(uint32_t*)buff = csz << (n - 9);
+         }
+         res = RES_OK;
+       }
+       break;
+       
+ 	case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (uint32_t) */
+       if (mmc_stat->CardType & CT_SD2) {	/* SDC ver 2.00 */
+         if (send_cmd(mmc_stat, ACMD13, 0) == 0) {	/* Read SD status */
+           xchg_spi(mmc_stat, 0xFF);	/* Discard 2nd byte of R2 resp. */
+           if (rcvr_datablock(mmc_stat, csd, 16)) {					/* Read partial block */
+             for (n = 64 - 16; n; n--) xchg_spi(mmc_stat, 0xFF);	/* Purge trailing data */
+             *(uint32_t*)buff = 16UL << (csd[10] >> 4);
+             res = RES_OK;
+           }
+         }
+       } else {					/* SDC ver 1.XX or MMC */
+         if ((send_cmd(mmc_stat, CMD9, 0) == 0) && rcvr_datablock(mmc_stat, csd, 16)) {	/* Read CSD */
+           if (mmc_stat->CardType & CT_SD1) {	/* SDC ver 1.XX */
+             *(uint32_t*)buff = (((csd[10] & 63) << 1) + ((uint16_t)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
+           } else {					/* MMC */
+             *(uint32_t*)buff = ((uint16_t)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
+           }
+           res = RES_OK;
+         }
+       }
+       break;
+       
+ 	case CTRL_TRIM :	/* Erase a block of sectors (used when _USE_TRIM == 1) */
+       if (!(mmc_stat->CardType & CT_SDC)) break;				/* Check if the card is SDC */
+       if (rspi_disk_ioctl((void*)mmc_stat, MMC_GET_CSD, csd)) break;	/* Get CSD */
+ 		if (!(csd[0] >> 6) && !(csd[10] & 0x40)) break;	/* Check if sector erase can be applied to the card */
+ 		dp = buff; st = dp[0]; ed = dp[1];				/* Load sector block */
+ 		if (!(mmc_stat->CardType & CT_BLOCK)) {
+           st *= 512; ed *= 512;
+ 		}
+ 		if (send_cmd(mmc_stat, CMD32, st) == 0 && send_cmd(mmc_stat, CMD33, ed) == 0 && send_cmd(mmc_stat, CMD38, 0) == 0 && wait_ready(mmc_stat, 30000))	/* Erase sector block */
+           res = RES_OK;
+ 		break;
+         
+         /* Following command are not used by FatFs module */
+         
+ 	case MMC_GET_TYPE :		/* Get MMC/SDC type (uint8_t) */
+       *ptr = mmc_stat->CardType;
+       res = RES_OK;
+       break;
+       
+ 	case MMC_GET_CSD :		/* Read CSD (16 bytes) */
+       if (send_cmd(mmc_stat, CMD9, 0) == 0		/* READ_CSD */
+           && rcvr_datablock(mmc_stat, ptr, 16))
+         res = RES_OK;
+       break;
+       
+ 	case MMC_GET_CID :		/* Read CID (16 bytes) */
+       if (send_cmd(mmc_stat, CMD10, 0) == 0		/* READ_CID */
+           && rcvr_datablock(mmc_stat, ptr, 16))
+ 			res = RES_OK;
+       break;
+       
+ 	case MMC_GET_OCR :		/* Read OCR (4 bytes) */
+       if (send_cmd(mmc_stat, CMD58, 0) == 0) {	/* READ_OCR */
+         for (n = 4; n; n--) *ptr++ = xchg_spi(mmc_stat, 0xFF);
+         res = RES_OK;
+       }
+       break;
+       
+ 	case MMC_GET_SDSTAT :	/* Read SD status (64 bytes) */
+       if (send_cmd(mmc_stat, ACMD13, 0) == 0) {	/* SD_STATUS */
+         xchg_spi(mmc_stat, 0xFF);
+         if (rcvr_datablock(mmc_stat, ptr, 64))
+           res = RES_OK;
+       }
+       break;
+       
+ 	default:
+       res = RES_PARERR;
+ 	}
+     
+ 	deselect(mmc_stat);
+     
+     rspi_relese_right(GET_DEV_STAT(mmc_stat->mmc_drv_id));
+ 	return res;
+ }
+ #endif /* _USE_IOCTL */
+ 
+ 
+ /*-----------------------------------------------------------------------*/
+ /* Device timer function                                                 */
+ /*-----------------------------------------------------------------------*/
+ 
+ /* This function must be called from RTOS alarm handler
+ */
+ void mmc_rspi_tout0_handler(intptr_t exinf){
+   mmc_rspi_stat_t* mmc_stat;
+   mmc_stat = (mmc_rspi_stat_t *)GET_DEV_STAT((dnode_id) exinf);
+ 
+   mmc_stat->tout_flg |= DATA_TRANS_TIME;
+ }
+ 
+ void mmc_rspi_tout1_handler(intptr_t exinf){
+   mmc_rspi_stat_t* mmc_stat;
+   mmc_stat = (mmc_rspi_stat_t *)GET_DEV_STAT((dnode_id) exinf);
+ 
+   mmc_stat->tout_flg |= WAIT_TIME;
+ }
+ 
+ /*
+  * fatfs API get_fattime
+  */
+ 
+ uint32_t rspi_get_fattime(){
+   return 0;
+ }
+ 
+ 
+ // register call back api of mmc_rspi api
+ const mmc_func_t mmc_rspi_func = {
+   rspi_disk_initialize,
+   rspi_disk_status,
+   rspi_disk_read,
+ #ifdef _USE_WRITE
+   rspi_disk_write,
+ #else
+   NULL,
+ #endif
+ #ifdef _USE_IOCTL
+   rspi_disk_ioctl,
+ #else
+   NULL
+ #endif
+ };
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/mmc_rspi.cfg ASPs/asp/driver/rx_gcc/mmc_rspi.cfg
*** 1.9.1/asp/driver/rx_gcc/mmc_rspi.cfg	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/mmc_rspi.cfg	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,32 ----
+ /*
+  * Copyright (c) 2016- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ 
+ 
+ /*
+  * configuration file of mmc_rspi for toppers/asp
+  */
+ 
+ #include <driver/rx_gcc/mmc_rspi.h>
+ 
+ #ifdef USE_MMC_RSPI_0
+ CRE_ALM(MMC_RSPI0_ALMHDR_0, { TA_NULL, DEV_MMC_RSPI0, mmc_rspi_tout0_handler});
+ CRE_ALM(MMC_RSPI0_ALMHDR_1, { TA_NULL, DEV_MMC_RSPI0, mmc_rspi_tout1_handler});
+ #endif
+ 
+ #ifdef USE_MMC_RSPI_1
+ CRE_ALM(MMC_RSPI1_ALMHDR_0, { TA_NULL, DEV_MMC_RSPI1, mmc_rspi_tout0_handler});
+ CRE_ALM(MMC_RSPI1_ALMHDR_1, { TA_NULL, DEV_MMC_RSPI1, mmc_rspi_tout1_handler});
+ #endif
+ 
+ #ifdef USE_MMC_RSPI_2
+ CRE_ALM(MMC_RSPI2_ALMHDR_0, { TA_NULL, DEV_MMC_RSPI2, mmc_rspi_tout0_handler});
+ CRE_ALM(MMC_RSPI2_ALMHDR_1, { TA_NULL, DEV_MMC_RSPI2, mmc_rspi_tout1_handler});
+ #endif
+ 
+ #ifdef USE_MMC_RSPI_3
+ CRE_ALM(MMC_RSPI3_ALMHDR_0, { TA_NULL, DEV_MMC_RSPI3, mmc_rspi_tout0_handler});
+ CRE_ALM(MMC_RSPI3_ALMHDR_1, { TA_NULL, DEV_MMC_RSPI3, mmc_rspi_tout1_handler});
+ #endif
diff -cr --new-file 1.9.1/asp/driver/rx_gcc/mmc_rspi.h ASPs/asp/driver/rx_gcc/mmc_rspi.h
*** 1.9.1/asp/driver/rx_gcc/mmc_rspi.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/driver/rx_gcc/mmc_rspi.h	Fri Dec  9 13:53:59 2022
***************
*** 0 ****
--- 1,37 ----
+ /*
+  * Copyright (c) 2016- Hisashi Hata
+  * Released under the toppers license
+  * https://www.toppers.jp/license.html
+  */
+ #include <target_board.h>
+ #include <driver/rx_gcc/RSPI.h>
+ #include <driver/include/mmc_sdcard.h>
+ 
+ //mode switch
+ //  use dtc transfer
+ #define RSPI_MMC_DTCA_TRANS
+ 
+ 
+ //rspi_mmc_node's status
+ typedef struct mmc_rspi_dev_status_type{
+   dnode_id mmc_drv_id;  //mmc driver id
+   dnode_id mmc_ins_id;  //mmc card detect driver id
+   DSTATUS Stat;
+   uint8_t CardType;
+   uint8_t tout_flg;
+   ID tout_task_id_0;
+   ID tout_task_id_1;
+ } mmc_rspi_stat_t;
+ 
+ //alarm handler
+ extern void disk_timerproc(intptr_t exinf);
+ 
+ //mmc_rspi_fucn is driver api.
+ //  refer from device node.
+ extern const mmc_func_t mmc_rspi_func;
+ 
+ //time out alarm handler
+ void mmc_rspi_tout0_handler(intptr_t exinf);
+ void mmc_rspi_tout1_handler(intptr_t exinf);
+ 
+ 
diff -cr --new-file 1.9.1/asp/extension/dcre/include/kernel.h ASPs/asp/extension/dcre/include/kernel.h
*** 1.9.1/asp/extension/dcre/include/kernel.h	Sun Aug 17 21:42:45 2014
--- ASPs/asp/extension/dcre/include/kernel.h	Fri Dec  9 13:53:59 2022
***************
*** 8,57 ****
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥ ɸإåե
   *
!  *  TOPPERS/ASPͥ뤬ݡȤ륵ӥȡɬפʥǡ
!  *  ޥޤإåե롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   *
!  *  Υե򥤥󥯥롼ɤ˥󥯥롼ɤƤ٤ե
!  *  Ϥʤ
   */
  
  #ifndef TOPPERS_KERNEL_H
--- 8,57 ----
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル 標準ヘッダファイル
   *
!  *  TOPPERS/ASPカーネルがサポートするサービスコールの宣言と，必要なデー
!  *  タ型，定数，マクロの定義を含むヘッダファイル．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   *
!  *  このファイルをインクルードする前にインクルードしておくべきファイル
!  *  はない．
   */
  
  #ifndef TOPPERS_KERNEL_H
***************
*** 62,93 ****
  #endif
  
  /*
!  *	TOPPERS̤Υǡޥ
   */
  #include <t_stddef.h>
  
  /*
!  *  åȰ¸
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ǡ
   */
  
  /*
!  *  ӥåȥѥ䥪ֹ֥η
   */
! typedef	uint_t		TEXPTN;		/* 㳰װΥӥåȥѥ */
! typedef	uint_t		FLGPTN;		/* ٥ȥե饰Υӥåȥѥ */
! typedef	uint_t		INTNO;		/* ֹ */
! typedef	uint_t		INHNO;		/* ߥϥɥֹ */
! typedef	uint_t		EXCNO;		/* CPU㳰ϥɥֹ */
  
  /*
!  *  ñ̤η
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
--- 62,93 ----
  #endif
  
  /*
!  *	TOPPERS共通のデータ型・定数・マクロ
   */
  #include <t_stddef.h>
  
  /*
!  *  ターゲット依存部
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  データ型の定義
   */
  
  /*
!  *  ビットパターンやオブジェクト番号の型定義
   */
! typedef	uint_t		TEXPTN;		/* タスク例外要因のビットパターン */
! typedef	uint_t		FLGPTN;		/* イベントフラグのビットパターン */
! typedef	uint_t		INTNO;		/* 割込み番号 */
! typedef	uint_t		INHNO;		/* 割込みハンドラ番号 */
! typedef	uint_t		EXCNO;		/* CPU例外ハンドラ番号 */
  
  /*
!  *  処理単位の型定義
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
***************
*** 100,278 ****
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  ΰݤΤη
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* åΰݤ뤿η */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* Ĺסΰݤ뤿η */
  
  /*
!  *  åإåη
   */
! typedef	struct t_msg {			/* ᡼ܥåΥåإå */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* ͥդåإå */
! 	T_MSG	msgque;				/* åإå */
! 	PRI		msgpri;				/* åͥ */
  } T_MSG_PRI;
  
  /*
!  *  ѥåȷ
   */
  typedef struct t_ctsk {
! 	ATR			tskatr;		/* ° */
! 	intptr_t	exinf;		/* γĥ */
! 	TASK		task;		/* Υᥤ롼Ƭ */
! 	PRI			itskpri;	/* εưͥ */
! 	SIZE		stksz;		/* ΥåΰΥ */
! 	STK_T 		*stk;		/* ΥåΰƬ */
  } T_CTSK;
  
  typedef struct t_rtsk {
! 	STAT	tskstat;	/*  */
! 	PRI		tskpri;		/* θͥ */
! 	PRI		tskbpri;	/* Υ١ͥ */
! 	STAT	tskwait;	/* Ԥװ */
! 	ID		wobjid;		/* ԤоݤΥ֥ȤID */
! 	TMO		lefttmo;	/* ॢȤޤǤλ */
! 	uint_t	actcnt;		/* ư׵ᥭ塼󥰿 */
! 	uint_t	wupcnt;		/* ׵ᥭ塼󥰿 */
  } T_RTSK;
  
  typedef struct t_dtex {
! 	ATR		texatr;		/* 㳰롼° */
! 	TEXRTN	texrtn;		/* 㳰롼Ƭ */
  } T_DTEX;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* 㳰ξ */
! 	TEXPTN	pndptn;		/* α㳰װ */
  } T_RTEX;
  
  typedef struct t_csem {
! 	ATR		sematr;		/* ޥե° */
! 	uint_t	isemcnt;	/* ޥեν񸻿 */
! 	uint_t	maxsem;		/* ޥեκ񸻿 */
  } T_CSEM;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* ޥեԤƬΥIDֹ */
! 	uint_t	semcnt;		/* ޥեθߤλ񸻿 */
  } T_RSEM;
  
  typedef struct t_cflg {
! 	ATR		flgatr;		/* ٥ȥե饰° */
! 	FLGPTN	iflgptn;	/* ٥ȥե饰νӥåȥѥ */
  } T_CFLG;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* ٥ȥե饰ԤƬΥIDֹ */
! 	FLGPTN	flgptn;		/* ٥ȥե饰θߤΥӥåȥѥ */
  } T_RFLG;
  
  typedef struct t_cdtq {
! 	ATR		dtqatr;		/* ǡ塼° */
! 	uint_t	dtqcnt;		/* ǡ塼ΰ˳ǼǤǡ */
! 	void 	*dtqmb;		/* ǡ塼ΰƬ */
  } T_CDTQ;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* ǡ塼ԤƬΥIDֹ */
! 	ID		rtskid;		/* ǡ塼μԤƬΥIDֹ */
! 	uint_t	sdtqcnt;	/* ǡ塼ΰ˳ǼƤǡο */
  } T_RDTQ;
  
  typedef struct t_cpdq {
! 	ATR		pdqatr;		/* ͥ٥ǡ塼° */
! 	uint_t	pdqcnt;		/* ͥ٥ǡ塼ΰ˳ǼǤǡ */
! 	PRI		maxdpri;	/* ͥ٥ǡ塼Ǥǡͥ٤κ
! 						    */
! 	void 	*pdqmb;		/* ͥ٥ǡ塼ΰƬ */
  } T_CPDQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* ͥ٥ǡ塼ԤƬΥ
! 						   IDֹ */
! 	ID		rtskid;		/* ͥ٥ǡ塼μԤƬΥ
! 						   IDֹ */
! 	uint_t	spdqcnt;	/* ͥ٥ǡ塼ΰ˳ǼƤǡ
! 						   ο */
  } T_RPDQ;
  
  typedef struct t_cmbx {
! 	ATR		mbxatr;		/* ᡼ܥå° */
! 	PRI		maxmpri;	/* ͥ٥᡼ܥåǤåͥ
! 						   ٤κ */
! 	void 	*mprihd;	/* ̤ͥΥå塼إåΰƬ */
  } T_CMBX;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* ᡼ܥåԤƬΥIDֹ */
! 	T_MSG	*pk_msg;	/* å塼ƬˤĤʤ줿å
! 						   Ƭ */
  } T_RMBX;
  
  typedef struct t_cmpf {
! 	ATR		mpfatr;		/* Ĺס° */
! 	uint_t	blkcnt;		/* ǤĹ֥åο */
! 	uint_t	blksz;		/* Ĺ֥åΥ */
! 	MPF_T 	*mpf;		/* ĹסΰƬ */
! 	void 	*mpfmb;		/* ĹסΰƬ */
  } T_CMPF;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* ĹסԤƬΥ
! 						   IDֹ */
! 	uint_t	fblkcnt;	/* Ĺסΰζΰ˳
! 						   դ뤳ȤǤĹ֥åο */
  } T_RMPF;
  
  typedef struct t_ccyc {
! 	ATR			cycatr;		/* ϥɥ° */
! 	intptr_t	exinf;		/* ϥɥγĥ */
! 	CYCHDR		cychdr;		/* ϥɥƬ */
! 	RELTIM		cyctim;		/* ϥɥεư */
! 	RELTIM		cycphs;		/* ϥɥεư */
  } T_CCYC;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* ϥɥư */
! 	RELTIM	lefttim;	/* ˼ϥɥưޤǤл */
  } T_RCYC;
  
  typedef struct t_calm {
! 	ATR			almatr;		/* 顼ϥɥ° */
! 	intptr_t	exinf;		/* 顼ϥɥγĥ */
! 	ALMHDR		almhdr;		/* 顼ϥɥƬ */
  } T_CALM;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* 顼ϥɥư */
! 	RELTIM	lefttim;	/* 顼ϥɥưޤǤл */
  } T_RALM;
  
  typedef struct t_cisr {
! 	ATR			isratr;		/* ߥӥ롼° */
! 	intptr_t	exinf;		/* ߥӥ롼γĥ */
! 	INTNO		intno;		/* ߥӥ롼Ͽֹ */
! 	ISR			isr;		/* ߥӥ롼Ƭ */
! 	PRI			isrpri;		/* ߥӥ롼ͥ */
  } T_CISR;
  
  /*
!  *  ӥ
   */
  
  /*
!  *  ǽ
   */
  extern ER_UINT	acre_tsk(const T_CTSK *pk_ctsk) throw();
  extern ER		del_tsk(ID tskid) throw();
--- 100,278 ----
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  メモリ領域確保のための型定義
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* スタック領域を確保するための型 */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* 固定長メモリプール領域を確保するための型 */
  
  /*
!  *  メッセージヘッダの型定義
   */
! typedef	struct t_msg {			/* メールボックスのメッセージヘッダ */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* 優先度付きメッセージヘッダ */
! 	T_MSG	msgque;				/* メッセージヘッダ */
! 	PRI		msgpri;				/* メッセージ優先度 */
  } T_MSG_PRI;
  
  /*
!  *  パケット形式の定義
   */
  typedef struct t_ctsk {
! 	ATR			tskatr;		/* タスク属性 */
! 	intptr_t	exinf;		/* タスクの拡張情報 */
! 	TASK		task;		/* タスクのメインルーチンの先頭番地 */
! 	PRI			itskpri;	/* タスクの起動時優先度 */
! 	SIZE		stksz;		/* タスクのスタック領域のサイズ */
! 	STK_T 		*stk;		/* タスクのスタック領域の先頭番地 */
  } T_CTSK;
  
  typedef struct t_rtsk {
! 	STAT	tskstat;	/* タスク状態 */
! 	PRI		tskpri;		/* タスクの現在優先度 */
! 	PRI		tskbpri;	/* タスクのベース優先度 */
! 	STAT	tskwait;	/* 待ち要因 */
! 	ID		wobjid;		/* 待ち対象のオブジェクトのID */
! 	TMO		lefttmo;	/* タイムアウトするまでの時間 */
! 	uint_t	actcnt;		/* 起動要求キューイング数 */
! 	uint_t	wupcnt;		/* 起床要求キューイング数 */
  } T_RTSK;
  
  typedef struct t_dtex {
! 	ATR		texatr;		/* タスク例外処理ルーチン属性 */
! 	TEXRTN	texrtn;		/* タスク例外処理ルーチンの先頭番地 */
  } T_DTEX;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* タスク例外処理の状態 */
! 	TEXPTN	pndptn;		/* 保留例外要因 */
  } T_RTEX;
  
  typedef struct t_csem {
! 	ATR		sematr;		/* セマフォ属性 */
! 	uint_t	isemcnt;	/* セマフォの初期資源数 */
! 	uint_t	maxsem;		/* セマフォの最大資源数 */
  } T_CSEM;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* セマフォの待ち行列の先頭のタスクのID番号 */
! 	uint_t	semcnt;		/* セマフォの現在の資源数 */
  } T_RSEM;
  
  typedef struct t_cflg {
! 	ATR		flgatr;		/* イベントフラグ属性 */
! 	FLGPTN	iflgptn;	/* イベントフラグの初期ビットパターン */
  } T_CFLG;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* イベントフラグの待ち行列の先頭のタスクのID番号 */
! 	FLGPTN	flgptn;		/* イベントフラグの現在のビットパターン */
  } T_RFLG;
  
  typedef struct t_cdtq {
! 	ATR		dtqatr;		/* データキュー属性 */
! 	uint_t	dtqcnt;		/* データキュー管理領域に格納できるデータ数 */
! 	void 	*dtqmb;		/* データキュー管理領域の先頭番地 */
  } T_CDTQ;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* データキューの送信待ち行列の先頭のタスクのID番号 */
! 	ID		rtskid;		/* データキューの受信待ち行列の先頭のタスクのID番号 */
! 	uint_t	sdtqcnt;	/* データキュー管理領域に格納されているデータの数 */
  } T_RDTQ;
  
  typedef struct t_cpdq {
! 	ATR		pdqatr;		/* 優先度データキュー属性 */
! 	uint_t	pdqcnt;		/* 優先度データキュー管理領域に格納できるデータ数 */
! 	PRI		maxdpri;	/* 優先度データキューに送信できるデータ優先度の最
! 						   大値 */
! 	void 	*pdqmb;		/* 優先度データキュー管理領域の先頭番地 */
  } T_CPDQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* 優先度データキューの送信待ち行列の先頭のタスク
! 						   のID番号 */
! 	ID		rtskid;		/* 優先度データキューの受信待ち行列の先頭のタスク
! 						   のID番号 */
! 	uint_t	spdqcnt;	/* 優先度データキュー管理領域に格納されているデー
! 						   タの数 */
  } T_RPDQ;
  
  typedef struct t_cmbx {
! 	ATR		mbxatr;		/* メールボックス属性 */
! 	PRI		maxmpri;	/* 優先度メールボックスに送信できるメッセージ優先
! 						   度の最大値 */
! 	void 	*mprihd;	/* 優先度別のメッセージキューヘッダ領域の先頭番地 */
  } T_CMBX;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* メールボックスの待ち行列の先頭のタスクのID番号 */
! 	T_MSG	*pk_msg;	/* メッセージキューの先頭につながれたメッセージ
! 						   の先頭番地 */
  } T_RMBX;
  
  typedef struct t_cmpf {
! 	ATR		mpfatr;		/* 固定長メモリプール属性 */
! 	uint_t	blkcnt;		/* 獲得できる固定長メモリブロックの数 */
! 	uint_t	blksz;		/* 固定長メモリブロックのサイズ */
! 	MPF_T 	*mpf;		/* 固定長メモリプール領域の先頭番地 */
! 	void 	*mpfmb;		/* 固定長メモリプール管理領域の先頭番地 */
  } T_CMPF;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* 固定長メモリプールの待ち行列の先頭のタスクの
! 						   ID番号 */
! 	uint_t	fblkcnt;	/* 固定長メモリプール領域の空きメモリ領域に割り
! 						   付けることができる固定長メモリブロックの数 */
  } T_RMPF;
  
  typedef struct t_ccyc {
! 	ATR			cycatr;		/* 周期ハンドラ属性 */
! 	intptr_t	exinf;		/* 周期ハンドラの拡張情報 */
! 	CYCHDR		cychdr;		/* 周期ハンドラの先頭番地 */
! 	RELTIM		cyctim;		/* 周期ハンドラの起動周期 */
! 	RELTIM		cycphs;		/* 周期ハンドラの起動位相 */
  } T_CCYC;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* 周期ハンドラの動作状態 */
! 	RELTIM	lefttim;	/* 次に周期ハンドラを起動する時刻までの相対時間 */
  } T_RCYC;
  
  typedef struct t_calm {
! 	ATR			almatr;		/* アラームハンドラ属性 */
! 	intptr_t	exinf;		/* アラームハンドラの拡張情報 */
! 	ALMHDR		almhdr;		/* アラームハンドラの先頭番地 */
  } T_CALM;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* アラームハンドラの動作状態 */
! 	RELTIM	lefttim;	/* アラームハンドラを起動する時刻までの相対時間 */
  } T_RALM;
  
  typedef struct t_cisr {
! 	ATR			isratr;		/* 割込みサービスルーチン属性 */
! 	intptr_t	exinf;		/* 割込みサービスルーチンの拡張情報 */
! 	INTNO		intno;		/* 割込みサービスルーチンを登録する割込み番号 */
! 	ISR			isr;		/* 割込みサービスルーチンの先頭番地 */
! 	PRI			isrpri;		/* 割込みサービスルーチン優先度 */
  } T_CISR;
  
  /*
!  *  サービスコールの宣言
   */
  
  /*
!  *  タスク管理機能
   */
  extern ER_UINT	acre_tsk(const T_CTSK *pk_ctsk) throw();
  extern ER		del_tsk(ID tskid) throw();
***************
*** 287,293 ****
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  °Ʊǽ
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
--- 287,293 ----
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  タスク付属同期機能
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
***************
*** 301,307 ****
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  㳰ǽ
   */
  extern ER		def_tex(ID tskid, const T_DTEX *pk_dtex) throw();
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
--- 301,307 ----
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  タスク例外処理機能
   */
  extern ER		def_tex(ID tskid, const T_DTEX *pk_dtex) throw();
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
***************
*** 312,318 ****
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  Ʊ̿ǽ
   */
  extern ER_ID	acre_sem(const T_CSEM *pk_csem) throw();
  extern ER		del_sem(ID semid) throw();
--- 312,318 ----
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  同期・通信機能
   */
  extern ER_ID	acre_sem(const T_CSEM *pk_csem) throw();
  extern ER		del_sem(ID semid) throw();
***************
*** 376,382 ****
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  סǽ
   */
  extern ER_ID	acre_mpf(const T_CMPF *pk_cmpf) throw();
  extern ER		del_mpf(ID mpfid) throw();
--- 376,382 ----
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  メモリプール管理機能
   */
  extern ER_ID	acre_mpf(const T_CMPF *pk_cmpf) throw();
  extern ER		del_mpf(ID mpfid) throw();
***************
*** 388,394 ****
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  ִǽ
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
--- 388,394 ----
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  時間管理機能
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
***************
*** 408,414 ****
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  ƥִǽ
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
--- 408,414 ----
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  システム状態管理機能
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
***************
*** 428,434 ****
  extern ER		ext_ker(void) throw();
  
  /*
!  *  ߴǽ
   */
  extern ER_ID	acre_isr(const T_CISR *pk_cisr) throw();
  extern ER		del_isr(ID isrid) throw();
--- 428,434 ----
  extern ER		ext_ker(void) throw();
  
  /*
!  *  割込み管理機能
   */
  extern ER_ID	acre_isr(const T_CISR *pk_cisr) throw();
  extern ER		del_isr(ID isrid) throw();
***************
*** 438,444 ****
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU㳰ǽ
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
--- 438,444 ----
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU例外管理機能
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
***************
*** 446,578 ****
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ֥°
   */
! #define TA_ACT			UINT_C(0x02)	/* ư줿֤ */
  
! #define TA_TPRI			UINT_C(0x01)	/* Ԥͥٽ */
! #define TA_MPRI			UINT_C(0x02)	/* å塼ͥٽ */
  
! #define TA_WMUL			UINT_C(0x02)	/* ʣԤ */
! #define TA_CLR			UINT_C(0x04)	/* ٥ȥե饰Υꥢ */
  
! #define TA_STA			UINT_C(0x02)	/* ϥɥư֤ */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* ͥγ */
  
! #define TA_ENAINT		UINT_C(0x01)	/* ׵ػߥե饰򥯥ꥢ */
! #define TA_EDGE			UINT_C(0x02)	/* åȥꥬ */
  
  /*
!  *  ӥư⡼ɤ
   */
! #define TWF_ORW			UINT_C(0x01)	/* ٥ȥե饰ORԤ */
! #define TWF_ANDW		UINT_C(0x02)	/* ٥ȥե饰ANDԤ */
  
  /*
!  *  ֥Ȥξ֤
   */
! #define TTS_RUN			UINT_C(0x01)	/* ¹Ծ */
! #define TTS_RDY			UINT_C(0x02)	/* ¹Բǽ */
! #define TTS_WAI			UINT_C(0x04)	/* Ԥ */
! #define TTS_SUS			UINT_C(0x08)	/* Ԥ */
! #define TTS_WAS			UINT_C(0x0c)	/* Ԥ */
! #define TTS_DMT			UINT_C(0x10)	/* ٻ߾ */
  
! #define TTW_SLP			UINT_C(0x0001)	/* Ԥ */
! #define TTW_DLY			UINT_C(0x0002)	/* ַвԤ */
! #define TTW_SEM			UINT_C(0x0004)	/* ޥեλ񸻳Ԥ */
! #define TTW_FLG			UINT_C(0x0008)	/* ٥ȥե饰Ԥ */
! #define TTW_SDTQ		UINT_C(0x0010)	/* ǡ塼ؤԤ */
! #define TTW_RDTQ		UINT_C(0x0020)	/* ǡ塼μԤ */
! #define TTW_SPDQ		UINT_C(0x0100)	/* ͥ٥ǡ塼ؤԤ */
! #define TTW_RPDQ		UINT_C(0x0200)	/* ͥ٥ǡ塼μԤ */
! #define TTW_MBX			UINT_C(0x0040)	/* ᡼ܥåμԤ */
! #define TTW_MPF			UINT_C(0x2000)	/* Ĺ֥åγԤ */
  
! #define TTEX_ENA		UINT_C(0x01)	/* 㳰ľ */
! #define TTEX_DIS		UINT_C(0x02)	/* 㳰ػ߾ */
  
! #define TCYC_STP		UINT_C(0x01)	/* ϥɥ餬ưƤʤ */
! #define TCYC_STA		UINT_C(0x02)	/* ϥɥ餬ưƤ */
  
! #define TALM_STP		UINT_C(0x01)	/* 顼ϥɥ餬ưƤʤ */
! #define TALM_STA		UINT_C(0x02)	/* 顼ϥɥ餬ưƤ */
  
  /*
!  *  ¾
   */
! #define TSK_SELF		0			/*  */
! #define TSK_NONE		0			/* 륿ʤ */
  
! #define TPRI_SELF		0			/* Υ١ͥ */
! #define TPRI_INI		0			/* εưͥ */
  
! #define TIPM_ENAALL		0			/* ͥ٥ޥ */
  
  /*
!  *  ȥޥ
   */
  
  /*
!  *  ݡȤ뵡ǽ
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_DYNAMIC_CRE		/* ưŪǽĥ */
  
  /*
!  *  ͥ٤ϰ
   */
! #define TMIN_TPRI		1			/* ͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_TPRI		16			/* ͥ٤κ͡ʺ͡*/
! #define TMIN_DPRI		1			/* ǡͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_DPRI		16			/* ǡͥ٤κ͡ʺ͡*/
! #define TMIN_MPRI		1			/* åͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_MPRI		16			/* åͥ٤κ͡ʺ͡*/
! #define TMIN_ISRPRI		1			/* ߥӥ롼ͥ٤κǾ */
! #define TMAX_ISRPRI		16			/* ߥӥ롼ͥ٤κ */
  
  /*
!  *  С
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* ͥΥ᡼ */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* ͥμֹ */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* ͥͤΥСֹ */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* ͥΥСֹ */
  
  /*
!  *  塼󥰲κ
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* ư׵ᥭ塼󥰿κ */
! #define TMAX_WUPCNT		UINT_C(1)		/* ׵ᥭ塼󥰿κ */
  
  /*
!  *  ӥåȥѥΥӥåȿ
   */
! #ifndef TBIT_TEXPTN					/* 㳰װΥӥåȿ */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* ٥ȥե饰Υӥåȿ */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  ΰݤΤΥޥ
   *
!  *  ʲTOPPERS_COUNT_SZTOPPERS_ROUND_SZϡunit2ζҾǤ
!  *  뤳ȤꤷƤ롥
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
--- 446,578 ----
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  オブジェクト属性の定義
   */
! #define TA_ACT			UINT_C(0x02)	/* タスクを起動された状態で生成 */
  
! #define TA_TPRI			UINT_C(0x01)	/* タスクの待ち行列を優先度順に */
! #define TA_MPRI			UINT_C(0x02)	/* メッセージキューを優先度順に */
  
! #define TA_WMUL			UINT_C(0x02)	/* 複数の待ちタスク */
! #define TA_CLR			UINT_C(0x04)	/* イベントフラグのクリア指定 */
  
! #define TA_STA			UINT_C(0x02)	/* 周期ハンドラを動作状態で生成 */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* カーネル管理外の割込み */
  
! #define TA_ENAINT		UINT_C(0x01)	/* 割込み要求禁止フラグをクリア */
! #define TA_EDGE			UINT_C(0x02)	/* エッジトリガ */
  
  /*
!  *  サービスコールの動作モードの定義
   */
! #define TWF_ORW			UINT_C(0x01)	/* イベントフラグのOR待ち */
! #define TWF_ANDW		UINT_C(0x02)	/* イベントフラグのAND待ち */
  
  /*
!  *  オブジェクトの状態の定義
   */
! #define TTS_RUN			UINT_C(0x01)	/* 実行状態 */
! #define TTS_RDY			UINT_C(0x02)	/* 実行可能状態 */
! #define TTS_WAI			UINT_C(0x04)	/* 待ち状態 */
! #define TTS_SUS			UINT_C(0x08)	/* 強制待ち状態 */
! #define TTS_WAS			UINT_C(0x0c)	/* 二重待ち状態 */
! #define TTS_DMT			UINT_C(0x10)	/* 休止状態 */
  
! #define TTW_SLP			UINT_C(0x0001)	/* 起床待ち */
! #define TTW_DLY			UINT_C(0x0002)	/* 時間経過待ち */
! #define TTW_SEM			UINT_C(0x0004)	/* セマフォの資源獲得待ち */
! #define TTW_FLG			UINT_C(0x0008)	/* イベントフラグ待ち */
! #define TTW_SDTQ		UINT_C(0x0010)	/* データキューへの送信待ち */
! #define TTW_RDTQ		UINT_C(0x0020)	/* データキューからの受信待ち */
! #define TTW_SPDQ		UINT_C(0x0100)	/* 優先度データキューへの送信待ち */
! #define TTW_RPDQ		UINT_C(0x0200)	/* 優先度データキューからの受信待ち */
! #define TTW_MBX			UINT_C(0x0040)	/* メールボックスからの受信待ち */
! #define TTW_MPF			UINT_C(0x2000)	/* 固定長メモリブロックの獲得待ち */
  
! #define TTEX_ENA		UINT_C(0x01)	/* タスク例外処理許可状態 */
! #define TTEX_DIS		UINT_C(0x02)	/* タスク例外処理禁止状態 */
  
! #define TCYC_STP		UINT_C(0x01)	/* 周期ハンドラが動作していない */
! #define TCYC_STA		UINT_C(0x02)	/* 周期ハンドラが動作している */
  
! #define TALM_STP		UINT_C(0x01)	/* アラームハンドラが動作していない */
! #define TALM_STA		UINT_C(0x02)	/* アラームハンドラが動作している */
  
  /*
!  *  その他の定数の定義
   */
! #define TSK_SELF		0			/* 自タスク指定 */
! #define TSK_NONE		0			/* 該当するタスクがない */
  
! #define TPRI_SELF		0			/* 自タスクのベース優先度 */
! #define TPRI_INI		0			/* タスクの起動時優先度 */
  
! #define TIPM_ENAALL		0			/* 割込み優先度マスク全解除 */
  
  /*
!  *  構成定数とマクロ
   */
  
  /*
!  *  サポートする機能
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_DYNAMIC_CRE		/* 動的生成機能拡張 */
  
  /*
!  *  優先度の範囲
   */
! #define TMIN_TPRI		1			/* タスク優先度の最小値（最高値）*/
! #define TMAX_TPRI		16			/* タスク優先度の最大値（最低値）*/
! #define TMIN_DPRI		1			/* データ優先度の最小値（最高値）*/
! #define TMAX_DPRI		16			/* データ優先度の最大値（最低値）*/
! #define TMIN_MPRI		1			/* メッセージ優先度の最小値（最高値）*/
! #define TMAX_MPRI		16			/* メッセージ優先度の最大値（最低値）*/
! #define TMIN_ISRPRI		1			/* 割込みサービスルーチン優先度の最小値 */
! #define TMAX_ISRPRI		16			/* 割込みサービスルーチン優先度の最大値 */
  
  /*
!  *  バージョン情報
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* カーネルのメーカーコード */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* カーネルの識別番号 */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* カーネル仕様のバージョン番号 */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* カーネルのバージョン番号 */
  
  /*
!  *  キューイング回数の最大値
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* 起動要求キューイング数の最大値 */
! #define TMAX_WUPCNT		UINT_C(1)		/* 起床要求キューイング数の最大値 */
  
  /*
!  *  ビットパターンのビット数
   */
! #ifndef TBIT_TEXPTN					/* タスク例外要因のビット数 */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* イベントフラグのビット数 */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  メモリ領域確保のためのマクロ
   *
!  *  以下のTOPPERS_COUNT_SZとTOPPERS_ROUND_SZの定義は，unitが2の巾乗であ
!  *  ることを仮定している．
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
***************
*** 599,607 ****
  #define TCNT_MPFMB(blkcnt)	TOPPERS_COUNT_SZ(TSZ_MPFMB(blkcnt), sizeof(MB_T))
  
  /*
!  *  ¾ι
   */
! #define TMAX_MAXSEM		UINT_MAX	/* ޥեκ񸻿κ */
  
  #ifdef __cplusplus
  }
--- 599,607 ----
  #define TCNT_MPFMB(blkcnt)	TOPPERS_COUNT_SZ(TSZ_MPFMB(blkcnt), sizeof(MB_T))
  
  /*
!  *  その他の構成定数
   */
! #define TMAX_MAXSEM		UINT_MAX	/* セマフォの最大資源数の最大値 */
  
  #ifdef __cplusplus
  }
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/Makefile.kernel ASPs/asp/extension/dcre/kernel/Makefile.kernel
*** 1.9.1/asp/extension/dcre/kernel/Makefile.kernel	Thu Sep  6 06:32:08 2012
--- ASPs/asp/extension/dcre/kernel/Makefile.kernel	Fri Dec  9 13:54:00 2022
***************
*** 8,52 ****
  #  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! #  ܥեȥѤΤޤࡥʲƱˤѡʣ
! #  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! #  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! #      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! #      ˴ޤޤƤ뤳ȡ
! #  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! #      ѤǤǺۤˤϡۤȼɥȡ
! #      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! #      ̵ݾڵǺܤ뤳ȡ
! #  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! #      ѤǤʤǺۤˤϡΤ줫ξ
! #      ȡ
! #    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! #        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! #    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! #        𤹤뤳ȡ
! #  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! #      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! #      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! #      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! #      դ뤳ȡ
  # 
! #  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! #  TOPPERSץȤϡܥեȥ˴ؤơλŪ
! #  ФŬޤơʤݾڤԤʤޤܥեȥ
! #  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! #  Ǥʤ
  # 
  #  @(#) $Id: Makefile.kernel 2414 2012-09-05 21:32:05Z ertl-hiro $
  # 
  
  #
! #		ͥΥե빽
  #
  
  #
! #  1ĤΥե뤫ʣΥ֥ȥե褦˺
! #  줿եΥꥹ
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
--- 8,52 ----
  #  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! #  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! #  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! #  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! #      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! #      スコード中に含まれていること．
! #  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! #      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! #      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! #      の無保証規定を掲載すること．
! #  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! #      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! #      と．
! #    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! #        作権表示，この利用条件および下記の無保証規定を掲載すること．
! #    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! #        報告すること．
! #  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! #      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! #      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! #      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! #      免責すること．
  # 
! #  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! #  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! #  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! #  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! #  の責任を負わない．
  # 
  #  @(#) $Id: Makefile.kernel 2414 2012-09-05 21:32:05Z ertl-hiro $
  # 
  
  #
! #		カーネルのファイル構成の定義
  #
  
  #
! #  1つのソースファイルから複数のオブジェクトファイルを生成するように作
! #  成されたソースファイルのリスト
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
***************
*** 55,61 ****
  				sys_manage.c interrupt.c exception.c
  
  #
! #  ƥե뤫륪֥ȥեΥꥹ
  #
  startup = sta_ker.o ext_ker.o kermem.o
  
--- 55,61 ----
  				sys_manage.c interrupt.c exception.c
  
  #
! #  各ソースファイルから生成されるオブジェクトファイルのリスト
  #
  startup = sta_ker.o ext_ker.o kermem.o
  
***************
*** 116,122 ****
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  륪֥ȥեΰ¸ط
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
--- 116,122 ----
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  生成されるオブジェクトファイルの依存関係の定義
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/alarm.c ASPs/asp/extension/dcre/kernel/alarm.c
*** 1.9.1/asp/extension/dcre/kernel/alarm.c	Sun Apr 13 15:51:55 2014
--- ASPs/asp/extension/dcre/kernel/alarm.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: alarm.c 2625 2014-04-13 06:51:47Z ertl-hiro $
   */
  
  /*
!  *		顼ϥɥ鵡ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: alarm.c 2625 2014-04-13 06:51:47Z ertl-hiro $
   */
  
  /*
!  *		アラームハンドラ機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "alarm.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ALM_ENTER
  #define LOG_ALM_ENTER(p_almcb)
--- 49,55 ----
  #include "alarm.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ALM_ENTER
  #define LOG_ALM_ENTER(p_almcb)
***************
*** 116,128 ****
  #endif /* LOG_REF_ALM_LEAVE */
  
  /*
!  *  顼ϥɥο
   */
  #define tnum_alm	((uint_t)(tmax_almid - TMIN_ALMID + 1))
  #define tnum_salm	((uint_t)(tmax_salmid - TMIN_ALMID + 1))
  
  /*
!  *  顼ϥɥID饢顼ϥɥ֥åФΥޥ
   */
  #define INDEX_ALM(almid)	((uint_t)((almid) - TMIN_ALMID))
  #define get_almcb(almid)	(&(almcb_table[INDEX_ALM(almid)]))
--- 116,128 ----
  #endif /* LOG_REF_ALM_LEAVE */
  
  /*
!  *  アラームハンドラの数
   */
  #define tnum_alm	((uint_t)(tmax_almid - TMIN_ALMID + 1))
  #define tnum_salm	((uint_t)(tmax_salmid - TMIN_ALMID + 1))
  
  /*
!  *  アラームハンドラIDからアラームハンドラ管理ブロックを取り出すためのマクロ
   */
  #define INDEX_ALM(almid)	((uint_t)((almid) - TMIN_ALMID))
  #define get_almcb(almid)	(&(almcb_table[INDEX_ALM(almid)]))
***************
*** 130,144 ****
  #ifdef TOPPERS_almini
  
  /*
!  *  ѤƤʤ顼ϥɥ֥åΥꥹ
   *
!  *  顼ϥɥ֥åƬˤϥ塼ˤĤʤΰ褬
!  *  ᡤ।٥ȥ֥åtmevtbˤΰѤ롥
   */
  QUEUE	free_almcb;
  
  /*
!  *  顼ϥɥ鵡ǽν
   */
  void
  initialize_alarm(void)
--- 130,144 ----
  #ifdef TOPPERS_almini
  
  /*
!  *  使用していないアラームハンドラ管理ブロックのリスト
   *
!  *  アラームハンドラ管理ブロックの先頭にはキューにつなぐための領域がな
!  *  いため，タイムイベントブロック（tmevtb）の領域を用いる．
   */
  QUEUE	free_almcb;
  
  /*
!  *  アラームハンドラ機能の初期化
   */
  void
  initialize_alarm(void)
***************
*** 165,171 ****
  #endif /* TOPPERS_almini */
  
  /*
!  *  顼ϥɥ
   */
  #ifdef TOPPERS_acre_alm
  
--- 165,171 ----
  #endif /* TOPPERS_almini */
  
  /*
!  *  アラームハンドラの生成
   */
  #ifdef TOPPERS_acre_alm
  
***************
*** 207,213 ****
  #endif /* TOPPERS_acre_alm */
  
  /*
!  *  顼ϥɥκ
   */
  #ifdef TOPPERS_del_alm
  
--- 207,213 ----
  #endif /* TOPPERS_acre_alm */
  
  /*
!  *  アラームハンドラの削除
   */
  #ifdef TOPPERS_del_alm
  
***************
*** 251,257 ****
  #endif /* TOPPERS_del_alm */
  
  /*
!  *  顼ϥɥư
   */
  #ifdef TOPPERS_sta_alm
  
--- 251,257 ----
  #endif /* TOPPERS_del_alm */
  
  /*
!  *  アラームハンドラの動作開始
   */
  #ifdef TOPPERS_sta_alm
  
***************
*** 292,298 ****
  #endif /* TOPPERS_sta_alm */
  
  /*
!  *  顼ϥɥưϡ󥿥ƥѡ
   */
  #ifdef TOPPERS_ista_alm
  
--- 292,298 ----
  #endif /* TOPPERS_sta_alm */
  
  /*
!  *  アラームハンドラの動作開始（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_ista_alm
  
***************
*** 333,339 ****
  #endif /* TOPPERS_ista_alm */
  
  /*
!  *  顼ϥɥư
   */
  #ifdef TOPPERS_stp_alm
  
--- 333,339 ----
  #endif /* TOPPERS_ista_alm */
  
  /*
!  *  アラームハンドラの動作停止
   */
  #ifdef TOPPERS_stp_alm
  
***************
*** 369,375 ****
  #endif /* TOPPERS_stp_alm */
  
  /*
!  *  顼ϥɥưߡ󥿥ƥѡ
   */
  #ifdef TOPPERS_istp_alm
  
--- 369,375 ----
  #endif /* TOPPERS_stp_alm */
  
  /*
!  *  アラームハンドラの動作停止（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_istp_alm
  
***************
*** 405,411 ****
  #endif /* TOPPERS_istp_alm */
  
  /*
!  *  顼ϥɥξֻ
   */
  #ifdef TOPPERS_ref_alm
  
--- 405,411 ----
  #endif /* TOPPERS_istp_alm */
  
  /*
!  *  アラームハンドラの状態参照
   */
  #ifdef TOPPERS_ref_alm
  
***************
*** 444,450 ****
  #endif /* TOPPERS_ref_alm */
  
  /*
!  *  顼ϥɥ鵯ư롼
   */
  #ifdef TOPPERS_almcal
  
--- 444,450 ----
  #endif /* TOPPERS_ref_alm */
  
  /*
!  *  アラームハンドラ起動ルーチン
   */
  #ifdef TOPPERS_almcal
  
***************
*** 454,465 ****
  	PRI		saved_ipm;
  
  	/*
! 	 *  顼ϥɥ߾֤ˤ롥
  	 */
  	p_almcb->almsta = false;
  
  	/*
! 	 *  顼ϥɥCPUå֤ǸƤӽФ
  	 */
  	saved_ipm = i_get_ipm();
  	i_unlock_cpu();
--- 454,465 ----
  	PRI		saved_ipm;
  
  	/*
! 	 *  アラームハンドラを停止状態にする．
  	 */
  	p_almcb->almsta = false;
  
  	/*
! 	 *  アラームハンドラを，CPUロック解除状態で呼び出す．
  	 */
  	saved_ipm = i_get_ipm();
  	i_unlock_cpu();
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/alarm.h ASPs/asp/extension/dcre/kernel/alarm.h
*** 1.9.1/asp/extension/dcre/kernel/alarm.h	Fri Aug 31 18:38:55 2012
--- ASPs/asp/extension/dcre/kernel/alarm.h	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: alarm.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		顼ϥɥ鵡ǽ
   */
  
  #ifndef TOPPERS_ALARM_H
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: alarm.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		アラームハンドラ機能
   */
  
  #ifndef TOPPERS_ALARM_H
***************
*** 51,108 ****
  #include "time_event.h"
  
  /*
!  *  顼ϥɥ֥å
   */
  typedef struct alarm_handler_initialization_block {
! 	ATR			almatr;			/* 顼ϥɥ° */
! 	intptr_t	exinf;			/* 顼ϥɥγĥ */
! 	ALMHDR		almhdr;			/* 顼ϥɥεư */
  } ALMINIB;
  
  /*
!  *  顼ϥɥ֥å
   */
  typedef struct alarm_handler_control_block {
! 	const ALMINIB *p_alminib;	/* ֥åؤΥݥ */
! 	bool_t		almsta;			/* 顼ϥɥư */
! 	TMEVTB		tmevtb;			/* ।٥ȥ֥å */
  } ALMCB;
  
  /*
!  *  ѤƤʤ顼ϥɥ֥åΥꥹ
   */
  extern QUEUE	free_almcb;
  
  /*
!  *  顼ϥɥIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_almid;
  extern const ID	tmax_salmid;
  
  /*
!  *  顼ϥɥ֥åΥꥢkernel_cfg.c
   */
  extern const ALMINIB	alminib_table[];
  extern ALMINIB			aalminib_table[];
  
  /*
!  *  顼ϥɥ֥åΥꥢkernel_cfg.c
   */
  extern ALMCB	almcb_table[];
  
  /*
!  *  顼ϥɥ֥å饢顼ϥɥIDФ
!  *  ޥ
   */
  #define	ALMID(p_almcb)	((ID)(((p_almcb) - almcb_table) + TMIN_ALMID))
  
  /*
!  *  顼ϥɥ鵡ǽν
   */
  extern void	initialize_alarm(void);
  
  /*
!  *  顼ϥɥ鵯ư롼
   */
  extern void	call_almhdr(ALMCB *p_almcb);
  
--- 51,108 ----
  #include "time_event.h"
  
  /*
!  *  アラームハンドラ初期化ブロック
   */
  typedef struct alarm_handler_initialization_block {
! 	ATR			almatr;			/* アラームハンドラ属性 */
! 	intptr_t	exinf;			/* アラームハンドラの拡張情報 */
! 	ALMHDR		almhdr;			/* アラームハンドラの起動番地 */
  } ALMINIB;
  
  /*
!  *  アラームハンドラ管理ブロック
   */
  typedef struct alarm_handler_control_block {
! 	const ALMINIB *p_alminib;	/* 初期化ブロックへのポインタ */
! 	bool_t		almsta;			/* アラームハンドラの動作状態 */
! 	TMEVTB		tmevtb;			/* タイムイベントブロック */
  } ALMCB;
  
  /*
!  *  使用していないアラームハンドラ管理ブロックのリスト
   */
  extern QUEUE	free_almcb;
  
  /*
!  *  アラームハンドラIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_almid;
  extern const ID	tmax_salmid;
  
  /*
!  *  アラームハンドラ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const ALMINIB	alminib_table[];
  extern ALMINIB			aalminib_table[];
  
  /*
!  *  アラームハンドラ管理ブロックのエリア（kernel_cfg.c）
   */
  extern ALMCB	almcb_table[];
  
  /*
!  *  アラームハンドラ管理ブロックからアラームハンドラIDを取り出すための
!  *  マクロ
   */
  #define	ALMID(p_almcb)	((ID)(((p_almcb) - almcb_table) + TMIN_ALMID))
  
  /*
!  *  アラームハンドラ機能の初期化
   */
  extern void	initialize_alarm(void);
  
  /*
!  *  アラームハンドラ起動ルーチン
   */
  extern void	call_almhdr(ALMCB *p_almcb);
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/allfunc.h ASPs/asp/extension/dcre/kernel/allfunc.h
*** 1.9.1/asp/extension/dcre/kernel/allfunc.h	Sat Nov 20 16:23:57 2010
--- ASPs/asp/extension/dcre/kernel/allfunc.h	Fri Dec  9 13:54:00 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: allfunc.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		٤Ƥδؿ򥳥ѥ뤹뤿
   */
  
  #ifndef TOPPERS_ALLFUNC_H
--- 6,45 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: allfunc.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		すべての関数をコンパイルするための定義
   */
  
  #ifndef TOPPERS_ALLFUNC_H
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/check.h ASPs/asp/extension/dcre/kernel/check.h
*** 1.9.1/asp/extension/dcre/kernel/check.h	Fri Apr 18 06:28:23 2014
--- ASPs/asp/extension/dcre/kernel/check.h	Fri Dec  9 13:54:00 2022
***************
*** 8,54 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: check.h 2642 2014-04-17 21:28:15Z ertl-hiro $
   */
  
  /*
!  *		顼åѥޥ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  ͽ°顼ΥåE_PAR
   */
  #define CHECK_RSATR(atr, valid_atr) do {					\
  	if (((atr) & ~(valid_atr)) != 0U) {						\
--- 8,54 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: check.h 2642 2014-04-17 21:28:15Z ertl-hiro $
   */
  
  /*
!  *		エラーチェック用マクロ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  予約属性エラーのチェック（E_PAR）
   */
  #define CHECK_RSATR(atr, valid_atr) do {					\
  	if (((atr) & ~(valid_atr)) != 0U) {						\
***************
*** 58,64 ****
  } while (false)
  
  /*
!  *  ͥ٤ϰϤȽ
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
--- 58,64 ----
  } while (false)
  
  /*
!  *  優先度の範囲の判定
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
***************
*** 75,81 ****
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
--- 75,81 ----
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  タスク優先度のチェック（E_PAR）
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
***************
*** 99,105 ****
  } while (false)
  
  /*
!  *  ǡͥ٤ΥåE_PAR
   */
  #define CHECK_DPRI(dpri) do {								\
  	if (!VALID_DPRI(dpri)) {								\
--- 99,105 ----
  } while (false)
  
  /*
!  *  データ優先度のチェック（E_PAR）
   */
  #define CHECK_DPRI(dpri) do {								\
  	if (!VALID_DPRI(dpri)) {								\
***************
*** 109,115 ****
  } while (false)
  
  /*
!  *  åͥ٤ΥåE_PAR
   */
  #define CHECK_MPRI(mpri) do {								\
  	if (!VALID_MPRI(mpri)) {								\
--- 109,115 ----
  } while (false)
  
  /*
!  *  メッセージ優先度のチェック（E_PAR）
   */
  #define CHECK_MPRI(mpri) do {								\
  	if (!VALID_MPRI(mpri)) {								\
***************
*** 119,125 ****
  } while (false)
  
  /*
!  *  ߥӥ롼ͥ٤ΥåE_PAR
   */
  #define CHECK_ISRPRI(isrpri) do {							\
  	if (!VALID_ISRPRI(isrpri)) {							\
--- 119,125 ----
  } while (false)
  
  /*
!  *  割込みサービスルーチン優先度のチェック（E_PAR）
   */
  #define CHECK_ISRPRI(isrpri) do {							\
  	if (!VALID_ISRPRI(isrpri)) {							\
***************
*** 129,135 ****
  } while (false)
  
  /*
!  *  ॢȻͤΥåE_PAR
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
--- 129,135 ----
  } while (false)
  
  /*
!  *  タイムアウト指定値のチェック（E_PAR）
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
***************
*** 139,145 ****
  } while (false)
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
--- 139,145 ----
  } while (false)
  
  /*
!  *  割込み優先度のチェック（E_PAR）
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
***************
*** 149,155 ****
  } while (false)
  
  /*
!  *  ֹΥåE_PAR
   */
  #define CHECK_INTNO_CREISR(intno) do {						\
  	if (!VALID_INTNO_CREISR(intno)) {						\
--- 149,155 ----
  } while (false)
  
  /*
!  *  割込み番号のチェック（E_PAR）
   */
  #define CHECK_INTNO_CREISR(intno) do {						\
  	if (!VALID_INTNO_CREISR(intno)) {						\
***************
*** 166,172 ****
  } while (false)
  
  /*
!  *  饤󤷤Ƥ뤫Ƚ
   */
  #define ALIGNED(val, align)		((((uintptr_t)(val)) & ((align) - 1U)) == 0U)
  
--- 166,172 ----
  } while (false)
  
  /*
!  *  アラインしているかの判定
   */
  #define ALIGNED(val, align)		((((uintptr_t)(val)) & ((align) - 1U)) == 0U)
  
***************
*** 201,207 ****
  #endif /* CHECK_MB_ALIGN */
  
  /*
!  *  NULLǤʤȤΥå
   */
  #ifdef CHECK_FUNC_NONNULL
  #define FUNC_NONNULL(func)		((func) != NULL)
--- 201,207 ----
  #endif /* CHECK_MB_ALIGN */
  
  /*
!  *  NULLでないことのチェック
   */
  #ifdef CHECK_FUNC_NONNULL
  #define FUNC_NONNULL(func)		((func) != NULL)
***************
*** 210,216 ****
  #endif /* CHECK_FUNC_NONNULL */
  
  /*
!  *  ؿƬϤΥåE_PAR
   */
  #define CHECK_ALIGN_FUNC(func) do {							\
  	if (!FUNC_ALIGNED(func)) {								\
--- 210,216 ----
  #endif /* CHECK_FUNC_NONNULL */
  
  /*
!  *  関数の先頭番地のチェック（E_PAR）
   */
  #define CHECK_ALIGN_FUNC(func) do {							\
  	if (!FUNC_ALIGNED(func)) {								\
***************
*** 227,233 ****
  } while (false)
  
  /*
!  *  åΥåE_PAR
   */
  #define CHECK_ALIGN_STKSZ(stksz) do {						\
  	if (!STKSZ_ALIGNED(stksz)) {							\
--- 227,233 ----
  } while (false)
  
  /*
!  *  スタックサイズのチェック（E_PAR）
   */
  #define CHECK_ALIGN_STKSZ(stksz) do {						\
  	if (!STKSZ_ALIGNED(stksz)) {							\
***************
*** 237,243 ****
  } while (false)
  
  /*
!  *  åƬϤΥåE_PAR
   */
  #define CHECK_ALIGN_STACK(stack) do {						\
  	if (!STACK_ALIGNED(stack)) {							\
--- 237,243 ----
  } while (false)
  
  /*
!  *  スタックの先頭番地のチェック（E_PAR）
   */
  #define CHECK_ALIGN_STACK(stack) do {						\
  	if (!STACK_ALIGNED(stack)) {							\
***************
*** 247,253 ****
  } while (false)
  
  /*
!  *  ĹסΰƬϤΥåE_PAR
   */
  #define CHECK_ALIGN_MPF(mpf) do {							\
  	if (!MPF_ALIGNED(mpf)) {								\
--- 247,253 ----
  } while (false)
  
  /*
!  *  固定長メモリプール領域の先頭番地のチェック（E_PAR）
   */
  #define CHECK_ALIGN_MPF(mpf) do {							\
  	if (!MPF_ALIGNED(mpf)) {								\
***************
*** 257,263 ****
  } while (false)
  
  /*
!  *  ΰƬϤΥåE_PAR
   */
  #define CHECK_ALIGN_MB(mb) do {								\
  	if (!MB_ALIGNED(mb)) {									\
--- 257,263 ----
  } while (false)
  
  /*
!  *  管理領域の先頭番地のチェック（E_PAR）
   */
  #define CHECK_ALIGN_MB(mb) do {								\
  	if (!MB_ALIGNED(mb)) {									\
***************
*** 267,273 ****
  } while (false)
  
  /*
!  *  ¾Υѥ᡼顼ΥåE_PAR
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
--- 267,273 ----
  } while (false)
  
  /*
!  *  その他のパラメータエラーのチェック（E_PAR）
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
***************
*** 277,283 ****
  } while (false)
  
  /*
!  *  ֥IDϰϤȽ
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
--- 277,283 ----
  } while (false)
  
  /*
!  *  オブジェクトIDの範囲の判定
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
***************
*** 291,297 ****
  #define VALID_ISRID(isrid)	(TMIN_ISRID <= (isrid) && (isrid) <= tmax_isrid)
  
  /*
!  *  ֥IDΥåE_ID
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
--- 291,297 ----
  #define VALID_ISRID(isrid)	(TMIN_ISRID <= (isrid) && (isrid) <= tmax_isrid)
  
  /*
!  *  オブジェクトIDのチェック（E_ID）
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
***************
*** 371,377 ****
  } while (false)
  
  /*
!  *  ƽФƥȤΥåE_CTX
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
--- 371,377 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストのチェック（E_CTX）
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
***************
*** 388,394 ****
  } while (false)
  
  /*
!  *  ƽФƥȤCPUå֤ΥåE_CTX
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
--- 388,394 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストとCPUロック状態のチェック（E_CTX）
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
***************
*** 405,411 ****
  } while (false)
  
  /*
!  *  ǥѥåα֤ǤʤΥåE_CTX
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
--- 405,411 ----
  } while (false)
  
  /*
!  *  ディスパッチ保留状態でないかのチェック（E_CTX）
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
***************
*** 415,421 ****
  } while (false)
  
  /*
!  *  ¾Υƥȥ顼ΥåE_CTX
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
--- 415,421 ----
  } while (false)
  
  /*
!  *  その他のコンテキストエラーのチェック（E_CTX）
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
***************
*** 425,431 ****
  } while (false)
  
  /*
!  *  ꤷƤʤΥåE_ILUSE
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
--- 425,431 ----
  } while (false)
  
  /*
!  *  自タスクを指定していないかのチェック（E_ILUSE）
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
***************
*** 435,441 ****
  } while (false)
  
  /*
!  *  ¾ѥ顼ΥåE_ILUSE
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
--- 435,441 ----
  } while (false)
  
  /*
!  *  その他の不正使用エラーのチェック（E_ILUSE）
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
***************
*** 445,451 ****
  } while (false)
  
  /*
!  *  ̤ݡȵǽ顼ΥåE_NOSPT
   */
  #define CHECK_NOSPT(exp) do {								\
  	if (!(exp)) {											\
--- 445,451 ----
  } while (false)
  
  /*
!  *  未サポート機能エラーのチェック（E_NOSPT）
   */
  #define CHECK_NOSPT(exp) do {								\
  	if (!(exp)) {											\
***************
*** 455,461 ****
  } while (false)
  
  /*
!  *  Ūʥ֥Ⱦ֥顼ΥåE_OBJ
   */
  #define CHECK_OBJ(exp) do {									\
  	if (!(exp)) {											\
--- 455,461 ----
  } while (false)
  
  /*
!  *  静的なオブジェクト状態エラーのチェック（E_OBJ）
   */
  #define CHECK_OBJ(exp) do {									\
  	if (!(exp)) {											\
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/cyclic.c ASPs/asp/extension/dcre/kernel/cyclic.c
*** 1.9.1/asp/extension/dcre/kernel/cyclic.c	Sun Apr 13 15:51:55 2014
--- ASPs/asp/extension/dcre/kernel/cyclic.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: cyclic.c 2625 2014-04-13 06:51:47Z ertl-hiro $
   */
  
  /*
!  *		ϥɥ鵡ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: cyclic.c 2625 2014-04-13 06:51:47Z ertl-hiro $
   */
  
  /*
!  *		周期ハンドラ機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "cyclic.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_CYC_ENTER
  #define LOG_CYC_ENTER(p_cyccb)
--- 49,55 ----
  #include "cyclic.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_CYC_ENTER
  #define LOG_CYC_ENTER(p_cyccb)
***************
*** 100,118 ****
  #endif /* LOG_REF_CYC_LEAVE */
  
  /*
!  *  ϥɥο
   */
  #define tnum_cyc	((uint_t)(tmax_cycid - TMIN_CYCID + 1))
  #define tnum_scyc	((uint_t)(tmax_scycid - TMIN_CYCID + 1))
  
  /*
!  *  ϥɥIDϥɥ֥åФΥޥ
   */
  #define INDEX_CYC(cycid)	((uint_t)((cycid) - TMIN_CYCID))
  #define get_cyccb(cycid)	(&(cyccb_table[INDEX_CYC(cycid)]))
  
  /*
!  *  ϥɥ鵯ưΤΥ।٥ȥ֥åϿ
   */
  Inline void
  tmevtb_enqueue_cyc(CYCCB *p_cyccb, EVTTIM evttim)
--- 100,118 ----
  #endif /* LOG_REF_CYC_LEAVE */
  
  /*
!  *  周期ハンドラの数
   */
  #define tnum_cyc	((uint_t)(tmax_cycid - TMIN_CYCID + 1))
  #define tnum_scyc	((uint_t)(tmax_scycid - TMIN_CYCID + 1))
  
  /*
!  *  周期ハンドラIDから周期ハンドラ管理ブロックを取り出すためのマクロ
   */
  #define INDEX_CYC(cycid)	((uint_t)((cycid) - TMIN_CYCID))
  #define get_cyccb(cycid)	(&(cyccb_table[INDEX_CYC(cycid)]))
  
  /*
!  *  周期ハンドラ起動のためのタイムイベントブロックの登録
   */
  Inline void
  tmevtb_enqueue_cyc(CYCCB *p_cyccb, EVTTIM evttim)
***************
*** 125,139 ****
  #ifdef TOPPERS_cycini
  
  /*
!  *  ѤƤʤϥɥ֥åΥꥹ
   *
!  *  ϥɥ֥åƬˤϥ塼ˤĤʤΰ褬ʤ
!  *  ᡤ।٥ȥ֥åtmevtbˤΰѤ롥
   */
  QUEUE	free_cyccb;
  
  /*
!  *  ϥɥ鵡ǽν
   */
  void
  initialize_cyclic(void)
--- 125,139 ----
  #ifdef TOPPERS_cycini
  
  /*
!  *  使用していない周期ハンドラ管理ブロックのリスト
   *
!  *  周期ハンドラ管理ブロックの先頭にはキューにつなぐための領域がないた
!  *  め，タイムイベントブロック（tmevtb）の領域を用いる．
   */
  QUEUE	free_cyccb;
  
  /*
!  *  周期ハンドラ機能の初期化
   */
  void
  initialize_cyclic(void)
***************
*** 166,172 ****
  #endif /* TOPPERS_cycini */
  
  /*
!  *  ϥɥ
   */
  #ifdef TOPPERS_acre_cyc
  
--- 166,172 ----
  #endif /* TOPPERS_cycini */
  
  /*
!  *  周期ハンドラの生成
   */
  #ifdef TOPPERS_acre_cyc
  
***************
*** 218,224 ****
  #endif /* TOPPERS_acre_cyc */
  
  /*
!  *  ϥɥκ
   */
  #ifdef TOPPERS_del_cyc
  
--- 218,224 ----
  #endif /* TOPPERS_acre_cyc */
  
  /*
!  *  周期ハンドラの削除
   */
  #ifdef TOPPERS_del_cyc
  
***************
*** 262,268 ****
  #endif /* TOPPERS_del_cyc */
  
  /*
!  *  ϥɥư
   */
  #ifdef TOPPERS_sta_cyc
  
--- 262,268 ----
  #endif /* TOPPERS_del_cyc */
  
  /*
!  *  周期ハンドラの動作開始
   */
  #ifdef TOPPERS_sta_cyc
  
***************
*** 301,307 ****
  #endif /* TOPPERS_sta_cyc */
  
  /*
!  *  ϥɥư
   */
  #ifdef TOPPERS_stp_cyc
  
--- 301,307 ----
  #endif /* TOPPERS_sta_cyc */
  
  /*
!  *  周期ハンドラの動作停止
   */
  #ifdef TOPPERS_stp_cyc
  
***************
*** 337,343 ****
  #endif /* TOPPERS_stp_cyc */
  
  /*
!  *  ϥɥξֻ
   */
  #ifdef TOPPERS_ref_cyc
  
--- 337,343 ----
  #endif /* TOPPERS_stp_cyc */
  
  /*
!  *  周期ハンドラの状態参照
   */
  #ifdef TOPPERS_ref_cyc
  
***************
*** 376,382 ****
  #endif /* TOPPERS_ref_cyc */
  
  /*
!  *  ϥɥ鵯ư롼
   */
  #ifdef TOPPERS_cyccal
  
--- 376,382 ----
  #endif /* TOPPERS_ref_cyc */
  
  /*
!  *  周期ハンドラ起動ルーチン
   */
  #ifdef TOPPERS_cyccal
  
***************
*** 386,401 ****
  	PRI		saved_ipm;
  
  	/*
! 	 *  εưΤΥ।٥ȥ֥åϿ롥
  	 *
! 	 *  ƱƥåǼϥɥٵư٤ˤϡ
! 	 *  ؿsignal_timeäˡ٤δؿƤФ뤳Ȥˤ
! 	 *  롥
  	 */
  	tmevtb_enqueue_cyc(p_cyccb, p_cyccb->evttim + p_cyccb->p_cycinib->cyctim);
  
  	/*
! 	 *  ϥɥCPUå֤ǸƤӽФ
  	 */
  	saved_ipm = i_get_ipm();
  	i_unlock_cpu();
--- 386,401 ----
  	PRI		saved_ipm;
  
  	/*
! 	 *  次回の起動のためのタイムイベントブロックを登録する．
  	 *
! 	 *  同じタイムティックで周期ハンドラを再度起動すべき場合には，この
! 	 *  関数からsignal_timeに戻った後に，再度この関数が呼ばれることにな
! 	 *  る．
  	 */
  	tmevtb_enqueue_cyc(p_cyccb, p_cyccb->evttim + p_cyccb->p_cycinib->cyctim);
  
  	/*
! 	 *  周期ハンドラを，CPUロック解除状態で呼び出す．
  	 */
  	saved_ipm = i_get_ipm();
  	i_unlock_cpu();
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/cyclic.h ASPs/asp/extension/dcre/kernel/cyclic.h
*** 1.9.1/asp/extension/dcre/kernel/cyclic.h	Sat Nov 20 16:23:57 2010
--- ASPs/asp/extension/dcre/kernel/cyclic.h	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: cyclic.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		ϥɥ鵡ǽ
   */
  
  #ifndef TOPPERS_CYCLIC_H
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: cyclic.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		周期ハンドラ機能
   */
  
  #ifndef TOPPERS_CYCLIC_H
***************
*** 51,110 ****
  #include "time_event.h"
  
  /*
!  *  ϥɥ֥å
   */
  typedef struct cyclic_handler_initialization_block {
! 	ATR			cycatr;			/* ϥɥ° */
! 	intptr_t	exinf;			/* ϥɥγĥ */
! 	CYCHDR		cychdr;			/* ϥɥεư */
! 	RELTIM		cyctim;			/* ϥɥεư */
! 	RELTIM		cycphs;			/* ϥɥεư */
  } CYCINIB;
  
  /*
!  *  ϥɥ֥å
   */
  typedef struct cyclic_handler_control_block {
! 	const CYCINIB *p_cycinib;	/* ֥åؤΥݥ */
! 	bool_t		cycsta;			/* ϥɥư */
! 	EVTTIM		evttim;			/* ˼ϥɥư */
! 	TMEVTB		tmevtb;			/* ।٥ȥ֥å */
  } CYCCB;
  
  /*
!  *  ѤƤʤϥɥ֥åΥꥹ
   */
  extern QUEUE	free_cyccb;
  
  /*
!  *  ϥɥIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_cycid;
  extern const ID	tmax_scycid;
  
  /*
!  *  ϥɥ֥åΥꥢkernel_cfg.c
   */
  extern const CYCINIB	cycinib_table[];
  extern CYCINIB			acycinib_table[];
  
  /*
!  *  ϥɥ֥åΥꥢkernel_cfg.c
   */
  extern CYCCB	cyccb_table[];
  
  /*
!  *  ϥɥ֥åϥɥIDФΥޥ
   */
  #define	CYCID(p_cyccb)	((ID)(((p_cyccb) - cyccb_table) + TMIN_CYCID))
  
  /*
!  *  ϥɥ鵡ǽν
   */
  extern void	initialize_cyclic(void);
  
  /*
!  *  ϥɥ鵯ư롼
   */
  extern void	call_cychdr(CYCCB *p_cyccb);
  
--- 51,110 ----
  #include "time_event.h"
  
  /*
!  *  周期ハンドラ初期化ブロック
   */
  typedef struct cyclic_handler_initialization_block {
! 	ATR			cycatr;			/* 周期ハンドラ属性 */
! 	intptr_t	exinf;			/* 周期ハンドラの拡張情報 */
! 	CYCHDR		cychdr;			/* 周期ハンドラの起動番地 */
! 	RELTIM		cyctim;			/* 周期ハンドラの起動周期 */
! 	RELTIM		cycphs;			/* 周期ハンドラの起動位相 */
  } CYCINIB;
  
  /*
!  *  周期ハンドラ管理ブロック
   */
  typedef struct cyclic_handler_control_block {
! 	const CYCINIB *p_cycinib;	/* 初期化ブロックへのポインタ */
! 	bool_t		cycsta;			/* 周期ハンドラの動作状態 */
! 	EVTTIM		evttim;			/* 次に周期ハンドラを起動する時刻 */
! 	TMEVTB		tmevtb;			/* タイムイベントブロック */
  } CYCCB;
  
  /*
!  *  使用していない周期ハンドラ管理ブロックのリスト
   */
  extern QUEUE	free_cyccb;
  
  /*
!  *  周期ハンドラIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_cycid;
  extern const ID	tmax_scycid;
  
  /*
!  *  周期ハンドラ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const CYCINIB	cycinib_table[];
  extern CYCINIB			acycinib_table[];
  
  /*
!  *  周期ハンドラ管理ブロックのエリア（kernel_cfg.c）
   */
  extern CYCCB	cyccb_table[];
  
  /*
!  *  周期ハンドラ管理ブロックから周期ハンドラIDを取り出すためのマクロ
   */
  #define	CYCID(p_cyccb)	((ID)(((p_cyccb) - cyccb_table) + TMIN_CYCID))
  
  /*
!  *  周期ハンドラ機能の初期化
   */
  extern void	initialize_cyclic(void);
  
  /*
!  *  周期ハンドラ起動ルーチン
   */
  extern void	call_cychdr(CYCCB *p_cyccb);
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/dataqueue.c ASPs/asp/extension/dcre/kernel/dataqueue.c
*** 1.9.1/asp/extension/dcre/kernel/dataqueue.c	Thu Apr 17 08:04:29 2014
--- ASPs/asp/extension/dcre/kernel/dataqueue.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: dataqueue.c 2639 2014-04-16 23:04:23Z ertl-hiro $
   */
  
  /*
!  *		ǡ塼ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: dataqueue.c 2639 2014-04-16 23:04:23Z ertl-hiro $
   */
  
  /*
!  *		データキュー機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "dataqueue.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACRE_DTQ_ENTER
  #define LOG_ACRE_DTQ_ENTER(pk_cdtq)
--- 51,57 ----
  #include "dataqueue.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACRE_DTQ_ENTER
  #define LOG_ACRE_DTQ_ENTER(pk_cdtq)
***************
*** 158,170 ****
  #endif /* LOG_REF_DTQ_LEAVE */
  
  /*
!  *  ǡ塼ο
   */
  #define tnum_dtq	((uint_t)(tmax_dtqid - TMIN_DTQID + 1))
  #define tnum_sdtq	((uint_t)(tmax_sdtqid - TMIN_DTQID + 1))
  
  /*
!  *  ǡ塼IDǡ塼֥åФΥޥ
   */
  #define INDEX_DTQ(dtqid)	((uint_t)((dtqid) - TMIN_DTQID))
  #define get_dtqcb(dtqid)	(&(dtqcb_table[INDEX_DTQ(dtqid)]))
--- 158,170 ----
  #endif /* LOG_REF_DTQ_LEAVE */
  
  /*
!  *  データキューの数
   */
  #define tnum_dtq	((uint_t)(tmax_dtqid - TMIN_DTQID + 1))
  #define tnum_sdtq	((uint_t)(tmax_sdtqid - TMIN_DTQID + 1))
  
  /*
!  *  データキューIDからデータキュー管理ブロックを取り出すためのマクロ
   */
  #define INDEX_DTQ(dtqid)	((uint_t)((dtqid) - TMIN_DTQID))
  #define get_dtqcb(dtqid)	(&(dtqcb_table[INDEX_DTQ(dtqid)]))
***************
*** 172,183 ****
  #ifdef TOPPERS_dtqini
  
  /*
!  *  ѤƤʤǡ塼֥åΥꥹ
   */
  QUEUE	free_dtqcb;
  
  /*
!  *  ǡ塼ǽν
   */
  void
  initialize_dataqueue(void)
--- 172,183 ----
  #ifdef TOPPERS_dtqini
  
  /*
!  *  使用していないデータキュー管理ブロックのリスト
   */
  QUEUE	free_dtqcb;
  
  /*
!  *  データキュー機能の初期化
   */
  void
  initialize_dataqueue(void)
***************
*** 208,214 ****
  #endif /* TOPPERS_dtqini */
  
  /*
!  *  ǡ塼ΰؤΥǡγǼ
   */
  #ifdef TOPPERS_dtqenq
  
--- 208,214 ----
  #endif /* TOPPERS_dtqini */
  
  /*
!  *  データキュー管理領域へのデータの格納
   */
  #ifdef TOPPERS_dtqenq
  
***************
*** 226,232 ****
  #endif /* TOPPERS_dtqenq */
  
  /*
!  *  ǡ塼ΰؤΥǡζǼ
   */
  #ifdef TOPPERS_dtqfenq
  
--- 226,232 ----
  #endif /* TOPPERS_dtqenq */
  
  /*
!  *  データキュー管理領域へのデータの強制格納
   */
  #ifdef TOPPERS_dtqfenq
  
***************
*** 249,255 ****
  #endif /* TOPPERS_dtqfenq */
  
  /*
!  *  ǡ塼ΰ褫ΥǡμФ
   */
  #ifdef TOPPERS_dtqdeq
  
--- 249,255 ----
  #endif /* TOPPERS_dtqfenq */
  
  /*
!  *  データキュー管理領域からのデータの取出し
   */
  #ifdef TOPPERS_dtqdeq
  
***************
*** 267,273 ****
  #endif /* TOPPERS_dtqdeq */
  
  /*
!  *  ǡ塼ؤΥǡ
   */
  #ifdef TOPPERS_dtqsnd
  
--- 267,273 ----
  #endif /* TOPPERS_dtqdeq */
  
  /*
!  *  データキューへのデータ送信
   */
  #ifdef TOPPERS_dtqsnd
  
***************
*** 295,301 ****
  #endif /* TOPPERS_dtqsnd */
  
  /*
!  *  ǡ塼ؤΥǡ
   */
  #ifdef TOPPERS_dtqfsnd
  
--- 295,301 ----
  #endif /* TOPPERS_dtqsnd */
  
  /*
!  *  データキューへのデータ強制送信
   */
  #ifdef TOPPERS_dtqfsnd
  
***************
*** 318,324 ****
  #endif /* TOPPERS_dtqfsnd */
  
  /*
!  *  ǡ塼Υǡ
   */
  #ifdef TOPPERS_dtqrcv
  
--- 318,324 ----
  #endif /* TOPPERS_dtqfsnd */
  
  /*
!  *  データキューからのデータ受信
   */
  #ifdef TOPPERS_dtqrcv
  
***************
*** 355,361 ****
  #endif /* TOPPERS_dtqrcv */
  
  /*
!  *  ǡ塼
   */
  #ifdef TOPPERS_acre_dtq
  
--- 355,361 ----
  #endif /* TOPPERS_dtqrcv */
  
  /*
!  *  データキューの生成
   */
  #ifdef TOPPERS_acre_dtq
  
***************
*** 414,420 ****
  #endif /* TOPPERS_acre_dtq */
  
  /*
!  *  ǡ塼κ
   */
  #ifdef TOPPERS_del_dtq
  
--- 414,420 ----
  #endif /* TOPPERS_acre_dtq */
  
  /*
!  *  データキューの削除
   */
  #ifdef TOPPERS_del_dtq
  
***************
*** 464,470 ****
  #endif /* TOPPERS_del_dtq */
  
  /*
!  *  ǡ塼ؤ
   */
  #ifdef TOPPERS_snd_dtq
  
--- 464,470 ----
  #endif /* TOPPERS_del_dtq */
  
  /*
!  *  データキューへの送信
   */
  #ifdef TOPPERS_snd_dtq
  
***************
*** 508,514 ****
  #endif /* TOPPERS_snd_dtq */
  
  /*
!  *  ǡ塼ؤʥݡ󥰡
   */
  #ifdef TOPPERS_psnd_dtq
  
--- 508,514 ----
  #endif /* TOPPERS_snd_dtq */
  
  /*
!  *  データキューへの送信（ポーリング）
   */
  #ifdef TOPPERS_psnd_dtq
  
***************
*** 547,553 ****
  #endif /* TOPPERS_psnd_dtq */
  
  /*
!  *  ǡ塼ؤʥݡ󥰡󥿥ƥѡ
   */
  #ifdef TOPPERS_ipsnd_dtq
  
--- 547,553 ----
  #endif /* TOPPERS_psnd_dtq */
  
  /*
!  *  データキューへの送信（ポーリング，非タスクコンテキスト用）
   */
  #ifdef TOPPERS_ipsnd_dtq
  
***************
*** 586,592 ****
  #endif /* TOPPERS_ipsnd_dtq */
  
  /*
!  *  ǡ塼ؤʥॢȤ
   */
  #ifdef TOPPERS_tsnd_dtq
  
--- 586,592 ----
  #endif /* TOPPERS_ipsnd_dtq */
  
  /*
!  *  データキューへの送信（タイムアウトあり）
   */
  #ifdef TOPPERS_tsnd_dtq
  
***************
*** 636,642 ****
  #endif /* TOPPERS_tsnd_dtq */
  
  /*
!  *  ǡ塼ؤζ
   */
  #ifdef TOPPERS_fsnd_dtq
  
--- 636,642 ----
  #endif /* TOPPERS_tsnd_dtq */
  
  /*
!  *  データキューへの強制送信
   */
  #ifdef TOPPERS_fsnd_dtq
  
***************
*** 672,678 ****
  #endif /* TOPPERS_fsnd_dtq */
  
  /*
!  *  ǡ塼ؤζ󥿥ƥѡ
   */
  #ifdef TOPPERS_ifsnd_dtq
  
--- 672,678 ----
  #endif /* TOPPERS_fsnd_dtq */
  
  /*
!  *  データキューへの強制送信（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_ifsnd_dtq
  
***************
*** 708,714 ****
  #endif /* TOPPERS_ifsnd_dtq */
  
  /*
!  *  ǡ塼μ
   */
  #ifdef TOPPERS_rcv_dtq
  
--- 708,714 ----
  #endif /* TOPPERS_ifsnd_dtq */
  
  /*
!  *  データキューからの受信
   */
  #ifdef TOPPERS_rcv_dtq
  
***************
*** 757,763 ****
  #endif /* TOPPERS_rcv_dtq */
  
  /*
!  *  ǡ塼μʥݡ󥰡
   */
  #ifdef TOPPERS_prcv_dtq
  
--- 757,763 ----
  #endif /* TOPPERS_rcv_dtq */
  
  /*
!  *  データキューからの受信（ポーリング）
   */
  #ifdef TOPPERS_prcv_dtq
  
***************
*** 796,802 ****
  #endif /* TOPPERS_prcv_dtq */
  
  /*
!  *  ǡ塼μʥॢȤ
   */
  #ifdef TOPPERS_trcv_dtq
  
--- 796,802 ----
  #endif /* TOPPERS_prcv_dtq */
  
  /*
!  *  データキューからの受信（タイムアウトあり）
   */
  #ifdef TOPPERS_trcv_dtq
  
***************
*** 850,856 ****
  #endif /* TOPPERS_trcv_dtq */
  
  /*
!  *  ǡ塼κƽ
   */
  #ifdef TOPPERS_ini_dtq
  
--- 850,856 ----
  #endif /* TOPPERS_trcv_dtq */
  
  /*
!  *  データキューの再初期化
   */
  #ifdef TOPPERS_ini_dtq
  
***************
*** 893,899 ****
  #endif /* TOPPERS_ini_dtq */
  
  /*
!  *  ǡ塼ξֻ
   */
  #ifdef TOPPERS_ref_dtq
  
--- 893,899 ----
  #endif /* TOPPERS_ini_dtq */
  
  /*
!  *  データキューの状態参照
   */
  #ifdef TOPPERS_ref_dtq
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/dataqueue.h ASPs/asp/extension/dcre/kernel/dataqueue.h
*** 1.9.1/asp/extension/dcre/kernel/dataqueue.h	Wed Jun 12 20:57:00 2013
--- ASPs/asp/extension/dcre/kernel/dataqueue.h	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: dataqueue.h 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		ǡ塼ǽ
   */
  
  #ifndef TOPPERS_DATAQUEUE_H
--- 8,47 ----
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: dataqueue.h 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		データキュー機能
   */
  
  #ifndef TOPPERS_DATAQUEUE_H
***************
*** 50,164 ****
  #include "wait.h"
  
  /*
!  *  ǡ֥å
   */
  typedef struct data_management_block {
! 	intptr_t	data;			/* ǡ */
  } DTQMB;
  
  /*
!  *  ǡ塼֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct dataqueue_initialization_block {
! 	ATR			dtqatr;			/* ǡ塼° */
! 	uint_t		dtqcnt;			/* ǡ塼 */
! 	DTQMB		*p_dtqmb;		/* ǡ塼ΰƬ */
  } DTQINIB;
  
  /*
!  *  ǡ塼֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct dataqueue_control_block {
! 	QUEUE		swait_queue;	/* ǡ塼Ԥ塼 */
! 	const DTQINIB *p_dtqinib;	/* ֥åؤΥݥ */
! 	QUEUE		rwait_queue;	/* ǡ塼Ԥ塼 */
! 	uint_t		count;			/* ǡ塼Υǡο */
! 	uint_t		head;			/* ǽΥǡγǼ */
! 	uint_t		tail;			/* ǸΥǡγǼμ */
  } DTQCB;
  
  /*
!  *  ǡ塼Ԥ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
!  *  ǡ塼ؤԤȥǡ塼μԤǡƱԤ
!  *  ֥åȤ
   */
  typedef struct dataqueue_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	DTQCB		*p_dtqcb;		/* ԤäƤǡ塼δ֥å */
! 	intptr_t	data;			/* ǡ */
  } WINFO_DTQ;
  
  /*
!  *  ѤƤʤǡ塼֥åΥꥹ
   */
  extern QUEUE	free_dtqcb;
  
  /*
!  *  ǡ塼IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_dtqid;
  extern const ID	tmax_sdtqid;
  
  /*
!  *  ǡ塼֥åΥꥢkernel_cfg.c
   */
  extern const DTQINIB	dtqinib_table[];
  extern DTQINIB			adtqinib_table[];
  
  /*
!  *  ǡ塼֥åΥꥢkernel_cfg.c
   */
  extern DTQCB	dtqcb_table[];
  
  /*
!  *  ǡ塼֥åǡ塼IDФΥޥ
   */
  #define	DTQID(p_dtqcb)	((ID)(((p_dtqcb) - dtqcb_table) + TMIN_DTQID))
  
  /*
!  *  ǡ塼ǽν
   */
  extern void	initialize_dataqueue(void);
  
  /*
!  *  ǡ塼ΰؤΥǡγǼ
   */
  extern void	enqueue_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  ǡ塼ΰؤΥǡζǼ
   */
  extern void	force_enqueue_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  ǡ塼ΰ褫ΥǡμФ
   */
  extern void	dequeue_data(DTQCB *p_dtqcb, intptr_t *p_data);
  
  /*
!  *  ǡ塼ؤΥǡ
   */
  extern bool_t	send_data(DTQCB *p_dtqcb, intptr_t data, bool_t *p_dspreq);
  
  /*
!  *  ǡ塼ؤΥǡ
   */
  extern bool_t	force_send_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  ǡ塼Υǡ
   */
  extern bool_t	receive_data(DTQCB *p_dtqcb, intptr_t *p_data,
  													bool_t *p_dspreq);
--- 50,164 ----
  #include "wait.h"
  
  /*
!  *  データ管理ブロック
   */
  typedef struct data_management_block {
! 	intptr_t	data;			/* データ本体 */
  } DTQMB;
  
  /*
!  *  データキュー初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct dataqueue_initialization_block {
! 	ATR			dtqatr;			/* データキュー属性 */
! 	uint_t		dtqcnt;			/* データキューの容量 */
! 	DTQMB		*p_dtqmb;		/* データキュー管理領域の先頭番地 */
  } DTQINIB;
  
  /*
!  *  データキュー管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct dataqueue_control_block {
! 	QUEUE		swait_queue;	/* データキュー送信待ちキュー */
! 	const DTQINIB *p_dtqinib;	/* 初期化ブロックへのポインタ */
! 	QUEUE		rwait_queue;	/* データキュー受信待ちキュー */
! 	uint_t		count;			/* データキュー中のデータの数 */
! 	uint_t		head;			/* 最初のデータの格納場所 */
! 	uint_t		tail;			/* 最後のデータの格納場所の次 */
  } DTQCB;
  
  /*
!  *  データキュー待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
!  *  データキューへの送信待ちとデータキューからの受信待ちで，同じ待ち情
!  *  報ブロックを使う．
   */
  typedef struct dataqueue_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	DTQCB		*p_dtqcb;		/* 待っているデータキューの管理ブロック */
! 	intptr_t	data;			/* 送受信データ */
  } WINFO_DTQ;
  
  /*
!  *  使用していないデータキュー管理ブロックのリスト
   */
  extern QUEUE	free_dtqcb;
  
  /*
!  *  データキューIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_dtqid;
  extern const ID	tmax_sdtqid;
  
  /*
!  *  データキュー初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const DTQINIB	dtqinib_table[];
  extern DTQINIB			adtqinib_table[];
  
  /*
!  *  データキュー管理ブロックのエリア（kernel_cfg.c）
   */
  extern DTQCB	dtqcb_table[];
  
  /*
!  *  データキュー管理ブロックからデータキューIDを取り出すためのマクロ
   */
  #define	DTQID(p_dtqcb)	((ID)(((p_dtqcb) - dtqcb_table) + TMIN_DTQID))
  
  /*
!  *  データキュー機能の初期化
   */
  extern void	initialize_dataqueue(void);
  
  /*
!  *  データキュー管理領域へのデータの格納
   */
  extern void	enqueue_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  データキュー管理領域へのデータの強制格納
   */
  extern void	force_enqueue_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  データキュー管理領域からのデータの取出し
   */
  extern void	dequeue_data(DTQCB *p_dtqcb, intptr_t *p_data);
  
  /*
!  *  データキューへのデータ送信
   */
  extern bool_t	send_data(DTQCB *p_dtqcb, intptr_t data, bool_t *p_dspreq);
  
  /*
!  *  データキューへのデータ強制送信
   */
  extern bool_t	force_send_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  データキューからのデータ受信
   */
  extern bool_t	receive_data(DTQCB *p_dtqcb, intptr_t *p_data,
  													bool_t *p_dspreq);
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/eventflag.c ASPs/asp/extension/dcre/kernel/eventflag.c
*** 1.9.1/asp/extension/dcre/kernel/eventflag.c	Sun Apr 13 18:49:51 2014
--- ASPs/asp/extension/dcre/kernel/eventflag.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: eventflag.c 2631 2014-04-13 09:49:44Z ertl-hiro $
   */
  
  /*
!  *		٥ȥե饰ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: eventflag.c 2631 2014-04-13 09:49:44Z ertl-hiro $
   */
  
  /*
!  *		イベントフラグ機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "eventflag.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACRE_FLG_ENTER
  #define LOG_ACRE_FLG_ENTER(pk_cflg)
--- 51,57 ----
  #include "eventflag.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACRE_FLG_ENTER
  #define LOG_ACRE_FLG_ENTER(pk_cflg)
***************
*** 134,146 ****
  #endif /* LOG_REF_FLG_LEAVE */
  
  /*
!  *  ٥ȥե饰ο
   */
  #define tnum_flg	((uint_t)(tmax_flgid - TMIN_FLGID + 1))
  #define tnum_sflg	((uint_t)(tmax_sflgid - TMIN_FLGID + 1))
  
  /*
!  *  ٥ȥե饰ID饤٥ȥե饰֥åФΥޥ
   */
  #define INDEX_FLG(flgid)	((uint_t)((flgid) - TMIN_FLGID))
  #define get_flgcb(flgid)	(&(flgcb_table[INDEX_FLG(flgid)]))
--- 134,146 ----
  #endif /* LOG_REF_FLG_LEAVE */
  
  /*
!  *  イベントフラグの数
   */
  #define tnum_flg	((uint_t)(tmax_flgid - TMIN_FLGID + 1))
  #define tnum_sflg	((uint_t)(tmax_sflgid - TMIN_FLGID + 1))
  
  /*
!  *  イベントフラグIDからイベントフラグ管理ブロックを取り出すためのマクロ
   */
  #define INDEX_FLG(flgid)	((uint_t)((flgid) - TMIN_FLGID))
  #define get_flgcb(flgid)	(&(flgcb_table[INDEX_FLG(flgid)]))
***************
*** 148,159 ****
  #ifdef TOPPERS_flgini
  
  /*
!  *  ѤƤʤ٥ȥե饰֥åΥꥹ
   */
  QUEUE	free_flgcb;
  
  /*
!  *  ٥ȥե饰ǽν
   */
  void
  initialize_eventflag(void)
--- 148,159 ----
  #ifdef TOPPERS_flgini
  
  /*
!  *  使用していないイベントフラグ管理ブロックのリスト
   */
  QUEUE	free_flgcb;
  
  /*
!  *  イベントフラグ機能の初期化
   */
  void
  initialize_eventflag(void)
***************
*** 181,187 ****
  #endif /* TOPPERS_flgini */
  
  /*
!  *  ٥ȥե饰ԤΥå
   */
  #ifdef TOPPERS_flgcnd
  
--- 181,187 ----
  #endif /* TOPPERS_flgini */
  
  /*
!  *  イベントフラグ待ち解除条件のチェック
   */
  #ifdef TOPPERS_flgcnd
  
***************
*** 202,208 ****
  #endif /* TOPPERS_flgcnd */
  
  /*
!  *  ٥ȥե饰
   */
  #ifdef TOPPERS_acre_flg
  
--- 202,208 ----
  #endif /* TOPPERS_flgcnd */
  
  /*
!  *  イベントフラグの生成
   */
  #ifdef TOPPERS_acre_flg
  
***************
*** 241,247 ****
  #endif /* TOPPERS_acre_flg */
  
  /*
!  *  ٥ȥե饰κ
   */
  #ifdef TOPPERS_del_flg
  
--- 241,247 ----
  #endif /* TOPPERS_acre_flg */
  
  /*
!  *  イベントフラグの削除
   */
  #ifdef TOPPERS_del_flg
  
***************
*** 285,291 ****
  #endif /* TOPPERS_del_flg */
  
  /*
!  *  ٥ȥե饰Υå
   */
  #ifdef TOPPERS_set_flg
  
--- 285,291 ----
  #endif /* TOPPERS_del_flg */
  
  /*
!  *  イベントフラグのセット
   */
  #ifdef TOPPERS_set_flg
  
***************
*** 341,347 ****
  #endif /* TOPPERS_set_flg */
  
  /*
!  *  ٥ȥե饰Υåȡ󥿥ƥѡ
   */
  #ifdef TOPPERS_iset_flg
  
--- 341,347 ----
  #endif /* TOPPERS_set_flg */
  
  /*
!  *  イベントフラグのセット（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iset_flg
  
***************
*** 393,399 ****
  #endif /* TOPPERS_iset_flg */
  
  /*
!  *  ٥ȥե饰Υꥢ
   */
  #ifdef TOPPERS_clr_flg
  
--- 393,399 ----
  #endif /* TOPPERS_iset_flg */
  
  /*
!  *  イベントフラグのクリア
   */
  #ifdef TOPPERS_clr_flg
  
***************
*** 426,432 ****
  #endif /* TOPPERS_clr_flg */
  
  /*
!  *  ٥ȥե饰Ԥ
   */
  #ifdef TOPPERS_wai_flg
  
--- 426,432 ----
  #endif /* TOPPERS_clr_flg */
  
  /*
!  *  イベントフラグ待ち
   */
  #ifdef TOPPERS_wai_flg
  
***************
*** 476,482 ****
  #endif /* TOPPERS_wai_flg */
  
  /*
!  *  ٥ȥե饰Ԥʥݡ󥰡
   */
  #ifdef TOPPERS_pol_flg
  
--- 476,482 ----
  #endif /* TOPPERS_wai_flg */
  
  /*
!  *  イベントフラグ待ち（ポーリング）
   */
  #ifdef TOPPERS_pol_flg
  
***************
*** 517,523 ****
  #endif /* TOPPERS_pol_flg */
  
  /*
!  *  ٥ȥե饰ԤʥॢȤ
   */
  #ifdef TOPPERS_twai_flg
  
--- 517,523 ----
  #endif /* TOPPERS_pol_flg */
  
  /*
!  *  イベントフラグ待ち（タイムアウトあり）
   */
  #ifdef TOPPERS_twai_flg
  
***************
*** 573,579 ****
  #endif /* TOPPERS_twai_flg */
  
  /*
!  *  ٥ȥե饰κƽ
   */
  #ifdef TOPPERS_ini_flg
  
--- 573,579 ----
  #endif /* TOPPERS_twai_flg */
  
  /*
!  *  イベントフラグの再初期化
   */
  #ifdef TOPPERS_ini_flg
  
***************
*** 611,617 ****
  #endif /* TOPPERS_ini_flg */
  
  /*
!  *  ٥ȥե饰ξֻ
   */
  #ifdef TOPPERS_ref_flg
  
--- 611,617 ----
  #endif /* TOPPERS_ini_flg */
  
  /*
!  *  イベントフラグの状態参照
   */
  #ifdef TOPPERS_ref_flg
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/eventflag.h ASPs/asp/extension/dcre/kernel/eventflag.h
*** 1.9.1/asp/extension/dcre/kernel/eventflag.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/dcre/kernel/eventflag.h	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: eventflag.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		٥ȥե饰ǽ
   */
  
  #ifndef TOPPERS_EVENTFLAG_H
--- 8,47 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: eventflag.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		イベントフラグ機能
   */
  
  #ifndef TOPPERS_EVENTFLAG_H
***************
*** 50,131 ****
  #include "wait.h"
  
  /*
!  *  ٥ȥե饰֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct eventflag_initialization_block {
! 	ATR			flgatr;			/* ٥ȥե饰° */
! 	FLGPTN		iflgptn;		/* ٥ȥե饰Υӥåȥѥν */
  } FLGINIB;
  
  /*
!  *  ٥ȥե饰֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct eventflag_control_block {
! 	QUEUE		wait_queue;		/* ٥ȥե饰Ԥ塼 */
! 	const FLGINIB *p_flginib;	/* ֥åؤΥݥ */
! 	FLGPTN		flgptn;			/* ٥ȥե饰ߥѥ */
  } FLGCB;
  
  /*
!  *  ٥ȥե饰Ԥ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
   *
!  *  flgptnϡwaiptnwfmodeƱ˻ȤȤϤʤᡤΤ
!  *  Х󤹤뤳ȤǽǤ롥
   */
  typedef struct eventflag_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	FLGCB		*p_flgcb;		/* ԤäƤ륤٥ȥե饰δ֥å */
! 	FLGPTN		waiptn;			/* Ԥѥ */
! 	MODE		wfmode;			/* Ԥ⡼ */
! 	FLGPTN		flgptn;			/* ԤΥѥ */
  } WINFO_FLG;
  
  /*
!  *  ѤƤʤ٥ȥե饰֥åΥꥹ
   */
  extern QUEUE	free_flgcb;
  
  /*
!  *  ٥ȥե饰IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_flgid;
  extern const ID	tmax_sflgid;
  
  /*
!  *  ٥ȥե饰֥åΥꥢkernel_cfg.c
   */
  extern const FLGINIB	flginib_table[];
  extern FLGINIB			aflginib_table[];
  
  /*
!  *  ٥ȥե饰֥åΥꥢkernel_cfg.c
   */
  extern FLGCB	flgcb_table[];
  
  /*
!  *  ٥ȥե饰֥å饤٥ȥե饰IDФΥޥ
   */
  #define	FLGID(p_flgcb)	((ID)(((p_flgcb) - flgcb_table) + TMIN_FLGID))
  
  /*
!  *  ٥ȥե饰ǽν
   */
  extern void	initialize_eventflag(void);
  
  /*
!  *  ٥ȥե饰ԤΥå
   */
  extern bool_t	check_flg_cond(FLGCB *p_flgcb, FLGPTN waiptn,
  								MODE wfmode, FLGPTN *p_flgptn);
--- 50,131 ----
  #include "wait.h"
  
  /*
!  *  イベントフラグ初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct eventflag_initialization_block {
! 	ATR			flgatr;			/* イベントフラグ属性 */
! 	FLGPTN		iflgptn;		/* イベントフラグのビットパターンの初期値 */
  } FLGINIB;
  
  /*
!  *  イベントフラグ管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct eventflag_control_block {
! 	QUEUE		wait_queue;		/* イベントフラグ待ちキュー */
! 	const FLGINIB *p_flginib;	/* 初期化ブロックへのポインタ */
! 	FLGPTN		flgptn;			/* イベントフラグ現在パターン */
  } FLGCB;
  
  /*
!  *  イベントフラグ待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
   *
!  *  flgptnは，waiptnおよびwfmodeと同時に使うことはないため，共用体を使
!  *  えばメモリを節約することが可能である．
   */
  typedef struct eventflag_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	FLGCB		*p_flgcb;		/* 待っているイベントフラグの管理ブロック */
! 	FLGPTN		waiptn;			/* 待ちパターン */
! 	MODE		wfmode;			/* 待ちモード */
! 	FLGPTN		flgptn;			/* 待ち解除時のパターン */
  } WINFO_FLG;
  
  /*
!  *  使用していないイベントフラグ管理ブロックのリスト
   */
  extern QUEUE	free_flgcb;
  
  /*
!  *  イベントフラグIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_flgid;
  extern const ID	tmax_sflgid;
  
  /*
!  *  イベントフラグ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const FLGINIB	flginib_table[];
  extern FLGINIB			aflginib_table[];
  
  /*
!  *  イベントフラグ管理ブロックのエリア（kernel_cfg.c）
   */
  extern FLGCB	flgcb_table[];
  
  /*
!  *  イベントフラグ管理ブロックからイベントフラグIDを取り出すためのマクロ
   */
  #define	FLGID(p_flgcb)	((ID)(((p_flgcb) - flgcb_table) + TMIN_FLGID))
  
  /*
!  *  イベントフラグ機能の初期化
   */
  extern void	initialize_eventflag(void);
  
  /*
!  *  イベントフラグ待ち解除条件のチェック
   */
  extern bool_t	check_flg_cond(FLGCB *p_flgcb, FLGPTN waiptn,
  								MODE wfmode, FLGPTN *p_flgptn);
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/interrupt.c ASPs/asp/extension/dcre/kernel/interrupt.c
*** 1.9.1/asp/extension/dcre/kernel/interrupt.c	Sun Apr 13 17:53:58 2014
--- ASPs/asp/extension/dcre/kernel/interrupt.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: interrupt.c 2627 2014-04-13 08:53:51Z ertl-hiro $
   */
  
  /*
!  *		ߴǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: interrupt.c 2627 2014-04-13 08:53:51Z ertl-hiro $
   */
  
  /*
!  *		割込み管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 50,56 ****
  #include "interrupt.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ISR_ENTER
  #define LOG_ISR_ENTER(intno)
--- 50,56 ----
  #include "interrupt.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ISR_ENTER
  #define LOG_ISR_ENTER(intno)
***************
*** 109,127 ****
  #endif /* LOG_GET_IPM_LEAVE */
  
  /*
!  *  ߥӥ롼ο
   */
  #define tnum_isr	((uint_t)(tmax_isrid - TMIN_SEMID + 1) + tnum_sisr)
  
  /*
!  *  ߥӥ롼IDߥӥ롼֥å
!  *  ФΥޥ
   */
  #define INDEX_ISR(isrid)	((uint_t)((isrid) - TMIN_ISRID) + tnum_sisr)
  #define get_isrcb(isrid)	(&(isrcb_table[INDEX_ISR(isrid)]))
  
  /*
!  *  ߥӥ롼󥭥塼ؤϿ
   */
  Inline void
  enqueue_isr(QUEUE *p_isr_queue, ISRCB *p_isrcb)
--- 109,127 ----
  #endif /* LOG_GET_IPM_LEAVE */
  
  /*
!  *  割込みサービスルーチンの数
   */
  #define tnum_isr	((uint_t)(tmax_isrid - TMIN_SEMID + 1) + tnum_sisr)
  
  /*
!  *  割込みサービスルーチンIDから割込みサービスルーチン管理ブロックを取
!  *  り出すためのマクロ
   */
  #define INDEX_ISR(isrid)	((uint_t)((isrid) - TMIN_ISRID) + tnum_sisr)
  #define get_isrcb(isrid)	(&(isrcb_table[INDEX_ISR(isrid)]))
  
  /*
!  *  割込みサービスルーチンキューへの登録
   */
  Inline void
  enqueue_isr(QUEUE *p_isr_queue, ISRCB *p_isrcb)
***************
*** 141,152 ****
  #ifdef TOPPERS_isrini
  
  /*
!  *  ѤƤʤߥӥ롼֥åΥꥹ
   */
  QUEUE	free_isrcb;
  
  /* 
!  *  ߥӥ롼ǽν
   */
  void
  initialize_isr(void)
--- 141,152 ----
  #ifdef TOPPERS_isrini
  
  /*
!  *  使用していない割込みサービスルーチン管理ブロックのリスト
   */
  QUEUE	free_isrcb;
  
  /* 
!  *  割込みサービスルーチン機能の初期化
   */
  void
  initialize_isr(void)
***************
*** 176,182 ****
  #endif /* TOPPERS_isrini */
  
  /*
!  *  ߥӥ롼θƽФ
   */
  #ifdef TOPPERS_isrcal
  
--- 176,182 ----
  #endif /* TOPPERS_isrini */
  
  /*
!  *  割込みサービスルーチンの呼出し
   */
  #ifdef TOPPERS_isrcal
  
***************
*** 196,202 ****
  		LOG_ISR_LEAVE(p_isrinib->intno);
  
  		if (p_queue->p_next != p_isr_queue) {
! 			/* ISRθƽФξ֤᤹ */
  			if (i_sense_lock()) {
  				i_unlock_cpu();
  			}
--- 196,202 ----
  		LOG_ISR_LEAVE(p_isrinib->intno);
  
  		if (p_queue->p_next != p_isr_queue) {
! 			/* ISRの呼出し前の状態に戻す */
  			if (i_sense_lock()) {
  				i_unlock_cpu();
  			}
***************
*** 208,214 ****
  #endif /* TOPPERS_isrcal */
  
  /*
!  *  ߥӥ롼ƽФ塼θ
   */
  Inline QUEUE *
  search_isr_queue(INTNO intno)
--- 208,214 ----
  #endif /* TOPPERS_isrcal */
  
  /*
!  *  割込みサービスルーチン呼出しキューの検索
   */
  Inline QUEUE *
  search_isr_queue(INTNO intno)
***************
*** 239,245 ****
  }
  
  /*
!  *  ߥӥ롼
   */
  #ifdef TOPPERS_acre_isr
  
--- 239,245 ----
  }
  
  /*
!  *  割込みサービスルーチンの生成
   */
  #ifdef TOPPERS_acre_isr
  
***************
*** 288,294 ****
  #endif /* TOPPERS_acre_isr */
  
  /*
!  *  ߥӥ롼κ
   */
  #ifdef TOPPERS_del_isr
  
--- 288,294 ----
  #endif /* TOPPERS_acre_isr */
  
  /*
!  *  割込みサービスルーチンの削除
   */
  #ifdef TOPPERS_del_isr
  
***************
*** 325,331 ****
  #endif /* TOPPERS_del_isr */
  
  /* 
!  *  ߴǽν
   */
  #ifdef TOPPERS_intini
  #ifndef OMIT_INITIALIZE_INTERRUPT
--- 325,331 ----
  #endif /* TOPPERS_del_isr */
  
  /* 
!  *  割込み管理機能の初期化
   */
  #ifdef TOPPERS_intini
  #ifndef OMIT_INITIALIZE_INTERRUPT
***************
*** 351,357 ****
  #endif /* TOPPERS_intini */
  
  /*
!  *  ߤζػ
   */
  #ifdef TOPPERS_dis_int
  #ifdef TOPPERS_SUPPORT_DIS_INT
--- 351,357 ----
  #endif /* TOPPERS_intini */
  
  /*
!  *  割込みの禁止
   */
  #ifdef TOPPERS_dis_int
  #ifdef TOPPERS_SUPPORT_DIS_INT
***************
*** 389,395 ****
  #endif /* TOPPERS_dis_int */
  
  /*
!  *  ߤε
   */
  #ifdef TOPPERS_ena_int
  #ifdef TOPPERS_SUPPORT_ENA_INT
--- 389,395 ----
  #endif /* TOPPERS_dis_int */
  
  /*
!  *  割込みの許可
   */
  #ifdef TOPPERS_ena_int
  #ifdef TOPPERS_SUPPORT_ENA_INT
***************
*** 427,433 ****
  #endif /* TOPPERS_ena_int */
  
  /*
!  *  ͥ٥ޥѹ
   */
  #ifdef TOPPERS_chg_ipm
  
--- 427,433 ----
  #endif /* TOPPERS_ena_int */
  
  /*
!  *  割込み優先度マスクの変更
   */
  #ifdef TOPPERS_chg_ipm
  
***************
*** 469,475 ****
  #endif /* TOPPERS_chg_ipm */
  
  /*
!  *  ͥ٥ޥλ
   */
  #ifdef TOPPERS_get_ipm
  
--- 469,475 ----
  #endif /* TOPPERS_chg_ipm */
  
  /*
!  *  割込み優先度マスクの参照
   */
  #ifdef TOPPERS_get_ipm
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/interrupt.h ASPs/asp/extension/dcre/kernel/interrupt.h
*** 1.9.1/asp/extension/dcre/kernel/interrupt.h	Sat Nov 20 16:23:57 2010
--- ASPs/asp/extension/dcre/kernel/interrupt.h	Fri Dec  9 13:54:00 2022
***************
*** 8,183 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: interrupt.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		ߴǽ
   */
  
  #ifndef TOPPERS_INTERRUPT_H
  #define TOPPERS_INTERRUPT_H
  
  /*
!  *  ߥӥ롼֥å
   */
  typedef struct isr_initialization_block {
! 	ATR			isratr;			/* ߥӥ롼° */
! 	intptr_t	exinf;			/* ߥӥ롼γĥ */
! 	INTNO		intno;			/* ߥӥ롼Ͽֹ */
! 	QUEUE		*p_isr_queue;	/* Ͽߥӥ롼󥭥塼 */
! 	ISR			isr;			/* ߥӥ롼Ƭ */
! 	PRI			isrpri;			/* ߥӥ롼ͥ */
  } ISRINIB;
  
  /*
!  *  ߥӥ롼֥å
   */
  typedef struct isr_control_block {
! 	QUEUE		isr_queue;		/* ߥӥ롼ƽФ塼 */
! 	const ISRINIB *p_isrinib;	/* ֥åؤΥݥ */
  } ISRCB;
  
  /*
!  *  ߥӥ롼ƽФ塼򸡺뤿Υǡ¤
   */
  typedef struct {
! 	INTNO		intno;			/* ֹ */
! 	QUEUE		*p_isr_queue;	/* ߥӥ롼ƽФ塼 */
  } ISR_ENTRY;
  
  /*
!  *  ߥӥ롼󥭥塼Υȥkernel_cfg.c
   */
  extern const uint_t tnum_isr_queue;
  
  /*
!  *  ߥӥ롼󥭥塼ꥹȡkernel_cfg.c
   */
  extern const ISR_ENTRY isr_queue_list[];
  
  /*
!  *  ߥӥ롼󥭥塼Υꥢkernel_cfg.c
   */
  extern QUEUE isr_queue_table[];
  
  /*
!  *  ѤƤʤߥӥ롼֥åΥꥹ
   */
  extern QUEUE	free_isrcb;
  
  /*
!  *  ߥӥ롼IDκ͡kernel_cfg.c
   *
!  *  Ūߥӥ롼IDֹʤᡤ
!  *  tmax_isridưŪߥӥ롼IDֹκ
!  *  Ǥ롥Ūߥӥ롼οϡtnum_sisr
!  *  롥
   */
  extern const ID		tmax_isrid;
  extern const uint_t	tnum_sisr;
  
  /*
!  *  ߥӥ롼֥åΥꥢkernel_cfg.c
   */
  extern const ISRINIB	sisrinib_table[];
  extern ISRINIB			aisrinib_table[];
  
  /*
!  *  ߥӥ롼֥åΥꥢkernel_cfg.c
   */
  extern ISRCB	isrcb_table[];
  
  /*
!  *  ߥӥ롼֥åߥӥ롼ID
!  *  ФΥޥ
   */
  #define	ISRID(p_isrcb)	((ID)(((p_isrcb) - isrcb_table) \
  										- tnum_sisr + TMIN_ISRID))
  
  /*
!  *  ߥӥ롼ǽν
   */
  extern void initialize_isr(void);
  
  /*
!  *  ߥӥ롼θƽФ
   */
  extern void call_isr(QUEUE *p_isr_queue);
  
  #ifndef OMIT_INITIALIZE_INTERRUPT
  
  /*
!  *  ߥϥɥ֥å
   */
  typedef struct interrupt_handler_initialization_block {
! 	INHNO		inhno;			/* ߥϥɥֹ */
! 	ATR			inhatr;			/* ߥϥɥ° */
! 	FP			int_entry;		/* ߥϥɥν */
  } INHINIB;
  
  /*
!  *  ׵饤֥å
   */
  typedef struct interrupt_request_initialization_block {
! 	INTNO		intno;			/* ֹ */
! 	ATR			intatr;			/* ° */
! 	PRI			intpri;			/* ͥ */
  } INTINIB;
  
  /*
!  *  ߥϥɥֹοkernel_cfg.c
   */
  extern const uint_t	tnum_inhno;
  
  /*
!  *  ߥϥɥ֥åΥꥢkernel_cfg.c
   */
  extern const INHINIB	inhinib_table[];
  
  /*
!  *  ׵饤οkernel_cfg.c
   */
  extern const uint_t	tnum_intno;
  
  /*
!  *  ׵饤֥åΥꥢkernel_cfg.c
   */
  extern const INTINIB	intinib_table[];
  
  #endif /* OMIT_INITIALIZE_INTERRUPT */
  
  /*
!  *  ߴǽν
   */
  extern void	initialize_interrupt(void);
  
--- 8,183 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: interrupt.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		割込み管理機能
   */
  
  #ifndef TOPPERS_INTERRUPT_H
  #define TOPPERS_INTERRUPT_H
  
  /*
!  *  割込みサービスルーチン初期化ブロック
   */
  typedef struct isr_initialization_block {
! 	ATR			isratr;			/* 割込みサービスルーチン属性 */
! 	intptr_t	exinf;			/* 割込みサービスルーチンの拡張情報 */
! 	INTNO		intno;			/* 割込みサービスルーチンを登録する割込み番号 */
! 	QUEUE		*p_isr_queue;	/* 登録先割込みサービスルーチンキューの番地 */
! 	ISR			isr;			/* 割込みサービスルーチンの先頭番地 */
! 	PRI			isrpri;			/* 割込みサービスルーチン優先度 */
  } ISRINIB;
  
  /*
!  *  割込みサービスルーチン管理ブロック
   */
  typedef struct isr_control_block {
! 	QUEUE		isr_queue;		/* 割込みサービスルーチン呼出しキュー */
! 	const ISRINIB *p_isrinib;	/* 初期化ブロックへのポインタ */
  } ISRCB;
  
  /*
!  *  割込みサービスルーチン呼出しキューを検索するためのデータ構造
   */
  typedef struct {
! 	INTNO		intno;			/* 割込み番号 */
! 	QUEUE		*p_isr_queue;	/* 割込みサービスルーチン呼出しキュー */
  } ISR_ENTRY;
  
  /*
!  *  割込みサービスルーチンキューのエントリ数（kernel_cfg.c）
   */
  extern const uint_t tnum_isr_queue;
  
  /*
!  *  割込みサービスルーチンキューリスト（kernel_cfg.c）
   */
  extern const ISR_ENTRY isr_queue_list[];
  
  /*
!  *  割込みサービスルーチンキューのエリア（kernel_cfg.c）
   */
  extern QUEUE isr_queue_table[];
  
  /*
!  *  使用していない割込みサービスルーチン管理ブロックのリスト
   */
  extern QUEUE	free_isrcb;
  
  /*
!  *  割込みサービスルーチンIDの最大値（kernel_cfg.c）
   *
!  *  静的に生成される割込みサービスルーチンはID番号を持たないため，
!  *  tmax_isridは動的に生成される割込みサービスルーチンのID番号の最大値
!  *  である．静的に生成される割込みサービスルーチンの数は，tnum_sisrに保
!  *  持する．
   */
  extern const ID		tmax_isrid;
  extern const uint_t	tnum_sisr;
  
  /*
!  *  割込みサービスルーチン初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const ISRINIB	sisrinib_table[];
  extern ISRINIB			aisrinib_table[];
  
  /*
!  *  割込みサービスルーチン管理ブロックのエリア（kernel_cfg.c）
   */
  extern ISRCB	isrcb_table[];
  
  /*
!  *  割込みサービスルーチン管理ブロックから割込みサービスルーチンIDを取
!  *  り出すためのマクロ
   */
  #define	ISRID(p_isrcb)	((ID)(((p_isrcb) - isrcb_table) \
  										- tnum_sisr + TMIN_ISRID))
  
  /*
!  *  割込みサービスルーチン機能の初期化
   */
  extern void initialize_isr(void);
  
  /*
!  *  割込みサービスルーチンの呼出し
   */
  extern void call_isr(QUEUE *p_isr_queue);
  
  #ifndef OMIT_INITIALIZE_INTERRUPT
  
  /*
!  *  割込みハンドラ初期化ブロック
   */
  typedef struct interrupt_handler_initialization_block {
! 	INHNO		inhno;			/* 割込みハンドラ番号 */
! 	ATR			inhatr;			/* 割込みハンドラ属性 */
! 	FP			int_entry;		/* 割込みハンドラの出入口処理の番地 */
  } INHINIB;
  
  /*
!  *  割込み要求ライン初期化ブロック
   */
  typedef struct interrupt_request_initialization_block {
! 	INTNO		intno;			/* 割込み番号 */
! 	ATR			intatr;			/* 割込み属性 */
! 	PRI			intpri;			/* 割込み優先度 */
  } INTINIB;
  
  /*
!  *  割込みハンドラ番号の数（kernel_cfg.c）
   */
  extern const uint_t	tnum_inhno;
  
  /*
!  *  割込みハンドラ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const INHINIB	inhinib_table[];
  
  /*
!  *  割込み要求ラインの数（kernel_cfg.c）
   */
  extern const uint_t	tnum_intno;
  
  /*
!  *  割込み要求ライン初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const INTINIB	intinib_table[];
  
  #endif /* OMIT_INITIALIZE_INTERRUPT */
  
  /*
!  *  割込み管理機能の初期化
   */
  extern void	initialize_interrupt(void);
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/kernel.tf ASPs/asp/extension/dcre/kernel/kernel.tf
*** 1.9.1/asp/extension/dcre/kernel/kernel.tf	Tue May 27 17:44:36 2014
--- ASPs/asp/extension/dcre/kernel/kernel.tf	Fri Dec  9 13:54:00 2022
***************
*** 8,53 ****
  $   Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   $Id: kernel.tf 2651 2014-05-27 08:44:34Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ AID_YYYν
  $ =====================================================================
  
  $num_atskid = 0$
  $FOREACH i ATSK.ORDER_LIST$
! $	// notskξE_PAR
  	$IF ATSK.NOTSK[i] < 0$
  		$ERROR ATSK.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "notsk", ATSK.NOTSK[i], "AID_TSK")$$END$
  	$END$
--- 8,53 ----
  $   Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   $Id: kernel.tf 2651 2014-05-27 08:44:34Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ AID_YYYの処理
  $ =====================================================================
  
  $num_atskid = 0$
  $FOREACH i ATSK.ORDER_LIST$
! $	// notskが負の場合（E_PAR）
  	$IF ATSK.NOTSK[i] < 0$
  		$ERROR ATSK.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "notsk", ATSK.NOTSK[i], "AID_TSK")$$END$
  	$END$
***************
*** 57,63 ****
  
  $num_asemid = 0$
  $FOREACH i ASEM.ORDER_LIST$
! $	// nosemξE_PAR
  	$IF ASEM.NOSEM[i] < 0$
  		$ERROR ASEM.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nosem", ASEM.NOSEM[i], "AID_SEM")$$END$
  	$END$
--- 57,63 ----
  
  $num_asemid = 0$
  $FOREACH i ASEM.ORDER_LIST$
! $	// nosemが負の場合（E_PAR）
  	$IF ASEM.NOSEM[i] < 0$
  		$ERROR ASEM.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nosem", ASEM.NOSEM[i], "AID_SEM")$$END$
  	$END$
***************
*** 67,73 ****
  
  $num_aflgid = 0$
  $FOREACH i AFLG.ORDER_LIST$
! $	// noflgξE_PAR
  	$IF AFLG.NOFLG[i] < 0$
  		$ERROR AFLG.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "noflg", AFLG.NOFLG[i], "AID_FLG")$$END$
  	$END$
--- 67,73 ----
  
  $num_aflgid = 0$
  $FOREACH i AFLG.ORDER_LIST$
! $	// noflgが負の場合（E_PAR）
  	$IF AFLG.NOFLG[i] < 0$
  		$ERROR AFLG.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "noflg", AFLG.NOFLG[i], "AID_FLG")$$END$
  	$END$
***************
*** 77,83 ****
  
  $num_adtqid = 0$
  $FOREACH i ADTQ.ORDER_LIST$
! $	// nodtqξE_PAR
  	$IF ADTQ.NODTQ[i] < 0$
  		$ERROR ADTQ.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nodtq", ADTQ.NODTQ[i], "AID_DTQ")$$END$
  	$END$
--- 77,83 ----
  
  $num_adtqid = 0$
  $FOREACH i ADTQ.ORDER_LIST$
! $	// nodtqが負の場合（E_PAR）
  	$IF ADTQ.NODTQ[i] < 0$
  		$ERROR ADTQ.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nodtq", ADTQ.NODTQ[i], "AID_DTQ")$$END$
  	$END$
***************
*** 87,93 ****
  
  $num_apdqid = 0$
  $FOREACH i APDQ.ORDER_LIST$
! $	// nopdqξE_PAR
  	$IF APDQ.NOPDQ[i] < 0$
  		$ERROR APDQ.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nopdq", APDQ.NOPDQ[i], "AID_PDQ")$$END$
  	$END$
--- 87,93 ----
  
  $num_apdqid = 0$
  $FOREACH i APDQ.ORDER_LIST$
! $	// nopdqが負の場合（E_PAR）
  	$IF APDQ.NOPDQ[i] < 0$
  		$ERROR APDQ.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nopdq", APDQ.NOPDQ[i], "AID_PDQ")$$END$
  	$END$
***************
*** 97,103 ****
  
  $num_ambxid = 0$
  $FOREACH i AMBX.ORDER_LIST$
! $	// nombxξE_PAR
  	$IF AMBX.NOMBX[i] < 0$
  		$ERROR AMBX.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nombx", AMBX.NOMBX[i], "AID_MBX")$$END$
  	$END$
--- 97,103 ----
  
  $num_ambxid = 0$
  $FOREACH i AMBX.ORDER_LIST$
! $	// nombxが負の場合（E_PAR）
  	$IF AMBX.NOMBX[i] < 0$
  		$ERROR AMBX.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nombx", AMBX.NOMBX[i], "AID_MBX")$$END$
  	$END$
***************
*** 107,113 ****
  
  $num_ampfid = 0$
  $FOREACH i AMPF.ORDER_LIST$
! $	// nompfξE_PAR
  	$IF AMPF.NOMPF[i] < 0$
  		$ERROR AMPF.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nompf", AMPF.NOMPF[i], "AID_MPF")$$END$
  	$END$
--- 107,113 ----
  
  $num_ampfid = 0$
  $FOREACH i AMPF.ORDER_LIST$
! $	// nompfが負の場合（E_PAR）
  	$IF AMPF.NOMPF[i] < 0$
  		$ERROR AMPF.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nompf", AMPF.NOMPF[i], "AID_MPF")$$END$
  	$END$
***************
*** 117,123 ****
  
  $num_acycid = 0$
  $FOREACH i ACYC.ORDER_LIST$
! $	// nocycξE_PAR
  	$IF ACYC.NOCYC[i] < 0$
  		$ERROR ACYC.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nocyc", ACYC.NOCYC[i], "AID_CYC")$$END$
  	$END$
--- 117,123 ----
  
  $num_acycid = 0$
  $FOREACH i ACYC.ORDER_LIST$
! $	// nocycが負の場合（E_PAR）
  	$IF ACYC.NOCYC[i] < 0$
  		$ERROR ACYC.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "nocyc", ACYC.NOCYC[i], "AID_CYC")$$END$
  	$END$
***************
*** 127,133 ****
  
  $num_aalmid = 0$
  $FOREACH i AALM.ORDER_LIST$
! $	// noalmξE_PAR
  	$IF AALM.NOALM[i] < 0$
  		$ERROR AALM.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "noalm", AALM.NOALM[i], "AID_ALM")$$END$
  	$END$
--- 127,133 ----
  
  $num_aalmid = 0$
  $FOREACH i AALM.ORDER_LIST$
! $	// noalmが負の場合（E_PAR）
  	$IF AALM.NOALM[i] < 0$
  		$ERROR AALM.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "noalm", AALM.NOALM[i], "AID_ALM")$$END$
  	$END$
***************
*** 137,143 ****
  
  $num_aisrid = 0$
  $FOREACH i AISR.ORDER_LIST$
! $	// noisrξE_PAR
  	$IF AISR.NOISR[i] < 0$
  		$ERROR AISR.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "noisr", AISR.NOISR[i], "AID_ISR")$$END$
  	$END$
--- 137,143 ----
  
  $num_aisrid = 0$
  $FOREACH i AISR.ORDER_LIST$
! $	// noisrが負の場合（E_PAR）
  	$IF AISR.NOISR[i] < 0$
  		$ERROR AISR.TEXT_LINE[i]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "noisr", AISR.NOISR[i], "AID_ISR")$$END$
  	$END$
***************
*** 147,153 ****
  $num_isr = LENGTH(ISR.ORDER_LIST) + num_aisrid$
  
  $ =====================================================================
! $ kernel_cfg.h
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
--- 147,153 ----
  $num_isr = LENGTH(ISR.ORDER_LIST) + num_aisrid$
  
  $ =====================================================================
! $ kernel_cfg.hの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
***************
*** 197,203 ****
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.c
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
--- 197,203 ----
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.cの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
***************
*** 211,217 ****
  $NL$
  
  $ 
! $  󥯥롼ɥǥ쥯ƥ֡#include
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
--- 211,217 ----
  $NL$
  
  $ 
! $  インクルードディレクティブ（#include）
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
***************
*** 221,227 ****
  $NL$
  
  $ 
! $  ֥ȤIDֹݻѿ
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
--- 221,227 ----
  $NL$
  
  $ 
! $  オブジェクトのID番号を保持する変数
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
***************
*** 258,312 ****
  $END$
  
  $ 
! $  
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ Ū줿1İʾ¸ߤ뤳ȤΥå
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ Ū줿ο
  #define TNUM_STSKID	$LENGTH(TSK.ID_LIST)$$NL$
  $NL$
  
! $ IDֹκ
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  const ID _kernel_tmax_stskid = (TMIN_TSKID + TNUM_STSKID - 1);$NL$
  $NL$
  
! $ 顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrʡTA_ACTϡˤǤʤE_RSATR
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)ǤʤE_PAR
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrTA_NULLˤǤʤE_RSATR
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ åΰȤ˴ؤ륨顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// stksz0ʲåκǾ͡TARGET_MIN_STKSZˤ
! $	// E_PAR
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszåΰΥȤʤE_PAR
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
--- 258,312 ----
  $END$
  
  $ 
! $  タスク
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 静的に生成されたタスクが1個以上存在することのチェック
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ 静的に生成されたタスクの数
  #define TNUM_STSKID	$LENGTH(TSK.ID_LIST)$$NL$
  $NL$
  
! $ タスクID番号の最大値
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  const ID _kernel_tmax_stskid = (TMIN_TSKID + TNUM_STSKID - 1);$NL$
  $NL$
  
! $ エラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrが（［TA_ACT］）でない場合（E_RSATR）
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)でない場合（E_PAR）
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrが（TA_NULL）でない場合（E_RSATR）
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ スタック領域の生成とそれに関するエラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// stkszが0以下か，ターゲット定義の最小値（TARGET_MIN_STKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
***************
*** 323,403 ****
  $END$
  $NL$
  
! $ ֥åʥ1İʾ¸ߤ
  const TINIB _kernel_tinib_table[TNUM_STSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// °ĥ󡤵ưϡưͥ
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// ƥȥ֥ååΰ
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// 㳰롼°ȵư
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ ưŪѤΥ֥å
  $IF num_atskid > 0$
  	TINIB _kernel_atinib_table[$num_atskid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(TINIB, _kernel_atinib_table);$NL$
  $END$$NL$
  
! $ ֥å
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ ơ֥
  const ID _kernel_torder_table[TNUM_STSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  ޥե
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ Ū줿ޥեο
  #define TNUM_SSEMID	$LENGTH(SEM.ID_LIST)$$NL$
  $NL$
  
! $ ޥեIDֹκ
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  const ID _kernel_tmax_ssemid = (TMIN_SEMID + TNUM_SSEMID - 1);$NL$
  $NL$
  
! $ ޥե֥å
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SSEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)ǤʤE_PAR
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)ǤʤE_PAR
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// ޥե֥å
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
--- 323,403 ----
  $END$
  $NL$
  
! $ タスク初期化ブロックの生成（タスクは1個以上存在する）
  const TINIB _kernel_tinib_table[TNUM_STSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// タスク属性，拡張情報，起動番地，起動時優先度
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// タスク初期化コンテキストブロック，スタック領域
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// タスク例外処理ルーチンの属性と起動番地
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ 動的生成タスク用のタスク初期化ブロックの生成
  $IF num_atskid > 0$
  	TINIB _kernel_atinib_table[$num_atskid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(TINIB, _kernel_atinib_table);$NL$
  $END$$NL$
  
! $ タスク管理ブロックの生成
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ タスク生成順序テーブルの生成
  const ID _kernel_torder_table[TNUM_STSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  セマフォ
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 静的に生成されたセマフォの数
  #define TNUM_SSEMID	$LENGTH(SEM.ID_LIST)$$NL$
  $NL$
  
! $ セマフォID番号の最大値
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  const ID _kernel_tmax_ssemid = (TMIN_SEMID + TNUM_SSEMID - 1);$NL$
  $NL$
  
! $ セマフォ初期化ブロックの生成
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SSEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)でない場合（E_PAR）
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)でない場合（E_PAR）
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// セマフォ初期化ブロック
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
***************
*** 405,418 ****
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
  $END$$NL$
  
! $ ưŪޥեѤΥޥե֥å
  $IF num_asemid > 0$
  	SEMINIB _kernel_aseminib_table[$num_asemid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(SEMINIB, _kernel_aseminib_table);$NL$
  $END$$NL$
  
! $ ޥե֥å
  $IF num_semid > 0$
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
--- 405,418 ----
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
  $END$$NL$
  
! $ 動的生成セマフォ用のセマフォ初期化ブロックの生成
  $IF num_asemid > 0$
  	SEMINIB _kernel_aseminib_table[$num_asemid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(SEMINIB, _kernel_aseminib_table);$NL$
  $END$$NL$
  
! $ セマフォ管理ブロックの生成
  $IF num_semid > 0$
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
***************
*** 420,456 ****
  $END$$NL$
  
  $ 
! $  ٥ȥե饰
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ Ū줿٥ȥե饰ο
  #define TNUM_SFLGID	$LENGTH(FLG.ID_LIST)$$NL$
  $NL$
  
! $ ٥ȥե饰IDֹκ
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  const ID _kernel_tmax_sflgid = (TMIN_FLGID + TNUM_SFLGID - 1);$NL$
  $NL$
  
! $ ٥ȥե饰֥å
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_SFLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrʡTA_TPRIϡáTA_WMULϡáTA_CLRϡˤǤʤE_RSATR
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnFLGPTN˳ǼǤʤE_PAR
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// ٥ȥե饰֥å
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
--- 420,456 ----
  $END$$NL$
  
  $ 
! $  イベントフラグ
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 静的に生成されたイベントフラグの数
  #define TNUM_SFLGID	$LENGTH(FLG.ID_LIST)$$NL$
  $NL$
  
! $ イベントフラグID番号の最大値
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  const ID _kernel_tmax_sflgid = (TMIN_FLGID + TNUM_SFLGID - 1);$NL$
  $NL$
  
! $ イベントフラグ初期化ブロックの生成
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_SFLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrが（［TA_TPRI］｜［TA_WMUL］｜［TA_CLR］）でない場合（E_RSATR）
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnがFLGPTNに格納できない場合（E_PAR）
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// イベントフラグ初期化ブロック
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
***************
*** 458,471 ****
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
  $END$$NL$
  
! $ ưŪ٥ȥե饰ѤΥ٥ȥե饰֥å
  $IF num_aflgid > 0$
  	FLGINIB _kernel_aflginib_table[$num_aflgid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(FLGINIB, _kernel_aflginib_table);$NL$
  $END$$NL$
  
! $ ٥ȥե饰֥å
  $IF num_flgid > 0$
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
--- 458,471 ----
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
  $END$$NL$
  
! $ 動的生成イベントフラグ用のイベントフラグ初期化ブロックの生成
  $IF num_aflgid > 0$
  	FLGINIB _kernel_aflginib_table[$num_aflgid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(FLGINIB, _kernel_aflginib_table);$NL$
  $END$$NL$
  
! $ イベントフラグ管理ブロックの生成
  $IF num_flgid > 0$
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
***************
*** 473,518 ****
  $END$$NL$
  
  $ 
! $  ǡ塼
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ Ū줿ǡ塼ο
  #define TNUM_SDTQID	$LENGTH(DTQ.ID_LIST)$$NL$
  $NL$
  
! $ ǡ塼IDֹκ
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  const ID _kernel_tmax_sdtqid = (TMIN_DTQID + TNUM_SDTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntξE_PAR
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbNULLǤʤE_NOSPT
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// ǡ塼ΰ
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// ǡ塼֥å
  	const DTQINIB _kernel_dtqinib_table[TNUM_SDTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
--- 473,518 ----
  $END$$NL$
  
  $ 
! $  データキュー
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 静的に生成されたデータキューの数
  #define TNUM_SDTQID	$LENGTH(DTQ.ID_LIST)$$NL$
  $NL$
  
! $ データキューID番号の最大値
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  const ID _kernel_tmax_sdtqid = (TMIN_DTQID + TNUM_SDTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntが負の場合（E_PAR）
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// データキュー管理領域
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// データキュー初期化ブロックの生成
  	const DTQINIB _kernel_dtqinib_table[TNUM_SDTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
***************
*** 522,535 ****
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
  $END$$NL$
  
! $ ưŪǡ塼ѤΥǡ塼֥å
  $IF num_adtqid > 0$
  	DTQINIB _kernel_adtqinib_table[$num_adtqid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(DTQINIB, _kernel_adtqinib_table);$NL$
  $END$$NL$
  
! $ ǡ塼֥å
  $IF num_dtqid > 0$
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
--- 522,535 ----
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
  $END$$NL$
  
! $ 動的生成データキュー用のデータキュー初期化ブロックの生成
  $IF num_adtqid > 0$
  	DTQINIB _kernel_adtqinib_table[$num_adtqid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(DTQINIB, _kernel_adtqinib_table);$NL$
  $END$$NL$
  
! $ データキュー管理ブロックの生成
  $IF num_dtqid > 0$
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
***************
*** 537,587 ****
  $END$$NL$
  
  $ 
! $  ͥ٥ǡ塼
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ Ū줿ͥ٥ǡ塼ο
  #define TNUM_SPDQID	$LENGTH(PDQ.ID_LIST)$$NL$
  $NL$
  
! $ ͥ٥ǡ塼IDֹκ
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  const ID _kernel_tmax_spdqid = (TMIN_PDQID + TNUM_SPDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntξE_PAR
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)ǤʤE_PAR
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbNULLǤʤE_NOSPT
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// ͥ٥ǡ塼ΰ
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// ͥ٥ǡ塼֥å
  	const PDQINIB _kernel_pdqinib_table[TNUM_SPDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
--- 537,587 ----
  $END$$NL$
  
  $ 
! $  優先度データキュー
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 静的に生成された優先度データキューの数
  #define TNUM_SPDQID	$LENGTH(PDQ.ID_LIST)$$NL$
  $NL$
  
! $ 優先度データキューID番号の最大値
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  const ID _kernel_tmax_spdqid = (TMIN_PDQID + TNUM_SPDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntが負の場合（E_PAR）
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)でない場合（E_PAR）
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// 優先度データキュー管理領域
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// 優先度データキュー初期化ブロックの生成
  	const PDQINIB _kernel_pdqinib_table[TNUM_SPDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
***************
*** 591,604 ****
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
  $END$$NL$
  
! $ ưŪͥ٥ǡ塼Ѥͥ٥ǡ塼֥å
  $IF num_apdqid > 0$
  	PDQINIB _kernel_apdqinib_table[$num_apdqid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(PDQINIB, _kernel_apdqinib_table);$NL$
  $END$$NL$
  
! $ ͥ٥ǡ塼֥å
  $IF num_pdqid > 0$
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
--- 591,604 ----
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
  $END$$NL$
  
! $ 動的生成優先度データキュー用の優先度データキュー初期化ブロックの生成
  $IF num_apdqid > 0$
  	PDQINIB _kernel_apdqinib_table[$num_apdqid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(PDQINIB, _kernel_apdqinib_table);$NL$
  $END$$NL$
  
! $ 優先度データキュー管理ブロックの生成
  $IF num_pdqid > 0$
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
***************
*** 606,647 ****
  $END$$NL$
  
  $ 
! $  ᡼ܥå
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ Ū줿᡼ܥåο
  #define TNUM_SMBXID	$LENGTH(MBX.ID_LIST)$$NL$
  $NL$
  
! $ ᡼ܥåIDֹκ
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  const ID _kernel_tmax_smbxid = (TMIN_MBXID + TNUM_SMBXID - 1);$NL$
  $NL$
  
! $ ᡼ܥå֥å
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_SMBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrʡTA_TPRIϡáTA_MPRIϡˤǤʤE_RSATR
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)ǤʤE_PAR
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdNULLǤʤE_NOSPT
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// ᡼ܥå֥å
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
--- 606,647 ----
  $END$$NL$
  
  $ 
! $  メールボックス
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 静的に生成されたメールボックスの数
  #define TNUM_SMBXID	$LENGTH(MBX.ID_LIST)$$NL$
  $NL$
  
! $ メールボックスID番号の最大値
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  const ID _kernel_tmax_smbxid = (TMIN_MBXID + TNUM_SMBXID - 1);$NL$
  $NL$
  
! $ メールボックス初期化ブロックの生成
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_SMBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrが（［TA_TPRI］｜［TA_MPRI］）でない場合（E_RSATR）
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)でない場合（E_PAR）
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdがNULLでない場合（E_NOSPT）
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// メールボックス初期化ブロック
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
***************
*** 649,662 ****
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
  $END$$NL$
  
! $ ưŪ᡼ܥåѤΥ᡼ܥå֥å
  $IF num_ambxid > 0$
  	MBXINIB _kernel_ambxinib_table[$num_ambxid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(MBXINIB, _kernel_ambxinib_table);$NL$
  $END$$NL$
  
! $ ᡼ܥå֥å
  $IF num_mbxid > 0$
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
--- 649,662 ----
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
  $END$$NL$
  
! $ 動的生成メールボックス用のメールボックス初期化ブロックの生成
  $IF num_ambxid > 0$
  	MBXINIB _kernel_ambxinib_table[$num_ambxid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(MBXINIB, _kernel_ambxinib_table);$NL$
  $END$$NL$
  
! $ メールボックス管理ブロックの生成
  $IF num_mbxid > 0$
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
***************
*** 664,717 ****
  $END$$NL$
  
  $ 
! $  Ĺס
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ Ū줿Ĺסο
  #define TNUM_SMPFID	$LENGTH(MPF.ID_LIST)$$NL$
  $NL$
  
! $ ĹסIDֹκ
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  const ID _kernel_tmax_smpfid = (TMIN_MPFID + TNUM_SMPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcnt0ʲξE_PAR
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blksz0ʲξE_PAR
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbNULLǤʤE_NOSPT
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// Ĺס֥å
  	const MPFINIB _kernel_mpfinib_table[TNUM_SMPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
--- 664,717 ----
  $END$$NL$
  
  $ 
! $  固定長メモリプール
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 静的に生成された固定長メモリプールの数
  #define TNUM_SMPFID	$LENGTH(MPF.ID_LIST)$$NL$
  $NL$
  
! $ 固定長メモリプールID番号の最大値
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  const ID _kernel_tmax_smpfid = (TMIN_MPFID + TNUM_SMPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcntが0以下の場合（E_PAR）
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkszが0以下の場合（E_PAR）
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール領域
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール管理領域
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// 固定長メモリプール初期化ブロックの生成
  	const MPFINIB _kernel_mpfinib_table[TNUM_SMPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
***************
*** 721,734 ****
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
  $END$$NL$
  
! $ ưŪĹסѤθĹס֥å
  $IF num_ampfid > 0$
  	MPFINIB _kernel_ampfinib_table[$num_ampfid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(MPFINIB, _kernel_ampfinib_table);$NL$
  $END$$NL$
  
! $ Ĺס֥å
  $IF num_mpfid > 0$
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
--- 721,734 ----
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
  $END$$NL$
  
! $ 動的生成固定長メモリプール用の固定長メモリプール初期化ブロックの生成
  $IF num_ampfid > 0$
  	MPFINIB _kernel_ampfinib_table[$num_ampfid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(MPFINIB, _kernel_ampfinib_table);$NL$
  $END$$NL$
  
! $ 固定長メモリプール管理ブロックの生成
  $IF num_mpfid > 0$
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
***************
*** 736,782 ****
  $END$$NL$
  
  $ 
! $  ϥɥ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ Ū줿ϥɥο
  #define TNUM_SCYCID	$LENGTH(CYC.ID_LIST)$$NL$
  $NL$
  
! $ ϥɥIDֹκ
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  const ID _kernel_tmax_scycid = (TMIN_CYCID + TNUM_SCYCID - 1);$NL$
  $NL$
  
! $ ϥɥơ֥
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_SCYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrʡTA_STAϡˤǤʤE_RSATR
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// ٹcycatrTA_STAꤵƤơ(cycphs == 0)ξ
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// ϥɥ֥å
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
--- 736,782 ----
  $END$$NL$
  
  $ 
! $  周期ハンドラ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 静的に生成された周期ハンドラの数
  #define TNUM_SCYCID	$LENGTH(CYC.ID_LIST)$$NL$
  $NL$
  
! $ 周期ハンドラID番号の最大値
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  const ID _kernel_tmax_scycid = (TMIN_CYCID + TNUM_SCYCID - 1);$NL$
  $NL$
  
! $ 周期ハンドラ初期化テーブルの生成
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_SCYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrが（［TA_STA］）でない場合（E_RSATR）
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// 警告：cycatrにTA_STAが設定されていて，(cycphs == 0)の場合
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// 周期ハンドラ初期化ブロック
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
***************
*** 784,797 ****
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
  $END$$NL$
  
! $ ưŪϥɥѤμϥɥ֥å
  $IF num_acycid > 0$
  	CYCINIB _kernel_acycinib_table[$num_acycid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(CYCINIB, _kernel_acycinib_table);$NL$
  $END$$NL$
  
! $ ϥɥ֥å
  $IF num_cycid > 0$
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
--- 784,797 ----
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
  $END$$NL$
  
! $ 動的生成周期ハンドラ用の周期ハンドラ初期化ブロックの生成
  $IF num_acycid > 0$
  	CYCINIB _kernel_acycinib_table[$num_acycid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(CYCINIB, _kernel_acycinib_table);$NL$
  $END$$NL$
  
! $ 周期ハンドラ管理ブロックの生成
  $IF num_cycid > 0$
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
***************
*** 799,830 ****
  $END$$NL$
  
  $ 
! $  顼ϥɥ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ Ū줿顼ϥɥο
  #define TNUM_SALMID	$LENGTH(ALM.ID_LIST)$$NL$
  $NL$
  
! $ 顼ϥɥIDֹκ
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  const ID _kernel_tmax_salmid = (TMIN_ALMID + TNUM_SALMID - 1);$NL$
  $NL$
  
! $ 顼ϥɥ֥å
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_SALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrTA_NULLˤǤʤE_RSATR
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// 顼ϥɥ֥å
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
--- 799,830 ----
  $END$$NL$
  
  $ 
! $  アラームハンドラ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 静的に生成されたアラームハンドラの数
  #define TNUM_SALMID	$LENGTH(ALM.ID_LIST)$$NL$
  $NL$
  
! $ アラームハンドラID番号の最大値
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  const ID _kernel_tmax_salmid = (TMIN_ALMID + TNUM_SALMID - 1);$NL$
  $NL$
  
! $ アラームハンドラ初期化ブロックの生成
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_SALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrが（TA_NULL）でない場合（E_RSATR）
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// アラームハンドラ初期化ブロック
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
***************
*** 832,845 ****
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
  $END$$NL$
  
! $ ưŪ顼ϥɥѤΥ顼ϥɥ֥å
  $IF num_aalmid > 0$
  	ALMINIB _kernel_aalminib_table[$num_aalmid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(ALMINIB, _kernel_aalminib_table);$NL$
  $END$$NL$
  
! $ 顼ϥɥ֥å
  $IF num_almid > 0$
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
--- 832,845 ----
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
  $END$$NL$
  
! $ 動的生成アラームハンドラ用のアラームハンドラ初期化ブロックの生成
  $IF num_aalmid > 0$
  	ALMINIB _kernel_aalminib_table[$num_aalmid$];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(ALMINIB, _kernel_aalminib_table);$NL$
  $END$$NL$
  
! $ アラームハンドラ管理ブロックの生成
  $IF num_almid > 0$
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
***************
*** 847,860 ****
  $END$$NL$
  
  $ 
! $  ߴǽ
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ֹȳߥϥɥֹѴơ֥κ
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
--- 847,860 ----
  $END$$NL$
  
  $ 
! $  割込み管理機能
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 割込み番号と割込みハンドラ番号の変換テーブルの作成
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
***************
*** 866,880 ****
  	$i = i + 1$
  $END$
  
! $ ׵饤˴ؤ륨顼å
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoCFG_INTФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoCFG_INTˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
--- 866,880 ----
  	$i = i + 1$
  $END$
  
! $ 割込み要求ラインに関するエラーチェック
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoがCFG_INTに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoがCFG_INTによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
***************
*** 883,908 ****
  		$j = j + 1$
  	$END$
  
! $	// intatrʡTA_ENAINTϡáTA_EDGEϡˤǤʤE_RSATR
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriCFG_INTФͥ٤ȤʤE_PAR
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵ줿E_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵʤäE_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
--- 883,908 ----
  		$j = j + 1$
  	$END$
  
! $	// intatrが（［TA_ENAINT］｜［TA_EDGE］）でない場合（E_RSATR）
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriがCFG_INTに対する割込み優先度として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// カーネル管理に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定された場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定されなかった場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
***************
*** 911,925 ****
  	$i = i + 1$
  $END$
  
! $ ߥϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoDEF_INHФߥϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoDEF_INHˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
--- 911,925 ----
  	$i = i + 1$
  $END$
  
! $ 割込みハンドラに関するエラーチェック
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoがDEF_INHに対する割込みハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoがDEF_INHによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
***************
*** 928,948 ****
  		$j = j + 1$
  	$END$
  
! $	// inhatrTA_NULLˤǤʤE_RSATR
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	//ꤵƤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	// ꤵƤʤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
--- 928,948 ----
  		$j = j + 1$
  	$END$
  
! $	// inhatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// カーネル管理に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	//　が指定されている場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	// が指定されていない場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
***************
*** 951,971 ****
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoбintnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrTA_NONKERNELꤵƤ餺inhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRI⾮E_OBJ
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrTA_NONKERNELꤵƤꡤinhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRIʾǤE_OBJ
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
--- 951,971 ----
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoに対応するintnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrにTA_NONKERNELが指定されておらず，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRIよりも小さい場合（E_OBJ）
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrにTA_NONKERNELが指定されており，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRI以上である場合（E_OBJ）
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
***************
*** 975,993 ****
  	$i = i + 1$
  $END$
  
! $ ߥӥ롼ISRˤ˴ؤ륨顼å
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrTA_NULLˤǤʤE_RSATR
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoATT_ISRФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)ǤʤE_PAR
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
--- 975,993 ----
  	$i = i + 1$
  $END$
  
! $ 割込みサービスルーチン（ISR）に関するエラーチェック
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrが（TA_NULL）でない場合（E_RSATR）
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoがATT_ISRに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)でない場合（E_PAR）
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
***************
*** 996,1002 ****
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// ֹintnoФϿ줿ISRΥꥹȤκ
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
--- 996,1002 ----
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// 割込み番号intnoに対して登録されたISRのリストの作成
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
***************
*** 1005,1023 ****
  		$END$
  	$END$
  
! $	// ֹintnoФϿ줿ISR¸ߤ
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoбinhnoФDEF_INHE_OBJ
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoФCFG_INTꤵ줿ͥ٤TMIN_INTPRI
! $			// ⾮E_OBJ
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
--- 1005,1023 ----
  		$END$
  	$END$
  
! $	// 割込み番号intnoに対して登録されたISRが存在する場合
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoに対応するinhnoに対してDEF_INHがある場合（E_OBJ）
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoに対してCFG_INTで設定された割込み優先度がTMIN_INTPRI
! $			// よりも小さい場合（E_OBJ）
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
***************
*** 1025,1031 ****
  	$END$
  $END$
  
! $ ߥӥ롼ISR˴Υǡ¤
  $intno_isr_list = {}$
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
--- 1025,1031 ----
  	$END$
  $END$
  
! $ 割込みサービスルーチン（ISR）管理のデータ構造
  $intno_isr_list = {}$
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
***************
*** 1061,1067 ****
  	TOPPERS_EMPTY_LABEL(QUEUE, _kernel_isr_queue_table);$NL$
  $END$$NL$
  
! $ ߥӥ롼ISR˸ƽФΤγߥϥɥ
  $FOREACH intno INTNO_ISR$
  	$inhno = INHNO[intno]$
  
--- 1061,1067 ----
  	TOPPERS_EMPTY_LABEL(QUEUE, _kernel_isr_queue_table);$NL$
  $END$$NL$
  
! $ 割込みサービスルーチン（ISR）呼出しのための割込みハンドラの生成
  $FOREACH intno INTNO_ISR$
  	$inhno = INHNO[intno]$
  
***************
*** 1071,1077 ****
  	$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  	$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $	// ISRѤγߥϥɥ
  	void$NL$
  	_kernel_inthdr_$intno$(void)$NL$
  	{$NL$
--- 1071,1077 ----
  	$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  	$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $	// ISR用の割込みハンドラ
  	void$NL$
  	_kernel_inthdr_$intno$(void)$NL$
  	{$NL$
***************
*** 1082,1098 ****
  	$NL$
  $END$
  
! $ ߥӥ롼ο
  #define TNUM_SISR	$LENGTH(ISR.ORDER_LIST)$$NL$
  #define TNUM_ISR	$LENGTH(ISR.ORDER_LIST) + num_aisrid$$NL$
  $NL$
  
! $ ߥӥ롼IDֹκ
  const ID _kernel_tmax_isrid = (TMIN_ISRID + TNUM_ISRID - 1);$NL$
  const uint_t _kernel_tnum_sisr = TNUM_SISR;$NL$
  $NL$
  
! $ ߥӥ롼֥å
  $IF LENGTH(ISR.ORDER_LIST)$
  	const ISRINIB _kernel_sisrinib_table[TNUM_SISR] = {$NL$
  	$JOINEACH order ISR.ORDER_LIST ",\n"$
--- 1082,1098 ----
  	$NL$
  $END$
  
! $ 割込みサービスルーチンの数
  #define TNUM_SISR	$LENGTH(ISR.ORDER_LIST)$$NL$
  #define TNUM_ISR	$LENGTH(ISR.ORDER_LIST) + num_aisrid$$NL$
  $NL$
  
! $ 割込みサービスルーチンID番号の最大値
  const ID _kernel_tmax_isrid = (TMIN_ISRID + TNUM_ISRID - 1);$NL$
  const uint_t _kernel_tnum_sisr = TNUM_SISR;$NL$
  $NL$
  
! $ 割込みサービスルーチン初期化ブロックの生成
  $IF LENGTH(ISR.ORDER_LIST)$
  	const ISRINIB _kernel_sisrinib_table[TNUM_SISR] = {$NL$
  	$JOINEACH order ISR.ORDER_LIST ",\n"$
***************
*** 1104,1111 ****
  $END$
  $NL$
  
! $ ưŪߥӥ롼Ѥγߥӥ롼֥
! $ 
  $IF num_aisrid > 0$
  	ISRINIB _kernel_aisrinib_table[$num_aisrid$];$NL$
  $ELSE$
--- 1104,1111 ----
  $END$
  $NL$
  
! $ 動的生成割込みサービスルーチン用の割込みサービスルーチン初期化ブロッ
! $ クの生成
  $IF num_aisrid > 0$
  	ISRINIB _kernel_aisrinib_table[$num_aisrid$];$NL$
  $ELSE$
***************
*** 1113,1119 ****
  $END$
  $NL$
  
! $ ߥӥ롼֥å
  $IF num_isr > 0$
  	ISRCB _kernel_isrcb_table[TNUM_ISR];$NL$
  $ELSE$
--- 1113,1119 ----
  $END$
  $NL$
  
! $ 割込みサービスルーチン管理ブロックの生成
  $IF num_isr > 0$
  	ISRCB _kernel_isrcb_table[TNUM_ISR];$NL$
  $ELSE$
***************
*** 1122,1133 ****
  $NL$
  
  $ 
! $  ߴǽΤɸŪʽ
  $ 
! $ ߥϥɥνɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ ߥϥɥ
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
--- 1122,1133 ----
  $NL$
  
  $ 
! $  割込み管理機能のための標準的な初期化情報の生成
  $ 
! $ 割込みハンドラの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ 割込みハンドラ数
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
***************
*** 1138,1144 ****
  $END$
  $NL$
  
! $ ߥϥɥơ֥
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
--- 1138,1144 ----
  $END$
  $NL$
  
! $ 割込みハンドラ初期化テーブル
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
***************
*** 1154,1168 ****
  $END$$NL$
  $END$
  
! $ ׵饤νɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ ׵饤
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ ׵饤ơ֥
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
--- 1154,1168 ----
  $END$$NL$
  $END$
  
! $ 割込み要求ラインの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ 割込み要求ライン数
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ 割込み要求ライン初期化テーブル
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
***************
*** 1175,1196 ****
  $END$
  
  $ 
! $  CPU㳰ǽ
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU㳰ϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoDEF_EXCФCPU㳰ϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoDEF_EXCˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
--- 1175,1196 ----
  $END$
  
  $ 
! $  CPU例外管理機能
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU例外ハンドラに関するエラーチェック
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoがDEF_EXCに対するCPU例外ハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoがDEF_EXCによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
***************
*** 1199,1215 ****
  		$j = j + 1$
  	$END$
  
! $	// excatrTA_NULLˤǤʤE_RSATR
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU㳰ϥɥΤɸŪʽ
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU㳰ϥɥ
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
--- 1199,1215 ----
  		$j = j + 1$
  	$END$
  
! $	// excatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU例外ハンドラのための標準的な初期化情報の生成
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU例外ハンドラ数
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
***************
*** 1218,1224 ****
  $END$
  $NL$
  
! $ CPU㳰ϥɥơ֥
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
--- 1218,1224 ----
  $END$
  $NL$
  
! $ CPU例外ハンドラ初期化テーブル
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
***************
*** 1231,1237 ****
  $END$
  
  $ 
! $  󥿥ƥѤΥåΰ
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
--- 1231,1237 ----
  $END$
  
  $ 
! $  非タスクコンテキスト用のスタック領域
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
***************
*** 1239,1245 ****
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSʤΥǥեͤ
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
--- 1239,1245 ----
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSがない場合のデフォルト値の設定
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
***************
*** 1254,1279 ****
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// ŪAPIDEF_ICSפʣE_OBJ
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istksz0ʲåκǾ͡TARGET_MIN_ISTKSZˤ
! $	// E_PAR
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszåΰΥȤʤE_PAR
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// åΰμưդ
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
--- 1254,1279 ----
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// 静的API「DEF_ICS」が複数ある（E_OBJ）
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istkszが0以下か，ターゲット定義の最小値（TARGET_MIN_ISTKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// スタック領域の自動割付け
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
***************
*** 1284,1290 ****
  $END$
  $NL$
  
! $ 󥿥ƥѤΥåΰ
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
--- 1284,1290 ----
  $END$
  $NL$
  
! $ 非タスクコンテキスト用のスタック領域
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
***************
*** 1294,1300 ****
  $NL$
  
  $ 
! $  ͥ뤬դΰ
  $ 
  /*$NL$
  $SPC$*  Memory Area Allocated by Kernel$NL$
--- 1294,1300 ----
  $NL$
  
  $ 
! $  カーネルが割り付けるメモリ領域
  $ 
  /*$NL$
  $SPC$*  Memory Area Allocated by Kernel$NL$
***************
*** 1302,1329 ****
  $NL$
  
  $IF !LENGTH(KMM.ORDER_LIST)$
! $	// DEF_KMMʤΥǥեͤ
  	#define TOPPERS_KMMSZ		0$NL$
  	#define TOPPERS_KMM			NULL$NL$
  $ELSE$
! $	// ŪAPIDEF_KMMפʣE_OBJ
  	$IF LENGTH(KMM.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_KMM")$$END$
  	$END$
  
! $	// kmmsz0ʲξE_PAR
  	$IF KMM.KMMSZ[1] <= 0$
  		$ERROR KMM.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' is zero in %3%"), "kmmsz", KMM.KMMSZ[1], "DEF_KMM")$$END$
  	$END$
  
! $ 	// kmmszͥ뤬դΰΥȤʤE_PAR
  	$IF !EQ(KMM.KMM[1], "NULL") && CHECK_MB_ALIGN
  							&& (KMM.KMMSZ[1] & (CHECK_MB_ALIGN - 1))$
  		$ERROR KMM.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "kmmsz", KMM.KMMSZ[1], "DEF_KMM")$$END$
  	$END$
  
  	$IF EQ(KMM.KMM[1], "NULL")$
! $		// ͥ뤬դΰμưդ
  		static MB_T					_kernel_memory[TOPPERS_COUNT_SZ($KMM.KMMSZ[1]$, sizeof(MB_T))];$NL$
  		#define TOPPERS_KMMSZ		TOPPERS_ROUND_SZ($KMM.KMMSZ[1]$, sizeof(MB_T))$NL$
  		#define TOPPERS_KMM			_kernel_memory$NL$
--- 1302,1329 ----
  $NL$
  
  $IF !LENGTH(KMM.ORDER_LIST)$
! $	// DEF_KMMがない場合のデフォルト値の設定
  	#define TOPPERS_KMMSZ		0$NL$
  	#define TOPPERS_KMM			NULL$NL$
  $ELSE$
! $	// 静的API「DEF_KMM」が複数ある（E_OBJ）
  	$IF LENGTH(KMM.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_KMM")$$END$
  	$END$
  
! $	// kmmszが0以下の場合（E_PAR）
  	$IF KMM.KMMSZ[1] <= 0$
  		$ERROR KMM.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' is zero in %3%"), "kmmsz", KMM.KMMSZ[1], "DEF_KMM")$$END$
  	$END$
  
! $ 	// kmmszがカーネルが割り付けるメモリ領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(KMM.KMM[1], "NULL") && CHECK_MB_ALIGN
  							&& (KMM.KMMSZ[1] & (CHECK_MB_ALIGN - 1))$
  		$ERROR KMM.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "kmmsz", KMM.KMMSZ[1], "DEF_KMM")$$END$
  	$END$
  
  	$IF EQ(KMM.KMM[1], "NULL")$
! $		// カーネルが割り付けるメモリ領域の自動割付け
  		static MB_T					_kernel_memory[TOPPERS_COUNT_SZ($KMM.KMMSZ[1]$, sizeof(MB_T))];$NL$
  		#define TOPPERS_KMMSZ		TOPPERS_ROUND_SZ($KMM.KMMSZ[1]$, sizeof(MB_T))$NL$
  		#define TOPPERS_KMM			_kernel_memory$NL$
***************
*** 1334,1346 ****
  $END$
  $NL$
  
! $ ͥ뤬դΰ
  const SIZE		_kernel_kmmsz = TOPPERS_KMMSZ;$NL$
  MB_T *const		_kernel_kmm = TOPPERS_KMM;$NL$
  $NL$
  
  $ 
! $  ।٥ȴ
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
--- 1334,1346 ----
  $END$
  $NL$
  
! $ カーネルが割り付けるメモリ領域
  const SIZE		_kernel_kmmsz = TOPPERS_KMMSZ;$NL$
  MB_T *const		_kernel_kmm = TOPPERS_KMM;$NL$
  $NL$
  
  $ 
! $  タイムイベント管理
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
***************
*** 1350,1356 ****
  $NL$
  
  $ 
! $  ƥ⥸塼νؿ
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
--- 1350,1356 ----
  $NL$
  
  $ 
! $  各モジュールの初期化関数
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
***************
*** 1375,1381 ****
  $NL$
  
  $ 
! $  롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
--- 1375,1381 ----
  $NL$
  
  $ 
! $  初期化ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
***************
*** 1385,1391 ****
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrTA_NULLˤǤʤE_RSATR
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
--- 1385,1391 ----
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrが（TA_NULL）でない場合（E_RSATR）
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
***************
*** 1395,1401 ****
  $NL$
  
  $ 
! $  λ롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
--- 1395,1401 ----
  $NL$
  
  $ 
! $  終了処理ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
***************
*** 1405,1411 ****
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrTA_NULLˤǤʤE_RSATR
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
--- 1405,1411 ----
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrが（TA_NULL）でない場合（E_RSATR）
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/kernel_check.tf ASPs/asp/extension/dcre/kernel/kernel_check.tf
*** 1.9.1/asp/extension/dcre/kernel/kernel_check.tf	Tue Dec 31 15:07:08 2013
--- ASPs/asp/extension/dcre/kernel/kernel_check.tf	Fri Dec  9 13:54:00 2022
***************
*** 7,47 ****
  $   Copyright (C) 2008-2010 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   @(#) $Id: kernel_check.tf 2583 2013-12-31 06:07:08Z ertl-hiro $
  $  
  $ =====================================================================
  
  $
! $  ǡLMAVMAؤΥԡ
  $
  $FOREACH lma LMA.ORDER_LIST$
  	$start_data = SYMBOL(LMA.START_DATA[lma])$
--- 7,47 ----
  $   Copyright (C) 2008-2010 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   @(#) $Id: kernel_check.tf 2583 2013-12-31 06:07:08Z ertl-hiro $
  $  
  $ =====================================================================
  
  $
! $  データセクションのLMAからVMAへのコピー
  $
  $FOREACH lma LMA.ORDER_LIST$
  	$start_data = SYMBOL(LMA.START_DATA[lma])$
***************
*** 59,68 ****
  $END$
  
  $ 
! $  ؿƬϤΥå
  $ 
  $IF CHECK_FUNC_ALIGN || CHECK_FUNC_NONNULL$
! $	// ȥ㳰롼ƬϤΥå
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$task = PEEK(tinib + offsetof_TINIB_task, sizeof_FP)$
--- 59,68 ----
  $END$
  
  $ 
! $  関数の先頭番地のチェック
  $ 
  $IF CHECK_FUNC_ALIGN || CHECK_FUNC_NONNULL$
! $	// タスクとタスク例外処理ルーチンの先頭番地のチェック
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$task = PEEK(tinib + offsetof_TINIB_task, sizeof_FP)$
***************
*** 85,91 ****
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// ϥɥƬϤΥå
  	$cycinib = SYMBOL("_kernel_cycinib_table")$
  	$FOREACH cycid CYC.ID_LIST$
  		$cychdr = PEEK(cycinib + offsetof_CYCINIB_cychdr, sizeof_FP)$
--- 85,91 ----
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// 周期ハンドラの先頭番地のチェック
  	$cycinib = SYMBOL("_kernel_cycinib_table")$
  	$FOREACH cycid CYC.ID_LIST$
  		$cychdr = PEEK(cycinib + offsetof_CYCINIB_cychdr, sizeof_FP)$
***************
*** 102,108 ****
  		$cycinib = cycinib + sizeof_CYCINIB$
  	$END$
  
! $	// 顼ϥɥƬϤΥå
  	$alminib = SYMBOL("_kernel_alminib_table")$
  	$FOREACH almid ALM.ID_LIST$
  		$almhdr = PEEK(alminib + offsetof_ALMINIB_almhdr, sizeof_FP)$
--- 102,108 ----
  		$cycinib = cycinib + sizeof_CYCINIB$
  	$END$
  
! $	// アラームハンドラの先頭番地のチェック
  	$alminib = SYMBOL("_kernel_alminib_table")$
  	$FOREACH almid ALM.ID_LIST$
  		$almhdr = PEEK(alminib + offsetof_ALMINIB_almhdr, sizeof_FP)$
***************
*** 119,125 ****
  		$alminib = alminib + sizeof_ALMINIB$
  	$END$
  
! $	// ߥӥ롼ƬϤΥå
  	$isrinib = SYMBOL("_kernel_sisrinib_table")$
  	$FOREACH order ISR.ORDER_LIST$
  		$isr = PEEK(isrinib + offsetof_ISRINIB_isr, sizeof_FP)$
--- 119,125 ----
  		$alminib = alminib + sizeof_ALMINIB$
  	$END$
  
! $	// 割込みサービスルーチンの先頭番地のチェック
  	$isrinib = SYMBOL("_kernel_sisrinib_table")$
  	$FOREACH order ISR.ORDER_LIST$
  		$isr = PEEK(isrinib + offsetof_ISRINIB_isr, sizeof_FP)$
***************
*** 138,147 ****
  $END$
  
  $ 
! $  åΰƬϤΥå
  $ 
  $IF CHECK_STACK_ALIGN || CHECK_STACK_NONNULL$
! $	// ΥåΰƬϤΥå
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$IF USE_TSKINICTXB$
--- 138,147 ----
  $END$
  
  $ 
! $  スタック領域の先頭番地のチェック
  $ 
  $IF CHECK_STACK_ALIGN || CHECK_STACK_NONNULL$
! $	// タスクのスタック領域の先頭番地のチェック
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$IF USE_TSKINICTXB$
***************
*** 162,168 ****
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// 󥿥ƥѤΥåΰƬϤΥå
  	$istk = PEEK(SYMBOL("_kernel_istk"), sizeof_void_ptr)$
  	$IF CHECK_STACK_ALIGN && (istk & (CHECK_STACK_ALIGN - 1)) != 0$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: 
--- 162,168 ----
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// 非タスクコンテキスト用のスタック領域の先頭番地のチェック
  	$istk = PEEK(SYMBOL("_kernel_istk"), sizeof_void_ptr)$
  	$IF CHECK_STACK_ALIGN && (istk & (CHECK_STACK_ALIGN - 1)) != 0$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: 
***************
*** 177,186 ****
  $END$
  
  $ 
! $  ĹסΰƬϤΥå
  $ 
  $IF CHECK_MPF_ALIGN || CHECK_MPF_NONNULL$
! $	// ĹסΰƬϤΥå
  	$mpfinib = SYMBOL("_kernel_mpfinib_table")$
  	$FOREACH mpfid MPF.ID_LIST$
  		$mpf = PEEK(mpfinib + offsetof_MPFINIB_mpf, sizeof_void_ptr)$
--- 177,186 ----
  $END$
  
  $ 
! $  固定長メモリプール領域の先頭番地のチェック
  $ 
  $IF CHECK_MPF_ALIGN || CHECK_MPF_NONNULL$
! $	// 固定長メモリプール領域の先頭番地のチェック
  	$mpfinib = SYMBOL("_kernel_mpfinib_table")$
  	$FOREACH mpfid MPF.ID_LIST$
  		$mpf = PEEK(mpfinib + offsetof_MPFINIB_mpf, sizeof_void_ptr)$
***************
*** 199,208 ****
  $END$
  
  $ 
! $  ͥ뤬դΰƬϤΥå
  $ 
  $IF CHECK_MB_ALIGN$
! $	// ͥ뤬դΰƬϤΥå
  	$kmm = PEEK(SYMBOL("_kernel_kmm"), sizeof_void_ptr)$
  	$IF CHECK_MB_ALIGN && (kmm & (CHECK_MB_ALIGN - 1)) != 0$
  		$ERROR KMM.TEXT_LINE[1]$E_PAR: 
--- 199,208 ----
  $END$
  
  $ 
! $  カーネルが割り付けるメモリ領域の先頭番地のチェック
  $ 
  $IF CHECK_MB_ALIGN$
! $	// カーネルが割り付けるメモリ領域の先頭番地のチェック
  	$kmm = PEEK(SYMBOL("_kernel_kmm"), sizeof_void_ptr)$
  	$IF CHECK_MB_ALIGN && (kmm & (CHECK_MB_ALIGN - 1)) != 0$
  		$ERROR KMM.TEXT_LINE[1]$E_PAR: 
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/kernel_impl.h ASPs/asp/extension/dcre/kernel/kernel_impl.h
*** 1.9.1/asp/extension/dcre/kernel/kernel_impl.h	Sat Nov 20 16:23:57 2010
--- ASPs/asp/extension/dcre/kernel/kernel_impl.h	Fri Dec  9 13:54:00 2022
***************
*** 8,213 ****
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: kernel_impl.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥɸإåե
   *
!  *  ΥإåեϡͥץΥե
!  *  ɬ󥯥롼ɤ٤ɸإåեǤ롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   */
  
  #ifndef TOPPERS_KERNEL_IMPL_H
  #define TOPPERS_KERNEL_IMPL_H
  
  /*
!  *  ͥ̾Υ͡
   */
  #include "kernel_rename.h"
  
  /*
!  *  ץꥱȶ̤Υإåե
   */
  #include <kernel.h>
  
  /*
!  *  ƥǽΤ
   */
  #include <t_syslog.h>
  
  /*
!  *  㥹ȤԤޥ
   */
  #ifndef CAST
  #define CAST(type, val)		((type)(val))
  #endif /* CAST */
  
  /*
!  *  åȰ¸
   */
  #include "target_config.h"
  
  /*
!  *  ٤Ƥδؿ򥳥ѥ뤹뤿
   */
  #ifdef ALLFUNC
  #include "allfunc.h"
  #endif /* ALLFUNC */
  
  /*
!  *  ӥåȥեɤǤ̵
   *
!  *  8ӥåȰʲΥӥåȥեɤǡ̵ͤݻ
!  *  Ѥ٤ǡANSI CǤϡӥåȥեɤΥǡˤ
!  *  intunsigned intʤᡤǥեȤunsigned
!  *  intȤƤ뤬åȤӥġ¸ǡunsigned charޤ
!  *  unsigned shortΨɤ礬롥
   */
  #ifndef BIT_FIELD_UINT
  #define BIT_FIELD_UINT		unsigned int
  #endif /* BIT_FIELD_UINT */
  
  /*
!  *  ӥåȥեɤǤΥ֡뷿
   *
!  *  1ӥåΥӥåȥեɤǡ֡ͤݻѤ٤
!  *  ǡǥեȤǤBIT_FIELD_UINTƱƤ뤬֡
!  *  ͤݻ뤳Ȥ뤿̤̾ΤȤƤ롥
   */
  #ifndef BIT_FIELD_BOOL
  #define BIT_FIELD_BOOL		BIT_FIELD_UINT
  #endif /* BIT_FIELD_BOOL */
  
  /*
!  *  ֥IDκǾͤ
   */
! #define TMIN_TSKID		1		/* IDκǾ */
! #define TMIN_SEMID		1		/* ޥեIDκǾ */
! #define TMIN_FLGID		1		/* ե饰IDκǾ */
! #define TMIN_DTQID		1		/* ǡ塼IDκǾ */
! #define TMIN_PDQID		1		/* ͥ٥ǡ塼IDκǾ */
! #define TMIN_MBXID		1		/* ᡼ܥåIDκǾ */
! #define TMIN_MPFID		1		/* ĹסIDκǾ */
! #define TMIN_CYCID		1		/* ϥɥIDκǾ */
! #define TMIN_ALMID		1		/* 顼ϥɥIDκǾ */
! #define TMIN_ISRID		1		/* ߥӥ롼IDκǾ */
  
  /*
!  *  ͥ٤ʳ
   */
  #define TNUM_TPRI		(TMAX_TPRI - TMIN_TPRI + 1)
  #define TNUM_MPRI		(TMAX_MPRI - TMIN_MPRI + 1)
  #define TNUM_INTPRI		(TMAX_INTPRI - TMIN_INTPRI + 1)
  
  /*
!  *  ͥǻѤ°
   */
! #define TA_NOEXS		((ATR)(-1))			/* ̤Ͽ */
  
  #ifndef TA_MEMALLOC
! #define TA_MEMALLOC		UINT_C(0x8000)		/* ΰ򥫡ͥǳ */
  #endif /* TA_MEMALLOC */
  #ifndef TA_MBALLOC
! #define TA_MBALLOC		UINT_C(0x4000)		/* ΰ򥫡ͥǳ */
  #endif /* TA_MBALLOC */
  
  /*
!  *  åΥ顼åޥΥǥեͤ
   */
  #ifndef TARGET_TSKATR
! #define TARGET_TSKATR		0U		/* åΥ° */
  #endif /* TARGET_TSKATR */
  
  #ifndef TARGET_ISRATR
! #define TARGET_ISRATR		0U		/* åISR° */
  #endif /* TARGET_ISRATR */
  
  /*
!  *  إåեʤ⥸塼δؿѿ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ƥ⥸塼νkernel_cfg.c
   */
  extern void	initialize_object(void);
  
  /*
!  *  롼μ¹ԡkernel_cfg.c
   */
  extern void	call_inirtn(void);
  
  /*
!  *  λ롼μ¹ԡkernel_cfg.c
   */
  extern void	call_terrtn(void);
  
  /*
!  *  󥿥ƥѤΥåΰkernel_cfg.c
   */
! extern const SIZE	istksz;		/* åΰΥʴݤ᤿͡ */
! extern STK_T *const	istk;		/* åΰƬ */
  #ifdef TOPPERS_ISTKPT
! extern STK_T *const	istkpt;		/* åݥ󥿤ν */
  #endif /* TOPPERS_ISTKPT */
  
  /*
!  *  ͥ뤬դΰkernel_cfg.c
   */
! extern const SIZE	kmmsz;		/* ͥ뤬դΰΥ */
! extern MB_T *const	kmm;		/* ͥ뤬դΰƬ */
  
  /*
!  *  ͥư֥ե饰startup.c
   */
  extern bool_t	kerflg;
  
  /*
!  *  ͥεưstartup.c
   */
  extern void	sta_ker(void);
  
  /*
!  *  ͥνλstartup.c
   */
  extern void	exit_kernel(void);
  
  /*
!  *  ͥγդΰδstartup.c
   */
  extern void initialize_kmm(void);
  extern void *kernel_malloc(SIZE size);
--- 8,213 ----
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: kernel_impl.h 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル内部向け標準ヘッダファイル
   *
!  *  このヘッダファイルは，カーネルを構成するプログラムのソースファイル
!  *  で必ずインクルードするべき標準ヘッダファイルである．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   */
  
  #ifndef TOPPERS_KERNEL_IMPL_H
  #define TOPPERS_KERNEL_IMPL_H
  
  /*
!  *  カーネルの内部識別名のリネーム
   */
  #include "kernel_rename.h"
  
  /*
!  *  アプリケーションと共通のヘッダファイル
   */
  #include <kernel.h>
  
  /*
!  *  システムログ機能のための定義
   */
  #include <t_syslog.h>
  
  /*
!  *  型キャストを行うマクロの定義
   */
  #ifndef CAST
  #define CAST(type, val)		((type)(val))
  #endif /* CAST */
  
  /*
!  *  ターゲット依存情報の定義
   */
  #include "target_config.h"
  
  /*
!  *  すべての関数をコンパイルするための定義
   */
  #ifdef ALLFUNC
  #include "allfunc.h"
  #endif /* ALLFUNC */
  
  /*
!  *  ビットフィールドでの符号無し整数型
   *
!  *  8ビット以下の幅のビットフィールドで，符号無し整数値を保持したい場合
!  *  に用いるべきデータ型．ANSI Cでは，ビットフィールドのデータ型には
!  *  intとunsigned intしか許されないため，デフォルトの定義はunsigned
!  *  intとしているが，ターゲットおよびツール依存で，unsigned charまたは
!  *  unsigned shortに定義した方が効率が良い場合がある．
   */
  #ifndef BIT_FIELD_UINT
  #define BIT_FIELD_UINT		unsigned int
  #endif /* BIT_FIELD_UINT */
  
  /*
!  *  ビットフィールドでのブール型
   *
!  *  1ビット幅のビットフィールドで，ブール値を保持したい場合に用いるべき
!  *  データ型．デフォルトではBIT_FIELD_UINTと同一に定義しているが，ブー
!  *  ル値を保持することを明示するために別の名称としている．
   */
  #ifndef BIT_FIELD_BOOL
  #define BIT_FIELD_BOOL		BIT_FIELD_UINT
  #endif /* BIT_FIELD_BOOL */
  
  /*
!  *  オブジェクトIDの最小値の定義
   */
! #define TMIN_TSKID		1		/* タスクIDの最小値 */
! #define TMIN_SEMID		1		/* セマフォIDの最小値 */
! #define TMIN_FLGID		1		/* フラグIDの最小値 */
! #define TMIN_DTQID		1		/* データキューIDの最小値 */
! #define TMIN_PDQID		1		/* 優先度データキューIDの最小値 */
! #define TMIN_MBXID		1		/* メールボックスIDの最小値 */
! #define TMIN_MPFID		1		/* 固定長メモリプールIDの最小値 */
! #define TMIN_CYCID		1		/* 周期ハンドラIDの最小値 */
! #define TMIN_ALMID		1		/* アラームハンドラIDの最小値 */
! #define TMIN_ISRID		1		/* 割込みサービスルーチンIDの最小値 */
  
  /*
!  *  優先度の段階数の定義
   */
  #define TNUM_TPRI		(TMAX_TPRI - TMIN_TPRI + 1)
  #define TNUM_MPRI		(TMAX_MPRI - TMIN_MPRI + 1)
  #define TNUM_INTPRI		(TMAX_INTPRI - TMIN_INTPRI + 1)
  
  /*
!  *  カーネル内部で使用する属性の定義
   */
! #define TA_NOEXS		((ATR)(-1))			/* 未登録状態 */
  
  #ifndef TA_MEMALLOC
! #define TA_MEMALLOC		UINT_C(0x8000)		/* メモリ領域をカーネルで確保 */
  #endif /* TA_MEMALLOC */
  #ifndef TA_MBALLOC
! #define TA_MBALLOC		UINT_C(0x4000)		/* 管理領域をカーネルで確保 */
  #endif /* TA_MBALLOC */
  
  /*
!  *  ターゲット定義のエラーチェックマクロのデフォルト値の定義
   */
  #ifndef TARGET_TSKATR
! #define TARGET_TSKATR		0U		/* ターゲット定義のタスク属性 */
  #endif /* TARGET_TSKATR */
  
  #ifndef TARGET_ISRATR
! #define TARGET_ISRATR		0U		/* ターゲット定義のISR属性 */
  #endif /* TARGET_ISRATR */
  
  /*
!  *  ヘッダファイルを持たないモジュールの関数・変数の宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  各モジュールの初期化（kernel_cfg.c）
   */
  extern void	initialize_object(void);
  
  /*
!  *  初期化ルーチンの実行（kernel_cfg.c）
   */
  extern void	call_inirtn(void);
  
  /*
!  *  終了処理ルーチンの実行（kernel_cfg.c）
   */
  extern void	call_terrtn(void);
  
  /*
!  *  非タスクコンテキスト用のスタック領域（kernel_cfg.c）
   */
! extern const SIZE	istksz;		/* スタック領域のサイズ（丸めた値） */
! extern STK_T *const	istk;		/* スタック領域の先頭番地 */
  #ifdef TOPPERS_ISTKPT
! extern STK_T *const	istkpt;		/* スタックポインタの初期値 */
  #endif /* TOPPERS_ISTKPT */
  
  /*
!  *  カーネルが割り付けるメモリ領域（kernel_cfg.c）
   */
! extern const SIZE	kmmsz;		/* カーネルが割り付けるメモリ領域のサイズ */
! extern MB_T *const	kmm;		/* カーネルが割り付けるメモリ領域の先頭番地 */
  
  /*
!  *  カーネル動作状態フラグ（startup.c）
   */
  extern bool_t	kerflg;
  
  /*
!  *  カーネルの起動（startup.c）
   */
  extern void	sta_ker(void);
  
  /*
!  *  カーネルの終了処理（startup.c）
   */
  extern void	exit_kernel(void);
  
  /*
!  *  カーネルの割り付けるメモリ領域の管理（startup.c）
   */
  extern void initialize_kmm(void);
  extern void *kernel_malloc(SIZE size);
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/mailbox.c ASPs/asp/extension/dcre/kernel/mailbox.c
*** 1.9.1/asp/extension/dcre/kernel/mailbox.c	Sun Apr 13 21:08:03 2014
--- ASPs/asp/extension/dcre/kernel/mailbox.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: mailbox.c 2634 2014-04-13 12:07:55Z ertl-hiro $
   */
  
  /*
!  *		᡼ܥåǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: mailbox.c 2634 2014-04-13 12:07:55Z ertl-hiro $
   */
  
  /*
!  *		メールボックス機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "mailbox.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACRE_MBX_ENTER
  #define LOG_ACRE_MBX_ENTER(pk_cmbx)
--- 51,57 ----
  #include "mailbox.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACRE_MBX_ENTER
  #define LOG_ACRE_MBX_ENTER(pk_cmbx)
***************
*** 118,130 ****
  #endif /* LOG_REF_MBX_LEAVE */
  
  /*
!  *  ᡼ܥåο
   */
  #define tnum_mbx	((uint_t)(tmax_mbxid - TMIN_MBXID + 1))
  #define tnum_smbx	((uint_t)(tmax_smbxid - TMIN_MBXID + 1))
  
  /*
!  *  ᡼ܥåID᡼ܥå֥åФΥޥ
   */
  #define INDEX_MBX(mbxid)	((uint_t)((mbxid) - TMIN_MBXID))
  #define get_mbxcb(mbxid)	(&(mbxcb_table[INDEX_MBX(mbxid)]))
--- 118,130 ----
  #endif /* LOG_REF_MBX_LEAVE */
  
  /*
!  *  メールボックスの数
   */
  #define tnum_mbx	((uint_t)(tmax_mbxid - TMIN_MBXID + 1))
  #define tnum_smbx	((uint_t)(tmax_smbxid - TMIN_MBXID + 1))
  
  /*
!  *  メールボックスIDからメールボックス管理ブロックを取り出すためのマクロ
   */
  #define INDEX_MBX(mbxid)	((uint_t)((mbxid) - TMIN_MBXID))
  #define get_mbxcb(mbxid)	(&(mbxcb_table[INDEX_MBX(mbxid)]))
***************
*** 132,143 ****
  #ifdef TOPPERS_mbxini
  
  /*
!  *  ѤƤʤ᡼ܥå֥åΥꥹ
   */
  QUEUE	free_mbxcb;
  
  /* 
!  *  ᡼ܥåǽν
   */
  void
  initialize_mailbox(void)
--- 132,143 ----
  #ifdef TOPPERS_mbxini
  
  /*
!  *  使用していないメールボックス管理ブロックのリスト
   */
  QUEUE	free_mbxcb;
  
  /* 
!  *  メールボックス機能の初期化
   */
  void
  initialize_mailbox(void)
***************
*** 165,176 ****
  #endif /* TOPPERS_mbxini */
  
  /*
!  *  åͥ٤μФ
   */
  #define	MSGPRI(pk_msg)	(((T_MSG_PRI *)(pk_msg))->msgpri)
  
  /*
!  *  ͥٽå塼ؤ
   */
  Inline void
  enqueue_msg_pri(T_MSG **ppk_prevmsg_next, T_MSG *pk_msg)
--- 165,176 ----
  #endif /* TOPPERS_mbxini */
  
  /*
!  *  メッセージ優先度の取出し
   */
  #define	MSGPRI(pk_msg)	(((T_MSG_PRI *)(pk_msg))->msgpri)
  
  /*
!  *  優先度順メッセージキューへの挿入
   */
  Inline void
  enqueue_msg_pri(T_MSG **ppk_prevmsg_next, T_MSG *pk_msg)
***************
*** 188,194 ****
  }
  
  /*
!  *  ᡼ܥå
   */
  #ifdef TOPPERS_acre_mbx
  
--- 188,194 ----
  }
  
  /*
!  *  メールボックスの生成
   */
  #ifdef TOPPERS_acre_mbx
  
***************
*** 229,235 ****
  #endif /* TOPPERS_acre_mbx */
  
  /*
!  *  ᡼ܥåκ
   */
  #ifdef TOPPERS_del_mbx
  
--- 229,235 ----
  #endif /* TOPPERS_acre_mbx */
  
  /*
!  *  メールボックスの削除
   */
  #ifdef TOPPERS_del_mbx
  
***************
*** 273,279 ****
  #endif /* TOPPERS_del_mbx */
  
  /*
!  *  ᡼ܥåؤ
   */
  #ifdef TOPPERS_snd_mbx
  
--- 273,279 ----
  #endif /* TOPPERS_del_mbx */
  
  /*
!  *  メールボックスへの送信
   */
  #ifdef TOPPERS_snd_mbx
  
***************
*** 331,337 ****
  #endif /* TOPPERS_snd_mbx */
  
  /*
!  *  ᡼ܥåμ
   */
  #ifdef TOPPERS_rcv_mbx
  
--- 331,337 ----
  #endif /* TOPPERS_snd_mbx */
  
  /*
!  *  メールボックスからの受信
   */
  #ifdef TOPPERS_rcv_mbx
  
***************
*** 375,381 ****
  #endif /* TOPPERS_rcv_mbx */
  
  /*
!  *  ᡼ܥåμʥݡ󥰡
   */
  #ifdef TOPPERS_prcv_mbx
  
--- 375,381 ----
  #endif /* TOPPERS_rcv_mbx */
  
  /*
!  *  メールボックスからの受信（ポーリング）
   */
  #ifdef TOPPERS_prcv_mbx
  
***************
*** 412,418 ****
  #endif /* TOPPERS_prcv_mbx */
  
  /*
!  *  ᡼ܥåμʥॢȤ
   */
  #ifdef TOPPERS_trcv_mbx
  
--- 412,418 ----
  #endif /* TOPPERS_prcv_mbx */
  
  /*
!  *  メールボックスからの受信（タイムアウトあり）
   */
  #ifdef TOPPERS_trcv_mbx
  
***************
*** 462,468 ****
  #endif /* TOPPERS_trcv_mbx */
  
  /*
!  *  ᡼ܥåκƽ
   */
  #ifdef TOPPERS_ini_mbx
  
--- 462,468 ----
  #endif /* TOPPERS_trcv_mbx */
  
  /*
!  *  メールボックスの再初期化
   */
  #ifdef TOPPERS_ini_mbx
  
***************
*** 500,506 ****
  #endif /* TOPPERS_ini_mbx */
  
  /*
!  *  ᡼ܥåξֻ
   */
  #ifdef TOPPERS_ref_mbx
  
--- 500,506 ----
  #endif /* TOPPERS_ini_mbx */
  
  /*
!  *  メールボックスの状態参照
   */
  #ifdef TOPPERS_ref_mbx
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/mailbox.h ASPs/asp/extension/dcre/kernel/mailbox.h
*** 1.9.1/asp/extension/dcre/kernel/mailbox.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/dcre/kernel/mailbox.h	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: mailbox.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		᡼ܥåǽ
   */
  
  #ifndef TOPPERS_MAILBOX_H
--- 8,47 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: mailbox.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		メールボックス機能
   */
  
  #ifndef TOPPERS_MAILBOX_H
***************
*** 50,126 ****
  #include "wait.h"
  
  /*
!  *  ᡼ܥå֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct mailbox_initialization_block {
! 	ATR			mbxatr;			/* ᡼ܥå° */
! 	PRI			maxmpri;		/* åͥ٤κ */
  } MBXINIB;
  
  /*
!  *  ᡼ܥå֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   *
!  *  å塼åͥٽξˤϡpk_lastϻȤ
!  *  ޤå塼ξpk_headNULLξˤˤ⡤
!  *  pk_last̵Ǥ롥
   */
  typedef struct mailbox_control_block {
! 	QUEUE		wait_queue;		/* ᡼ܥåԤ塼 */
! 	const MBXINIB *p_mbxinib;	/* ֥åؤΥݥ */
! 	T_MSG		*pk_head;		/* ƬΥå */
! 	T_MSG		*pk_last;		/* Υå */
  } MBXCB;
  
  /*
!  *  ᡼ܥåԤ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
   */
  typedef struct mailbox_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	MBXCB		*p_mbxcb;		/* ԤäƤ᡼ܥåδ֥å */
! 	T_MSG		*pk_msg;		/* å */
  } WINFO_MBX;
  
  /*
!  *  ѤƤʤ᡼ܥå֥åΥꥹ
   */
  extern QUEUE	free_mbxcb;
  
  /*
!  *  ᡼ܥåIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_mbxid;
  extern const ID	tmax_smbxid;
  
  /*
!  *  ᡼ܥå֥åΥꥢkernel_cfg.c
   */
  extern const MBXINIB	mbxinib_table[];
  extern MBXINIB			ambxinib_table[];
  
  /*
!  *  ᡼ܥå֥åΥꥢkernel_cfg.c
   */
  extern MBXCB	mbxcb_table[];
  
  /*
!  *  ᡼ܥå֥å᡼ܥåIDФΥޥ
   */
  #define	MBXID(p_mbxcb)	((ID)(((p_mbxcb) - mbxcb_table) + TMIN_MBXID))
  
  /*
!  *  ᡼ܥåǽν
   */
  extern void	initialize_mailbox(void);
  
--- 50,126 ----
  #include "wait.h"
  
  /*
!  *  メールボックス初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct mailbox_initialization_block {
! 	ATR			mbxatr;			/* メールボックス属性 */
! 	PRI			maxmpri;		/* メッセージ優先度の最大値 */
  } MBXINIB;
  
  /*
!  *  メールボックス管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   *
!  *  メッセージキューがメッセージの優先度順の場合には，pk_lastは使わな
!  *  い．また，メッセージキューが空の場合（pk_headがNULLの場合）にも，
!  *  pk_lastは無効である．
   */
  typedef struct mailbox_control_block {
! 	QUEUE		wait_queue;		/* メールボックス待ちキュー */
! 	const MBXINIB *p_mbxinib;	/* 初期化ブロックへのポインタ */
! 	T_MSG		*pk_head;		/* 先頭のメッセージ */
! 	T_MSG		*pk_last;		/* 末尾のメッセージ */
  } MBXCB;
  
  /*
!  *  メールボックス待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
   */
  typedef struct mailbox_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	MBXCB		*p_mbxcb;		/* 待っているメールボックスの管理ブロック */
! 	T_MSG		*pk_msg;		/* 受信したメッセージ */
  } WINFO_MBX;
  
  /*
!  *  使用していないメールボックス管理ブロックのリスト
   */
  extern QUEUE	free_mbxcb;
  
  /*
!  *  メールボックスIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_mbxid;
  extern const ID	tmax_smbxid;
  
  /*
!  *  メールボックス初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const MBXINIB	mbxinib_table[];
  extern MBXINIB			ambxinib_table[];
  
  /*
!  *  メールボックス管理ブロックのエリア（kernel_cfg.c）
   */
  extern MBXCB	mbxcb_table[];
  
  /*
!  *  メールボックス管理ブロックからメールボックスIDを取り出すためのマクロ
   */
  #define	MBXID(p_mbxcb)	((ID)(((p_mbxcb) - mbxcb_table) + TMIN_MBXID))
  
  /*
!  *  メールボックス機能の初期化
   */
  extern void	initialize_mailbox(void);
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/mempfix.c ASPs/asp/extension/dcre/kernel/mempfix.c
*** 1.9.1/asp/extension/dcre/kernel/mempfix.c	Mon Apr 21 02:57:41 2014
--- ASPs/asp/extension/dcre/kernel/mempfix.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: mempfix.c 2647 2014-04-20 17:57:40Z ertl-hiro $
   */
  
  /*
!  *		Ĺס뵡ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: mempfix.c 2647 2014-04-20 17:57:40Z ertl-hiro $
   */
  
  /*
!  *		固定長メモリプール機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "mempfix.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACRE_MPF_ENTER
  #define LOG_ACRE_MPF_ENTER(pk_cmpf)
--- 51,57 ----
  #include "mempfix.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACRE_MPF_ENTER
  #define LOG_ACRE_MPF_ENTER(pk_cmpf)
***************
*** 118,150 ****
  #endif /* LOG_REF_MPF_LEAVE */
  
  /*
!  *  Ĺסο
   */
  #define tnum_mpf	((uint_t)(tmax_mpfid - TMIN_MPFID + 1))
  #define tnum_smpf	((uint_t)(tmax_smpfid - TMIN_MPFID + 1))
  
  /*
!  *  ĹסIDĹס֥åФ
!  *  Υޥ
   */
  #define INDEX_MPF(mpfid)	((uint_t)((mpfid) - TMIN_MPFID))
  #define get_mpfcb(mpfid)	(&(mpfcb_table[INDEX_MPF(mpfid)]))
  
  /*
!  *  üʥǥåͤ
   */
! #define INDEX_NULL		(~0U)		/* ֥åꥹȤκǸ */
! #define INDEX_ALLOC		(~1U)		/* ƺѤߤΥ֥å */
  
  #ifdef TOPPERS_mpfini
  
  /*
!  *  ѤƤʤĹס֥åΥꥹ
   */
  QUEUE	free_mpfcb;
  
  /*
!  *  Ĺס뵡ǽν
   */
  void
  initialize_mempfix(void)
--- 118,150 ----
  #endif /* LOG_REF_MPF_LEAVE */
  
  /*
!  *  固定長メモリプールの数
   */
  #define tnum_mpf	((uint_t)(tmax_mpfid - TMIN_MPFID + 1))
  #define tnum_smpf	((uint_t)(tmax_smpfid - TMIN_MPFID + 1))
  
  /*
!  *  固定長メモリプールIDから固定長メモリプール管理ブロックを取り出すた
!  *  めのマクロ
   */
  #define INDEX_MPF(mpfid)	((uint_t)((mpfid) - TMIN_MPFID))
  #define get_mpfcb(mpfid)	(&(mpfcb_table[INDEX_MPF(mpfid)]))
  
  /*
!  *  特殊なインデックス値の定義
   */
! #define INDEX_NULL		(~0U)		/* 空きブロックリストの最後 */
! #define INDEX_ALLOC		(~1U)		/* 割当て済みのブロック */
  
  #ifdef TOPPERS_mpfini
  
  /*
!  *  使用していない固定長メモリプール管理ブロックのリスト
   */
  QUEUE	free_mpfcb;
  
  /*
!  *  固定長メモリプール機能の初期化
   */
  void
  initialize_mempfix(void)
***************
*** 174,180 ****
  #endif /* TOPPERS_mpfini */
  
  /*
!  *  Ĺס뤫֥å
   */
  #ifdef TOPPERS_mpfget
  
--- 174,180 ----
  #endif /* TOPPERS_mpfini */
  
  /*
!  *  固定長メモリプールからブロックを獲得
   */
  #ifdef TOPPERS_mpfget
  
***************
*** 200,206 ****
  #endif /* TOPPERS_mpfget */
  
  /*
!  *  Ĺס
   */
  #ifdef TOPPERS_acre_mpf
  
--- 200,206 ----
  #endif /* TOPPERS_mpfget */
  
  /*
!  *  固定長メモリプールの生成
   */
  #ifdef TOPPERS_acre_mpf
  
***************
*** 279,285 ****
  #endif /* TOPPERS_acre_mpf */
  
  /*
!  *  Ĺסκ
   */
  #ifdef TOPPERS_del_mpf
  
--- 279,285 ----
  #endif /* TOPPERS_acre_mpf */
  
  /*
!  *  固定長メモリプールの削除
   */
  #ifdef TOPPERS_del_mpf
  
***************
*** 329,335 ****
  #endif /* TOPPERS_del_mpf */
  
  /*
!  *  Ĺ֥åγ
   */
  #ifdef TOPPERS_get_mpf
  
--- 329,335 ----
  #endif /* TOPPERS_del_mpf */
  
  /*
!  *  固定長メモリブロックの獲得
   */
  #ifdef TOPPERS_get_mpf
  
***************
*** 372,378 ****
  #endif /* TOPPERS_get_mpf */
  
  /*
!  *  Ĺ֥åγʥݡ󥰡
   */
  #ifdef TOPPERS_pget_mpf
  
--- 372,378 ----
  #endif /* TOPPERS_get_mpf */
  
  /*
!  *  固定長メモリブロックの獲得（ポーリング）
   */
  #ifdef TOPPERS_pget_mpf
  
***************
*** 408,414 ****
  #endif /* TOPPERS_pget_mpf */
  
  /*
!  *  Ĺ֥åγʥॢȤ
   */
  #ifdef TOPPERS_tget_mpf
  
--- 408,414 ----
  #endif /* TOPPERS_pget_mpf */
  
  /*
!  *  固定長メモリブロックの獲得（タイムアウトあり）
   */
  #ifdef TOPPERS_tget_mpf
  
***************
*** 457,463 ****
  #endif /* TOPPERS_tget_mpf */
  
  /*
!  *  Ĺ֥åֵ
   */
  #ifdef TOPPERS_rel_mpf
  
--- 457,463 ----
  #endif /* TOPPERS_tget_mpf */
  
  /*
!  *  固定長メモリブロックの返却
   */
  #ifdef TOPPERS_rel_mpf
  
***************
*** 514,520 ****
  #endif /* TOPPERS_rel_mpf */
  
  /*
!  *  Ĺסκƽ
   */
  #ifdef TOPPERS_ini_mpf
  
--- 514,520 ----
  #endif /* TOPPERS_rel_mpf */
  
  /*
!  *  固定長メモリプールの再初期化
   */
  #ifdef TOPPERS_ini_mpf
  
***************
*** 554,560 ****
  #endif /* TOPPERS_ini_mpf */
  
  /*
!  *  Ĺסξֻ
   */
  #ifdef TOPPERS_ref_mpf
  
--- 554,560 ----
  #endif /* TOPPERS_ini_mpf */
  
  /*
!  *  固定長メモリプールの状態参照
   */
  #ifdef TOPPERS_ref_mpf
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/mempfix.h ASPs/asp/extension/dcre/kernel/mempfix.h
*** 1.9.1/asp/extension/dcre/kernel/mempfix.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/dcre/kernel/mempfix.h	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: mempfix.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		Ĺס뵡ǽ
   */
  
  #ifndef TOPPERS_MEMPFIX_H
--- 8,47 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: mempfix.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		固定長メモリプール機能
   */
  
  #ifndef TOPPERS_MEMPFIX_H
***************
*** 50,143 ****
  #include "wait.h"
  
  /*
!  *  Ĺ֥å֥å
   *
!  *  nextեɤˤϡ֥åƺѤߤξINDEX_ALLOC
!  *  ̤Ƥξϼ̤ƥ֥åΥǥåֹǼ롥
!  *  Ǹ̤ƥ֥åξˤϡINDEX_NULLǼ롥
   */
  typedef struct fixed_memoryblock_management_block {
! 	uint_t		next;			/* ̤ƥ֥å */
  } MPFMB;
  
  /*
!  *  Ĺס֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct fixed_memorypool_initialization_block {
! 	ATR			mpfatr;			/* Ĺס° */
! 	uint_t		blkcnt;			/* ֥å */
! 	uint_t		blksz;			/* ֥åΥʴݤ᤿͡ */
! 	void		*mpf;			/* ĹסΰƬ */
! 	MPFMB		*p_mpfmb;		/* ĹסΰƬ */
  } MPFINIB;
  
  /*
!  *  Ĺס֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct fixed_memorypool_control_block {
! 	QUEUE		wait_queue;		/* ĹסԤ塼 */
! 	const MPFINIB *p_mpfinib;	/* ֥åؤΥݥ */
! 	uint_t		fblkcnt;		/* ̤ƥ֥å */
! 	uint_t		unused;			/* ̤ѥ֥åƬ */
! 	uint_t		freelist;		/* ̤ƥ֥åΥꥹ */
  } MPFCB;
  
  /*
!  *  ĹסԤ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
   */
  typedef struct fixed_memorypool_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	MPFCB		*p_mpfcb;		/* ԤäƤĹסδ֥å*/
! 	void		*blk;			/* ֥å */
  } WINFO_MPF;
  
  /*
!  *  ѤƤʤĹס֥åΥꥹ
   */
  extern QUEUE	free_mpfcb;
  
  /*
!  *  ĹסIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_mpfid;
  extern const ID	tmax_smpfid;
  
  /*
!  *  Ĺס֥åΥꥢkernel_cfg.c
   */
  extern const MPFINIB	mpfinib_table[];
  extern MPFINIB			ampfinib_table[];
  
  /*
!  *  Ĺס֥åΥꥢkernel_cfg.c
   */
  extern MPFCB	mpfcb_table[];
  
  /*
!  *  Ĺס֥åĹסIDФ
!  *  Υޥ
   */
  #define	MPFID(p_mpfcb)	((ID)(((p_mpfcb) - mpfcb_table) + TMIN_MPFID))
  
  /*
!  *  Ĺס뵡ǽν
   */
  extern void	initialize_mempfix(void);
  
  /*
!  *  Ĺס뤫֥å
   */
  extern void	get_mpf_block(MPFCB *p_mpfcb, void **p_blk);
  
--- 50,143 ----
  #include "wait.h"
  
  /*
!  *  固定長メモリブロック管理ブロック
   *
!  *  nextフィールドには，メモリブロックが割当て済みの場合はINDEX_ALLOCを，
!  *  未割当ての場合は次の未割当てブロックのインデックス番号を格納する．
!  *  最後の未割当てブロックの場合には，INDEX_NULLを格納する．
   */
  typedef struct fixed_memoryblock_management_block {
! 	uint_t		next;			/* 次の未割当てブロック */
  } MPFMB;
  
  /*
!  *  固定長メモリプール初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct fixed_memorypool_initialization_block {
! 	ATR			mpfatr;			/* 固定長メモリプール属性 */
! 	uint_t		blkcnt;			/* メモリブロック数 */
! 	uint_t		blksz;			/* メモリブロックのサイズ（丸めた値） */
! 	void		*mpf;			/* 固定長メモリプール領域の先頭番地 */
! 	MPFMB		*p_mpfmb;		/* 固定長メモリプール管理領域の先頭番地 */
  } MPFINIB;
  
  /*
!  *  固定長メモリプール管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct fixed_memorypool_control_block {
! 	QUEUE		wait_queue;		/* 固定長メモリプール待ちキュー */
! 	const MPFINIB *p_mpfinib;	/* 初期化ブロックへのポインタ */
! 	uint_t		fblkcnt;		/* 未割当てブロック数 */
! 	uint_t		unused;			/* 未使用ブロックの先頭 */
! 	uint_t		freelist;		/* 未割当てブロックのリスト */
  } MPFCB;
  
  /*
!  *  固定長メモリプール待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
   */
  typedef struct fixed_memorypool_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	MPFCB		*p_mpfcb;		/* 待っている固定長メモリプールの管理ブロック*/
! 	void		*blk;			/* 獲得したメモリブロック */
  } WINFO_MPF;
  
  /*
!  *  使用していない固定長メモリプール管理ブロックのリスト
   */
  extern QUEUE	free_mpfcb;
  
  /*
!  *  固定長メモリプールIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_mpfid;
  extern const ID	tmax_smpfid;
  
  /*
!  *  固定長メモリプール初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const MPFINIB	mpfinib_table[];
  extern MPFINIB			ampfinib_table[];
  
  /*
!  *  固定長メモリプール管理ブロックのエリア（kernel_cfg.c）
   */
  extern MPFCB	mpfcb_table[];
  
  /*
!  *  固定長メモリプール管理ブロックから固定長メモリプールIDを取り出すた
!  *  めのマクロ
   */
  #define	MPFID(p_mpfcb)	((ID)(((p_mpfcb) - mpfcb_table) + TMIN_MPFID))
  
  /*
!  *  固定長メモリプール機能の初期化
   */
  extern void	initialize_mempfix(void);
  
  /*
!  *  固定長メモリプールからブロックを獲得
   */
  extern void	get_mpf_block(MPFCB *p_mpfcb, void **p_blk);
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/pridataq.c ASPs/asp/extension/dcre/kernel/pridataq.c
*** 1.9.1/asp/extension/dcre/kernel/pridataq.c	Thu Apr 17 08:04:29 2014
--- ASPs/asp/extension/dcre/kernel/pridataq.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: pridataq.c 2639 2014-04-16 23:04:23Z ertl-hiro $
   */
  
  /*
!  *		ͥ٥ǡ塼ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: pridataq.c 2639 2014-04-16 23:04:23Z ertl-hiro $
   */
  
  /*
!  *		優先度データキュー機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "pridataq.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACRE_PDQ_ENTER
  #define LOG_ACRE_PDQ_ENTER(pk_cpdq)
--- 51,57 ----
  #include "pridataq.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACRE_PDQ_ENTER
  #define LOG_ACRE_PDQ_ENTER(pk_cpdq)
***************
*** 142,155 ****
  #endif /* LOG_REF_PDQ_LEAVE */
  
  /*
!  *  ͥ٥ǡ塼ο
   */
  #define tnum_pdq	((uint_t)(tmax_pdqid - TMIN_PDQID + 1))
  #define tnum_spdq	((uint_t)(tmax_spdqid - TMIN_PDQID + 1))
  
  /*
!  *  ͥ٥ǡ塼IDͥ٥ǡ塼֥åФ
!  *  Υޥ
   */
  #define INDEX_PDQ(pdqid)	((uint_t)((pdqid) - TMIN_PDQID))
  #define get_pdqcb(pdqid)	(&(pdqcb_table[INDEX_PDQ(pdqid)]))
--- 142,155 ----
  #endif /* LOG_REF_PDQ_LEAVE */
  
  /*
!  *  優先度データキューの数
   */
  #define tnum_pdq	((uint_t)(tmax_pdqid - TMIN_PDQID + 1))
  #define tnum_spdq	((uint_t)(tmax_spdqid - TMIN_PDQID + 1))
  
  /*
!  *  優先度データキューIDから優先度データキュー管理ブロックを取り出すた
!  *  めのマクロ
   */
  #define INDEX_PDQ(pdqid)	((uint_t)((pdqid) - TMIN_PDQID))
  #define get_pdqcb(pdqid)	(&(pdqcb_table[INDEX_PDQ(pdqid)]))
***************
*** 157,168 ****
  #ifdef TOPPERS_pdqini
  
  /*
!  *  ѤƤʤͥ٥ǡ塼֥åΥꥹ
   */
  QUEUE	free_pdqcb;
  
  /*
!  *  ͥ٥ǡ塼ǽν
   */
  void
  initialize_pridataq(void)
--- 157,168 ----
  #ifdef TOPPERS_pdqini
  
  /*
!  *  使用していない優先度データキュー管理ブロックのリスト
   */
  QUEUE	free_pdqcb;
  
  /*
!  *  優先度データキュー機能の初期化
   */
  void
  initialize_pridataq(void)
***************
*** 194,200 ****
  #endif /* TOPPERS_pdqini */
  
  /*
!  *  ͥ٥ǡ塼ΰؤΥǡγǼ
   */
  #ifdef TOPPERS_pdqenq
  
--- 194,200 ----
  #endif /* TOPPERS_pdqini */
  
  /*
!  *  優先度データキュー管理領域へのデータの格納
   */
  #ifdef TOPPERS_pdqenq
  
***************
*** 231,237 ****
  #endif /* TOPPERS_pdqenq */
  
  /*
!  *  ͥ٥ǡ塼ΰ褫ΥǡμФ
   */
  #ifdef TOPPERS_pdqdeq
  
--- 231,237 ----
  #endif /* TOPPERS_pdqenq */
  
  /*
!  *  優先度データキュー管理領域からのデータの取出し
   */
  #ifdef TOPPERS_pdqdeq
  
***************
*** 254,260 ****
  #endif /* TOPPERS_pdqdeq */
  
  /*
!  *  ͥ٥ǡ塼ؤΥǡ
   */
  #ifdef TOPPERS_pdqsnd
  
--- 254,260 ----
  #endif /* TOPPERS_pdqdeq */
  
  /*
!  *  優先度データキューへのデータ送信
   */
  #ifdef TOPPERS_pdqsnd
  
***************
*** 283,289 ****
  #endif /* TOPPERS_pdqsnd */
  
  /*
!  *  ͥ٥ǡ塼Υǡ
   */
  #ifdef TOPPERS_pdqrcv
  
--- 283,289 ----
  #endif /* TOPPERS_pdqsnd */
  
  /*
!  *  優先度データキューからのデータ受信
   */
  #ifdef TOPPERS_pdqrcv
  
***************
*** 324,330 ****
  #endif /* TOPPERS_pdqrcv */
  
  /*
!  *  ͥ٥ǡ塼
   */
  #ifdef TOPPERS_acre_pdq
  
--- 324,330 ----
  #endif /* TOPPERS_pdqrcv */
  
  /*
!  *  優先度データキューの生成
   */
  #ifdef TOPPERS_acre_pdq
  
***************
*** 386,392 ****
  #endif /* TOPPERS_acre_pdq */
  
  /*
!  *  ͥ٥ǡ塼κ
   */
  #ifdef TOPPERS_del_pdq
  
--- 386,392 ----
  #endif /* TOPPERS_acre_pdq */
  
  /*
!  *  優先度データキューの削除
   */
  #ifdef TOPPERS_del_pdq
  
***************
*** 436,442 ****
  #endif /* TOPPERS_del_pdq */
  
  /*
!  *  ͥ٥ǡ塼ؤ
   */
  #ifdef TOPPERS_snd_pdq
  
--- 436,442 ----
  #endif /* TOPPERS_del_pdq */
  
  /*
!  *  優先度データキューへの送信
   */
  #ifdef TOPPERS_snd_pdq
  
***************
*** 485,491 ****
  #endif /* TOPPERS_snd_pdq */
  
  /*
!  *  ͥ٥ǡ塼ؤʥݡ󥰡
   */
  #ifdef TOPPERS_psnd_pdq
  
--- 485,491 ----
  #endif /* TOPPERS_snd_pdq */
  
  /*
!  *  優先度データキューへの送信（ポーリング）
   */
  #ifdef TOPPERS_psnd_pdq
  
***************
*** 528,534 ****
  #endif /* TOPPERS_psnd_pdq */
  
  /*
!  *  ͥ٥ǡ塼ؤʥݡ󥰡󥿥ƥѡ
   */
  #ifdef TOPPERS_ipsnd_pdq
  
--- 528,534 ----
  #endif /* TOPPERS_psnd_pdq */
  
  /*
!  *  優先度データキューへの送信（ポーリング，非タスクコンテキスト用）
   */
  #ifdef TOPPERS_ipsnd_pdq
  
***************
*** 571,577 ****
  #endif /* TOPPERS_ipsnd_pdq */
  
  /*
!  *  ͥ٥ǡ塼ؤʥॢȤ
   */
  #ifdef TOPPERS_tsnd_pdq
  
--- 571,577 ----
  #endif /* TOPPERS_ipsnd_pdq */
  
  /*
!  *  優先度データキューへの送信（タイムアウトあり）
   */
  #ifdef TOPPERS_tsnd_pdq
  
***************
*** 626,632 ****
  #endif /* TOPPERS_tsnd_pdq */
  
  /*
!  *  ͥ٥ǡ塼μ
   */
  #ifdef TOPPERS_rcv_pdq
  
--- 626,632 ----
  #endif /* TOPPERS_tsnd_pdq */
  
  /*
!  *  優先度データキューからの受信
   */
  #ifdef TOPPERS_rcv_pdq
  
***************
*** 676,682 ****
  #endif /* TOPPERS_rcv_pdq */
  
  /*
!  *  ͥ٥ǡ塼μʥݡ󥰡
   */
  #ifdef TOPPERS_prcv_pdq
  
--- 676,682 ----
  #endif /* TOPPERS_rcv_pdq */
  
  /*
!  *  優先度データキューからの受信（ポーリング）
   */
  #ifdef TOPPERS_prcv_pdq
  
***************
*** 715,721 ****
  #endif /* TOPPERS_prcv_pdq */
  
  /*
!  *  ͥ٥ǡ塼μʥॢȤ
   */
  #ifdef TOPPERS_trcv_pdq
  
--- 715,721 ----
  #endif /* TOPPERS_prcv_pdq */
  
  /*
!  *  優先度データキューからの受信（タイムアウトあり）
   */
  #ifdef TOPPERS_trcv_pdq
  
***************
*** 770,776 ****
  #endif /* TOPPERS_trcv_pdq */
  
  /*
!  *  ͥ٥ǡ塼κƽ
   */
  #ifdef TOPPERS_ini_pdq
  
--- 770,776 ----
  #endif /* TOPPERS_trcv_pdq */
  
  /*
!  *  優先度データキューの再初期化
   */
  #ifdef TOPPERS_ini_pdq
  
***************
*** 814,820 ****
  #endif /* TOPPERS_ini_pdq */
  
  /*
!  *  ͥ٥ǡ塼ξֻ
   */
  #ifdef TOPPERS_ref_pdq
  
--- 814,820 ----
  #endif /* TOPPERS_ini_pdq */
  
  /*
!  *  優先度データキューの状態参照
   */
  #ifdef TOPPERS_ref_pdq
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/pridataq.h ASPs/asp/extension/dcre/kernel/pridataq.h
*** 1.9.1/asp/extension/dcre/kernel/pridataq.h	Wed Jun 12 20:57:00 2013
--- ASPs/asp/extension/dcre/kernel/pridataq.h	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: pridataq.h 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		ͥ٥ǡ塼ǽ
   */
  
  #ifndef TOPPERS_PRIDATAQ_H
--- 8,47 ----
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: pridataq.h 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		優先度データキュー機能
   */
  
  #ifndef TOPPERS_PRIDATAQ_H
***************
*** 50,163 ****
  #include "wait.h"
  
  /*
!  *  ͥ٥ǡ֥å
   */
  typedef struct pridata_management_block PDQMB;
  
  struct pridata_management_block {
! 	PDQMB		*p_next;		/* Υǡ */
! 	intptr_t	data;			/* ǡ */
! 	PRI			datapri;		/* ǡͥ */
  };
  
  /*
!  *  ͥ٥ǡ塼֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct pridataq_initialization_block {
! 	ATR			pdqatr;			/* ͥ٥ǡ塼° */
! 	uint_t		pdqcnt;			/* ͥ٥ǡ塼 */
! 	PRI			maxdpri;		/* ǡͥ٤κ */
! 	PDQMB		*p_pdqmb;		/* ͥ٥ǡ塼ΰƬ */
  } PDQINIB;
  
  /*
!  *  ͥ٥ǡ塼֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct pridataq_control_block {
! 	QUEUE		swait_queue;	/* ͥ٥ǡ塼Ԥ塼 */
! 	const PDQINIB *p_pdqinib;	/* ֥åؤΥݥ */
! 	QUEUE		rwait_queue;	/* ͥ٥ǡ塼Ԥ塼 */
! 	uint_t		count;			/* ͥ٥ǡ塼Υǡο */
! 	PDQMB		*p_head;		/* ǽΥǡ */
! 	uint_t		unused;			/* ̤ѥǡ֥åƬ */
! 	PDQMB		*p_freelist;	/* ̤ƥǡ֥åΥꥹ */
  } PDQCB;
  
  /*
!  *  ͥ٥ǡ塼Ԥ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
!  *  ͥ٥ǡ塼ؤԤͥ٥ǡ塼μԤǡ
!  *  ƱԤ֥åȤ
   */
  typedef struct pridataq_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	PDQCB		*p_pdqcb;		/* ԤäƤͥ٥ǡ塼δ֥å*/
! 	intptr_t	data;			/* ǡ */
! 	PRI			datapri;		/* ǡͥ */
  } WINFO_PDQ;
  
  /*
!  *  ѤƤʤͥ٥ǡ塼֥åΥꥹ
   */
  extern QUEUE	free_pdqcb;
  
  /*
!  *  ͥ٥ǡ塼IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_pdqid;
  extern const ID	tmax_spdqid;
  
  /*
!  *  ͥ٥ǡ塼֥åΥꥢkernel_cfg.c
   */
  extern const PDQINIB	pdqinib_table[];
  extern PDQINIB			apdqinib_table[];
  
  /*
!  *  ͥ٥ǡ塼֥åΥꥢkernel_cfg.c
   */
  extern PDQCB	pdqcb_table[];
  
  /*
!  *  ͥ٥ǡ塼֥åͥ٥ǡ塼IDФ
!  *  Υޥ
   */
  #define	PDQID(p_pdqcb)	((ID)(((p_pdqcb) - pdqcb_table) + TMIN_PDQID))
  
  /*
!  *  ͥ٥ǡ塼ǽν
   */
  extern void	initialize_pridataq(void);
  
  /*
!  *  ͥ٥ǡ塼ΰؤΥǡγǼ
   */
  extern void	enqueue_pridata(PDQCB *p_pdqcb, intptr_t data, PRI datapri);
  
  /*
!  *  ͥ٥ǡ塼ΰ褫ΥǡμФ
   */
  extern void	dequeue_pridata(PDQCB *p_pdqcb, intptr_t *p_data, PRI *p_datapri);
  
  /*
!  *  ͥ٥ǡ塼ؤΥǡ
   */
  extern bool_t	send_pridata(PDQCB *p_pdqcb, intptr_t data,
  											PRI datapri, bool_t *p_dspreq);
  
  /*
!  *  ͥ٥ǡ塼Υǡ
   */
  extern bool_t	receive_pridata(PDQCB *p_pdqcb, intptr_t *p_data,
  											PRI *p_datapri, bool_t *p_dspreq);
--- 50,163 ----
  #include "wait.h"
  
  /*
!  *  優先度データ管理ブロック
   */
  typedef struct pridata_management_block PDQMB;
  
  struct pridata_management_block {
! 	PDQMB		*p_next;		/* 次のデータ */
! 	intptr_t	data;			/* データ本体 */
! 	PRI			datapri;		/* データ優先度 */
  };
  
  /*
!  *  優先度データキュー初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct pridataq_initialization_block {
! 	ATR			pdqatr;			/* 優先度データキュー属性 */
! 	uint_t		pdqcnt;			/* 優先度データキューの容量 */
! 	PRI			maxdpri;		/* データ優先度の最大値 */
! 	PDQMB		*p_pdqmb;		/* 優先度データキュー管理領域の先頭番地 */
  } PDQINIB;
  
  /*
!  *  優先度データキュー管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct pridataq_control_block {
! 	QUEUE		swait_queue;	/* 優先度データキュー送信待ちキュー */
! 	const PDQINIB *p_pdqinib;	/* 初期化ブロックへのポインタ */
! 	QUEUE		rwait_queue;	/* 優先度データキュー受信待ちキュー */
! 	uint_t		count;			/* 優先度データキュー中のデータの数 */
! 	PDQMB		*p_head;		/* 最初のデータ */
! 	uint_t		unused;			/* 未使用データ管理ブロックの先頭 */
! 	PDQMB		*p_freelist;	/* 未割当てデータ管理ブロックのリスト */
  } PDQCB;
  
  /*
!  *  優先度データキュー待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
!  *  優先度データキューへの送信待ちと優先度データキューからの受信待ちで，
!  *  同じ待ち情報ブロックを使う．
   */
  typedef struct pridataq_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	PDQCB		*p_pdqcb;		/* 待っている優先度データキューの管理ブロック*/
! 	intptr_t	data;			/* 送受信データ */
! 	PRI			datapri;		/* データ優先度 */
  } WINFO_PDQ;
  
  /*
!  *  使用していない優先度データキュー管理ブロックのリスト
   */
  extern QUEUE	free_pdqcb;
  
  /*
!  *  優先度データキューIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_pdqid;
  extern const ID	tmax_spdqid;
  
  /*
!  *  優先度データキュー初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const PDQINIB	pdqinib_table[];
  extern PDQINIB			apdqinib_table[];
  
  /*
!  *  優先度データキュー管理ブロックのエリア（kernel_cfg.c）
   */
  extern PDQCB	pdqcb_table[];
  
  /*
!  *  優先度データキュー管理ブロックから優先度データキューIDを取り出すた
!  *  めのマクロ
   */
  #define	PDQID(p_pdqcb)	((ID)(((p_pdqcb) - pdqcb_table) + TMIN_PDQID))
  
  /*
!  *  優先度データキュー機能の初期化
   */
  extern void	initialize_pridataq(void);
  
  /*
!  *  優先度データキュー管理領域へのデータの格納
   */
  extern void	enqueue_pridata(PDQCB *p_pdqcb, intptr_t data, PRI datapri);
  
  /*
!  *  優先度データキュー管理領域からのデータの取出し
   */
  extern void	dequeue_pridata(PDQCB *p_pdqcb, intptr_t *p_data, PRI *p_datapri);
  
  /*
!  *  優先度データキューへのデータ送信
   */
  extern bool_t	send_pridata(PDQCB *p_pdqcb, intptr_t data,
  											PRI datapri, bool_t *p_dspreq);
  
  /*
!  *  優先度データキューからのデータ受信
   */
  extern bool_t	receive_pridata(PDQCB *p_pdqcb, intptr_t *p_data,
  											PRI *p_datapri, bool_t *p_dspreq);
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/semaphore.c ASPs/asp/extension/dcre/kernel/semaphore.c
*** 1.9.1/asp/extension/dcre/kernel/semaphore.c	Thu Sep  6 12:13:08 2012
--- ASPs/asp/extension/dcre/kernel/semaphore.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: semaphore.c 2415 2012-09-06 03:13:06Z ertl-hiro $
   */
  
  /*
!  *		ޥեǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: semaphore.c 2415 2012-09-06 03:13:06Z ertl-hiro $
   */
  
  /*
!  *		セマフォ機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "semaphore.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACRE_SEM_ENTER
  #define LOG_ACRE_SEM_ENTER(pk_csem)
--- 51,57 ----
  #include "semaphore.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACRE_SEM_ENTER
  #define LOG_ACRE_SEM_ENTER(pk_csem)
***************
*** 126,138 ****
  #endif /* LOG_REF_SEM_LEAVE */
  
  /*
!  *  ޥեο
   */
  #define tnum_sem	((uint_t)(tmax_semid - TMIN_SEMID + 1))
  #define tnum_ssem	((uint_t)(tmax_ssemid - TMIN_SEMID + 1))
  
  /*
!  *  ޥեID饻ޥե֥åФΥޥ
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
--- 126,138 ----
  #endif /* LOG_REF_SEM_LEAVE */
  
  /*
!  *  セマフォの数
   */
  #define tnum_sem	((uint_t)(tmax_semid - TMIN_SEMID + 1))
  #define tnum_ssem	((uint_t)(tmax_ssemid - TMIN_SEMID + 1))
  
  /*
!  *  セマフォIDからセマフォ管理ブロックを取り出すためのマクロ
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
***************
*** 140,151 ****
  #ifdef TOPPERS_semini
  
  /*
!  *  ѤƤʤޥե֥åΥꥹ
   */
  QUEUE	free_semcb;
  
  /* 
!  *  ޥեǽν
   */
  void
  initialize_semaphore(void)
--- 140,151 ----
  #ifdef TOPPERS_semini
  
  /*
!  *  使用していないセマフォ管理ブロックのリスト
   */
  QUEUE	free_semcb;
  
  /* 
!  *  セマフォ機能の初期化
   */
  void
  initialize_semaphore(void)
***************
*** 173,179 ****
  #endif /* TOPPERS_semini */
  
  /*
!  *  ޥե
   */
  #ifdef TOPPERS_acre_sem
  
--- 173,179 ----
  #endif /* TOPPERS_semini */
  
  /*
!  *  セマフォの生成
   */
  #ifdef TOPPERS_acre_sem
  
***************
*** 215,221 ****
  #endif /* TOPPERS_acre_sem */
  
  /*
!  *  ޥեκ
   */
  #ifdef TOPPERS_del_sem
  
--- 215,221 ----
  #endif /* TOPPERS_acre_sem */
  
  /*
!  *  セマフォの削除
   */
  #ifdef TOPPERS_del_sem
  
***************
*** 259,265 ****
  #endif /* TOPPERS_del_sem */
  
  /*
!  *  ޥե񸻤ֵ
   */
  #ifdef TOPPERS_sig_sem
  
--- 259,265 ----
  #endif /* TOPPERS_del_sem */
  
  /*
!  *  セマフォ資源の返却
   */
  #ifdef TOPPERS_sig_sem
  
***************
*** 303,309 ****
  #endif /* TOPPERS_sig_sem */
  
  /*
!  *  ޥե񸻤ֵѡ󥿥ƥѡ
   */
  #ifdef TOPPERS_isig_sem
  
--- 303,309 ----
  #endif /* TOPPERS_sig_sem */
  
  /*
!  *  セマフォ資源の返却（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_isig_sem
  
***************
*** 347,353 ****
  #endif /* TOPPERS_isig_sem */
  
  /*
!  *  ޥե񸻤γ
   */
  #ifdef TOPPERS_wai_sem
  
--- 347,353 ----
  #endif /* TOPPERS_isig_sem */
  
  /*
!  *  セマフォ資源の獲得
   */
  #ifdef TOPPERS_wai_sem
  
***************
*** 387,393 ****
  #endif /* TOPPERS_wai_sem */
  
  /*
!  *  ޥե񸻤γʥݡ󥰡
   */
  #ifdef TOPPERS_pol_sem
  
--- 387,393 ----
  #endif /* TOPPERS_wai_sem */
  
  /*
!  *  セマフォ資源の獲得（ポーリング）
   */
  #ifdef TOPPERS_pol_sem
  
***************
*** 423,429 ****
  #endif /* TOPPERS_pol_sem */
  
  /*
!  *  ޥե񸻤γʥॢȤ
   */
  #ifdef TOPPERS_twai_sem
  
--- 423,429 ----
  #endif /* TOPPERS_pol_sem */
  
  /*
!  *  セマフォ資源の獲得（タイムアウトあり）
   */
  #ifdef TOPPERS_twai_sem
  
***************
*** 469,475 ****
  #endif /* TOPPERS_twai_sem */
  
  /*
!  *  ޥեκƽ
   */
  #ifdef TOPPERS_ini_sem
  
--- 469,475 ----
  #endif /* TOPPERS_twai_sem */
  
  /*
!  *  セマフォの再初期化
   */
  #ifdef TOPPERS_ini_sem
  
***************
*** 507,513 ****
  #endif /* TOPPERS_ini_sem */
  
  /*
!  *  ޥեξֻ
   */
  #ifdef TOPPERS_ref_sem
  
--- 507,513 ----
  #endif /* TOPPERS_ini_sem */
  
  /*
!  *  セマフォの状態参照
   */
  #ifdef TOPPERS_ref_sem
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/semaphore.h ASPs/asp/extension/dcre/kernel/semaphore.h
*** 1.9.1/asp/extension/dcre/kernel/semaphore.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/dcre/kernel/semaphore.h	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: semaphore.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		ޥեǽ
   */
  
  #ifndef TOPPERS_SEMAPHORE_H
--- 8,47 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: semaphore.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		セマフォ機能
   */
  
  #ifndef TOPPERS_SEMAPHORE_H
***************
*** 50,121 ****
  #include "wait.h"
  
  /*
!  *  ޥե֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct semaphore_initialization_block {
! 	ATR			sematr;			/* ޥե° */
! 	uint_t		isemcnt;		/* ޥեλ񸻿ν */
! 	uint_t		maxsem;			/* ޥեκ񸻿 */
  } SEMINIB;
  
  /*
!  *  ޥե֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct semaphore_control_block {
! 	QUEUE		wait_queue;		/* ޥեԤ塼 */
! 	const SEMINIB *p_seminib;	/* ֥åؤΥݥ */
! 	uint_t		semcnt;			/* ޥեߥ */
  } SEMCB;
  
  /*
!  *  ޥեԤ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ٤ƤΥեɤ̤ˤʤäƤ롥
   */
  typedef struct semaphore_waiting_information {
! 	WINFO	winfo;			/* ɸԤ֥å */
! 	SEMCB	*p_semcb;		/* ԤäƤ륻ޥեδ֥å */
  } WINFO_SEM;
  
  /*
!  *  ѤƤʤޥե֥åΥꥹ
   */
  extern QUEUE	free_semcb;
  
  /*
!  *  ޥեIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_semid;
  extern const ID	tmax_ssemid;
  
  /*
!  *  ޥե֥åΥꥢkernel_cfg.c
   */
  extern const SEMINIB	seminib_table[];
  extern SEMINIB			aseminib_table[];
  
  /*
!  *  ޥե֥åΥꥢkernel_cfg.c
   */
  extern SEMCB	semcb_table[];
  
  /*
!  *  ޥե֥å饻ޥեIDФΥޥ
   */
  #define	SEMID(p_semcb)	((ID)(((p_semcb) - semcb_table) + TMIN_SEMID))
  
  /*
!  *  ޥեǽν
   */
  extern void	initialize_semaphore(void);
  
--- 50,121 ----
  #include "wait.h"
  
  /*
!  *  セマフォ初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct semaphore_initialization_block {
! 	ATR			sematr;			/* セマフォ属性 */
! 	uint_t		isemcnt;		/* セマフォの資源数の初期値 */
! 	uint_t		maxsem;			/* セマフォの最大資源数 */
  } SEMINIB;
  
  /*
!  *  セマフォ管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct semaphore_control_block {
! 	QUEUE		wait_queue;		/* セマフォ待ちキュー */
! 	const SEMINIB *p_seminib;	/* 初期化ブロックへのポインタ */
! 	uint_t		semcnt;			/* セマフォ現在カウント値 */
  } SEMCB;
  
  /*
!  *  セマフォ待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  すべてのフィールドが共通になっている．
   */
  typedef struct semaphore_waiting_information {
! 	WINFO	winfo;			/* 標準の待ち情報ブロック */
! 	SEMCB	*p_semcb;		/* 待っているセマフォの管理ブロック */
  } WINFO_SEM;
  
  /*
!  *  使用していないセマフォ管理ブロックのリスト
   */
  extern QUEUE	free_semcb;
  
  /*
!  *  セマフォIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_semid;
  extern const ID	tmax_ssemid;
  
  /*
!  *  セマフォ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const SEMINIB	seminib_table[];
  extern SEMINIB			aseminib_table[];
  
  /*
!  *  セマフォ管理ブロックのエリア（kernel_cfg.c）
   */
  extern SEMCB	semcb_table[];
  
  /*
!  *  セマフォ管理ブロックからセマフォIDを取り出すためのマクロ
   */
  #define	SEMID(p_semcb)	((ID)(((p_semcb) - semcb_table) + TMIN_SEMID))
  
  /*
!  *  セマフォ機能の初期化
   */
  extern void	initialize_semaphore(void);
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/startup.c ASPs/asp/extension/dcre/kernel/startup.c
*** 1.9.1/asp/extension/dcre/kernel/startup.c	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/dcre/kernel/startup.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: startup.c 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		ͥνȽλ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: startup.c 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		カーネルの初期化と終了処理
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include <sil.h>
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_KER_ENTER
  #define LOG_KER_ENTER()
--- 49,55 ----
  #include <sil.h>
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_KER_ENTER
  #define LOG_KER_ENTER()
***************
*** 70,110 ****
  #ifdef TOPPERS_sta_ker
  
  /*
!  *  ͥư֥ե饰
   *
!  *  ȥåץ롼ǡfalseʡ0ˤ˽뤳ȤԤ
!  *  롥
   */
  bool_t	kerflg = false;
  
  /*
!  *  ͥεư
   */
  void
  sta_ker(void)
  {
  	/*
! 	 *  åȰ¸ν
  	 */
  	target_initialize();
  
  	/*
! 	 *  ƥ⥸塼ν
  	 *
! 	 *  ।٥ȴ⥸塼¾Υ⥸塼˽
! 	 *  ɬפ롥
  	 */
  	initialize_kmm();
  	initialize_tmevt();
  	initialize_object();
  
  	/*
! 	 *  롼μ¹
  	 */ 
  	call_inirtn();
  
  	/*
! 	 *  ͥưγ
  	 */
  	kerflg = true;
  	LOG_KER_ENTER();
--- 70,110 ----
  #ifdef TOPPERS_sta_ker
  
  /*
!  *  カーネル動作状態フラグ
   *
!  *  スタートアップルーチンで，false（＝0）に初期化されることを期待して
!  *  いる．
   */
  bool_t	kerflg = false;
  
  /*
!  *  カーネルの起動
   */
  void
  sta_ker(void)
  {
  	/*
! 	 *  ターゲット依存の初期化
  	 */
  	target_initialize();
  
  	/*
! 	 *  各モジュールの初期化
  	 *
! 	 *  タイムイベント管理モジュールは他のモジュールより先に初期化
! 	 *  する必要がある．
  	 */
  	initialize_kmm();
  	initialize_tmevt();
  	initialize_object();
  
  	/*
! 	 *  初期化ルーチンの実行
  	 */ 
  	call_inirtn();
  
  	/*
! 	 *  カーネル動作の開始
  	 */
  	kerflg = true;
  	LOG_KER_ENTER();
***************
*** 115,121 ****
  #endif /* TOPPERS_sta_ker */
  
  /*
!  *  ͥνλ
   */
  #ifdef TOPPERS_ext_ker
  
--- 115,121 ----
  #endif /* TOPPERS_sta_ker */
  
  /*
!  *  カーネルの終了
   */
  #ifdef TOPPERS_ext_ker
  
***************
*** 127,151 ****
  	LOG_EXT_KER_ENTER();
  
  	/*
! 	 *  ߥå֤˰ܹ
  	 */
  	SIL_LOC_INT();
  
  	/*
! 	 *  ͥưνλ
  	 */
  	LOG_KER_LEAVE();
  	kerflg = false;
  
  	/*
! 	 *  ͥνλθƽФ
  	 *
! 	 *  󥿥ƥȤڤ괹ơexit_kernelƤӽФ
  	 */
  	call_exit_kernel();
  
  	/*
! 	 *  ѥηٹкʤ뤳ȤϤʤϤ
  	 */
  	SIL_UNL_INT();
  	LOG_EXT_KER_LEAVE(E_SYS);
--- 127,151 ----
  	LOG_EXT_KER_ENTER();
  
  	/*
! 	 *  割込みロック状態に移行
  	 */
  	SIL_LOC_INT();
  
  	/*
! 	 *  カーネル動作の終了
  	 */
  	LOG_KER_LEAVE();
  	kerflg = false;
  
  	/*
! 	 *  カーネルの終了処理の呼出し
  	 *
! 	 *  非タスクコンテキストに切り換えて，exit_kernelを呼び出す．
  	 */
  	call_exit_kernel();
  
  	/*
! 	 *  コンパイラの警告対策（ここへ来ることはないはず）
  	 */
  	SIL_UNL_INT();
  	LOG_EXT_KER_LEAVE(E_SYS);
***************
*** 153,170 ****
  }
  
  /*
!  *  ͥνλ
   */
  void
  exit_kernel(void)
  {
  	/*
! 	 *  λ롼μ¹
  	 */
  	call_terrtn();
  
  	/*
! 	 *  åȰ¸νλ
  	 */
  	target_exit();
  	assert(0);
--- 153,170 ----
  }
  
  /*
!  *  カーネルの終了処理
   */
  void
  exit_kernel(void)
  {
  	/*
! 	 *  終了処理ルーチンの実行
  	 */
  	call_terrtn();
  
  	/*
! 	 *  ターゲット依存の終了処理
  	 */
  	target_exit();
  	assert(0);
***************
*** 173,182 ****
  #endif /* TOPPERS_ext_ker */
  
  /*
!  *  ͥγդΰδ
   *
!  *  ΰƬ˳ơ줿ΰѤ
!  *  ⥸塼롥
   */
  #ifdef TOPPERS_kermem
  #ifndef OMIT_KMM_ALLOCONLY
--- 173,182 ----
  #endif /* TOPPERS_ext_ker */
  
  /*
!  *  カーネルの割り付けるメモリ領域の管理
   *
!  *  メモリ領域を先頭から順に割り当て，解放されたメモリ領域を再利用しな
!  *  いメモリ管理モジュール．
   */
  #ifdef TOPPERS_kermem
  #ifndef OMIT_KMM_ALLOCONLY
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/task.c ASPs/asp/extension/dcre/kernel/task.c
*** 1.9.1/asp/extension/dcre/kernel/task.c	Sat Aug 27 07:59:56 2011
--- ASPs/asp/extension/dcre/kernel/task.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
***************
*** 62,113 ****
  #ifdef TOPPERS_tskini
  
  /*
!  *  ¹Ծ֤Υ
   */
  TCB		*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   */
  TCB		*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   */
  bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   */
  bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   */
  bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   */
  bool_t	dspflg;
  
  /*
!  *  ǥ塼
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   */
  uint16_t	ready_primap;
  
  /*
!  *  ѤƤʤTCBΥꥹ
   */
  QUEUE	free_tcb;
  
  /*
!  *  ⥸塼ν
   */
  void
  initialize_task(void)
--- 62,113 ----
  #ifdef TOPPERS_tskini
  
  /*
!  *  実行状態のタスク
   */
  TCB		*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   */
  TCB		*p_schedtsk;
  
  /*
!  *  タスクディスパッチ／タスク例外処理ルーチン起動要求フラグ
   */
  bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   */
  bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   */
  bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   */
  bool_t	dspflg;
  
  /*
!  *  レディキュー
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   */
  uint16_t	ready_primap;
  
  /*
!  *  使用していないTCBのリスト
   */
  QUEUE	free_tcb;
  
  /*
!  *  タスク管理モジュールの初期化
   */
  void
  initialize_task(void)
***************
*** 151,172 ****
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ӥåȥޥåץؿ
   *
!  *  bitmap1ΥӥåȤ⡤ǤⲼ̡ʱˤΤΤ򥵡Υӥ
!  *  ֹ֤ӥåֹϡǲ̥ӥåȤ0Ȥ롥bitmap0
!  *  ƤϤʤʤδؿǤϡbitmap16ӥåȤǤ뤳Ȥꤷ
!  *  uint16_tȤƤ롥
   *
!  *  ӥåȥ̿ĥץåǤϡӥåȥ̿Ȥ褦
!  *  ľΨɤ礬롥Τ褦ʾˤϡå
!  *  ¸ǥӥåȥ̿Ȥäbitmap_search
!  *  OMIT_BITMAP_SEARCHޥФ褤ޤӥåȥ̿
!  *  դʤɤͳͥ٤ȥӥåȤȤбѹ
!  *  ϡPRIMAP_BITޥФ褤
   *
!  *  ޤ饤֥ffsʤ顤Τ褦ƥ饤֥ؿ
!  *  ȤäΨɤǽ⤢롥
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
--- 151,172 ----
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ビットマップサーチ関数
   *
!  *  bitmap内の1のビットの内，最も下位（右）のものをサーチし，そのビッ
!  *  ト番号を返す．ビット番号は，最下位ビットを0とする．bitmapに0を指定
!  *  してはならない．この関数では，bitmapが16ビットであることを仮定し，
!  *  uint16_t型としている．
   *
!  *  ビットサーチ命令を持つプロセッサでは，ビットサーチ命令を使うように
!  *  書き直した方が効率が良い場合がある．このような場合には，ターゲット
!  *  依存部でビットサーチ命令を使ったbitmap_searchを定義し，
!  *  OMIT_BITMAP_SEARCHをマクロ定義すればよい．また，ビットサーチ命令の
!  *  サーチ方向が逆などの理由で優先度とビットとの対応を変更したい場合に
!  *  は，PRIMAP_BITをマクロ定義すればよい．
   *
!  *  また，ライブラリにffsがあるなら，次のように定義してライブラリ関数を
!  *  使った方が効率が良い可能性もある．
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
***************
*** 198,204 ****
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline bool_t
  primap_empty(void)
--- 198,204 ----
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  優先度ビットマップが空かのチェック
   */
  Inline bool_t
  primap_empty(void)
***************
*** 207,213 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥ
   */
  Inline uint_t
  primap_search(void)
--- 207,213 ----
  }
  
  /*
!  *  優先度ビットマップのサーチ
   */
  Inline uint_t
  primap_search(void)
***************
*** 216,222 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline void
  primap_set(uint_t pri)
--- 216,222 ----
  }
  
  /*
!  *  優先度ビットマップのセット
   */
  Inline void
  primap_set(uint_t pri)
***************
*** 225,231 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥꥢ
   */
  Inline void
  primap_clear(uint_t pri)
--- 225,231 ----
  }
  
  /*
!  *  優先度ビットマップのクリア
   */
  Inline void
  primap_clear(uint_t pri)
***************
*** 234,240 ****
  }
  
  /*
!  *  ǹ̥ͥΥ
   */
  #ifdef TOPPERS_tsksched
  
--- 234,240 ----
  }
  
  /*
!  *  最高優先順位タスクのサーチ
   */
  #ifdef TOPPERS_tsksched
  
***************
*** 250,260 ****
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡ¹ԤǤ륿ʤä
!  *  ȡp_tcbͥ٤ǹ̤ͥΥͥ٤⤤Ǥ
!  *  롥
   */
  #ifdef TOPPERS_tskrun
  
--- 250,260 ----
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  実行できる状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，実行できるタスクがなかった場合
!  *  と，p_tcbの優先度が最高優先順位のタスクの優先度よりも高い場合であ
!  *  る．
   */
  #ifdef TOPPERS_tskrun
  
***************
*** 276,287 ****
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡp_tcbǹ̤ͥΥ
!  *  äǤ롥p_tcbƱͥ٤Υ¾ˤϡp_tcb
!  *  μΥǹ̤ͥˤʤ롥Ǥʤϡǥ塼
!  *  ɬפ롥
   */
  #ifdef TOPPERS_tsknrun
  
--- 276,287 ----
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，p_tcbが最高優先順位のタスクで
!  *  あった場合である．p_tcbと同じ優先度のタスクが他にある場合は，p_tcb
!  *  の次のタスクが最高優先順位になる．そうでない場合は，レディキューを
!  *  サーチする必要がある．
   */
  #ifdef TOPPERS_tsknrun
  
***************
*** 311,317 ****
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  ٻ߾֤ؤ
   */
  #ifdef TOPPERS_tskdmt
  
--- 311,317 ----
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  休止状態への遷移
   */
  #ifdef TOPPERS_tskdmt
  
***************
*** 329,335 ****
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   */
  #ifdef TOPPERS_tskact
  
--- 329,335 ----
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  休止状態から実行できる状態への遷移
   */
  #ifdef TOPPERS_tskact
  
***************
*** 345,360 ****
  #endif /* TOPPERS_tskact */
  
  /*
!  *  ͥ٤ѹ
   *
!  *  ¹ԤǤ֤ξˤϡǥ塼Ǥΰ֤ѹ
!  *  롥֥ȤԤ塼Ԥ֤ˤʤäƤˤϡ
!  *  塼Ǥΰ֤ѹ롥
   *
!  *  ǹ̤ͥΥ򹹿Τϡ(1) p_tcbǹ̤ͥΥ
!  *  Ǥäơͥ٤򲼤硤(2) p_tcbǹ̤ͥΥ
!  *  ǤϤʤѹͥ٤ǹ̤ͥΥͥ٤⤤
!  *  Ǥ롥(1)ξˤϡǥ塼򥵡ɬפ롥
   */
  #ifdef TOPPERS_tskpri
  
--- 345,360 ----
  #endif /* TOPPERS_tskact */
  
  /*
!  *  タスクの優先度の変更
   *
!  *  タスクが実行できる状態の場合には，レディキューの中での位置を変更す
!  *  る．オブジェクトの待ちキューの中で待ち状態になっている場合には，待
!  *  ちキューの中での位置を変更する．
   *
!  *  最高優先順位のタスクを更新するのは，(1) p_tcbが最高優先順位のタス
!  *  クであって，その優先度を下げた場合，(2) p_tcbが最高優先順位のタス
!  *  クではなく，変更後の優先度が最高優先順位のタスクの優先度よりも高い
!  *  場合である．(1)の場合には，レディキューをサーチする必要がある．
   */
  #ifdef TOPPERS_tskpri
  
***************
*** 368,374 ****
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤ξ
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
--- 368,374 ----
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  タスクが実行できる状態の場合
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
***************
*** 393,400 ****
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  Ʊ֥̿Ȥδ֥åζ
! 			 *  ʬWOBJCBˤԤ塼ˤĤʤƤ
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
--- 393,400 ----
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  タスクが，同期・通信オブジェクトの管理ブロックの共通部
! 			 *  分（WOBJCB）の待ちキューにつながれている場合
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
***************
*** 406,415 ****
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  ǥ塼βž
   *
!  *  ǹ̤ͥΥ򹹿Τϡǹ̤ͥΥ
!  *  塼˰ưǤ롥
   */
  #ifdef TOPPERS_tskrot
  
--- 406,415 ----
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  レディキューの回転
   *
!  *  最高優先順位のタスクを更新するのは，最高優先順位のタスクがタスクキ
!  *  ューの末尾に移動した場合である．
   */
  #ifdef TOPPERS_tskrot
  
***************
*** 433,442 ****
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  㳰롼θƽФ
   *
!  *  ASPͥǤϡ㳰롼CPUå֤ܤ
!  *  ξ֤ᤵ˥꥿󤷤硤ͥ뤬ξ֤᤹
   */
  #ifdef TOPPERS_tsktex
  
--- 433,442 ----
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  ASPカーネルでは，タスク例外処理ルーチン内でCPUロック状態に遷移し，
!  *  元の状態に戻さずにリターンした場合，カーネルが元の状態に戻す．
   */
  #ifdef TOPPERS_tsktex
  
***************
*** 469,478 ****
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  dispatchƤӽФϡߺƵƽФˤʤä
! 			 *  뤬dispatchƤp_runtsk->enatexfalseˤ
! 			 *  лپ㤬ʤͳˤĤƤϡTOPPERS/ASP 
! 			 *  ͥ ߷ץפ򻲾ȤΤȡ
  			 */
  			dispatch();
  		}
--- 469,478 ----
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  ここでdispatchを呼び出す処理は，相互再帰呼出しになって
! 			 *  いるが，dispatchを呼ぶ前にp_runtsk->enatexをfalseにして
! 			 *  おけば支障がない．その理由については，「TOPPERS/ASP カー
! 			 *  ネル 設計メモ」を参照のこと．
  			 */
  			dispatch();
  		}
***************
*** 481,487 ****
  }
  
  /*
!  *  㳰롼εư
   */
  #ifndef OMIT_CALLTEX
  
--- 481,487 ----
  }
  
  /*
!  *  タスク例外処理ルーチンの起動
   */
  #ifndef OMIT_CALLTEX
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/task.h ASPs/asp/extension/dcre/kernel/task.h
*** 1.9.1/asp/extension/dcre/kernel/task.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/dcre/kernel/task.h	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #ifndef TOPPERS_TASK_H
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #ifndef TOPPERS_TASK_H
***************
*** 51,99 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  ͥ٤ɽɽѴޥ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  ֤ɽ
   *
!  *  TCBΥ֤Ǥϡ¹Ծ֡RUNNINGˤȼ¹Բǽ֡READY
!  *  ϶̤ʤξ֤Τơ¹ԤǤ֡RUNNABLEˤȸƤ֡
!  *  Ԥ֤ϡ(TS_WAITING | TS_SUSPENDED)ɽTS_WAIT_???
!  *  װɽԤ֡Ԥ֤ޤˤξˤΤꤹ롥
!  */
! #define TS_DORMANT		0x00U			/* ٻ߾ */
! #define TS_RUNNABLE		0x01U			/* ¹ԤǤ */
! #define TS_WAITING		0x02U			/* Ԥ */
! #define TS_SUSPENDED	0x04U			/* Ԥ */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* ַвԤ */
! #define TS_WAIT_SLP		(0x01U << 3)	/* Ԥ */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* ǡ塼μԤ */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* ͥ٥ǡ塼μԤ */
! #define TS_WAIT_SEM		(0x04U << 3)	/* ޥե񸻤γԤ */
! #define TS_WAIT_FLG		(0x05U << 3)	/* ٥ȥե饰Ԥ */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* ǡ塼ؤԤ */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* ͥ٥ǡ塼ؤԤ */
! #define TS_WAIT_MBX		(0x08U << 3)	/* ᡼ܥåμԤ */
! #define TS_WAIT_MPF		(0x09U << 3)	/* Ĺ֥åγԤ */
! 
! /*
!  *  Ƚ̥ޥ
!  *
!  *  TSTAT_DORMANTϥٻ߾֤Ǥ뤫ɤTSTAT_RUNNABLE
!  *  ¹ԤǤ֤Ǥ뤫ɤȽ̤롥TSTAT_WAITING
!  *  ֤Ԥ֤Τ줫Ǥ뤫ɤTSTAT_SUSPENDED
!  *  Ԥ֤Ԥ֤Τ줫Ǥ뤫ɤȽ̤롥
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
--- 51,99 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  タスク優先度の内部表現・外部表現変換マクロ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  タスク状態の内部表現
   *
!  *  TCB中のタスク状態では，実行状態（RUNNING）と実行可能状態（READY）
!  *  は区別しない．両状態を総称して，実行できる状態（RUNNABLE）と呼ぶ．
!  *  二重待ち状態は，(TS_WAITING | TS_SUSPENDED)で表す．TS_WAIT_???は待
!  *  ち要因を表し，待ち状態（二重待ち状態を含む）の場合にのみ設定する．
!  */
! #define TS_DORMANT		0x00U			/* 休止状態 */
! #define TS_RUNNABLE		0x01U			/* 実行できる状態 */
! #define TS_WAITING		0x02U			/* 待ち状態 */
! #define TS_SUSPENDED	0x04U			/* 強制待ち状態 */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* 時間経過待ち */
! #define TS_WAIT_SLP		(0x01U << 3)	/* 起床待ち */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* データキューからの受信待ち */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* 優先度データキューからの受信待ち */
! #define TS_WAIT_SEM		(0x04U << 3)	/* セマフォ資源の獲得待ち */
! #define TS_WAIT_FLG		(0x05U << 3)	/* イベントフラグ待ち */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* データキューへの送信待ち */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* 優先度データキューへの送信待ち */
! #define TS_WAIT_MBX		(0x08U << 3)	/* メールボックスからの受信待ち */
! #define TS_WAIT_MPF		(0x09U << 3)	/* 固定長メモリブロックの獲得待ち */
! 
! /*
!  *  タスク状態判別マクロ
!  *
!  *  TSTAT_DORMANTはタスクが休止状態であるかどうかを，TSTAT_RUNNABLEは
!  *  タスクが実行できる状態であるかどうかを判別する．TSTAT_WAITINGは待
!  *  ち状態と二重待ち状態のいずれかであるかどうかを，TSTAT_SUSPENDEDは
!  *  強制待ち状態と二重待ち状態のいずれかであるかどうかを判別する．
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
***************
*** 101,487 ****
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  ԤװȽ̥ޥ
   *
!  *  TSTAT_WAIT_SLPϥԤǤ뤫ɤTSTAT_WAIT_WOBJ
!  *  ϥƱ֥̿ȤФԤǤ뤫ʸȡ
!  *  Ʊ֥̿ȤԤ塼ˤĤʤƤ뤫ˤɤȽ̤
!  *  롥ޤTSTAT_WAIT_WOBJCBϥƱ֥̿Ȥδ
!  *  ֥åζʬWOBJCBˤԤ塼ˤĤʤƤ뤫ɤ
!  *  Ƚ̤롥
!  *
!  *  TSTAT_WAIT_SLPϡǤդΥ֤椫顤ԤǤ
!  *  ȤȽ̤Ǥ롥ʤTSTAT_WAITINGˤԤ֤Ǥ뤳Ȥ
!  *  Ƚ̤ˡTSTAT_SLPѤƵԤ֤Ǥ뤳ȤȽ̤Ǥ롥
!  *  ΨŪ˼¸뤿ˡTS_WAIT_SLPͤ(0x00U << 3)ǤϤ
!  *  (0x01U << 3)ȤƤ롥ΤᡤַвԤ֤Ǥ
!  *  ȤȽ̤뤿TSTAT_WAIT_DLYTSTAT_WAIT_SLPƱͤˡ
!  *  ¸뤳ȤϤǤʤ
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* ԤװμФޥ */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  Ԥ֥åWINFOˤ
   *
!  *  Ԥ֤δ֤ϡTCBӤp_winfoǻؤWINFO򼡤
!  *  褦ꤷʤФʤʤ
   *
!  *  (a) TCBΥ֤Ԥ֡TS_WAITINGˤˤ롥κݤˡԤ
!  *  װTS_WAIT_???ˤꤹ롥
   *
!  *  (b) ॢȤƻ뤹뤿ˡ।٥ȥ֥åϿ롥
!  *  Ͽ륿।٥ȥ֥åϡԤ륵ӥؿ
!  *  ΥѿȤƳݤؤΥݥ󥿤WINFOp_tmevtb˵
!  *  롥ॢȤδƻ뤬ɬפʤʱʵԤξˤˤϡ
!  *  p_tmevtbNULLˤ롥
!  *
!  *  Ʊ֥̿ȤФԤ֤ξˤϡɸWINFO
!  *  p_wobjcbեɤɲä¤ΡWINFO_WOBJwait.hˤ
!  *  ޤʲ(c)(e)Ԥɬפ롥Ʊ֥̿
!  *  Ȥ˴طʤԤʵԤַвԤˤξˤϡ(c)(e)
!  *  ɬפʤ
!  *
!  *  (c) TCBԤоݤƱ֥̿ȤԤ塼ˤĤʤ
!  *  塼ˤĤʤˡtask_queueȤ
!  *
!  *  (d) ԤоݤƱ֥̿Ȥδ֥åؤΥݥ󥿤
!  *  WINFO_WOBJp_wobjcb˵롥
!  *
!  *  (e) ԤоݤƱ֥̿Ȥ˰¸Ƶ뤳Ȥɬפ
!  *  󤬤ˤϡWINFO_WOBJɬפʾΤΥեɤɲ
!  *  ¤ΤWINFO_WOBJѤ롥
!  *
!  *  Ԥ֤ݤˤϡԤФͤWINFO
!  *  wercdꤹ롥wercdɬפʤΤԤʹߤǤΤФơ
!  *  p_tmevtbԤɬפʤᡤΤ˶ΤȤ
!  *  Ƥ롥Τᡤwercdإ顼ɤꤹΤϡ।٥
!  *  ֥åϿˤʤФʤʤ
   */
  typedef union waiting_information {
! 	ER		wercd;			/* ԤΥ顼 */
! 	TMEVTB	*p_tmevtb;		/* ԤѤΥ।٥ȥ֥å */
  } WINFO;
  
  /*
!  *  ֥å
   *
!  *  ˴ؤͤѤʤROM֤ʬʥ
!  *  ֥åˤȡͤѲ뤿RAM֤ʤФʤʤ
!  *  ʬʥ֥åTCBˤʬΥTCBб륿
!  *  ֥åؤݥ󥿤롥֥åб
!  *  TCBؤݥ󥿤ˡRAMδ˾ޤ
!  *  ¹ԸΨʤ뤿˺ѤƤʤ¾Υ֥ȤˤĤ
!  *  ƤƱͤ˰
   *
!  *  ֥åˤϡDEF_TEX륿㳰롼
!  *  ˴ؤޤࡥ
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* ° */
! 	intptr_t	exinf;			/* γĥ */
! 	TASK		task;			/* εư */
! 	uint_t		ipriority;		/* εưͥ١ɽ */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* ƥȥ֥å */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* åΰΥʴݤ᤿͡ */
! 	void		*stk;			/* åΰƬ */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* 㳰롼° */
! 	TEXRTN		texrtn;			/* 㳰롼εư */
  } TINIB;
  
  /*
!  *  TCBΥեɤΥӥå
   *
!  *  ץåˤäƤϡTCBΥեɤΥӥåǥ̤
!  *  ǽȥ졼ɥդˤʤ뤿ᡤåȰ¸˥եɤΥӥå
!  *  ѹ뤳ȤƤ롥
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityեɤΥӥå */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  ֥åTCB
   *
!  *  ASPͥǤϡεư׵ᥭ塼󥰿κ͡TMAX_ACTCNT
!  *  ȵ׵ᥭ塼󥰿κ͡TMAX_WUPCNTˤ1˸ꤵƤ
!  *  ᡤ塼󥰤Ƥ뤫ɤοͤɽ뤳ȤǤ롥
!  *  ޤԤ׵ͥȿκ͡TMAX_SUSCNTˤ1˸ꤵƤ
!  *  ΤǡԤ׵ͥȿsuscntˤɬפʤ
!  *
!  *  TCBΤĤΥեɤϡΥ֤ǤΤͭͤݻ
!  *  ʳξͤݾڤʤʤäơȤƤϤʤʤˡ
!  *  եɤͭͤݻϼ̤ꡥ
!  *
!  *  Ͼͭ
!  *  		p_tinibtstatactque
!  *  ٻ߾ְʳͭʵٻ߾֤ǤϽͤˤʤäƤˡ
!  *  		prioritywupqueenatextexptn
!  *  Ԥ֡Ԥ֤ޤˤͭ
   *  		p_winfo
!  *  ¹ԤǤ֤Ʊ֥̿ȤФԤ֤ͭ
   *  		task_queue
!  *  ¹Բǽ֡Ԥ֡Ԥ֡Ԥ֤ͭ
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* 塼 */
! 	const TINIB		*p_tinib;		/* ֥åؤΥݥ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* ֡ɽ*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* ֡ɽ*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* ߤͥ١ɽ*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* ߤͥ١ɽ*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* ư׵ᥭ塼 */
! 	BIT_FIELD_BOOL	wupque : 1;		/* ׵ᥭ塼 */
! 	BIT_FIELD_BOOL	enatex : 1;		/* 㳰ľ */
! 
! 	TEXPTN			texptn;			/* α㳰װ */
! 	WINFO			*p_winfo;		/* Ԥ֥åؤΥݥ */
! 	TSKCTXB			tskctxb;		/* ƥȥ֥å */
  } TCB;
  
  /*
!  *  ¹Ծ֤Υ
   *
!  *  ¹Ծ֤ΥʡץåƥȤäƤ륿ˤ
!  *  TCBؤݥ󥿡¹Ծ֤ΥʤNULLˤ롥
   *
!  *  ӥνǡʥӥƤӽФ
!  *  ˤ˴ؤ򻲾Ȥp_runtskȤp_runtsk񤭴
!  *  ΤϡǥѥåʤȽˤΤߤǤ롥
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   *
!  *  ¹ԤǤ륿Ǻǹ̤ͥΥTCBؤݥ󥿡
!  *  ԤǤ륿ʤNULLˤ롥
   *
!  *  ǥѥåػ߾֤ʤɡǥѥåαƤ֤p_runtsk
!  *  ȰפƤȤϸ¤ʤ
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   *
!  *  ߥϥɥ顿CPU㳰ϥɥνиˡǥѥåޤ
!  *  㳰롼εư׵᤹뤳Ȥ򼨤ե饰
   */
  extern bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   *
!  *  ͥ٥ޥ֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   *
!  *  ǥѥåػ߾֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   *
!  *  ͥ٥ޥ֤Ǥꡤǥѥåľ֤Ǥʥǥ
!  *  ѥåػ߾֤ǤʤˤȤ򼨤ե饰
   */
  extern bool_t	dspflg;
  
  /*
!  *  ǥ塼
   *
!  *  ǥ塼ϡ¹ԤǤ֤Υ뤿Υ塼Ǥ롥
!  *  ¹Ծ֤ΥƤ뤿ᡤǥʼ¹Բǽ˥塼Ȥ
!  *  ̾ΤΤǤϤʤǥ塼Ȥ̾Τ夷Ƥ뤿ᡤ
!  *  ̾ΤǸƤ֤Ȥˤ롥
   *
!  *  ǥ塼ϡͥ٤ȤΥ塼ǹƤ롥
!  *  TCBϡͥ٤Υ塼Ͽ롥
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   *
!  *  ǥ塼ΥΨ褯Ԥˡͥ٤ȤΥ塼
!  *  ˥äƤ뤫ɤ򼨤ӥåȥޥåפѰդƤ롥ӥ
!  *  ȥޥåפȤȤǡꥢβ򸺤餹ȤǤ뤬
!  *  ӥå̿᤬¤Ƥʤץåǡͥ٤ʳʤ
!  *  ˤϡӥåȥޥåΥСإåɤΤˡդ˸Ψ
!  *  ǽ⤢롥
   *
!  *  ͥ٤16ʳǤ뤳ȤꤷƤ뤿ᡤuint16_tȤƤ롥
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  ѤƤʤTCBΥꥹ
   */
  extern QUEUE	free_tcb;
  
  /*
!  *  IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_tskid;
  extern const ID	tmax_stskid;
  
  /*
!  *  ֥åΥꥢkernel_cfg.c
   */
  extern const TINIB	tinib_table[];
  extern TINIB		atinib_table[];
  
  /*
!  *  ơ֥kernel_cfg.c
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBΥꥢkernel_cfg.c
   */
  extern TCB	tcb_table[];
  
  /*
!  *  ο
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  #define tnum_stsk	((uint_t)(tmax_stskid - TMIN_TSKID + 1))
  
  /*
!  *  IDTCBФΥޥ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCB饿IDФΥޥ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  ⥸塼ν
   */
  extern void	initialize_task(void);
  
  /*
!  *  ǹ̥ͥΥ
   *
!  *  ǥ塼κǹ̤ͥΥ򥵡TCBؤΥݥ
!  *  ֤ǥ塼ξˤϡδؿƤӽФƤϤʤʤ
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥ǥ塼
!  *  ͥ٤ǹ̤ͥΥͥ٤⤤ϡ
!  *  ǹ̤ͥΥ򹹿ǥѥåľ֤Ǥtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥p_tcbǻꤷ
!  *  ǹ̤ͥΥǤäˤϡǹ̤ͥΥ
!  *  ꤷʤǥѥåľ֤Ǥtrue֤Ǥʤ
!  *  false֤ξ֤Ϲʤ
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤Ȥ롥ޤεư
!  *  ˽٤ѿνȡưΤΥƥȤ
!  *  ꤹ롥
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤¹ԤǤ֤Ȥ롥
!  *  ¹ԤǤ֤ܤؤΥǥѥåɬפʾtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  ͥ٤ѹ
   *
!  *  p_tcbǻꤵ륿ͥ٤newpriɽˤѹ롥ޤ
!  *  ɬפʾˤϺǹ̤ͥΥ򹹿ǥѥåľ֤
!  *  true֤Ǥʤfalse֤
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  ǥ塼βž
   *
!  *  ǥ塼Ρpriǻꤵͥ٤Υ塼ž롥
!  *  ޤɬפʾˤϺǹ̤ͥΥѹǥѥå
!  *  αƤʤtrue֤Ǥʤfalse֤
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  㳰롼θƽФ
   *
!  *  㳰롼ƤӽФƤӽФˡ¹Ծ֤Υ
!  *  α㳰װ򥯥ꥢ㳰ػ߾֤ˤCPUå
!  *  롥
!  *
!  *  㳰롼󤫤ȡޤCPUå֤ᤷδ
!  *  α㳰װ0ǤʤʤäƤСƤӥ㳰롼
!  *  ƤӽФα㳰װ0ξˤϡ㳰ľ֤ˤƴؿ
!  *  ꥿󤹤롥
!  *
!  *  δؿϡ¹Ծ֤Υ㳰ľ֡enatex
!  *  trueˤǡα㳰װ0Ǥʤtexptn0Ǥʤ˾˸ƤӽФ
!  *  ȤꤷƤ롥δؿϡCPUå֤ǸƤӽФʤФʤ
!  *  ʤ
   */
  extern void	call_texrtn(void);
  
  /*
!  *  㳰롼εư
   *
!  *  ¹Ծ֤Υ㳰롼εưƤС
!  *  㳰롼ƤӽФCPU㳰롼ƤӽФ
!  *  ϡŪCPUå롥
!  *
!  *  δؿϡǥѥåߥϥɥ顿CPU㳰ϥɥνи
!  *  ƤӽФ뤳ȤꤷƤ롥δؿϡCPUå
!  *  ǸƤӽФʤФʤʤ
   *
!  *  ¹ԸΨ夲뤿ˡδؿ򥿡åȰ¸ǵҤƤ褤
!  *  ξˤϡOMIT_CALLTEXޥ롥
   */
  extern void	calltex(void);
  
--- 101,487 ----
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  タスク待ち要因判別マクロ
   *
!  *  TSTAT_WAIT_SLPはタスクが起床待ちであるかどうかを，TSTAT_WAIT_WOBJ
!  *  はタスクが同期・通信オブジェクトに対する待ちであるか（言い換えると，
!  *  同期通信オブジェクトの待ちキューにつながれているか）どうかを判別す
!  *  る．また，TSTAT_WAIT_WOBJCBはタスクが同期・通信オブジェクトの管理
!  *  ブロックの共通部分（WOBJCB）の待ちキューにつながれているかどうかを
!  *  判別する．
!  *
!  *  TSTAT_WAIT_SLPは，任意のタスク状態の中から，タスクが起床待ちである
!  *  ことを判別できる．すなわち，TSTAT_WAITINGにより待ち状態であることを
!  *  判別せずに，TSTAT_SLPだけを用いて起床待ち状態であることを判別できる．
!  *  これを効率的に実現するために，TS_WAIT_SLPの値を，(0x00U << 3)ではな
!  *  く(0x01U << 3)としている．そのため，タスクが時間経過待ち状態である
!  *  ことを判別するためのTSTAT_WAIT_DLYを，TSTAT_WAIT_SLPと同様の方法で
!  *  実現することはできない．
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* 待ち要因の取出しマスク */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  待ち情報ブロック（WINFO）の定義
   *
!  *  タスクが待ち状態の間は，TCBおよびそのp_winfoで指されるWINFOを次の
!  *  ように設定しなければならない．
   *
!  *  (a) TCBのタスク状態を待ち状態（TS_WAITING）にする．その際に，待ち
!  *  要因（TS_WAIT_???）も設定する．
   *
!  *  (b) タイムアウトを監視するために，タイムイベントブロックを登録する．
!  *  登録するタイムイベントブロックは，待ちに入るサービスコール処理関数
!  *  のローカル変数として確保し，それへのポインタをWINFOのp_tmevtbに記
!  *  憶する．タイムアウトの監視が必要ない場合（永久待ちの場合）には，
!  *  p_tmevtbをNULLにする．
!  *
!  *  同期・通信オブジェクトに対する待ち状態の場合には，標準のWINFOに
!  *  p_wobjcbフィールドを追加した構造体（WINFO_WOBJ，wait.hで定義）を使
!  *  う．また，以下の(c)〜(e)の設定を行う必要がある．同期・通信オブジェ
!  *  クトに関係しない待ち（起床待ち，時間経過待ち）の場合には，(c)〜(e)
!  *  は必要ない．
!  *
!  *  (c) TCBを待ち対象の同期・通信オブジェクトの待ちキューにつなぐ．待
!  *  ちキューにつなぐために，task_queueを使う．
!  *
!  *  (d) 待ち対象の同期・通信オブジェクトの管理ブロックへのポインタを，
!  *  WINFO_WOBJのp_wobjcbに記憶する．
!  *
!  *  (e) 待ち対象の同期・通信オブジェクトに依存して記憶することが必要な
!  *  情報がある場合には，WINFO_WOBJに必要な情報のためのフィールドを追加
!  *  した構造体を定義し，WINFO_WOBJの代わりに用いる．
!  *
!  *  待ち状態を解除する際には，待ち解除したタスクに対する返値をWINFOの
!  *  wercdに設定する．wercdが必要なのは待ち解除以降であるのに対して，
!  *  p_tmevtbは待ち解除後は必要ないため，メモリ節約のために共用体を使っ
!  *  ている．そのため，wercdへエラーコードを設定するのは，タイムイベント
!  *  ブロックを登録解除した後にしなければならない．
   */
  typedef union waiting_information {
! 	ER		wercd;			/* 待ち解除時のエラーコード */
! 	TMEVTB	*p_tmevtb;		/* 待ち状態用のタイムイベントブロック */
  } WINFO;
  
  /*
!  *  タスク初期化ブロック
   *
!  *  タスクに関する情報を，値が変わらないためにROMに置ける部分（タスク
!  *  初期化ブロック）と，値が変化するためにRAMに置かなければならない部
!  *  分（タスク管理ブロック，TCB）に分離し，TCB内に対応するタスク初期化
!  *  ブロックを指すポインタを入れる．タスク初期化ブロック内に対応する
!  *  TCBを指すポインタを入れる方法の方が，RAMの節約の観点からは望ましい
!  *  が，実行効率が悪くなるために採用していない．他のオブジェクトについ
!  *  ても同様に扱う．
   *
!  *  タスク初期化ブロックには，DEF_TEXで定義されるタスク例外処理ルーチ
!  *  ンに関する情報も含む．
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* タスク属性 */
! 	intptr_t	exinf;			/* タスクの拡張情報 */
! 	TASK		task;			/* タスクの起動番地 */
! 	uint_t		ipriority;		/* タスクの起動時優先度（内部表現） */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* タスク初期化コンテキストブロック */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* スタック領域のサイズ（丸めた値） */
! 	void		*stk;			/* スタック領域の先頭番地 */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* タスク例外処理ルーチン属性 */
! 	TEXRTN		texrtn;			/* タスク例外処理ルーチンの起動番地 */
  } TINIB;
  
  /*
!  *  TCB中のフィールドのビット幅の定義
   *
!  *  プロセッサによっては，TCB中のフィールドのビット幅でメモリ使用量と
!  *  性能がトレードオフになるため，ターゲット依存にフィールドのビット幅
!  *  を変更することを許している．
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityフィールドのビット幅 */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  タスク管理ブロック（TCB）
   *
!  *  ASPカーネルでは，タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）
!  *  と起床要求キューイング数の最大値（TMAX_WUPCNT）は1に固定されている
!  *  ため，キューイングされているかどうかの真偽値で表現することができる．
!  *  また，強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が1に固定されてい
!  *  るので，強制待ち要求ネスト数（suscnt）は必要ない．
!  *
!  *  TCBのいくつかのフィールドは，特定のタスク状態でのみ有効な値を保持し，
!  *  それ以外の場合は値が保証されない（よって，参照してはならない）．各
!  *  フィールドが有効な値を保持する条件は次の通り．
!  *
!  *  ・初期化後は常に有効：
!  *  		p_tinib，tstat，actque
!  *  ・休止状態以外で有効（休止状態では初期値になっている）：
!  *  		priority，wupque，enatex，texptn
!  *  ・待ち状態（二重待ち状態を含む）で有効：
   *  		p_winfo
!  *  ・実行できる状態と同期・通信オブジェクトに対する待ち状態で有効：
   *  		task_queue
!  *  ・実行可能状態，待ち状態，強制待ち状態，二重待ち状態で有効：
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* タスクキュー */
! 	const TINIB		*p_tinib;		/* 初期化ブロックへのポインタ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* タスク状態（内部表現）*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* タスク状態（内部表現）*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* 現在の優先度（内部表現）*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* 現在の優先度（内部表現）*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* 起動要求キューイング */
! 	BIT_FIELD_BOOL	wupque : 1;		/* 起床要求キューイング */
! 	BIT_FIELD_BOOL	enatex : 1;		/* タスク例外処理許可状態 */
! 
! 	TEXPTN			texptn;			/* 保留例外要因 */
! 	WINFO			*p_winfo;		/* 待ち情報ブロックへのポインタ */
! 	TSKCTXB			tskctxb;		/* タスクコンテキストブロック */
  } TCB;
  
  /*
!  *  実行状態のタスク
   *
!  *  実行状態のタスク（＝プロセッサがコンテキストを持っているタスク）の
!  *  TCBを指すポインタ．実行状態のタスクがない場合はNULLにする．
   *
!  *  サービスコールの処理中で，自タスク（サービスコールを呼び出したタス
!  *  ク）に関する情報を参照する場合はp_runtskを使う．p_runtskを書き換え
!  *  るのは，ディスパッチャ（と初期化処理）のみである．
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   *
!  *  実行できるタスクの中で最高優先順位のタスクのTCBを指すポインタ．実
!  *  行できるタスクがない場合はNULLにする．
   *
!  *  ディスパッチ禁止状態など，ディスパッチが保留されている間はp_runtsk
!  *  と一致しているとは限らない．
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ディスパッチ／タスク例外処理ルーチン起動要求フラグ
   *
!  *  割込みハンドラ／CPU例外ハンドラの出口処理に，ディスパッチまたは
!  *  タスク例外処理ルーチンの起動を要求することを示すフラグ．
   */
  extern bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   *
!  *  割込み優先度マスク全解除状態であることを示すフラグ．
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   *
!  *  ディスパッチ禁止状態であることを示すフラグ．
   */
  extern bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   *
!  *  割込み優先度マスク全解除状態であり，ディスパッチ許可状態である（ディ
!  *  スパッチ禁止状態でない）ことを示すフラグ．
   */
  extern bool_t	dspflg;
  
  /*
!  *  レディキュー
   *
!  *  レディキューは，実行できる状態のタスクを管理するためのキューである．
!  *  実行状態のタスクも管理しているため，レディ（実行可能）キューという
!  *  名称は正確ではないが，レディキューという名称が定着しているため，こ
!  *  の名称で呼ぶことにする．
   *
!  *  レディキューは，優先度ごとのタスクキューで構成されている．タスクの
!  *  TCBは，該当する優先度のキューに登録される．
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   *
!  *  レディキューのサーチを効率よく行うために，優先度ごとのタスクキュー
!  *  にタスクが入っているかどうかを示すビットマップを用意している．ビッ
!  *  トマップを使うことで，メモリアクセスの回数を減らすことができるが，
!  *  ビット操作命令が充実していないプロセッサで，優先度の段階数が少ない
!  *  場合には，ビットマップ操作のオーバーヘッドのために，逆に効率が落ち
!  *  る可能性もある．
   *
!  *  優先度が16段階であることを仮定しているため，uint16_t型としている．
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  使用していないTCBのリスト
   */
  extern QUEUE	free_tcb;
  
  /*
!  *  タスクIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_tskid;
  extern const ID	tmax_stskid;
  
  /*
!  *  タスク初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const TINIB	tinib_table[];
  extern TINIB		atinib_table[];
  
  /*
!  *  タスク生成順序テーブル（kernel_cfg.c）
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBのエリア（kernel_cfg.c）
   */
  extern TCB	tcb_table[];
  
  /*
!  *  タスクの数
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  #define tnum_stsk	((uint_t)(tmax_stskid - TMIN_TSKID + 1))
  
  /*
!  *  タスクIDからTCBを取り出すためのマクロ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCBからタスクIDを取り出すためのマクロ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  タスク管理モジュールの初期化
   */
  extern void	initialize_task(void);
  
  /*
!  *  最高優先順位タスクのサーチ
   *
!  *  レディキュー中の最高優先順位のタスクをサーチし，そのTCBへのポインタ
!  *  を返す．レディキューが空の場合には，この関数を呼び出してはならない．
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューに挿入する．レディキューに挿入
!  *  したタスクの優先度が，最高優先順位のタスクの優先度よりも高い場合は，
!  *  最高優先順位のタスクを更新し，ディスパッチ許可状態であればtrueを返
!  *  す．そうでない場合はfalseを返す．
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューから削除する．p_tcbで指定した
!  *  タスクが最高優先順位のタスクであった場合には，最高優先順位のタスク
!  *  を設定しなおし，ディスパッチ許可状態であればtrueを返す．そうでない
!  *  場合はfalseを返す．タスクの状態は更新しない．
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  休止状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態とする．また，タスクの起動
!  *  時に初期化すべき変数の初期化と，タスク起動のためのコンテキストを設
!  *  定する．
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  休止状態から実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態から実行できる状態とする．
!  *  実行できる状態に遷移したタスクへのディスパッチが必要な場合はtrue，
!  *  そうでない場合はfalseを返す．
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  タスクの優先度の変更
   *
!  *  p_tcbで指定されるタスクの優先度をnewpri（内部表現）に変更する．また，
!  *  必要な場合には最高優先順位のタスクを更新し，ディスパッチ許可状態で
!  *  あればtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  レディキューの回転
   *
!  *  レディキュー中の，priで指定される優先度のタスクキューを回転させる．
!  *  また，必要な場合には最高優先順位のタスクを変更し，ディスパッチが保
!  *  留されていなければtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  タスク例外処理ルーチンを呼び出す．呼び出す前に，実行状態のタスクの
!  *  保留例外要因をクリアし，タスク例外処理禁止状態にし，CPUロックを解
!  *  除する．
!  *
!  *  タスク例外処理ルーチンから戻ると，まずCPUロック状態に戻し，その間
!  *  に保留例外要因が0でなくなっていれば，再びタスク例外処理ルーチンを
!  *  呼び出す．保留例外要因が0の場合には，例外処理許可状態にして関数か
!  *  らリターンする．
!  *
!  *  この関数は，実行状態のタスクが，タスク例外処理許可状態（enatexが
!  *  true）で，保留例外要因が0でない（texptnが0でない）場合に呼び出すこ
!  *  とを想定している．この関数は，CPUロック状態で呼び出さなければなら
!  *  ない．
   */
  extern void	call_texrtn(void);
  
  /*
!  *  タスク例外処理ルーチンの起動
   *
!  *  実行状態のタスクがタスク例外処理ルーチンの起動条件を満たしていれば，
!  *  タスク例外処理ルーチンを呼び出す．CPU例外処理ルーチンを呼び出す時
!  *  は，一時的にCPUロックを解除する．
!  *
!  *  この関数は，ディスパッチャや割込みハンドラ／CPU例外ハンドラの出口
!  *  処理から呼び出されることを想定している．この関数は，CPUロック状態
!  *  で呼び出さなければならない．
   *
!  *  実行効率を上げるために，この関数をターゲット依存部で記述してもよい．
!  *  その場合には，OMIT_CALLTEXをマクロ定義する．
   */
  extern void	calltex(void);
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/task_except.c ASPs/asp/extension/dcre/kernel/task_except.c
*** 1.9.1/asp/extension/dcre/kernel/task_except.c	Sun Apr 13 21:20:28 2014
--- ASPs/asp/extension/dcre/kernel/task_except.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task_except.c 2635 2014-04-13 12:20:20Z ertl-hiro $
   */
  
  /*
!  *		㳰ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task_except.c 2635 2014-04-13 12:20:20Z ertl-hiro $
   */
  
  /*
!  *		タスク例外処理機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_DEF_TEX_ENTER
  #define LOG_DEF_TEX_ENTER(tskid, pk_dtex)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_DEF_TEX_ENTER
  #define LOG_DEF_TEX_ENTER(tskid, pk_dtex)
***************
*** 108,114 ****
  #endif /* LOG_REF_TEX_LEAVE */
  
  /*
!  *  㳰롼
   */
  #ifdef TOPPERS_def_tex
  
--- 108,114 ----
  #endif /* LOG_REF_TEX_LEAVE */
  
  /*
!  *  タスク例外処理ルーチンの定義
   */
  #ifdef TOPPERS_def_tex
  
***************
*** 170,176 ****
  #endif /* TOPPERS_def_tex */
  
  /*
!  *  㳰׵
   */
  #ifdef TOPPERS_ras_tex
  
--- 170,176 ----
  #endif /* TOPPERS_def_tex */
  
  /*
!  *  タスク例外処理の要求
   */
  #ifdef TOPPERS_ras_tex
  
***************
*** 210,216 ****
  #endif /* TOPPERS_ras_tex */
  
  /*
!  *  㳰׵󥿥ƥѡ
   */
  #ifdef TOPPERS_iras_tex
  
--- 210,216 ----
  #endif /* TOPPERS_ras_tex */
  
  /*
!  *  タスク例外処理の要求（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iras_tex
  
***************
*** 250,256 ****
  #endif /* TOPPERS_iras_tex */
  
  /*
!  *  㳰ζػ
   */
  #ifdef TOPPERS_dis_tex
  
--- 250,256 ----
  #endif /* TOPPERS_iras_tex */
  
  /*
!  *  タスク例外処理の禁止
   */
  #ifdef TOPPERS_dis_tex
  
***************
*** 280,286 ****
  #endif /* TOPPERS_dis_tex */
  
  /*
!  *  㳰ε
   */
  #ifdef TOPPERS_ena_tex
  
--- 280,286 ----
  #endif /* TOPPERS_dis_tex */
  
  /*
!  *  タスク例外処理の許可
   */
  #ifdef TOPPERS_ena_tex
  
***************
*** 313,319 ****
  #endif /* TOPPERS_ena_tex */
  
  /*
!  *  㳰ػ߾֤λ
   */
  #ifdef TOPPERS_sns_tex
  
--- 313,319 ----
  #endif /* TOPPERS_ena_tex */
  
  /*
!  *  タスク例外処理禁止状態の参照
   */
  #ifdef TOPPERS_sns_tex
  
***************
*** 331,337 ****
  #endif /* TOPPERS_sns_tex */
  
  /*
!  *  㳰ξֻ
   */
  #ifdef TOPPERS_ref_tex
  
--- 331,337 ----
  #endif /* TOPPERS_sns_tex */
  
  /*
!  *  タスク例外処理の状態参照
   */
  #ifdef TOPPERS_ref_tex
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/task_manage.c ASPs/asp/extension/dcre/kernel/task_manage.c
*** 1.9.1/asp/extension/dcre/kernel/task_manage.c	Fri Apr 18 06:28:23 2014
--- ASPs/asp/extension/dcre/kernel/task_manage.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task_manage.c 2642 2014-04-17 21:28:15Z ertl-hiro $
   */
  
  /*
!  *		ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task_manage.c 2642 2014-04-17 21:28:15Z ertl-hiro $
   */
  
  /*
!  *		タスク管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 50,56 ****
  #include "wait.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACRE_TSK_ENTER
  #define LOG_ACRE_TSK_ENTER(pk_ctsk)
--- 50,56 ----
  #include "wait.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACRE_TSK_ENTER
  #define LOG_ACRE_TSK_ENTER(pk_ctsk)
***************
*** 133,144 ****
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  
   */
  #ifdef TOPPERS_acre_tsk
  
  #ifndef TARGET_MIN_STKSZ
! #define TARGET_MIN_STKSZ	1U		/* ̤ξ0ǤʤȤå */
  #endif /* TARGET_MIN_STKSZ */
  
  ER_UINT
--- 133,144 ----
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  タスクの生成
   */
  #ifdef TOPPERS_acre_tsk
  
  #ifndef TARGET_MIN_STKSZ
! #define TARGET_MIN_STKSZ	1U		/* 未定義の場合は0でないことをチェック */
  #endif /* TARGET_MIN_STKSZ */
  
  ER_UINT
***************
*** 210,216 ****
  #endif /* TOPPERS_acre_tsk */
  
  /*
!  *  κ
   */
  #ifdef TOPPERS_del_tsk
  
--- 210,216 ----
  #endif /* TOPPERS_acre_tsk */
  
  /*
!  *  タスクの削除
   */
  #ifdef TOPPERS_del_tsk
  
***************
*** 256,262 ****
  #endif /* TOPPERS_del_tsk */
  
  /*
!  *  εư
   */
  #ifdef TOPPERS_act_tsk
  
--- 256,262 ----
  #endif /* TOPPERS_del_tsk */
  
  /*
!  *  タスクの起動
   */
  #ifdef TOPPERS_act_tsk
  
***************
*** 298,304 ****
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  εư󥿥ƥѡ
   */
  #ifdef TOPPERS_iact_tsk
  
--- 298,304 ----
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  タスクの起動（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iact_tsk
  
***************
*** 340,346 ****
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  ư׵Υ󥻥
   */
  #ifdef TOPPERS_can_act
  
--- 340,346 ----
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  タスク起動要求のキャンセル
   */
  #ifdef TOPPERS_can_act
  
***************
*** 373,379 ****
  #endif /* TOPPERS_can_act */
  
  /*
!  *  νλ
   */
  #ifdef TOPPERS_ext_tsk
  
--- 373,379 ----
  #endif /* TOPPERS_can_act */
  
  /*
!  *  自タスクの終了
   */
  #ifdef TOPPERS_ext_tsk
  
***************
*** 387,395 ****
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUå֤ext_tskƤФ줿ϡCPUå
! 		 *  Ƥ饿λ롥ϡӥǤCPU
! 		 *  åάФ褤
  		 */
  	}
  	else {
--- 387,395 ----
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUロック状態でext_tskが呼ばれた場合は，CPUロックを解除し
! 		 *  てからタスクを終了する．実装上は，サービスコール内でのCPU
! 		 *  ロックを省略すればよいだけ．
  		 */
  	}
  	else {
***************
*** 397,412 ****
  	}
  	if (disdsp) {
  		/*
! 		 *  ǥѥåػ߾֤ext_tskƤФ줿ϡǥѥ
! 		 *  ľ֤ˤƤ饿λ롥
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  ͥ٥ޥIPMˤTIPM_ENAALLʳξ֤ext_tsk
! 		 *  ƤФ줿ϡIPMTIPM_ENAALLˤƤ饿λ
! 		 *  롥
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
--- 397,412 ----
  	}
  	if (disdsp) {
  		/*
! 		 *  ディスパッチ禁止状態でext_tskが呼ばれた場合は，ディスパッ
! 		 *  チ許可状態にしてからタスクを終了する．
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  割込み優先度マスク（IPM）がTIPM_ENAALL以外の状態でext_tsk
! 		 *  が呼ばれた場合は，IPMをTIPM_ENAALLにしてからタスクを終了す
! 		 *  る．
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
***************
*** 430,436 ****
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  ζλ
   */
  #ifdef TOPPERS_ter_tsk
  
--- 430,436 ----
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  タスクの強制終了
   */
  #ifdef TOPPERS_ter_tsk
  
***************
*** 456,464 ****
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbϼǤʤᡤʥ󥰥ץåǤϡ˼
! 			 *  Ծ֤Ǥʤmake_non_runnable(p_tcb)ǥǥѥ
! 			 *  ɬפˤʤ뤳ȤϤʤ
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
--- 456,464 ----
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbは自タスクでないため，（シングルプロセッサでは）実
! 			 *  行状態でなく，make_non_runnable(p_tcb)でタスクディスパッ
! 			 *  チが必要になることはない．
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
***************
*** 485,491 ****
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  Υ١ͥ٤ѹ
   */
  #ifdef TOPPERS_chg_pri
  
--- 485,491 ----
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  タスクのベース優先度の変更
   */
  #ifdef TOPPERS_chg_pri
  
***************
*** 527,533 ****
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  ͥ٤λ
   */
  #ifdef TOPPERS_get_pri
  
--- 527,533 ----
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  タスク優先度の参照
   */
  #ifdef TOPPERS_get_pri
  
***************
*** 563,569 ****
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  γĥλ
   */
  #ifdef TOPPERS_get_inf
  
--- 563,569 ----
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  自タスクの拡張情報の参照
   */
  #ifdef TOPPERS_get_inf
  
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/task_refer.c ASPs/asp/extension/dcre/kernel/task_refer.c
*** 1.9.1/asp/extension/dcre/kernel/task_refer.c	Sun Apr 20 06:26:29 2014
--- ASPs/asp/extension/dcre/kernel/task_refer.c	Fri Dec  9 13:54:00 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task_refer.c 2645 2014-04-19 21:26:29Z ertl-hiro $
   */
  
  /*
!  *		ξֻȵǽ
   */
  
  #include "kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task_refer.c 2645 2014-04-19 21:26:29Z ertl-hiro $
   */
  
  /*
!  *		タスクの状態参照機能
   */
  
  #include "kernel_impl.h"
***************
*** 55,61 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_REF_TSK_ENTER
  #define LOG_REF_TSK_ENTER(tskid, pk_rtsk)
--- 55,61 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_REF_TSK_ENTER
  #define LOG_REF_TSK_ENTER(tskid, pk_rtsk)
***************
*** 66,72 ****
  #endif /* LOG_REF_TSK_LEAVE */
  
  /*
!  *  ξֻ
   */
  #ifdef TOPPERS_ref_tsk
  
--- 66,72 ----
  #endif /* LOG_REF_TSK_LEAVE */
  
  /*
!  *  タスクの状態参照
   */
  #ifdef TOPPERS_ref_tsk
  
***************
*** 90,102 ****
  		tstat = p_tcb->tstat;
  		if (TSTAT_DORMANT(tstat)) {
  			/*
! 	 		 *  оݥٻ߾֤ξ
  			 */
  			pk_rtsk->tskstat = TTS_DMT;
  		}
  		else {
  			/*
! 	 		 *  ֤μФ
  			 */
  			if (TSTAT_SUSPENDED(tstat)) {
  				if (TSTAT_WAITING(tstat)) {
--- 90,102 ----
  		tstat = p_tcb->tstat;
  		if (TSTAT_DORMANT(tstat)) {
  			/*
! 	 		 *  対象タスクが休止状態の場合
  			 */
  			pk_rtsk->tskstat = TTS_DMT;
  		}
  		else {
  			/*
! 	 		 *  タスク状態の取出し
  			 */
  			if (TSTAT_SUSPENDED(tstat)) {
  				if (TSTAT_WAITING(tstat)) {
***************
*** 117,130 ****
  			}
  
  			/*
! 	 		 *  ͥ٤ȥ١ͥ٤μФ
  			 */
  			pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
  			pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->priority);
  
  			if (TSTAT_WAITING(tstat)) {
  				/*
! 		 		 *  ԤװԤоݤΥ֥ȤIDμФ
  				 */
  				switch (tstat & TS_WAIT_MASK) {
  				case TS_WAIT_SLP:
--- 117,130 ----
  			}
  
  			/*
! 	 		 *  現在優先度とベース優先度の取出し
  			 */
  			pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
  			pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->priority);
  
  			if (TSTAT_WAITING(tstat)) {
  				/*
! 		 		 *  待ち要因と待ち対象のオブジェクトのIDの取出し
  				 */
  				switch (tstat & TS_WAIT_MASK) {
  				case TS_WAIT_SLP:
***************
*** 176,182 ****
  				}
  
  				/*
! 		 		 *  ॢȤޤǤλ֤μФ
  				 */
  				if (p_tcb->p_winfo->p_tmevtb != NULL) {
  					pk_rtsk->lefttmo
--- 176,182 ----
  				}
  
  				/*
! 		 		 *  タイムアウトするまでの時間の取出し
  				 */
  				if (p_tcb->p_winfo->p_tmevtb != NULL) {
  					pk_rtsk->lefttmo
***************
*** 188,200 ****
  			}
  
  			/*
! 	 		 *  ׵ᥭ塼󥰿μФ
  			 */
  			pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
  		}
  
  		/*
! 		 *  ư׵ᥭ塼󥰿μФ
  		 */
  		pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
  		ercd = E_OK;
--- 188,200 ----
  			}
  
  			/*
! 	 		 *  起床要求キューイング数の取出し
  			 */
  			pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
  		}
  
  		/*
! 		 *  起動要求キューイング数の取出し
  		 */
  		pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
  		ercd = E_OK;
diff -cr --new-file 1.9.1/asp/extension/dcre/kernel/task_sync.c ASPs/asp/extension/dcre/kernel/task_sync.c
*** 1.9.1/asp/extension/dcre/kernel/task_sync.c	Sat Nov 20 16:23:57 2010
--- ASPs/asp/extension/dcre/kernel/task_sync.c	Fri Dec  9 13:54:00 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: task_sync.c 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		°Ʊǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: task_sync.c 1966 2010-11-20 07:23:56Z ertl-hiro $
   */
  
  /*
!  *		タスク付属同期機能
   */
  
  #include "kernel_impl.h"
***************
*** 50,56 ****
  #include "wait.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SLP_TSK_ENTER
  #define LOG_SLP_TSK_ENTER()
--- 50,56 ----
  #include "wait.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SLP_TSK_ENTER
  #define LOG_SLP_TSK_ENTER()
***************
*** 133,139 ****
  #endif /* LOG_DLY_TSK_LEAVE */
  
  /*
!  *  Ԥ
   */
  #ifdef TOPPERS_slp_tsk
  
--- 133,139 ----
  #endif /* LOG_DLY_TSK_LEAVE */
  
  /*
!  *  起床待ち
   */
  #ifdef TOPPERS_slp_tsk
  
***************
*** 168,174 ****
  #endif /* TOPPERS_slp_tsk */
  
  /*
!  *  ԤʥॢȤ
   */
  #ifdef TOPPERS_tslp_tsk
  
--- 168,174 ----
  #endif /* TOPPERS_slp_tsk */
  
  /*
!  *  起床待ち（タイムアウトあり）
   */
  #ifdef TOPPERS_tslp_tsk
  
***************
*** 208,214 ****
  #endif /* TOPPERS_tslp_tsk */
  
  /*
!  *  ε
   */
  #ifdef TOPPERS_wup_tsk
  
--- 208,214 ----
  #endif /* TOPPERS_tslp_tsk */
  
  /*
!  *  タスクの起床
   */
  #ifdef TOPPERS_wup_tsk
  
***************
*** 253,259 ****
  #endif /* TOPPERS_wup_tsk */
  
  /*
!  *  ε󥿥ƥѡ
   */
  #ifdef TOPPERS_iwup_tsk
  
--- 253,259 ----
  #endif /* TOPPERS_wup_tsk */
  
  /*
!  *  タスクの起床（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iwup_tsk
  
***************
*** 298,304 ****
  #endif /* TOPPERS_iwup_tsk */
  
  /*
!  *  ׵Υ󥻥
   */
  #ifdef TOPPERS_can_wup
  
--- 298,304 ----
  #endif /* TOPPERS_iwup_tsk */
  
  /*
!  *  タスク起床要求のキャンセル
   */
  #ifdef TOPPERS_can_wup
  
***************
*** 334,340 ****
  #endif /* TOPPERS_can_wup */
  
  /*
!  *  Ԥ֤ζ
   */
  #ifdef TOPPERS_rel_wai
  
--- 334,340 ----
  #endif /* TOPPERS_can_wup */
  
  /*
!  *  待ち状態の強制解除
   */
  #ifdef TOPPERS_rel_wai
  
***************
*** 372,378 ****
  #endif /* TOPPERS_rel_wai */
  
  /*
!  *  Ԥ֤ζ󥿥ƥѡ
   */
  #ifdef TOPPERS_irel_wai
  
--- 372,378 ----
  #endif /* TOPPERS_rel_wai */
  
  /*
!  *  待ち状態の強制解除（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_irel_wai
  
***************
*** 410,416 ****
  #endif /* TOPPERS_irel_wai */
  
  /*
!  *  Ԥ֤ؤΰܹ
   */
  #ifdef TOPPERS_sus_tsk
  
--- 410,416 ----
  #endif /* TOPPERS_irel_wai */
  
  /*
!  *  強制待ち状態への移行
   */
  #ifdef TOPPERS_sus_tsk
  
***************
*** 437,443 ****
  	}
  	else if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤鶯Ԥ֤ؤ
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 437,443 ----
  	}
  	else if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  実行できる状態から強制待ち状態への遷移
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 451,457 ****
  	}
  	else {
  		/*
! 		 *  Ԥ֤Ԥ֤ؤ
  		 */
  		p_tcb->tstat |= TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 451,457 ----
  	}
  	else {
  		/*
! 		 *  待ち状態から二重待ち状態への遷移
  		 */
  		p_tcb->tstat |= TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 467,473 ****
  #endif /* TOPPERS_sus_tsk */
  
  /*
!  *  Ԥ֤κƳ
   */
  #ifdef TOPPERS_rsm_tsk
  
--- 467,473 ----
  #endif /* TOPPERS_sus_tsk */
  
  /*
!  *  強制待ち状態からの再開
   */
  #ifdef TOPPERS_rsm_tsk
  
***************
*** 491,497 ****
  	}
  	else if (!TSTAT_WAITING(p_tcb->tstat)) {
  		/*
! 		 *  Ԥ֤¹ԤǤ֤ؤ
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
--- 491,497 ----
  	}
  	else if (!TSTAT_WAITING(p_tcb->tstat)) {
  		/*
! 		 *  強制待ち状態から実行できる状態への遷移
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
***************
*** 502,508 ****
  	}
  	else {
  		/*
! 		 *  Ԥ֤Ԥ֤ؤ
  		 */
  		p_tcb->tstat &= ~TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 502,508 ----
  	}
  	else {
  		/*
! 		 *  二重待ち状態から待ち状態への遷移
  		 */
  		p_tcb->tstat &= ~TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 518,524 ****
  #endif /* TOPPERS_rsm_tsk */
  
  /*
!  *  ٱ
   */
  #ifdef TOPPERS_dly_tsk
  
--- 518,524 ----
  #endif /* TOPPERS_rsm_tsk */
  
  /*
!  *  自タスクの遅延
   */
  #ifdef TOPPERS_dly_tsk
  
diff -cr --new-file 1.9.1/asp/extension/dcre/sample/sample1.c ASPs/asp/extension/dcre/sample/sample1.c
*** 1.9.1/asp/extension/dcre/sample/sample1.c	Fri Sep  7 17:06:21 2012
--- ASPs/asp/extension/dcre/sample/sample1.c	Fri Dec  9 13:54:00 2022
***************
*** 8,111 ****
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: sample1.c 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /* 
!  *  ץץ(1)
   *
!  *  ASPͥδŪưǧ뤿Υץץࡥ
   *
!  *  ץγ:
   *
!  *  桼󥿥եĥᥤ󥿥ʥID: MAIN_TASKͥ
!  *  : MAIN_PRIORITYˤȡ3Ĥ¹Լ¹Ԥ륿ʥID:
!  *  TASK1TASK3ͥ: MID_PRIORITYˤǹ롥ޤư
!  *  2äμϥɥʼϥɥID: CYCHDR1ˤѤ롥
   *
!  *  ¹Լ¹Ԥ륿ϡtask_loop롼פ¹Ԥ٤ˡ
!  *  ¹Ǥ뤳Ȥ򤢤魯åɽ롥롼פ¹Ԥ
!  *  Τϡ롼פʤǥåϤȡ¿̤Υå
!  *  졤ץưǧ餯ʤ뤿Ǥ롥ޤ®ʥ
!  *  ꥢݡȤѤƥåϤˡ٤ƤΥå
!  *  ϤǤ褦ˡå̤¤Ȥͳ⤢롥
   *
!  *  ϥɥϡĤͥ١HIGH_PRIORITYMID_PRIORITY
!  *  LOW_PRIORITYˤΥǥ塼ž롥ץεưľϡ
!  *  ϥɥ߾֤ˤʤäƤ롥
   *
!  *  ᥤ󥿥ϡꥢI/OݡȤʸϤԤʸϤ
!  *  ԤäƤ֤ϡ¹Լ¹Ԥ륿¹ԤƤˡϤ줿
!  *  ʸб¹Ԥ롥Ϥ줿ʸȽδطϼ̤ꡥ
!  *  Control-Cޤ'Q'Ϥȡץλ롥
   *
!  *  '1' : оݥTASK1ڤ괹ʽˡ
!  *  '2' : оݥTASK2ڤ괹롥
!  *  '3' : оݥTASK3ڤ괹롥
!  *  'a' : оݥact_tskˤ굯ư롥
!  *  'A' : оݥФ뵯ư׵can_actˤꥭ󥻥뤹롥
!  *  'e' : оݥext_tskƤӽФλ롥
!  *  't' : оݥter_tskˤ궯λ롥
!  *  '>' : оݥͥ٤HIGH_PRIORITYˤ롥
!  *  '=' : оݥͥ٤MID_PRIORITYˤ롥
!  *  '<' : оݥͥ٤LOW_PRIORITYˤ롥
!  *  'G' : оݥͥ٤get_priɤ߽Ф
!  *  's' : оݥslp_tskƤӽФԤˤ롥
!  *  'S' : оݥtslp_tsk(10)ƤӽФԤˤ롥
!  *  'w' : оݥwup_tskˤ굯롥
!  *  'W' : оݥФ뵯׵can_wupˤꥭ󥻥뤹롥
!  *  'l' : оݥrel_waiˤ궯ŪԤˤ롥
!  *  'u' : оݥsus_tskˤ궯Ԥ֤ˤ롥
!  *  'm' : оݥζԤ֤rsm_tskˤ롥
!  *  'd' : оݥdly_tsk(10)ƤӽФַвԤˤ롥
!  *  'x' : оݥ㳰ѥ0x0001㳰׵᤹롥
!  *  'X' : оݥ㳰ѥ0x0002㳰׵᤹롥
!  *  'y' : оݥdis_texƤӽФ㳰ػߤ롥
!  *  'Y' : оݥena_texƤӽФ㳰Ĥ롥
!  *  'r' : 3Ĥͥ١HIGH_PRIORITYMID_PRIORITYLOW_PRIORITYˤΥ
!  *        ǥ塼ž롥
!  *  'c' : ϥɥưϤ롥
!  *  'C' : ϥɥưߤ롥
!  *  'b' : 顼ϥɥ5ø˵ư褦ưϤ롥
!  *  'B' : 顼ϥɥưߤ롥
!  *  'z' : оݥCPU㳰ȯʥλˡ
!  *  'Z' : оݥCPUå֤CPU㳰ȯʥץ
!  *        λˡ
!  *  '@' : 3acre_tskˤdef_texˤ꥿㳰
!  *        롼ꤹ롥
!  *  '!' : оݥdel_tskˤ롥
!  *  'V' : get_utmǽɾѥƥ2ɤࡥ
!  *  'v' : ȯԤƥॳɽʥǥեȡˡ
!  *  'q' : ȯԤƥॳɽʤ
   */
  
  #include <kernel.h>
--- 8,111 ----
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: sample1.c 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /* 
!  *  サンプルプログラム(1)の本体
   *
!  *  ASPカーネルの基本的な動作を確認するためのサンプルプログラム．
   *
!  *  プログラムの概要:
   *
!  *  ユーザインタフェースを受け持つメインタスク（タスクID: MAIN_TASK，優
!  *  先度: MAIN_PRIORITY）と，3つの並行実行されるタスク（タスクID:
!  *  TASK1〜TASK3，初期優先度: MID_PRIORITY）で構成される．また，起動周
!  *  期が2秒の周期ハンドラ（周期ハンドラID: CYCHDR1）を用いる．
   *
!  *  並行実行されるタスクは，task_loop回空ループを実行する度に，タスクが
!  *  実行中であることをあらわすメッセージを表示する．空ループを実行する
!  *  のは，空ループなしでメッセージを出力すると，多量のメッセージが出力
!  *  され，プログラムの動作が確認しずらくなるためである．また，低速なシ
!  *  リアルポートを用いてメッセージを出力する場合に，すべてのメッセージ
!  *  が出力できるように，メッセージの量を制限するという理由もある．
   *
!  *  周期ハンドラは，三つの優先度（HIGH_PRIORITY，MID_PRIORITY，
!  *  LOW_PRIORITY）のレディキューを回転させる．プログラムの起動直後は，
!  *  周期ハンドラは停止状態になっている．
   *
!  *  メインタスクは，シリアルI/Oポートからの文字入力を行い（文字入力を
!  *  待っている間は，並行実行されるタスクが実行されている），入力された
!  *  文字に対応した処理を実行する．入力された文字と処理の関係は次の通り．
!  *  Control-Cまたは'Q'が入力されると，プログラムを終了する．
   *
!  *  '1' : 対象タスクをTASK1に切り換える（初期設定）．
!  *  '2' : 対象タスクをTASK2に切り換える．
!  *  '3' : 対象タスクをTASK3に切り換える．
!  *  'a' : 対象タスクをact_tskにより起動する．
!  *  'A' : 対象タスクに対する起動要求をcan_actによりキャンセルする．
!  *  'e' : 対象タスクにext_tskを呼び出させ，終了させる．
!  *  't' : 対象タスクをter_tskにより強制終了する．
!  *  '>' : 対象タスクの優先度をHIGH_PRIORITYにする．
!  *  '=' : 対象タスクの優先度をMID_PRIORITYにする．
!  *  '<' : 対象タスクの優先度をLOW_PRIORITYにする．
!  *  'G' : 対象タスクの優先度をget_priで読み出す．
!  *  's' : 対象タスクにslp_tskを呼び出させ，起床待ちにさせる．
!  *  'S' : 対象タスクにtslp_tsk(10秒)を呼び出させ，起床待ちにさせる．
!  *  'w' : 対象タスクをwup_tskにより起床する．
!  *  'W' : 対象タスクに対する起床要求をcan_wupによりキャンセルする．
!  *  'l' : 対象タスクをrel_waiにより強制的に待ち解除にする．
!  *  'u' : 対象タスクをsus_tskにより強制待ち状態にする．
!  *  'm' : 対象タスクの強制待ち状態をrsm_tskにより解除する．
!  *  'd' : 対象タスクにdly_tsk(10秒)を呼び出させ，時間経過待ちにさせる．
!  *  'x' : 対象タスクに例外パターン0x0001の例外処理を要求する．
!  *  'X' : 対象タスクに例外パターン0x0002の例外処理を要求する．
!  *  'y' : 対象タスクにdis_texを呼び出させ，タスク例外を禁止する．
!  *  'Y' : 対象タスクにena_texを呼び出させ，タスク例外を許可する．
!  *  'r' : 3つの優先度（HIGH_PRIORITY，MID_PRIORITY，LOW_PRIORITY）のレ
!  *        ディキューを回転させる．
!  *  'c' : 周期ハンドラを動作開始させる．
!  *  'C' : 周期ハンドラを動作停止させる．
!  *  'b' : アラームハンドラを5秒後に起動するよう動作開始させる．
!  *  'B' : アラームハンドラを動作停止させる．
!  *  'z' : 対象タスクにCPU例外を発生させる（タスクを終了させる）．
!  *  'Z' : 対象タスクにCPUロック状態でCPU例外を発生させる（プログラムを
!  *        終了する）．
!  *  '@' : タスク3をacre_tskにより生成し，def_texによりタスク例外処理
!  *        ルーチンを設定する．
!  *  '!' : 対象タスクをdel_tskにより削除する．
!  *  'V' : get_utmで性能評価用システム時刻を2回読む．
!  *  'v' : 発行したシステムコールを表示する（デフォルト）．
!  *  'q' : 発行したシステムコールを表示しない．
   */
  
  #include <kernel.h>
***************
*** 117,123 ****
  #include "sample1.h"
  
  /*
!  *  ӥΥ顼Υ
   */
  Inline void
  svc_perror(const char *file, int_t line, const char *expr, ER ercd)
--- 117,123 ----
  #include "sample1.h"
  
  /*
!  *  サービスコールのエラーのログ出力
   */
  Inline void
  svc_perror(const char *file, int_t line, const char *expr, ER ercd)
***************
*** 130,147 ****
  #define	SVC_PERROR(expr)	svc_perror(__FILE__, __LINE__, #expr, (expr))
  
  /*
!  *  ¹Լ¹Ԥ륿ؤΥåΰ
   */
  char	message[3];
  
  /*
!  *  롼ײ
   */
! ulong_t	task_loop;		/* ǤΥ롼ײ */
! ulong_t	tex_loop;		/* 㳰롼ǤΥ롼ײ */
  
  /*
!  *  ¹Լ¹Ԥ륿
   */
  void task(intptr_t exinf)
  {
--- 130,147 ----
  #define	SVC_PERROR(expr)	svc_perror(__FILE__, __LINE__, #expr, (expr))
  
  /*
!  *  並行実行されるタスクへのメッセージ領域
   */
  char	message[3];
  
  /*
!  *  ループ回数
   */
! ulong_t	task_loop;		/* タスク内でのループ回数 */
! ulong_t	tex_loop;		/* 例外処理ルーチン内でのループ回数 */
  
  /*
!  *  並行実行されるタスク
   */
  void task(intptr_t exinf)
  {
***************
*** 202,208 ****
  }
  
  /*
!  *  ¹ԤƼ¹Ԥ륿ѤΥ㳰롼
   */
  void tex_routine(TEXPTN texptn, intptr_t exinf)
  {
--- 202,208 ----
  }
  
  /*
!  *  並行して実行されるタスク用のタスク例外処理ルーチン
   */
  void tex_routine(TEXPTN texptn, intptr_t exinf)
  {
***************
*** 220,226 ****
  }
  
  /*
!  *  CPU㳰ϥɥ
   */
  #ifdef CPUEXC1
  
--- 220,226 ----
  }
  
  /*
!  *  CPU例外ハンドラ
   */
  #ifdef CPUEXC1
  
***************
*** 256,265 ****
  #endif /* CPUEXC1 */
  
  /*
!  *  ϥɥ
   *
!  *  HIGH_PRIORITYMID_PRIORITYLOW_PRIORITY γͥ٤Υǥ塼
!  *  ž롥
   */
  void cyclic_handler(intptr_t exinf)
  {
--- 256,265 ----
  #endif /* CPUEXC1 */
  
  /*
!  *  周期ハンドラ
   *
!  *  HIGH_PRIORITY，MID_PRIORITY，LOW_PRIORITY の各優先度のレディキュー
!  *  を回転させる．
   */
  void cyclic_handler(intptr_t exinf)
  {
***************
*** 269,278 ****
  }
  
  /*
!  *  顼ϥɥ
   *
!  *  HIGH_PRIORITYMID_PRIORITYLOW_PRIORITY γͥ٤Υǥ塼
!  *  ž롥
   */
  void alarm_handler(intptr_t exinf)
  {
--- 269,278 ----
  }
  
  /*
!  *  アラームハンドラ
   *
!  *  HIGH_PRIORITY，MID_PRIORITY，LOW_PRIORITY の各優先度のレディキュー
!  *  を回転させる．
   */
  void alarm_handler(intptr_t exinf)
  {
***************
*** 282,288 ****
  }
  
  /*
!  *  ᥤ󥿥
   */
  void main_task(intptr_t exinf)
  {
--- 282,288 ----
  }
  
  /*
!  *  メインタスク
   */
  void main_task(intptr_t exinf)
  {
***************
*** 306,316 ****
  	syslog(LOG_NOTICE, "Sample program starts (exinf = %d).", (int_t) exinf);
  
  	/*
! 	 *  ꥢݡȤν
  	 *
! 	 *  ƥƱꥢݡȤȤʤɡꥢ
! 	 *  ݡȤץѤߤξˤϤE_OBJ顼ˤʤ뤬پ
! 	 *  ʤ
  	 */
  	ercd = serial_opn_por(TASK_PORTID);
  	if (ercd < 0 && MERCD(ercd) != E_OBJ) {
--- 306,316 ----
  	syslog(LOG_NOTICE, "Sample program starts (exinf = %d).", (int_t) exinf);
  
  	/*
! 	 *  シリアルポートの初期化
  	 *
! 	 *  システムログタスクと同じシリアルポートを使う場合など，シリアル
! 	 *  ポートがオープン済みの場合にはここでE_OBJエラーになるが，支障は
! 	 *  ない．
  	 */
  	ercd = serial_opn_por(TASK_PORTID);
  	if (ercd < 0 && MERCD(ercd) != E_OBJ) {
***************
*** 321,355 ****
  							(IOCTL_CRLF | IOCTL_FCSND | IOCTL_FCRCV)));
  
  	/*
!  	 *  롼ײ
  	 *
! 	 *  ¹Լ¹Ԥ륿Ǥζ롼פβtask_loopˤϡ롼
! 	 *  פμ¹Ի֤0.4äˤʤ褦ꤹ롥Τˡ
! 	 *  LOOP_REFζ롼פμ¹Ի֤򡤤get_timƤ֤Ȥ
! 	 *  ¬ꤷ¬̤롼פμ¹Ի֤0.4äˤʤ롼ײ
! 	 *  ᡤtask_loopꤹ롥
  	 *
! 	 *  LOOP_REFϡǥեȤǤ1,000,000ꤷƤ뤬ꤷ
! 	 *  ٤ץåǤϡץץμ¹ԳϤ˻֤
! 	 *  ꤹȤ롥դꤷ®ץåǤϡ
! 	 *  LOOP_REFζ롼פμ¹Ի֤ûʤꡤtask_loopꤹ
! 	 *  θ礭ʤȤ꤬롥
  	 *
! 	 *  ǡΤ褦ʥåȤǤϡtarget_test.hǡLOOP_REFŬ
! 	 *  ڤͤΤ˾ޤ
  	 *
! 	 *  ޤtask_loopͤꤷˤϡͤTASK_LOOP˥
! 	 *  롥TASK_LOOPޥƤ硤嵭¬
! 	 *  Ԥ鷺ˡTASK_LOOP줿ͤ롼פβȤ롥
  	 *
! 	 * åȤˤäƤϡ롼פμ¹Ի֤1ܤ¬ǡ
! 	 * ĹˤʤΤ롥Τ褦ʥåȤǤϡMEASURE_TWICE
! 	 * ޥ뤳Ȥǡ1ܤ¬̤ΤƤơ2ܤ¬
! 	 * Ȥ
  	 *
! 	 *  㳰롼Ǥζ롼פβtex_loopˤϡ
! 	 *  task_loop4ʬ1͡ʶ롼פμ¹Ի֤0.1äˤʤ롼ײ
! 	 *  ˤꤹ롥
  	 */
  #ifdef TASK_LOOP
  	task_loop = TASK_LOOP;
--- 321,355 ----
  							(IOCTL_CRLF | IOCTL_FCSND | IOCTL_FCRCV)));
  
  	/*
!  	 *  ループ回数の設定
  	 *
! 	 *  並行実行されるタスク内での空ループの回数（task_loop）は，空ルー
! 	 *  プの実行時間が約0.4秒になるように設定する．この設定のために，
! 	 *  LOOP_REF回の空ループの実行時間を，その前後でget_timを呼ぶことで
! 	 *  測定し，その測定結果から空ループの実行時間が0.4秒になるループ回
! 	 *  数を求め，task_loopに設定する．
  	 *
! 	 *  LOOP_REFは，デフォルトでは1,000,000に設定しているが，想定したよ
! 	 *  り遅いプロセッサでは，サンプルプログラムの実行開始に時間がかか
! 	 *  りすぎるという問題を生じる．逆に想定したより速いプロセッサでは，
! 	 *  LOOP_REF回の空ループの実行時間が短くなり，task_loopに設定する値
! 	 *  の誤差が大きくなるという問題がある．
  	 *
! 	 *  そこで，そのようなターゲットでは，target_test.hで，LOOP_REFを適
! 	 *  切な値に定義するのが望ましい．
  	 *
! 	 *  また，task_loopの値を固定したい場合には，その値をTASK_LOOPにマ
! 	 *  クロ定義する．TASK_LOOPがマクロ定義されている場合，上記の測定を
! 	 *  行わずに，TASK_LOOPに定義された値を空ループの回数とする．
  	 *
! 	 * ターゲットによっては，空ループの実行時間の1回目の測定で，本来よ
! 	 * りも長めになるものがある．このようなターゲットでは，MEASURE_TWICE
! 	 * をマクロ定義することで，1回目の測定結果を捨てて，2回目の測定結果
! 	 * を使う．
  	 *
! 	 *  タスク例外処理ルーチン内での空ループの回数（tex_loop）は，
! 	 *  task_loopの4分の1の値（空ループの実行時間が0.1秒になるループ回
! 	 *  数）に設定する．
  	 */
  #ifdef TASK_LOOP
  	task_loop = TASK_LOOP;
***************
*** 372,384 ****
  	tex_loop = task_loop / 4;
  
  	/*
!  	 *  εư
  	 */
  	SVC_PERROR(act_tsk(TASK1));
  	SVC_PERROR(act_tsk(TASK2));
  
  	/*
!  	 *  ᥤ롼
  	 */
  	do {
  		SVC_PERROR(serial_rea_dat(TASK_PORTID, &c, 1));
--- 372,384 ----
  	tex_loop = task_loop / 4;
  
  	/*
!  	 *  タスクの起動
  	 */
  	SVC_PERROR(act_tsk(TASK1));
  	SVC_PERROR(act_tsk(TASK2));
  
  	/*
!  	 *  メインループ
  	 */
  	do {
  		SVC_PERROR(serial_rea_dat(TASK_PORTID, &c, 1));
diff -cr --new-file 1.9.1/asp/extension/dcre/sample/sample1.cfg ASPs/asp/extension/dcre/sample/sample1.cfg
*** 1.9.1/asp/extension/dcre/sample/sample1.cfg	Sun Apr 20 05:46:40 2014
--- ASPs/asp/extension/dcre/sample/sample1.cfg	Fri Dec  9 13:54:00 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ץץ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  サンプルプログラム(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/dcre/sample/sample1.h ASPs/asp/extension/dcre/sample/sample1.h
*** 1.9.1/asp/extension/dcre/sample/sample1.h	Fri Sep  7 17:06:21 2012
--- ASPs/asp/extension/dcre/sample/sample1.h	Fri Dec  9 13:54:00 2022
***************
*** 8,87 ****
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   *
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   *
   *  $Id: sample1.h 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /*
!  *		ץץ(1)Υإåե
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
  
! #define MAIN_PRIORITY	5		/* ᥤ󥿥ͥ */
! 								/* HIGH_PRIORITY⤯뤳 */
  
! #define HIGH_PRIORITY	9		/* ¹Լ¹Ԥ륿ͥ */
  #define MID_PRIORITY	10
  #define LOW_PRIORITY	11
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  
  #ifndef TASK_PORTID
! #define	TASK_PORTID		1			/* ʸϤ륷ꥢݡID */
  #endif /* TASK_PORTID */
  
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  #ifndef KMM_SIZE
! #define	KMM_SIZE		(STACK_SIZE * 16)	/* ͥ뤬դ   */
! #endif /* KMM_SIZE */						/*     ΰΥ */
  
  #ifndef LOOP_REF
! #define LOOP_REF		ULONG_C(1000000)	/* ®ٷ¬ѤΥ롼ײ */
  #endif /* LOOP_REF */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 8,87 ----
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   *
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   *
   *  $Id: sample1.h 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /*
!  *		サンプルプログラム(1)のヘッダファイル
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
  
! #define MAIN_PRIORITY	5		/* メインタスクの優先度 */
! 								/* HIGH_PRIORITYより高くすること */
  
! #define HIGH_PRIORITY	9		/* 並行実行されるタスクの優先度 */
  #define MID_PRIORITY	10
  #define LOW_PRIORITY	11
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  
  #ifndef TASK_PORTID
! #define	TASK_PORTID		1			/* 文字入力するシリアルポートID */
  #endif /* TASK_PORTID */
  
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  #ifndef KMM_SIZE
! #define	KMM_SIZE		(STACK_SIZE * 16)	/* カーネルが割り付ける   */
! #endif /* KMM_SIZE */						/*     メモリ領域のサイズ */
  
  #ifndef LOOP_REF
! #define LOOP_REF		ULONG_C(1000000)	/* 速度計測用のループ回数 */
  #endif /* LOOP_REF */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/include/kernel.h ASPs/asp/extension/messagebuf/include/kernel.h
*** 1.9.1/asp/extension/messagebuf/include/kernel.h	Sun Aug 17 21:42:45 2014
--- ASPs/asp/extension/messagebuf/include/kernel.h	Fri Dec  9 13:54:00 2022
***************
*** 8,57 ****
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥ ɸإåե
   *
!  *  TOPPERS/ASPͥ뤬ݡȤ륵ӥȡɬפʥǡ
!  *  ޥޤإåե롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   *
!  *  Υե򥤥󥯥롼ɤ˥󥯥롼ɤƤ٤ե
!  *  Ϥʤ
   */
  
  #ifndef TOPPERS_KERNEL_H
--- 8,57 ----
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル 標準ヘッダファイル
   *
!  *  TOPPERS/ASPカーネルがサポートするサービスコールの宣言と，必要なデー
!  *  タ型，定数，マクロの定義を含むヘッダファイル．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   *
!  *  このファイルをインクルードする前にインクルードしておくべきファイル
!  *  はない．
   */
  
  #ifndef TOPPERS_KERNEL_H
***************
*** 62,93 ****
  #endif
  
  /*
!  *	TOPPERS̤Υǡޥ
   */
  #include <t_stddef.h>
  
  /*
!  *  åȰ¸
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ǡ
   */
  
  /*
!  *  ӥåȥѥ䥪ֹ֥η
   */
! typedef	uint_t		TEXPTN;		/* 㳰װΥӥåȥѥ */
! typedef	uint_t		FLGPTN;		/* ٥ȥե饰Υӥåȥѥ */
! typedef	uint_t		INTNO;		/* ֹ */
! typedef	uint_t		INHNO;		/* ߥϥɥֹ */
! typedef	uint_t		EXCNO;		/* CPU㳰ϥɥֹ */
  
  /*
!  *  ñ̤η
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
--- 62,93 ----
  #endif
  
  /*
!  *	TOPPERS共通のデータ型・定数・マクロ
   */
  #include <t_stddef.h>
  
  /*
!  *  ターゲット依存部
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  データ型の定義
   */
  
  /*
!  *  ビットパターンやオブジェクト番号の型定義
   */
! typedef	uint_t		TEXPTN;		/* タスク例外要因のビットパターン */
! typedef	uint_t		FLGPTN;		/* イベントフラグのビットパターン */
! typedef	uint_t		INTNO;		/* 割込み番号 */
! typedef	uint_t		INHNO;		/* 割込みハンドラ番号 */
! typedef	uint_t		EXCNO;		/* CPU例外ハンドラ番号 */
  
  /*
!  *  処理単位の型定義
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
***************
*** 100,212 ****
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  ΰݤΤη
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* åΰݤ뤿η */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* Ĺסΰݤ뤿η */
  
  /*
!  *  åإåη
   */
! typedef	struct t_msg {			/* ᡼ܥåΥåإå */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* ͥդåإå */
! 	T_MSG	msgque;				/* åإå */
! 	PRI		msgpri;				/* åͥ */
  } T_MSG_PRI;
  
  /*
!  *  ѥåȷ
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/*  */
! 	PRI		tskpri;		/* θͥ */
! 	PRI		tskbpri;	/* Υ١ͥ */
! 	STAT	tskwait;	/* Ԥװ */
! 	ID		wobjid;		/* ԤоݤΥ֥ȤID */
! 	TMO		lefttmo;	/* ॢȤޤǤλ */
! 	uint_t	actcnt;		/* ư׵ᥭ塼󥰿 */
! 	uint_t	wupcnt;		/* ׵ᥭ塼󥰿 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* 㳰ξ */
! 	TEXPTN	pndptn;		/* α㳰װ */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* ޥեԤƬΥIDֹ */
! 	uint_t	semcnt;		/* ޥեθߤλ񸻿 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* ٥ȥե饰ԤƬΥIDֹ */
! 	FLGPTN	flgptn;		/* ٥ȥե饰θߤΥӥåȥѥ */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* ǡ塼ԤƬΥIDֹ */
! 	ID		rtskid;		/* ǡ塼μԤƬΥIDֹ */
! 	uint_t	sdtqcnt;	/* ǡ塼ΰ˳ǼƤǡο */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* ͥ٥ǡ塼ԤƬΥ
! 						   IDֹ */
! 	ID		rtskid;		/* ͥ٥ǡ塼μԤƬΥ
! 						   IDֹ */
! 	uint_t	spdqcnt;	/* ͥ٥ǡ塼ΰ˳ǼƤǡ
! 						   ο */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* ᡼ܥåԤƬΥIDֹ */
! 	T_MSG	*pk_msg;	/* å塼ƬˤĤʤ줿å
! 						   Ƭ */
  } T_RMBX;
  
  typedef struct t_rmbf {
! 	ID		stskid;		/* åХåեԤƬΥ
! 						   IDֹ */
! 	ID		rtskid;		/* åХåեμԤƬΥ
! 						   IDֹ */
! 	uint_t	smbfcnt;	/* åХåեΰ˳ǼƤ
! 						   ο */
! 	SIZE	fmbfsz;		/* åХåեΰζΰΥ */
  } T_RMBF;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* ĹסԤƬΥ
! 						   IDֹ */
! 	uint_t	fblkcnt;	/* Ĺסΰζΰ˳
! 						   դ뤳ȤǤĹ֥åο */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* ϥɥư */
! 	RELTIM	lefttim;	/* ˼ϥɥưޤǤл */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* 顼ϥɥư */
! 	RELTIM	lefttim;	/* 顼ϥɥưޤǤл */
  } T_RALM;
  
  /*
!  *  ӥ
   */
  
  /*
!  *  ǽ
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
--- 100,212 ----
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  メモリ領域確保のための型定義
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* スタック領域を確保するための型 */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* 固定長メモリプール領域を確保するための型 */
  
  /*
!  *  メッセージヘッダの型定義
   */
! typedef	struct t_msg {			/* メールボックスのメッセージヘッダ */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* 優先度付きメッセージヘッダ */
! 	T_MSG	msgque;				/* メッセージヘッダ */
! 	PRI		msgpri;				/* メッセージ優先度 */
  } T_MSG_PRI;
  
  /*
!  *  パケット形式の定義
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/* タスク状態 */
! 	PRI		tskpri;		/* タスクの現在優先度 */
! 	PRI		tskbpri;	/* タスクのベース優先度 */
! 	STAT	tskwait;	/* 待ち要因 */
! 	ID		wobjid;		/* 待ち対象のオブジェクトのID */
! 	TMO		lefttmo;	/* タイムアウトするまでの時間 */
! 	uint_t	actcnt;		/* 起動要求キューイング数 */
! 	uint_t	wupcnt;		/* 起床要求キューイング数 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* タスク例外処理の状態 */
! 	TEXPTN	pndptn;		/* 保留例外要因 */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* セマフォの待ち行列の先頭のタスクのID番号 */
! 	uint_t	semcnt;		/* セマフォの現在の資源数 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* イベントフラグの待ち行列の先頭のタスクのID番号 */
! 	FLGPTN	flgptn;		/* イベントフラグの現在のビットパターン */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* データキューの送信待ち行列の先頭のタスクのID番号 */
! 	ID		rtskid;		/* データキューの受信待ち行列の先頭のタスクのID番号 */
! 	uint_t	sdtqcnt;	/* データキュー管理領域に格納されているデータの数 */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* 優先度データキューの送信待ち行列の先頭のタスク
! 						   のID番号 */
! 	ID		rtskid;		/* 優先度データキューの受信待ち行列の先頭のタスク
! 						   のID番号 */
! 	uint_t	spdqcnt;	/* 優先度データキュー管理領域に格納されているデー
! 						   タの数 */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* メールボックスの待ち行列の先頭のタスクのID番号 */
! 	T_MSG	*pk_msg;	/* メッセージキューの先頭につながれたメッセージ
! 						   の先頭番地 */
  } T_RMBX;
  
  typedef struct t_rmbf {
! 	ID		stskid;		/* メッセージバッファの送信待ち行列の先頭のタスク
! 						   のID番号 */
! 	ID		rtskid;		/* メッセージバッファの受信待ち行列の先頭のタスク
! 						   のID番号 */
! 	uint_t	smbfcnt;	/* メッセージバッファ管理領域に格納されているメッ
! 						   セージの数 */
! 	SIZE	fmbfsz;		/* メッセージバッファ管理領域中の空き領域のサイズ */
  } T_RMBF;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* 固定長メモリプールの待ち行列の先頭のタスクの
! 						   ID番号 */
! 	uint_t	fblkcnt;	/* 固定長メモリプール領域の空きメモリ領域に割り
! 						   付けることができる固定長メモリブロックの数 */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* 周期ハンドラの動作状態 */
! 	RELTIM	lefttim;	/* 次に周期ハンドラを起動する時刻までの相対時間 */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* アラームハンドラの動作状態 */
! 	RELTIM	lefttim;	/* アラームハンドラを起動する時刻までの相対時間 */
  } T_RALM;
  
  /*
!  *  サービスコールの宣言
   */
  
  /*
!  *  タスク管理機能
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
***************
*** 219,225 ****
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  °Ʊǽ
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
--- 219,225 ----
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  タスク付属同期機能
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
***************
*** 233,239 ****
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  㳰ǽ
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
--- 233,239 ----
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  タスク例外処理機能
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
***************
*** 243,249 ****
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  Ʊ̿ǽ
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
--- 243,249 ----
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  同期・通信機能
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
***************
*** 307,313 ****
  extern ER		ref_mbf(ID mbfid, T_RMBF *pk_rmbf) throw();
  
  /*
!  *  סǽ
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
--- 307,313 ----
  extern ER		ref_mbf(ID mbfid, T_RMBF *pk_rmbf) throw();
  
  /*
!  *  メモリプール管理機能
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
***************
*** 317,323 ****
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  ִǽ
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
--- 317,323 ----
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  時間管理機能
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
***************
*** 333,339 ****
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  ƥִǽ
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
--- 333,339 ----
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  システム状態管理機能
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
***************
*** 353,359 ****
  extern ER		ext_ker(void) throw();
  
  /*
!  *  ߴǽ
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
--- 353,359 ----
  extern ER		ext_ker(void) throw();
  
  /*
!  *  割込み管理機能
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
***************
*** 361,367 ****
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU㳰ǽ
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
--- 361,367 ----
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU例外管理機能
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
***************
*** 369,503 ****
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ֥°
   */
! #define TA_ACT			UINT_C(0x02)	/* ư줿֤ */
  
! #define TA_TPRI			UINT_C(0x01)	/* Ԥͥٽ */
! #define TA_MPRI			UINT_C(0x02)	/* å塼ͥٽ */
  
! #define TA_WMUL			UINT_C(0x02)	/* ʣԤ */
! #define TA_CLR			UINT_C(0x04)	/* ٥ȥե饰Υꥢ */
  
! #define TA_STA			UINT_C(0x02)	/* ϥɥư֤ */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* ͥγ */
  
! #define TA_ENAINT		UINT_C(0x01)	/* ׵ػߥե饰򥯥ꥢ */
! #define TA_EDGE			UINT_C(0x02)	/* åȥꥬ */
  
  /*
!  *  ӥư⡼ɤ
   */
! #define TWF_ORW			UINT_C(0x01)	/* ٥ȥե饰ORԤ */
! #define TWF_ANDW		UINT_C(0x02)	/* ٥ȥե饰ANDԤ */
  
  /*
!  *  ֥Ȥξ֤
   */
! #define TTS_RUN			UINT_C(0x01)	/* ¹Ծ */
! #define TTS_RDY			UINT_C(0x02)	/* ¹Բǽ */
! #define TTS_WAI			UINT_C(0x04)	/* Ԥ */
! #define TTS_SUS			UINT_C(0x08)	/* Ԥ */
! #define TTS_WAS			UINT_C(0x0c)	/* Ԥ */
! #define TTS_DMT			UINT_C(0x10)	/* ٻ߾ */
  
! #define TTW_SLP			UINT_C(0x0001)	/* Ԥ */
! #define TTW_DLY			UINT_C(0x0002)	/* ַвԤ */
! #define TTW_SEM			UINT_C(0x0004)	/* ޥեλ񸻳Ԥ */
! #define TTW_FLG			UINT_C(0x0008)	/* ٥ȥե饰Ԥ */
! #define TTW_SDTQ		UINT_C(0x0010)	/* ǡ塼ؤԤ */
! #define TTW_RDTQ		UINT_C(0x0020)	/* ǡ塼μԤ */
! #define TTW_SPDQ		UINT_C(0x0100)	/* ͥ٥ǡ塼ؤԤ */
! #define TTW_RPDQ		UINT_C(0x0200)	/* ͥ٥ǡ塼μԤ */
! #define TTW_MBX			UINT_C(0x0040)	/* ᡼ܥåμԤ */
! #define TTW_SMBF		UINT_C(0x0400)	/* åХåեؤԤ */
! #define TTW_RMBF		UINT_C(0x0800)	/* åХåեμԤ */
! #define TTW_MPF			UINT_C(0x2000)	/* Ĺ֥åγԤ */
  
! #define TTEX_ENA		UINT_C(0x01)	/* 㳰ľ */
! #define TTEX_DIS		UINT_C(0x02)	/* 㳰ػ߾ */
  
! #define TCYC_STP		UINT_C(0x01)	/* ϥɥ餬ưƤʤ */
! #define TCYC_STA		UINT_C(0x02)	/* ϥɥ餬ưƤ */
  
! #define TALM_STP		UINT_C(0x01)	/* 顼ϥɥ餬ưƤʤ */
! #define TALM_STA		UINT_C(0x02)	/* 顼ϥɥ餬ưƤ */
  
  /*
!  *  ¾
   */
! #define TSK_SELF		0			/*  */
! #define TSK_NONE		0			/* 륿ʤ */
  
! #define TPRI_SELF		0			/* Υ١ͥ */
! #define TPRI_INI		0			/* εưͥ */
  
! #define TIPM_ENAALL		0			/* ͥ٥ޥ */
  
  /*
!  *  ȥޥ
   */
  
  /*
!  *  ݡȤ뵡ǽ
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_MESSAGEBUF		/* åХåեǽĥ */
  
  /*
!  *  ͥ٤ϰ
   */
! #define TMIN_TPRI		1			/* ͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_TPRI		16			/* ͥ٤κ͡ʺ͡*/
! #define TMIN_DPRI		1			/* ǡͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_DPRI		16			/* ǡͥ٤κ͡ʺ͡*/
! #define TMIN_MPRI		1			/* åͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_MPRI		16			/* åͥ٤κ͡ʺ͡*/
! #define TMIN_ISRPRI		1			/* ߥӥ롼ͥ٤κǾ */
! #define TMAX_ISRPRI		16			/* ߥӥ롼ͥ٤κ */
  
  /*
!  *  С
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* ͥΥ᡼ */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* ͥμֹ */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* ͥͤΥСֹ */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* ͥΥСֹ */
  
  /*
!  *  塼󥰲κ
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* ư׵ᥭ塼󥰿κ */
! #define TMAX_WUPCNT		UINT_C(1)		/* ׵ᥭ塼󥰿κ */
  
  /*
!  *  ӥåȥѥΥӥåȿ
   */
! #ifndef TBIT_TEXPTN					/* 㳰װΥӥåȿ */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* ٥ȥե饰Υӥåȿ */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  ΰݤΤΥޥ
   *
!  *  ʲTOPPERS_COUNT_SZTOPPERS_ROUND_SZϡunit2ζҾǤ
!  *  뤳ȤꤷƤ롥
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
--- 369,503 ----
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  オブジェクト属性の定義
   */
! #define TA_ACT			UINT_C(0x02)	/* タスクを起動された状態で生成 */
  
! #define TA_TPRI			UINT_C(0x01)	/* タスクの待ち行列を優先度順に */
! #define TA_MPRI			UINT_C(0x02)	/* メッセージキューを優先度順に */
  
! #define TA_WMUL			UINT_C(0x02)	/* 複数の待ちタスク */
! #define TA_CLR			UINT_C(0x04)	/* イベントフラグのクリア指定 */
  
! #define TA_STA			UINT_C(0x02)	/* 周期ハンドラを動作状態で生成 */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* カーネル管理外の割込み */
  
! #define TA_ENAINT		UINT_C(0x01)	/* 割込み要求禁止フラグをクリア */
! #define TA_EDGE			UINT_C(0x02)	/* エッジトリガ */
  
  /*
!  *  サービスコールの動作モードの定義
   */
! #define TWF_ORW			UINT_C(0x01)	/* イベントフラグのOR待ち */
! #define TWF_ANDW		UINT_C(0x02)	/* イベントフラグのAND待ち */
  
  /*
!  *  オブジェクトの状態の定義
   */
! #define TTS_RUN			UINT_C(0x01)	/* 実行状態 */
! #define TTS_RDY			UINT_C(0x02)	/* 実行可能状態 */
! #define TTS_WAI			UINT_C(0x04)	/* 待ち状態 */
! #define TTS_SUS			UINT_C(0x08)	/* 強制待ち状態 */
! #define TTS_WAS			UINT_C(0x0c)	/* 二重待ち状態 */
! #define TTS_DMT			UINT_C(0x10)	/* 休止状態 */
  
! #define TTW_SLP			UINT_C(0x0001)	/* 起床待ち */
! #define TTW_DLY			UINT_C(0x0002)	/* 時間経過待ち */
! #define TTW_SEM			UINT_C(0x0004)	/* セマフォの資源獲得待ち */
! #define TTW_FLG			UINT_C(0x0008)	/* イベントフラグ待ち */
! #define TTW_SDTQ		UINT_C(0x0010)	/* データキューへの送信待ち */
! #define TTW_RDTQ		UINT_C(0x0020)	/* データキューからの受信待ち */
! #define TTW_SPDQ		UINT_C(0x0100)	/* 優先度データキューへの送信待ち */
! #define TTW_RPDQ		UINT_C(0x0200)	/* 優先度データキューからの受信待ち */
! #define TTW_MBX			UINT_C(0x0040)	/* メールボックスからの受信待ち */
! #define TTW_SMBF		UINT_C(0x0400)	/* メッセージバッファへの送信待ち */
! #define TTW_RMBF		UINT_C(0x0800)	/* メッセージバッファからの受信待ち */
! #define TTW_MPF			UINT_C(0x2000)	/* 固定長メモリブロックの獲得待ち */
  
! #define TTEX_ENA		UINT_C(0x01)	/* タスク例外処理許可状態 */
! #define TTEX_DIS		UINT_C(0x02)	/* タスク例外処理禁止状態 */
  
! #define TCYC_STP		UINT_C(0x01)	/* 周期ハンドラが動作していない */
! #define TCYC_STA		UINT_C(0x02)	/* 周期ハンドラが動作している */
  
! #define TALM_STP		UINT_C(0x01)	/* アラームハンドラが動作していない */
! #define TALM_STA		UINT_C(0x02)	/* アラームハンドラが動作している */
  
  /*
!  *  その他の定数の定義
   */
! #define TSK_SELF		0			/* 自タスク指定 */
! #define TSK_NONE		0			/* 該当するタスクがない */
  
! #define TPRI_SELF		0			/* 自タスクのベース優先度 */
! #define TPRI_INI		0			/* タスクの起動時優先度 */
  
! #define TIPM_ENAALL		0			/* 割込み優先度マスク全解除 */
  
  /*
!  *  構成定数とマクロ
   */
  
  /*
!  *  サポートする機能
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_MESSAGEBUF		/* メッセージバッファ機能拡張 */
  
  /*
!  *  優先度の範囲
   */
! #define TMIN_TPRI		1			/* タスク優先度の最小値（最高値）*/
! #define TMAX_TPRI		16			/* タスク優先度の最大値（最低値）*/
! #define TMIN_DPRI		1			/* データ優先度の最小値（最高値）*/
! #define TMAX_DPRI		16			/* データ優先度の最大値（最低値）*/
! #define TMIN_MPRI		1			/* メッセージ優先度の最小値（最高値）*/
! #define TMAX_MPRI		16			/* メッセージ優先度の最大値（最低値）*/
! #define TMIN_ISRPRI		1			/* 割込みサービスルーチン優先度の最小値 */
! #define TMAX_ISRPRI		16			/* 割込みサービスルーチン優先度の最大値 */
  
  /*
!  *  バージョン情報
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* カーネルのメーカーコード */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* カーネルの識別番号 */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* カーネル仕様のバージョン番号 */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* カーネルのバージョン番号 */
  
  /*
!  *  キューイング回数の最大値
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* 起動要求キューイング数の最大値 */
! #define TMAX_WUPCNT		UINT_C(1)		/* 起床要求キューイング数の最大値 */
  
  /*
!  *  ビットパターンのビット数
   */
! #ifndef TBIT_TEXPTN					/* タスク例外要因のビット数 */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* イベントフラグのビット数 */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  メモリ領域確保のためのマクロ
   *
!  *  以下のTOPPERS_COUNT_SZとTOPPERS_ROUND_SZの定義は，unitが2の巾乗であ
!  *  ることを仮定している．
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
***************
*** 516,524 ****
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  ¾ι
   */
! #define TMAX_MAXSEM		UINT_MAX	/* ޥեκ񸻿κ */
  
  #ifdef __cplusplus
  }
--- 516,524 ----
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  その他の構成定数
   */
! #define TMAX_MAXSEM		UINT_MAX	/* セマフォの最大資源数の最大値 */
  
  #ifdef __cplusplus
  }
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/Makefile.kernel ASPs/asp/extension/messagebuf/kernel/Makefile.kernel
*** 1.9.1/asp/extension/messagebuf/kernel/Makefile.kernel	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/Makefile.kernel	Fri Dec  9 13:54:01 2022
***************
*** 8,52 ****
  #  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! #  ܥեȥѤΤޤࡥʲƱˤѡʣ
! #  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! #  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! #      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! #      ˴ޤޤƤ뤳ȡ
! #  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! #      ѤǤǺۤˤϡۤȼɥȡ
! #      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! #      ̵ݾڵǺܤ뤳ȡ
! #  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! #      ѤǤʤǺۤˤϡΤ줫ξ
! #      ȡ
! #    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! #        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! #    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! #        𤹤뤳ȡ
! #  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! #      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! #      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! #      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! #      դ뤳ȡ
  # 
! #  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! #  TOPPERSץȤϡܥեȥ˴ؤơλŪ
! #  ФŬޤơʤݾڤԤʤޤܥեȥ
! #  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! #  Ǥʤ
  # 
  #  @(#) $Id: Makefile.kernel 2589 2014-01-02 05:10:53Z ertl-hiro $
  # 
  
  #
! #		ͥΥե빽
  #
  
  #
! #  1ĤΥե뤫ʣΥ֥ȥե褦˺
! #  줿եΥꥹ
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
--- 8,52 ----
  #  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! #  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! #  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! #  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! #      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! #      スコード中に含まれていること．
! #  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! #      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! #      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! #      の無保証規定を掲載すること．
! #  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! #      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! #      と．
! #    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! #        作権表示，この利用条件および下記の無保証規定を掲載すること．
! #    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! #        報告すること．
! #  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! #      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! #      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! #      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! #      免責すること．
  # 
! #  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! #  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! #  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! #  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! #  の責任を負わない．
  # 
  #  @(#) $Id: Makefile.kernel 2589 2014-01-02 05:10:53Z ertl-hiro $
  # 
  
  #
! #		カーネルのファイル構成の定義
  #
  
  #
! #  1つのソースファイルから複数のオブジェクトファイルを生成するように作
! #  成されたソースファイルのリスト
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
***************
*** 55,61 ****
  				sys_manage.c interrupt.c exception.c
  
  #
! #  ƥե뤫륪֥ȥեΥꥹ
  #
  startup = sta_ker.o ext_ker.o
  
--- 55,61 ----
  				sys_manage.c interrupt.c exception.c
  
  #
! #  各ソースファイルから生成されるオブジェクトファイルのリスト
  #
  startup = sta_ker.o ext_ker.o
  
***************
*** 117,123 ****
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  륪֥ȥեΰ¸ط
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
--- 117,123 ----
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  生成されるオブジェクトファイルの依存関係の定義
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/allfunc.h ASPs/asp/extension/messagebuf/kernel/allfunc.h
*** 1.9.1/asp/extension/messagebuf/kernel/allfunc.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/allfunc.h	Fri Dec  9 13:54:00 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: allfunc.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		٤Ƥδؿ򥳥ѥ뤹뤿
   */
  
  #ifndef TOPPERS_ALLFUNC_H
--- 6,45 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: allfunc.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		すべての関数をコンパイルするための定義
   */
  
  #ifndef TOPPERS_ALLFUNC_H
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/check.h ASPs/asp/extension/messagebuf/kernel/check.h
*** 1.9.1/asp/extension/messagebuf/kernel/check.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/check.h	Fri Dec  9 13:54:00 2022
***************
*** 8,54 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: check.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		顼åѥޥ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  ͥ٤ϰϤȽ
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
--- 8,54 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: check.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		エラーチェック用マクロ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  優先度の範囲の判定
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
***************
*** 58,64 ****
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
--- 58,64 ----
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  タスク優先度のチェック（E_PAR）
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
***************
*** 82,88 ****
  } while (false)
  
  /*
!  *  ॢȻͤΥåE_PAR
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
--- 82,88 ----
  } while (false)
  
  /*
!  *  タイムアウト指定値のチェック（E_PAR）
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
***************
*** 92,98 ****
  } while (false)
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
--- 92,98 ----
  } while (false)
  
  /*
!  *  割込み優先度のチェック（E_PAR）
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
***************
*** 102,108 ****
  } while (false)
  
  /*
!  *  ֹΥåE_PAR
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
--- 102,108 ----
  } while (false)
  
  /*
!  *  割込み番号のチェック（E_PAR）
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
***************
*** 112,118 ****
  } while (false)
  
  /*
!  *  ¾Υѥ᡼顼ΥåE_PAR
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
--- 112,118 ----
  } while (false)
  
  /*
!  *  その他のパラメータエラーのチェック（E_PAR）
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
***************
*** 122,128 ****
  } while (false)
  
  /*
!  *  ֥IDϰϤȽ
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
--- 122,128 ----
  } while (false)
  
  /*
!  *  オブジェクトIDの範囲の判定
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
***************
*** 136,142 ****
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  ֥IDΥåE_ID
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
--- 136,142 ----
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  オブジェクトIDのチェック（E_ID）
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
***************
*** 216,222 ****
  } while (false)
  
  /*
!  *  ƽФƥȤΥåE_CTX
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
--- 216,222 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストのチェック（E_CTX）
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
***************
*** 233,239 ****
  } while (false)
  
  /*
!  *  ƽФƥȤCPUå֤ΥåE_CTX
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
--- 233,239 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストとCPUロック状態のチェック（E_CTX）
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
***************
*** 250,256 ****
  } while (false)
  
  /*
!  *  ǥѥåα֤ǤʤΥåE_CTX
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
--- 250,256 ----
  } while (false)
  
  /*
!  *  ディスパッチ保留状態でないかのチェック（E_CTX）
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
***************
*** 260,266 ****
  } while (false)
  
  /*
!  *  ¾Υƥȥ顼ΥåE_CTX
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
--- 260,266 ----
  } while (false)
  
  /*
!  *  その他のコンテキストエラーのチェック（E_CTX）
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
***************
*** 270,276 ****
  } while (false)
  
  /*
!  *  ꤷƤʤΥåE_ILUSE
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
--- 270,276 ----
  } while (false)
  
  /*
!  *  自タスクを指定していないかのチェック（E_ILUSE）
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
***************
*** 280,286 ****
  } while (false)
  
  /*
!  *  ¾ѥ顼ΥåE_ILUSE
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
--- 280,286 ----
  } while (false)
  
  /*
!  *  その他の不正使用エラーのチェック（E_ILUSE）
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/kernel.tf ASPs/asp/extension/messagebuf/kernel/kernel.tf
*** 1.9.1/asp/extension/messagebuf/kernel/kernel.tf	Sun May  4 22:18:02 2014
--- ASPs/asp/extension/messagebuf/kernel/kernel.tf	Fri Dec  9 13:54:00 2022
***************
*** 8,48 ****
  $   Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   $Id: kernel.tf 2595 2014-01-02 12:00:09Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.h
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
--- 8,48 ----
  $   Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   $Id: kernel.tf 2595 2014-01-02 12:00:09Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.hの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
***************
*** 95,101 ****
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.c
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
--- 95,101 ----
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.cの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
***************
*** 109,115 ****
  $NL$
  
  $ 
! $  󥯥롼ɥǥ쥯ƥ֡#include
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
--- 109,115 ----
  $NL$
  
  $ 
! $  インクルードディレクティブ（#include）
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
***************
*** 119,125 ****
  $NL$
  
  $ 
! $  ֥ȤIDֹݻѿ
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
--- 119,125 ----
  $NL$
  
  $ 
! $  オブジェクトのID番号を保持する変数
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
***************
*** 159,165 ****
  $END$
  
  $ 
! $  ȥ졼ޥΥǥե
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
--- 159,165 ----
  $END$
  
  $ 
! $  トレースログマクロのデフォルト定義
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
***************
*** 175,224 ****
  $NL$
  
  $ 
! $  
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 1İʾ¸ߤ뤳ȤΥå
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ IDֹκ
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ 顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrʡTA_ACTϡˤǤʤE_RSATR
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)ǤʤE_PAR
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrTA_NULLˤǤʤE_RSATR
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ åΰȤ˴ؤ륨顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// stksz0ʲåκǾ͡TARGET_MIN_STKSZˤ
! $	// E_PAR
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszåΰΥȤʤE_PAR
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
--- 175,224 ----
  $NL$
  
  $ 
! $  タスク
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ タスクが1個以上存在することのチェック
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ タスクID番号の最大値
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ エラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrが（［TA_ACT］）でない場合（E_RSATR）
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)でない場合（E_PAR）
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrが（TA_NULL）でない場合（E_RSATR）
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ スタック領域の生成とそれに関するエラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// stkszが0以下か，ターゲット定義の最小値（TARGET_MIN_STKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
***************
*** 235,309 ****
  $END$
  $NL$
  
! $ ֥åʥ1İʾ¸ߤ
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// °ĥ󡤵ưϡưͥ
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// ƥȥ֥ååΰ
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// 㳰롼°ȵư
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ ֥å
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ ơ֥
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  ޥե
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ޥեIDֹκ
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ ޥե֥å
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)ǤʤE_PAR
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)ǤʤE_PAR
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// ޥե֥å
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ޥե֥å
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
--- 235,309 ----
  $END$
  $NL$
  
! $ タスク初期化ブロックの生成（タスクは1個以上存在する）
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// タスク属性，拡張情報，起動番地，起動時優先度
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// タスク初期化コンテキストブロック，スタック領域
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// タスク例外処理ルーチンの属性と起動番地
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ タスク管理ブロックの生成
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ タスク生成順序テーブルの生成
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  セマフォ
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ セマフォID番号の最大値
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ セマフォ初期化ブロックの生成
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)でない場合（E_PAR）
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)でない場合（E_PAR）
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// セマフォ初期化ブロック
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// セマフォ管理ブロック
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
***************
*** 311,348 ****
  $END$$NL$
  
  $ 
! $  ٥ȥե饰
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ٥ȥե饰IDֹκ
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ ٥ȥե饰֥å
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrʡTA_TPRIϡáTA_WMULϡáTA_CLRϡˤǤʤE_RSATR
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnFLGPTN˳ǼǤʤE_PAR
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// ٥ȥե饰֥å
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ٥ȥե饰֥å
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
--- 311,348 ----
  $END$$NL$
  
  $ 
! $  イベントフラグ
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ イベントフラグID番号の最大値
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ イベントフラグ初期化ブロックの生成
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrが（［TA_TPRI］｜［TA_WMUL］｜［TA_CLR］）でない場合（E_RSATR）
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnがFLGPTNに格納できない場合（E_PAR）
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// イベントフラグ初期化ブロック
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// イベントフラグ管理ブロック
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
***************
*** 350,390 ****
  $END$$NL$
  
  $ 
! $  ǡ塼
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ǡ塼IDֹκ
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntξE_PAR
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbNULLǤʤE_NOSPT
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// ǡ塼ΰ
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// ǡ塼֥å
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
--- 350,390 ----
  $END$$NL$
  
  $ 
! $  データキュー
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ データキューID番号の最大値
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntが負の場合（E_PAR）
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// データキュー管理領域
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// データキュー初期化ブロックの生成
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
***************
*** 392,398 ****
  	};$NL$
  	$NL$
  
! $	// ǡ塼֥å
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
--- 392,398 ----
  	};$NL$
  	$NL$
  
! $	// データキュー管理ブロック
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
***************
*** 400,445 ****
  $END$$NL$
  
  $ 
! $  ͥ٥ǡ塼
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ͥ٥ǡ塼IDֹκ
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntξE_PAR
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)ǤʤE_PAR
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbNULLǤʤE_NOSPT
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// ͥ٥ǡ塼ΰ
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// ͥ٥ǡ塼֥å
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
--- 400,445 ----
  $END$$NL$
  
  $ 
! $  優先度データキュー
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 優先度データキューID番号の最大値
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntが負の場合（E_PAR）
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)でない場合（E_PAR）
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// 優先度データキュー管理領域
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// 優先度データキュー初期化ブロックの生成
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
***************
*** 447,453 ****
  	};$NL$
  	$NL$
  
! $	// ͥ٥ǡ塼֥å
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
--- 447,453 ----
  	};$NL$
  	$NL$
  
! $	// 優先度データキュー管理ブロック
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
***************
*** 455,497 ****
  $END$$NL$
  
  $ 
! $  ᡼ܥå
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ᡼ܥåIDֹκ
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ ᡼ܥå֥å
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrʡTA_TPRIϡáTA_MPRIϡˤǤʤE_RSATR
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)ǤʤE_PAR
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdNULLǤʤE_NOSPT
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// ᡼ܥå֥å
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ᡼ܥå֥å
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
--- 455,497 ----
  $END$$NL$
  
  $ 
! $  メールボックス
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ メールボックスID番号の最大値
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ メールボックス初期化ブロックの生成
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrが（［TA_TPRI］｜［TA_MPRI］）でない場合（E_RSATR）
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)でない場合（E_PAR）
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdがNULLでない場合（E_NOSPT）
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// メールボックス初期化ブロック
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// メールボックス管理ブロック
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
***************
*** 499,544 ****
  $END$$NL$
  
  $
! $  åХåե
  $
  /*$NL$
  $SPC$*  Message Buffer Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ åХåեIDֹκ
  const ID _kernel_tmax_mbfid = (TMIN_MBFID + TNUM_MBFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MBF.ID_LIST)$
  	$FOREACH mbfid MBF.ID_LIST$
! $		// mbfatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (MBF.MBFATR[mbfid] & ~TA_TPRI) != 0$
  			$ERROR MBF.TEXT_LINE[mbfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbfatr", MBF.MBFATR[mbfid], mbfid, "CRE_MBF")$$END$
  		$END$
  
! $		// maxmsz0ʲξE_PAR
  		$IF MBF.MAXMSZ[mbfid] <= 0$
  			$ERROR MBF.TEXT_LINE[mbfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmsz", MBF.MAXMSZ[mbfid], mbfid, "CRE_MBF")$$END$
  		$END$
  
! $		// mbfszξE_PAR
  		$IF MBF.MBFSZ[mbfid] < 0$
  			$ERROR MBF.TEXT_LINE[mbfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbfsz", MBF.MBFSZ[mbfid], mbfid, "CRE_MBF")$$END$
  		$END$
  
! $		// mbfmbNULLǤʤE_NOSPT
  		$IF !EQ(MBF.MBFMB[mbfid], "NULL")$
  			$ERROR MBF.TEXT_LINE[mbfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbfmb", MBF.MBFMB[mbfid], mbfid, "CRE_MBF")$$END$
  		$END$
  
! $		// åХåեΰ
  		$IF MBF.MBFSZ[mbfid]$
  			static uint_t _kernel_mbfmb_$mbfid$[TOPPERS_COUNT_SZ($MBF.MBFSZ[mbfid]$, sizeof(uint_t))];$NL$
  		$END$
  	$END$
  
! $	// åХåե֥å
  	const MBFINIB _kernel_mbfinib_table[TNUM_MBFID] = {$NL$
  	$JOINEACH mbfid MBF.ID_LIST ",\n"$
  		$TAB${ ($MBF.MBFATR[mbfid]$), ($MBF.MAXMSZ[mbfid]$), TOPPERS_ROUND_SZ($MBF.MBFSZ[mbfid]$, sizeof(uint_t)), $IF MBF.MBFSZ[mbfid]$(_kernel_mbfmb_$mbfid$)$ELSE$NULL$END$ }
--- 499,544 ----
  $END$$NL$
  
  $
! $  メッセージバッファ
  $
  /*$NL$
  $SPC$*  Message Buffer Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ メッセージバッファID番号の最大値
  const ID _kernel_tmax_mbfid = (TMIN_MBFID + TNUM_MBFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MBF.ID_LIST)$
  	$FOREACH mbfid MBF.ID_LIST$
! $		// mbfatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (MBF.MBFATR[mbfid] & ~TA_TPRI) != 0$
  			$ERROR MBF.TEXT_LINE[mbfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbfatr", MBF.MBFATR[mbfid], mbfid, "CRE_MBF")$$END$
  		$END$
  
! $		// maxmszが0以下の場合（E_PAR）
  		$IF MBF.MAXMSZ[mbfid] <= 0$
  			$ERROR MBF.TEXT_LINE[mbfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmsz", MBF.MAXMSZ[mbfid], mbfid, "CRE_MBF")$$END$
  		$END$
  
! $		// mbfszが負の場合（E_PAR）
  		$IF MBF.MBFSZ[mbfid] < 0$
  			$ERROR MBF.TEXT_LINE[mbfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbfsz", MBF.MBFSZ[mbfid], mbfid, "CRE_MBF")$$END$
  		$END$
  
! $		// mbfmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(MBF.MBFMB[mbfid], "NULL")$
  			$ERROR MBF.TEXT_LINE[mbfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbfmb", MBF.MBFMB[mbfid], mbfid, "CRE_MBF")$$END$
  		$END$
  
! $		// メッセージバッファ管理領域
  		$IF MBF.MBFSZ[mbfid]$
  			static uint_t _kernel_mbfmb_$mbfid$[TOPPERS_COUNT_SZ($MBF.MBFSZ[mbfid]$, sizeof(uint_t))];$NL$
  		$END$
  	$END$
  
! $	// メッセージバッファ初期化ブロックの生成
  	const MBFINIB _kernel_mbfinib_table[TNUM_MBFID] = {$NL$
  	$JOINEACH mbfid MBF.ID_LIST ",\n"$
  		$TAB${ ($MBF.MBFATR[mbfid]$), ($MBF.MAXMSZ[mbfid]$), TOPPERS_ROUND_SZ($MBF.MBFSZ[mbfid]$, sizeof(uint_t)), $IF MBF.MBFSZ[mbfid]$(_kernel_mbfmb_$mbfid$)$ELSE$NULL$END$ }
***************
*** 546,552 ****
  	};$NL$
  	$NL$
  
! $	// åХåե֥å
  	MBFCB _kernel_mbfcb_table[TNUM_MBFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBFINIB, _kernel_mbfinib_table);$NL$
--- 546,552 ----
  	};$NL$
  	$NL$
  
! $	// メッセージバッファ管理ブロック
  	MBFCB _kernel_mbfcb_table[TNUM_MBFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBFINIB, _kernel_mbfinib_table);$NL$
***************
*** 554,602 ****
  $END$$NL$
  
  $ 
! $  Ĺס
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ĹסIDֹκ
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcnt0ʲξE_PAR
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blksz0ʲξE_PAR
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbNULLǤʤE_NOSPT
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// Ĺס֥å
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
--- 554,602 ----
  $END$$NL$
  
  $ 
! $  固定長メモリプール
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 固定長メモリプールID番号の最大値
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcntが0以下の場合（E_PAR）
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkszが0以下の場合（E_PAR）
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール領域
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール管理領域
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// 固定長メモリプール初期化ブロックの生成
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
***************
*** 604,610 ****
  	};$NL$
  	$NL$
  
! $	// Ĺס֥å
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
--- 604,610 ----
  	};$NL$
  	$NL$
  
! $	// 固定長メモリプール管理ブロック
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
***************
*** 612,659 ****
  $END$$NL$
  
  $ 
! $  ϥɥ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ϥɥIDֹκ
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ ϥɥơ֥
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrʡTA_STAϡˤǤʤE_RSATR
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// ٹcycatrTA_STAꤵƤơ(cycphs == 0)ξ
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// ϥɥ֥å
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ϥɥ֥å
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
--- 612,659 ----
  $END$$NL$
  
  $ 
! $  周期ハンドラ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 周期ハンドラID番号の最大値
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ 周期ハンドラ初期化テーブルの生成
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrが（［TA_STA］）でない場合（E_RSATR）
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// 警告：cycatrにTA_STAが設定されていて，(cycphs == 0)の場合
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// 周期ハンドラ初期化ブロック
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 周期ハンドラ管理ブロック
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
***************
*** 661,693 ****
  $END$$NL$
  
  $ 
! $  顼ϥɥ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 顼ϥɥIDֹκ
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ 顼ϥɥ֥å
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrTA_NULLˤǤʤE_RSATR
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// 顼ϥɥ֥å
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 顼ϥɥ֥å
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
--- 661,693 ----
  $END$$NL$
  
  $ 
! $  アラームハンドラ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ アラームハンドラID番号の最大値
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ アラームハンドラ初期化ブロックの生成
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrが（TA_NULL）でない場合（E_RSATR）
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// アラームハンドラ初期化ブロック
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// アラームハンドラ管理ブロック
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
***************
*** 695,708 ****
  $END$$NL$
  
  $ 
! $  ߴǽ
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ֹȳߥϥɥֹѴơ֥κ
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
--- 695,708 ----
  $END$$NL$
  
  $ 
! $  割込み管理機能
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 割込み番号と割込みハンドラ番号の変換テーブルの作成
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
***************
*** 714,728 ****
  	$i = i + 1$
  $END$
  
! $ ׵饤˴ؤ륨顼å
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoCFG_INTФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoCFG_INTˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
--- 714,728 ----
  	$i = i + 1$
  $END$
  
! $ 割込み要求ラインに関するエラーチェック
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoがCFG_INTに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoがCFG_INTによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
***************
*** 731,756 ****
  		$j = j + 1$
  	$END$
  
! $	// intatrʡTA_ENAINTϡáTA_EDGEϡˤǤʤE_RSATR
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriCFG_INTФͥ٤ȤʤE_PAR
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵ줿E_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵʤäE_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
--- 731,756 ----
  		$j = j + 1$
  	$END$
  
! $	// intatrが（［TA_ENAINT］｜［TA_EDGE］）でない場合（E_RSATR）
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriがCFG_INTに対する割込み優先度として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// カーネル管理に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定された場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定されなかった場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
***************
*** 759,773 ****
  	$i = i + 1$
  $END$
  
! $ ߥϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoDEF_INHФߥϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoDEF_INHˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
--- 759,773 ----
  	$i = i + 1$
  $END$
  
! $ 割込みハンドラに関するエラーチェック
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoがDEF_INHに対する割込みハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoがDEF_INHによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
***************
*** 776,796 ****
  		$j = j + 1$
  	$END$
  
! $	// inhatrTA_NULLˤǤʤE_RSATR
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	//ꤵƤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	// ꤵƤʤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
--- 776,796 ----
  		$j = j + 1$
  	$END$
  
! $	// inhatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// カーネル管理に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	//　が指定されている場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	// が指定されていない場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
***************
*** 799,819 ****
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoбintnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrTA_NONKERNELꤵƤ餺inhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRI⾮E_OBJ
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrTA_NONKERNELꤵƤꡤinhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRIʾǤE_OBJ
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
--- 799,819 ----
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoに対応するintnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrにTA_NONKERNELが指定されておらず，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRIよりも小さい場合（E_OBJ）
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrにTA_NONKERNELが指定されており，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRI以上である場合（E_OBJ）
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
***************
*** 823,841 ****
  	$i = i + 1$
  $END$
  
! $ ߥӥ롼ISRˤ˴ؤ륨顼åȳߥϥɥ
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrTA_NULLˤǤʤE_RSATR
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoATT_ISRФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)ǤʤE_PAR
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
--- 823,841 ----
  	$i = i + 1$
  $END$
  
! $ 割込みサービスルーチン（ISR）に関するエラーチェックと割込みハンドラの生成
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrが（TA_NULL）でない場合（E_RSATR）
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoがATT_ISRに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)でない場合（E_PAR）
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
***************
*** 844,850 ****
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// ֹintnoФϿ줿ISRΥꥹȤκ
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
--- 844,850 ----
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// 割込み番号intnoに対して登録されたISRのリストの作成
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
***************
*** 853,871 ****
  		$END$
  	$END$
  
! $	// ֹintnoФϿ줿ISR¸ߤ
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoбinhnoФDEF_INHE_OBJ
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoФCFG_INTꤵ줿ͥ٤TMIN_INTPRI
! $			// ⾮E_OBJ
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
--- 853,871 ----
  		$END$
  	$END$
  
! $	// 割込み番号intnoに対して登録されたISRが存在する場合
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoに対応するinhnoに対してDEF_INHがある場合（E_OBJ）
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoに対してCFG_INTで設定された割込み優先度がTMIN_INTPRI
! $			// よりも小さい場合（E_OBJ）
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
***************
*** 877,883 ****
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISRѤγߥϥɥ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
--- 877,883 ----
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISR用の割込みハンドラ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
***************
*** 889,895 ****
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRͥٽ˸ƤӽФ
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
--- 889,895 ----
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRを優先度順に呼び出す
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
***************
*** 902,913 ****
  $NL$
  
  $ 
! $  ߴǽΤɸŪʽ
  $ 
! $ ߥϥɥνɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ ߥϥɥ
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
--- 902,913 ----
  $NL$
  
  $ 
! $  割込み管理機能のための標準的な初期化情報の生成
  $ 
! $ 割込みハンドラの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ 割込みハンドラ数
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
***************
*** 918,924 ****
  $END$
  $NL$
  
! $ ߥϥɥơ֥
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
--- 918,924 ----
  $END$
  $NL$
  
! $ 割込みハンドラ初期化テーブル
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
***************
*** 934,948 ****
  $END$$NL$
  $END$
  
! $ ׵饤νɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ ׵饤
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ ׵饤ơ֥
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
--- 934,948 ----
  $END$$NL$
  $END$
  
! $ 割込み要求ラインの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ 割込み要求ライン数
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ 割込み要求ライン初期化テーブル
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
***************
*** 955,976 ****
  $END$
  
  $ 
! $  CPU㳰ǽ
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU㳰ϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoDEF_EXCФCPU㳰ϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoDEF_EXCˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
--- 955,976 ----
  $END$
  
  $ 
! $  CPU例外管理機能
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU例外ハンドラに関するエラーチェック
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoがDEF_EXCに対するCPU例外ハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoがDEF_EXCによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
***************
*** 979,995 ****
  		$j = j + 1$
  	$END$
  
! $	// excatrTA_NULLˤǤʤE_RSATR
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU㳰ϥɥΤɸŪʽ
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU㳰ϥɥ
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
--- 979,995 ----
  		$j = j + 1$
  	$END$
  
! $	// excatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU例外ハンドラのための標準的な初期化情報の生成
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU例外ハンドラ数
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
***************
*** 998,1004 ****
  $END$
  $NL$
  
! $ CPU㳰ϥɥơ֥
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
--- 998,1004 ----
  $END$
  $NL$
  
! $ CPU例外ハンドラ初期化テーブル
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
***************
*** 1011,1017 ****
  $END$
  
  $ 
! $  󥿥ƥѤΥåΰ
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
--- 1011,1017 ----
  $END$
  
  $ 
! $  非タスクコンテキスト用のスタック領域
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
***************
*** 1019,1025 ****
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSʤΥǥեͤ
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
--- 1019,1025 ----
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSがない場合のデフォルト値の設定
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
***************
*** 1034,1059 ****
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// ŪAPIDEF_ICSפʣE_OBJ
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istksz0ʲåκǾ͡TARGET_MIN_ISTKSZˤ
! $	// E_PAR
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszåΰΥȤʤE_PAR
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// åΰμưդ
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
--- 1034,1059 ----
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// 静的API「DEF_ICS」が複数ある（E_OBJ）
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istkszが0以下か，ターゲット定義の最小値（TARGET_MIN_ISTKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// スタック領域の自動割付け
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
***************
*** 1064,1070 ****
  $END$
  $NL$
  
! $ 󥿥ƥѤΥåΰ
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
--- 1064,1070 ----
  $END$
  $NL$
  
! $ 非タスクコンテキスト用のスタック領域
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
***************
*** 1074,1080 ****
  $NL$
  
  $ 
! $  ।٥ȴ
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
--- 1074,1080 ----
  $NL$
  
  $ 
! $  タイムイベント管理
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
***************
*** 1084,1090 ****
  $NL$
  
  $ 
! $  ƥ⥸塼νؿ
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
--- 1084,1090 ----
  $NL$
  
  $ 
! $  各モジュールの初期化関数
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
***************
*** 1109,1115 ****
  $NL$
  
  $ 
! $  롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
--- 1109,1115 ----
  $NL$
  
  $ 
! $  初期化ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
***************
*** 1119,1125 ****
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrTA_NULLˤǤʤE_RSATR
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
--- 1119,1125 ----
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrが（TA_NULL）でない場合（E_RSATR）
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
***************
*** 1129,1135 ****
  $NL$
  
  $ 
! $  λ롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
--- 1129,1135 ----
  $NL$
  
  $ 
! $  終了処理ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
***************
*** 1139,1145 ****
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrTA_NULLˤǤʤE_RSATR
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
--- 1139,1145 ----
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrが（TA_NULL）でない場合（E_RSATR）
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/kernel_impl.h ASPs/asp/extension/messagebuf/kernel/kernel_impl.h
*** 1.9.1/asp/extension/messagebuf/kernel/kernel_impl.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/kernel_impl.h	Fri Dec  9 13:54:01 2022
***************
*** 8,179 ****
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: kernel_impl.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥɸإåե
   *
!  *  ΥإåեϡͥץΥե
!  *  ɬ󥯥롼ɤ٤ɸإåեǤ롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   */
  
  #ifndef TOPPERS_KERNEL_IMPL_H
  #define TOPPERS_KERNEL_IMPL_H
  
  /*
!  *  ͥ̾Υ͡
   */
  #include "kernel_rename.h"
  
  /*
!  *  ץꥱȶ̤Υإåե
   */
  #include <kernel.h>
  
  /*
!  *  ƥǽΤ
   */
  #include <t_syslog.h>
  
  /*
!  *  㥹ȤԤޥ
   */
  #ifndef CAST
  #define CAST(type, val)		((type)(val))
  #endif /* CAST */
  
  /*
!  *  åȰ¸
   */
  #include "target_config.h"
  
  /*
!  *  ٤Ƥδؿ򥳥ѥ뤹뤿
   */
  #ifdef ALLFUNC
  #include "allfunc.h"
  #endif /* ALLFUNC */
  
  /*
!  *  ӥåȥեɤǤ̵
   *
!  *  8ӥåȰʲΥӥåȥեɤǡ̵ͤݻ
!  *  Ѥ٤ǡANSI CǤϡӥåȥեɤΥǡˤ
!  *  intunsigned intʤᡤǥեȤunsigned
!  *  intȤƤ뤬åȤӥġ¸ǡunsigned charޤ
!  *  unsigned shortΨɤ礬롥
   */
  #ifndef BIT_FIELD_UINT
  #define BIT_FIELD_UINT		unsigned int
  #endif /* BIT_FIELD_UINT */
  
  /*
!  *  ӥåȥեɤǤΥ֡뷿
   *
!  *  1ӥåΥӥåȥեɤǡ֡ͤݻѤ٤
!  *  ǡǥեȤǤBIT_FIELD_UINTƱƤ뤬֡
!  *  ͤݻ뤳Ȥ뤿̤̾ΤȤƤ롥
   */
  #ifndef BIT_FIELD_BOOL
  #define BIT_FIELD_BOOL		BIT_FIELD_UINT
  #endif /* BIT_FIELD_BOOL */
  
  /*
!  *  ֥IDκǾͤ
   */
! #define TMIN_TSKID		1		/* IDκǾ */
! #define TMIN_SEMID		1		/* ޥեIDκǾ */
! #define TMIN_FLGID		1		/* ե饰IDκǾ */
! #define TMIN_DTQID		1		/* ǡ塼IDκǾ */
! #define TMIN_PDQID		1		/* ͥ٥ǡ塼IDκǾ */
! #define TMIN_MBXID		1		/* ᡼ܥåIDκǾ */
! #define TMIN_MBFID		1		/* åХåեIDκǾ */
! #define TMIN_MPFID		1		/* ĹסIDκǾ */
! #define TMIN_CYCID		1		/* ϥɥIDκǾ */
! #define TMIN_ALMID		1		/* 顼ϥɥIDκǾ */
  
  /*
!  *  ͥ٤ʳ
   */
  #define TNUM_TPRI		(TMAX_TPRI - TMIN_TPRI + 1)
  #define TNUM_MPRI		(TMAX_MPRI - TMIN_MPRI + 1)
  #define TNUM_INTPRI		(TMAX_INTPRI - TMIN_INTPRI + 1)
  
  /*
!  *  إåեʤ⥸塼δؿѿ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ƥ⥸塼νkernel_cfg.c
   */
  extern void	initialize_object(void);
  
  /*
!  *  롼μ¹ԡkernel_cfg.c
   */
  extern void	call_inirtn(void);
  
  /*
!  *  λ롼μ¹ԡkernel_cfg.c
   */
  extern void	call_terrtn(void);
  
  /*
!  *  󥿥ƥѤΥåΰkernel_cfg.c
   */
! extern const SIZE	istksz;		/* åΰΥʴݤ᤿͡ */
! extern STK_T *const	istk;		/* åΰƬ */
  #ifdef TOPPERS_ISTKPT
! extern STK_T *const	istkpt;		/* åݥ󥿤ν */
  #endif /* TOPPERS_ISTKPT */
  
  /*
!  *  ͥư֥ե饰startup.c
   */
  extern bool_t	kerflg;
  
  /*
!  *  ͥεưstartup.c
   */
  extern void	sta_ker(void);
  
  /*
!  *  ͥνλstartup.c
   */
  extern void	exit_kernel(void);
  
--- 8,179 ----
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: kernel_impl.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル内部向け標準ヘッダファイル
   *
!  *  このヘッダファイルは，カーネルを構成するプログラムのソースファイル
!  *  で必ずインクルードするべき標準ヘッダファイルである．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   */
  
  #ifndef TOPPERS_KERNEL_IMPL_H
  #define TOPPERS_KERNEL_IMPL_H
  
  /*
!  *  カーネルの内部識別名のリネーム
   */
  #include "kernel_rename.h"
  
  /*
!  *  アプリケーションと共通のヘッダファイル
   */
  #include <kernel.h>
  
  /*
!  *  システムログ機能のための定義
   */
  #include <t_syslog.h>
  
  /*
!  *  型キャストを行うマクロの定義
   */
  #ifndef CAST
  #define CAST(type, val)		((type)(val))
  #endif /* CAST */
  
  /*
!  *  ターゲット依存情報の定義
   */
  #include "target_config.h"
  
  /*
!  *  すべての関数をコンパイルするための定義
   */
  #ifdef ALLFUNC
  #include "allfunc.h"
  #endif /* ALLFUNC */
  
  /*
!  *  ビットフィールドでの符号無し整数型
   *
!  *  8ビット以下の幅のビットフィールドで，符号無し整数値を保持したい場合
!  *  に用いるべきデータ型．ANSI Cでは，ビットフィールドのデータ型には
!  *  intとunsigned intしか許されないため，デフォルトの定義はunsigned
!  *  intとしているが，ターゲットおよびツール依存で，unsigned charまたは
!  *  unsigned shortに定義した方が効率が良い場合がある．
   */
  #ifndef BIT_FIELD_UINT
  #define BIT_FIELD_UINT		unsigned int
  #endif /* BIT_FIELD_UINT */
  
  /*
!  *  ビットフィールドでのブール型
   *
!  *  1ビット幅のビットフィールドで，ブール値を保持したい場合に用いるべき
!  *  データ型．デフォルトではBIT_FIELD_UINTと同一に定義しているが，ブー
!  *  ル値を保持することを明示するために別の名称としている．
   */
  #ifndef BIT_FIELD_BOOL
  #define BIT_FIELD_BOOL		BIT_FIELD_UINT
  #endif /* BIT_FIELD_BOOL */
  
  /*
!  *  オブジェクトIDの最小値の定義
   */
! #define TMIN_TSKID		1		/* タスクIDの最小値 */
! #define TMIN_SEMID		1		/* セマフォIDの最小値 */
! #define TMIN_FLGID		1		/* フラグIDの最小値 */
! #define TMIN_DTQID		1		/* データキューIDの最小値 */
! #define TMIN_PDQID		1		/* 優先度データキューIDの最小値 */
! #define TMIN_MBXID		1		/* メールボックスIDの最小値 */
! #define TMIN_MBFID		1		/* メッセージバッファIDの最小値 */
! #define TMIN_MPFID		1		/* 固定長メモリプールIDの最小値 */
! #define TMIN_CYCID		1		/* 周期ハンドラIDの最小値 */
! #define TMIN_ALMID		1		/* アラームハンドラIDの最小値 */
  
  /*
!  *  優先度の段階数の定義
   */
  #define TNUM_TPRI		(TMAX_TPRI - TMIN_TPRI + 1)
  #define TNUM_MPRI		(TMAX_MPRI - TMIN_MPRI + 1)
  #define TNUM_INTPRI		(TMAX_INTPRI - TMIN_INTPRI + 1)
  
  /*
!  *  ヘッダファイルを持たないモジュールの関数・変数の宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  各モジュールの初期化（kernel_cfg.c）
   */
  extern void	initialize_object(void);
  
  /*
!  *  初期化ルーチンの実行（kernel_cfg.c）
   */
  extern void	call_inirtn(void);
  
  /*
!  *  終了処理ルーチンの実行（kernel_cfg.c）
   */
  extern void	call_terrtn(void);
  
  /*
!  *  非タスクコンテキスト用のスタック領域（kernel_cfg.c）
   */
! extern const SIZE	istksz;		/* スタック領域のサイズ（丸めた値） */
! extern STK_T *const	istk;		/* スタック領域の先頭番地 */
  #ifdef TOPPERS_ISTKPT
! extern STK_T *const	istkpt;		/* スタックポインタの初期値 */
  #endif /* TOPPERS_ISTKPT */
  
  /*
!  *  カーネル動作状態フラグ（startup.c）
   */
  extern bool_t	kerflg;
  
  /*
!  *  カーネルの起動（startup.c）
   */
  extern void	sta_ker(void);
  
  /*
!  *  カーネルの終了処理（startup.c）
   */
  extern void	exit_kernel(void);
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/kernel_int.h ASPs/asp/extension/messagebuf/kernel/kernel_int.h
*** 1.9.1/asp/extension/messagebuf/kernel/kernel_int.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/kernel_int.h	Fri Dec  9 13:54:01 2022
***************
*** 8,59 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: kernel_int.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		kernel_cfg.cʤcfg1_out.cѥإåե
   */
  
  #ifndef TOPPERS_KERNEL_INT_H
  #define TOPPERS_KERNEL_INT_H
  
  /*
!  *  ͥɸإåե
   */
  #include "kernel_impl.h"
  
  /*
!  *  ͥγƥإåե
   */
  #include "task.h"
  #include "semaphore.h"
--- 8,59 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: kernel_int.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		kernel_cfg.c（およびcfg1_out.c）用ヘッダファイル
   */
  
  #ifndef TOPPERS_KERNEL_INT_H
  #define TOPPERS_KERNEL_INT_H
  
  /*
!  *  カーネル標準ヘッダファイル
   */
  #include "kernel_impl.h"
  
  /*
!  *  カーネルの各ヘッダファイル
   */
  #include "task.h"
  #include "semaphore.h"
***************
*** 70,81 ****
  #include "time_event.h"
  
  /*
!  *  ͡षܥ򸵤᤹Υإåե
   */
  #include "kernel_unrename.h"
  
  /*
!  *  Ƥ뤿Υޥ
   */
  #ifndef TOPPERS_EMPTY_LABEL
  #define TOPPERS_EMPTY_LABEL(type, var)		type var[0]
--- 70,81 ----
  #include "time_event.h"
  
  /*
!  *  リネームしたシンボルを元に戻すためのヘッダファイル
   */
  #include "kernel_unrename.h"
  
  /*
!  *  内容が空の配列を生成するためのマクロ
   */
  #ifndef TOPPERS_EMPTY_LABEL
  #define TOPPERS_EMPTY_LABEL(type, var)		type var[0]
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/messagebuf.c ASPs/asp/extension/messagebuf/kernel/messagebuf.c
*** 1.9.1/asp/extension/messagebuf/kernel/messagebuf.c	Sun Apr 13 18:38:35 2014
--- ASPs/asp/extension/messagebuf/kernel/messagebuf.c	Fri Dec  9 13:54:01 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: messagebuf.c 2629 2014-04-13 09:38:28Z ertl-hiro $
   */
  
  /*
!  *		åХåեǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: messagebuf.c 2629 2014-04-13 09:38:28Z ertl-hiro $
   */
  
  /*
!  *		メッセージバッファ機能
   */
  
  #include "kernel_impl.h"
***************
*** 52,58 ****
  #include <string.h>
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SND_MBF_ENTER
  #define LOG_SND_MBF_ENTER(mbfid, msg, msgsz)
--- 52,58 ----
  #include <string.h>
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SND_MBF_ENTER
  #define LOG_SND_MBF_ENTER(mbfid, msg, msgsz)
***************
*** 119,137 ****
  #endif /* LOG_REF_MBF_LEAVE */
  
  /*
!  *  åХåեο
   */
  #define tnum_mbf	((uint_t)(tmax_mbfid - TMIN_MBFID + 1))
  
  /*
!  *  åХåեIDåХåե֥åФ
!  *  Υޥ
   */
  #define INDEX_MBF(mbfid)	((uint_t)((mbfid) - TMIN_MBFID))
  #define get_mbfcb(mbfid)	(&(mbfcb_table[INDEX_MBF(mbfid)]))
  
  /*
!  *  եå롼ƽФѤѿ
   */
  #ifdef TOPPERS_mbfhook
  
--- 119,137 ----
  #endif /* LOG_REF_MBF_LEAVE */
  
  /*
!  *  メッセージバッファの数
   */
  #define tnum_mbf	((uint_t)(tmax_mbfid - TMIN_MBFID + 1))
  
  /*
!  *  メッセージバッファIDからメッセージバッファ管理ブロックを取り出すた
!  *  めのマクロ
   */
  #define INDEX_MBF(mbfid)	((uint_t)((mbfid) - TMIN_MBFID))
  #define get_mbfcb(mbfid)	(&(mbfcb_table[INDEX_MBF(mbfid)]))
  
  /*
!  *  フックルーチン呼出し用の変数
   */
  #ifdef TOPPERS_mbfhook
  
***************
*** 141,147 ****
  #endif /* TOPPERS_mbfhook */
  
  /*
!  *  åХåեǽν
   */
  #ifdef TOPPERS_mbfini
  
--- 141,147 ----
  #endif /* TOPPERS_mbfhook */
  
  /*
!  *  メッセージバッファ機能の初期化
   */
  #ifdef TOPPERS_mbfini
  
***************
*** 169,175 ****
  #endif /* TOPPERS_mbfini */
  
  /*
!  *  åХåեΰؤΥåγǼ
   */
  #ifdef TOPPERS_mbfenq
  
--- 169,175 ----
  #endif /* TOPPERS_mbfini */
  
  /*
!  *  メッセージバッファ管理領域へのメッセージの格納
   */
  #ifdef TOPPERS_mbfenq
  
***************
*** 212,218 ****
  #endif /* TOPPERS_mbfenq */
  
  /*
!  *  åХåեΰ褫ΥåμФ
   */
  #ifdef TOPPERS_mbfdeq
  
--- 212,218 ----
  #endif /* TOPPERS_mbfenq */
  
  /*
!  *  メッセージバッファ管理領域からのメッセージの取出し
   */
  #ifdef TOPPERS_mbfdeq
  
***************
*** 253,273 ****
  #endif /* TOPPERS_mbfdeq */
  
  /*
!  *  Ԥ˼ͥ褷ƥåǤ륿¸
!  *  ߤʤtrue֤ؿ
   */
  Inline bool_t
  have_precedence(MBFCB *p_mbfcb)
  {
  	if (queue_empty(&(p_mbfcb->swait_queue))) {
! 		/* Ԥ󤬶λ */
  		return(true);
  	}
  	else if ((p_mbfcb->p_mbfinib->mbfatr & TA_TPRI) != 0) {
  		if (((TCB *)(p_mbfcb->swait_queue.p_next))->priority
  												> p_runtsk->priority) {
! 			/* Ԥ󤬥ͥٽǡ
! 					ƬΥͥ٤ͥ٤㤤 */
  			return(true);
  		}
  	}
--- 253,273 ----
  #endif /* TOPPERS_mbfdeq */
  
  /*
!  *  送信待ち行列に自タスクより優先してメッセージを送信できるタスクが存
!  *  在しない場合にtrueを返す関数
   */
  Inline bool_t
  have_precedence(MBFCB *p_mbfcb)
  {
  	if (queue_empty(&(p_mbfcb->swait_queue))) {
! 		/* 送信待ち行列が空の時 */
  		return(true);
  	}
  	else if ((p_mbfcb->p_mbfinib->mbfatr & TA_TPRI) != 0) {
  		if (((TCB *)(p_mbfcb->swait_queue.p_next))->priority
  												> p_runtsk->priority) {
! 			/* 送信待ち行列がタスクの優先度順で，
! 					先頭のタスクの優先度が自タスクの優先度よりも低い時 */
  			return(true);
  		}
  	}
***************
*** 275,281 ****
  }
  
  /*
!  *  åХåեؤΥå
   */
  #ifdef TOPPERS_mbfsnd
  
--- 275,281 ----
  }
  
  /*
!  *  メッセージバッファへのメッセージ送信
   */
  #ifdef TOPPERS_mbfsnd
  
***************
*** 304,315 ****
  #endif /* TOPPERS_mbfsnd */
  
  /*
!  *  åХåեԤΥå
   *
!  *  åХåեԤ塼ƬΥå
!  *  åХåեΰ˳Ǽ뤳ȤǤгǼԤ
!  *  롥νƬΥåǼǤʤʤޤ
!  *  ֤
   */
  #ifdef TOPPERS_mbfsig
  
--- 304,315 ----
  #endif /* TOPPERS_mbfsnd */
  
  /*
!  *  メッセージバッファ送信待ちタスクのチェック
   *
!  *  メッセージバッファ送信待ちキューの先頭のタスクの送信メッセージが，
!  *  メッセージバッファ管理領域に格納することできれば格納し，待ち解除す
!  *  る．この処理を，先頭のタスクの送信メッセージが格納できなくなるまで
!  *  繰り返す．
   */
  #ifdef TOPPERS_mbfsig
  
***************
*** 338,344 ****
  #endif /* TOPPERS_mbfsig */
  
  /*
!  *  åХåեΥå
   */
  #ifdef TOPPERS_mbfrcv
  
--- 338,344 ----
  #endif /* TOPPERS_mbfsig */
  
  /*
!  *  メッセージバッファからのメッセージ受信
   */
  #ifdef TOPPERS_mbfrcv
  
***************
*** 368,374 ****
  #endif /* TOPPERS_mbfrcv */
  
  /*
!  *  åХåեԤԤ
   */
  #ifdef TOPPERS_mbfwobj
  
--- 368,374 ----
  #endif /* TOPPERS_mbfrcv */
  
  /*
!  *  メッセージバッファ送信待ちタスクの待ち解除時処理
   */
  #ifdef TOPPERS_mbfwobj
  
***************
*** 381,387 ****
  #endif /* TOPPERS_mbfwobj */
  
  /*
!  *  åХåեԤͥѹ
   */
  #ifdef TOPPERS_mbfpri
  
--- 381,387 ----
  #endif /* TOPPERS_mbfwobj */
  
  /*
!  *  メッセージバッファ送信待ちタスクの優先度変更時処理
   */
  #ifdef TOPPERS_mbfpri
  
***************
*** 394,400 ****
  #endif /* TOPPERS_mbfpri */
  
  /*
!  *  åХåեؤ
   */
  #ifdef TOPPERS_snd_mbf
  
--- 394,400 ----
  #endif /* TOPPERS_mbfpri */
  
  /*
!  *  メッセージバッファへの送信
   */
  #ifdef TOPPERS_snd_mbf
  
***************
*** 437,443 ****
  #endif /* TOPPERS_snd_mbf */
  
  /*
!  *  åХåեؤʥݡ󥰡
   */
  #ifdef TOPPERS_psnd_mbf
  
--- 437,443 ----
  #endif /* TOPPERS_snd_mbf */
  
  /*
!  *  メッセージバッファへの送信（ポーリング）
   */
  #ifdef TOPPERS_psnd_mbf
  
***************
*** 474,480 ****
  #endif /* TOPPERS_psnd_mbf */
  
  /*
!  *  åХåեؤʥॢȤ
   */
  #ifdef TOPPERS_tsnd_mbf
  
--- 474,480 ----
  #endif /* TOPPERS_psnd_mbf */
  
  /*
!  *  メッセージバッファへの送信（タイムアウトあり）
   */
  #ifdef TOPPERS_tsnd_mbf
  
***************
*** 523,529 ****
  #endif /* TOPPERS_tsnd_mbf */
  
  /*
!  *  åХåեμ
   */
  #ifdef TOPPERS_rcv_mbf
  
--- 523,529 ----
  #endif /* TOPPERS_tsnd_mbf */
  
  /*
!  *  メッセージバッファからの受信
   */
  #ifdef TOPPERS_rcv_mbf
  
***************
*** 571,577 ****
  #endif /* TOPPERS_rcv_mbf */
  
  /*
!  *  åХåեμʥݡ󥰡
   */
  #ifdef TOPPERS_prcv_mbf
  
--- 571,577 ----
  #endif /* TOPPERS_rcv_mbf */
  
  /*
!  *  メッセージバッファからの受信（ポーリング）
   */
  #ifdef TOPPERS_prcv_mbf
  
***************
*** 608,614 ****
  #endif /* TOPPERS_prcv_mbf */
  
  /*
!  *  åХåեμʥॢȤ
   */
  #ifdef TOPPERS_trcv_mbf
  
--- 608,614 ----
  #endif /* TOPPERS_prcv_mbf */
  
  /*
!  *  メッセージバッファからの受信（タイムアウトあり）
   */
  #ifdef TOPPERS_trcv_mbf
  
***************
*** 661,667 ****
  #endif /* TOPPERS_trcv_mbf */
  
  /*
!  *  åХåեκƽ
   */
  #ifdef TOPPERS_ini_mbf
  
--- 661,667 ----
  #endif /* TOPPERS_trcv_mbf */
  
  /*
!  *  メッセージバッファの再初期化
   */
  #ifdef TOPPERS_ini_mbf
  
***************
*** 700,706 ****
  #endif /* TOPPERS_ini_mbf */
  
  /*
!  *  åХåեξֻ
   */
  #ifdef TOPPERS_ref_mbf
  
--- 700,706 ----
  #endif /* TOPPERS_ini_mbf */
  
  /*
!  *  メッセージバッファの状態参照
   */
  #ifdef TOPPERS_ref_mbf
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/messagebuf.h ASPs/asp/extension/messagebuf/kernel/messagebuf.h
*** 1.9.1/asp/extension/messagebuf/kernel/messagebuf.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/messagebuf.h	Fri Dec  9 13:54:01 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: messagebuf.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		åХåեǽ
   */
  
  #ifndef TOPPERS_MESSAGEBUF_H
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: messagebuf.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		メッセージバッファ機能
   */
  
  #ifndef TOPPERS_MESSAGEBUF_H
***************
*** 50,161 ****
  #include "wait.h"
  
  /*
!  *  åХåե֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct messagebuf_initialization_block {
! 	ATR			mbfatr;			/* åХåե° */
! 	uint_t		maxmsz;			/* åκĹ */
! 	SIZE		mbfsz;			/* åХåեΰΥ */
! 	void		*mbfmb;			/* åХåեΰƬ */
  } MBFINIB;
  
  /*
!  *  åХåե֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct messagebuf_control_block {
! 	QUEUE		swait_queue;	/* åХåեԤ塼 */
! 	const MBFINIB *p_mbfinib;	/* ֥åؤΥݥ */
! 	QUEUE		rwait_queue;	/* åХåեԤ塼 */
! 	SIZE		fmbfsz;			/* ΰΥ */
! 	SIZE		head;			/* ǽΥåγǼ */
! 	SIZE		tail;			/* ǸΥåγǼμ */
! 	uint_t		smbfcnt;		/* ΰ˳ǼƤåο */
  } MBFCB;
  
  /*
!  *  åХåեԤ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
!  *  åХåեؤԤȥåХåեμԤǡ
!  *  ƱԤ֥åȤ
   */
  typedef struct messagebuf_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	MBFCB		*p_mbfcb;		/* ԤäƤåХåեδ֥å */
! 	void		*msg;			/* å */
! 	uint_t		msgsz;			/* å */
  } WINFO_MBF;
  
  /*
!  *  åХåեIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_mbfid;
  
  /*
!  *  åХåե֥åΥꥢkernel_cfg.c
   */
  extern const MBFINIB	mbfinib_table[];
  
  /*
!  *  åХåե֥åΥꥢkernel_cfg.c
   */
  extern MBFCB	mbfcb_table[];
  
  /*
!  *  åХåե֥ååХåեIDФ
!  *  Υޥ
   */
  #define	MBFID(p_mbfcb)	((ID)(((p_mbfcb) - mbfcb_table) + TMIN_MBFID))
  
  /*
!  *  åХåեǽν
   */
  extern void	initialize_messagebuf(void);
  
  /*
!  *  åХåեΰؤΥåγǼ
   */
  extern bool_t	enqueue_message(MBFCB *p_mbfcb, const void *msg, uint_t msgsz);
  
  /*
!  *  åХåեΰ褫ΥåμФ
   */
  extern uint_t	dequeue_message(MBFCB *p_mbfcb, void *msg);
  
  /*
!  *  åХåեؤΥå
   */
  extern bool_t	send_message(MBFCB *p_mbfcb, const void *msg,
  											uint_t msgsz, bool_t *p_dspreq);
  
  /*
!  *  åХåեԤΥå
   */
  extern bool_t	messagebuf_signal(MBFCB *p_mbfcb);
  
  /*
!  *  åХåեΥå
   */
  extern uint_t	receive_message(MBFCB *p_mbfcb, void *msg, bool_t *p_dspreq);
  
  /*
!  *  åХåեԤԤ
   */
  extern bool_t	(*mbfhook_dequeue_wobj)(TCB *p_tcb);
  extern bool_t	messagebuf_dequeue_wobj(TCB *p_tcb);
  
  /*
!  *  åХåեԤͥѹ
   */
  extern bool_t	(*mbfhook_change_priority)(WOBJCB *p_wobjcb);
  extern bool_t	messagebuf_change_priority(WOBJCB *p_wobjcb);
--- 50,161 ----
  #include "wait.h"
  
  /*
!  *  メッセージバッファ初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct messagebuf_initialization_block {
! 	ATR			mbfatr;			/* メッセージバッファ属性 */
! 	uint_t		maxmsz;			/* メッセージの最大長 */
! 	SIZE		mbfsz;			/* メッセージバッファ管理領域のサイズ */
! 	void		*mbfmb;			/* メッセージバッファ管理領域の先頭番地 */
  } MBFINIB;
  
  /*
!  *  メッセージバッファ管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct messagebuf_control_block {
! 	QUEUE		swait_queue;	/* メッセージバッファ送信待ちキュー */
! 	const MBFINIB *p_mbfinib;	/* 初期化ブロックへのポインタ */
! 	QUEUE		rwait_queue;	/* メッセージバッファ受信待ちキュー */
! 	SIZE		fmbfsz;			/* 空き領域のサイズ */
! 	SIZE		head;			/* 最初のメッセージの格納場所 */
! 	SIZE		tail;			/* 最後のメッセージの格納場所の次 */
! 	uint_t		smbfcnt;		/* 管理領域に格納されているメッセージの数 */
  } MBFCB;
  
  /*
!  *  メッセージバッファ待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
!  *  メッセージバッファへの送信待ちとメッセージバッファからの受信待ちで，
!  *  同じ待ち情報ブロックを使う．
   */
  typedef struct messagebuf_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	MBFCB		*p_mbfcb;		/* 待っているメッセージバッファの管理ブロック */
! 	void		*msg;			/* 送受信メッセージ */
! 	uint_t		msgsz;			/* 送受信メッセージサイズ */
  } WINFO_MBF;
  
  /*
!  *  メッセージバッファIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_mbfid;
  
  /*
!  *  メッセージバッファ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const MBFINIB	mbfinib_table[];
  
  /*
!  *  メッセージバッファ管理ブロックのエリア（kernel_cfg.c）
   */
  extern MBFCB	mbfcb_table[];
  
  /*
!  *  メッセージバッファ管理ブロックからメッセージバッファIDを取り出すた
!  *  めのマクロ
   */
  #define	MBFID(p_mbfcb)	((ID)(((p_mbfcb) - mbfcb_table) + TMIN_MBFID))
  
  /*
!  *  メッセージバッファ機能の初期化
   */
  extern void	initialize_messagebuf(void);
  
  /*
!  *  メッセージバッファ管理領域へのメッセージの格納
   */
  extern bool_t	enqueue_message(MBFCB *p_mbfcb, const void *msg, uint_t msgsz);
  
  /*
!  *  メッセージバッファ管理領域からのメッセージの取出し
   */
  extern uint_t	dequeue_message(MBFCB *p_mbfcb, void *msg);
  
  /*
!  *  メッセージバッファへのメッセージ送信
   */
  extern bool_t	send_message(MBFCB *p_mbfcb, const void *msg,
  											uint_t msgsz, bool_t *p_dspreq);
  
  /*
!  *  メッセージバッファ送信待ちタスクのチェック
   */
  extern bool_t	messagebuf_signal(MBFCB *p_mbfcb);
  
  /*
!  *  メッセージバッファからのメッセージ受信
   */
  extern uint_t	receive_message(MBFCB *p_mbfcb, void *msg, bool_t *p_dspreq);
  
  /*
!  *  メッセージバッファ送信待ちタスクの待ち解除時処理
   */
  extern bool_t	(*mbfhook_dequeue_wobj)(TCB *p_tcb);
  extern bool_t	messagebuf_dequeue_wobj(TCB *p_tcb);
  
  /*
!  *  メッセージバッファ送信待ちタスクの優先度変更時処理
   */
  extern bool_t	(*mbfhook_change_priority)(WOBJCB *p_wobjcb);
  extern bool_t	messagebuf_change_priority(WOBJCB *p_wobjcb);
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/task.c ASPs/asp/extension/messagebuf/kernel/task.c
*** 1.9.1/asp/extension/messagebuf/kernel/task.c	Thu Jan  2 14:53:51 2014
--- ASPs/asp/extension/messagebuf/kernel/task.c	Fri Dec  9 13:54:01 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.c 2592 2014-01-02 05:53:50Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.c 2592 2014-01-02 05:53:50Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
***************
*** 62,108 ****
  #ifdef TOPPERS_tskini
  
  /*
!  *  ¹Ծ֤Υ
   */
  TCB		*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   */
  TCB		*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   */
  bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   */
  bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   */
  bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   */
  bool_t	dspflg;
  
  /*
!  *  ǥ塼
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   */
  uint16_t	ready_primap;
  
  /*
!  *  ⥸塼ν
   */
  void
  initialize_task(void)
--- 62,108 ----
  #ifdef TOPPERS_tskini
  
  /*
!  *  実行状態のタスク
   */
  TCB		*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   */
  TCB		*p_schedtsk;
  
  /*
!  *  タスクディスパッチ／タスク例外処理ルーチン起動要求フラグ
   */
  bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   */
  bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   */
  bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   */
  bool_t	dspflg;
  
  /*
!  *  レディキュー
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   */
  uint16_t	ready_primap;
  
  /*
!  *  タスク管理モジュールの初期化
   */
  void
  initialize_task(void)
***************
*** 137,158 ****
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ӥåȥޥåץؿ
   *
!  *  bitmap1ΥӥåȤ⡤ǤⲼ̡ʱˤΤΤ򥵡Υӥ
!  *  ֹ֤ӥåֹϡǲ̥ӥåȤ0Ȥ롥bitmap0
!  *  ƤϤʤʤδؿǤϡbitmap16ӥåȤǤ뤳Ȥꤷ
!  *  uint16_tȤƤ롥
   *
!  *  ӥåȥ̿ĥץåǤϡӥåȥ̿Ȥ褦
!  *  ľΨɤ礬롥Τ褦ʾˤϡå
!  *  ¸ǥӥåȥ̿Ȥäbitmap_search
!  *  OMIT_BITMAP_SEARCHޥФ褤ޤӥåȥ̿
!  *  դʤɤͳͥ٤ȥӥåȤȤбѹ
!  *  ϡPRIMAP_BITޥФ褤
   *
!  *  ޤ饤֥ffsʤ顤Τ褦ƥ饤֥ؿ
!  *  ȤäΨɤǽ⤢롥
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
--- 137,158 ----
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ビットマップサーチ関数
   *
!  *  bitmap内の1のビットの内，最も下位（右）のものをサーチし，そのビッ
!  *  ト番号を返す．ビット番号は，最下位ビットを0とする．bitmapに0を指定
!  *  してはならない．この関数では，bitmapが16ビットであることを仮定し，
!  *  uint16_t型としている．
   *
!  *  ビットサーチ命令を持つプロセッサでは，ビットサーチ命令を使うように
!  *  書き直した方が効率が良い場合がある．このような場合には，ターゲット
!  *  依存部でビットサーチ命令を使ったbitmap_searchを定義し，
!  *  OMIT_BITMAP_SEARCHをマクロ定義すればよい．また，ビットサーチ命令の
!  *  サーチ方向が逆などの理由で優先度とビットとの対応を変更したい場合に
!  *  は，PRIMAP_BITをマクロ定義すればよい．
   *
!  *  また，ライブラリにffsがあるなら，次のように定義してライブラリ関数を
!  *  使った方が効率が良い可能性もある．
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
***************
*** 184,190 ****
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline bool_t
  primap_empty(void)
--- 184,190 ----
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  優先度ビットマップが空かのチェック
   */
  Inline bool_t
  primap_empty(void)
***************
*** 193,199 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥ
   */
  Inline uint_t
  primap_search(void)
--- 193,199 ----
  }
  
  /*
!  *  優先度ビットマップのサーチ
   */
  Inline uint_t
  primap_search(void)
***************
*** 202,208 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline void
  primap_set(uint_t pri)
--- 202,208 ----
  }
  
  /*
!  *  優先度ビットマップのセット
   */
  Inline void
  primap_set(uint_t pri)
***************
*** 211,217 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥꥢ
   */
  Inline void
  primap_clear(uint_t pri)
--- 211,217 ----
  }
  
  /*
!  *  優先度ビットマップのクリア
   */
  Inline void
  primap_clear(uint_t pri)
***************
*** 220,226 ****
  }
  
  /*
!  *  ǹ̥ͥΥ
   */
  #ifdef TOPPERS_tsksched
  
--- 220,226 ----
  }
  
  /*
!  *  最高優先順位タスクのサーチ
   */
  #ifdef TOPPERS_tsksched
  
***************
*** 236,246 ****
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡ¹ԤǤ륿ʤä
!  *  ȡp_tcbͥ٤ǹ̤ͥΥͥ٤⤤Ǥ
!  *  롥
   */
  #ifdef TOPPERS_tskrun
  
--- 236,246 ----
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  実行できる状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，実行できるタスクがなかった場合
!  *  と，p_tcbの優先度が最高優先順位のタスクの優先度よりも高い場合であ
!  *  る．
   */
  #ifdef TOPPERS_tskrun
  
***************
*** 262,273 ****
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡp_tcbǹ̤ͥΥ
!  *  äǤ롥p_tcbƱͥ٤Υ¾ˤϡp_tcb
!  *  μΥǹ̤ͥˤʤ롥Ǥʤϡǥ塼
!  *  ɬפ롥
   */
  #ifdef TOPPERS_tsknrun
  
--- 262,273 ----
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，p_tcbが最高優先順位のタスクで
!  *  あった場合である．p_tcbと同じ優先度のタスクが他にある場合は，p_tcb
!  *  の次のタスクが最高優先順位になる．そうでない場合は，レディキューを
!  *  サーチする必要がある．
   */
  #ifdef TOPPERS_tsknrun
  
***************
*** 297,303 ****
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  ٻ߾֤ؤ
   */
  #ifdef TOPPERS_tskdmt
  
--- 297,303 ----
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  休止状態への遷移
   */
  #ifdef TOPPERS_tskdmt
  
***************
*** 315,321 ****
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   */
  #ifdef TOPPERS_tskact
  
--- 315,321 ----
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  休止状態から実行できる状態への遷移
   */
  #ifdef TOPPERS_tskact
  
***************
*** 331,346 ****
  #endif /* TOPPERS_tskact */
  
  /*
!  *  ͥ٤ѹ
   *
!  *  ¹ԤǤ֤ξˤϡǥ塼Ǥΰ֤ѹ
!  *  롥֥ȤԤ塼Ԥ֤ˤʤäƤˤϡ
!  *  塼Ǥΰ֤ѹ롥
   *
!  *  ǹ̤ͥΥ򹹿Τϡ(1) p_tcbǹ̤ͥΥ
!  *  Ǥäơͥ٤򲼤硤(2) p_tcbǹ̤ͥΥ
!  *  ǤϤʤѹͥ٤ǹ̤ͥΥͥ٤⤤
!  *  Ǥ롥(1)ξˤϡǥ塼򥵡ɬפ롥
   */
  #ifdef TOPPERS_tskpri
  
--- 331,346 ----
  #endif /* TOPPERS_tskact */
  
  /*
!  *  タスクの優先度の変更
   *
!  *  タスクが実行できる状態の場合には，レディキューの中での位置を変更す
!  *  る．オブジェクトの待ちキューの中で待ち状態になっている場合には，待
!  *  ちキューの中での位置を変更する．
   *
!  *  最高優先順位のタスクを更新するのは，(1) p_tcbが最高優先順位のタス
!  *  クであって，その優先度を下げた場合，(2) p_tcbが最高優先順位のタス
!  *  クではなく，変更後の優先度が最高優先順位のタスクの優先度よりも高い
!  *  場合である．(1)の場合には，レディキューをサーチする必要がある．
   */
  #ifdef TOPPERS_tskpri
  
***************
*** 354,360 ****
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤ξ
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
--- 354,360 ----
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  タスクが実行できる状態の場合
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
***************
*** 379,386 ****
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  Ʊ֥̿Ȥδ֥åζ
! 			 *  ʬWOBJCBˤԤ塼ˤĤʤƤ
  			 */
  			return(wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))
  														->p_wobjcb, p_tcb));
--- 379,386 ----
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  タスクが，同期・通信オブジェクトの管理ブロックの共通部
! 			 *  分（WOBJCB）の待ちキューにつながれている場合
  			 */
  			return(wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))
  														->p_wobjcb, p_tcb));
***************
*** 392,401 ****
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  ǥ塼βž
   *
!  *  ǹ̤ͥΥ򹹿Τϡǹ̤ͥΥ
!  *  塼˰ưǤ롥
   */
  #ifdef TOPPERS_tskrot
  
--- 392,401 ----
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  レディキューの回転
   *
!  *  最高優先順位のタスクを更新するのは，最高優先順位のタスクがタスクキ
!  *  ューの末尾に移動した場合である．
   */
  #ifdef TOPPERS_tskrot
  
***************
*** 419,428 ****
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  㳰롼θƽФ
   *
!  *  ASPͥǤϡ㳰롼CPUå֤ܤ
!  *  ξ֤ᤵ˥꥿󤷤硤ͥ뤬ξ֤᤹
   */
  #ifdef TOPPERS_tsktex
  
--- 419,428 ----
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  ASPカーネルでは，タスク例外処理ルーチン内でCPUロック状態に遷移し，
!  *  元の状態に戻さずにリターンした場合，カーネルが元の状態に戻す．
   */
  #ifdef TOPPERS_tsktex
  
***************
*** 455,464 ****
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  dispatchƤӽФϡߺƵƽФˤʤä
! 			 *  뤬dispatchƤp_runtsk->enatexfalseˤ
! 			 *  лپ㤬ʤͳˤĤƤϡTOPPERS/ASP 
! 			 *  ͥ ߷ץפ򻲾ȤΤȡ
  			 */
  			dispatch();
  		}
--- 455,464 ----
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  ここでdispatchを呼び出す処理は，相互再帰呼出しになって
! 			 *  いるが，dispatchを呼ぶ前にp_runtsk->enatexをfalseにして
! 			 *  おけば支障がない．その理由については，「TOPPERS/ASP カー
! 			 *  ネル 設計メモ」を参照のこと．
  			 */
  			dispatch();
  		}
***************
*** 467,473 ****
  }
  
  /*
!  *  㳰롼εư
   */
  #ifndef OMIT_CALLTEX
  
--- 467,473 ----
  }
  
  /*
!  *  タスク例外処理ルーチンの起動
   */
  #ifndef OMIT_CALLTEX
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/task.h ASPs/asp/extension/messagebuf/kernel/task.h
*** 1.9.1/asp/extension/messagebuf/kernel/task.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/task.h	Fri Dec  9 13:54:01 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #ifndef TOPPERS_TASK_H
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #ifndef TOPPERS_TASK_H
***************
*** 51,101 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  ͥ٤ɽɽѴޥ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  ֤ɽ
   *
!  *  TCBΥ֤Ǥϡ¹Ծ֡RUNNINGˤȼ¹Բǽ֡READY
!  *  ϶̤ʤξ֤Τơ¹ԤǤ֡RUNNABLEˤȸƤ֡
!  *  Ԥ֤ϡ(TS_WAITING | TS_SUSPENDED)ɽTS_WAIT_???
!  *  װɽԤ֡Ԥ֤ޤˤξˤΤꤹ롥
!  */
! #define TS_DORMANT		0x00U			/* ٻ߾ */
! #define TS_RUNNABLE		0x01U			/* ¹ԤǤ */
! #define TS_WAITING		0x02U			/* Ԥ */
! #define TS_SUSPENDED	0x04U			/* Ԥ */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* ַвԤ */
! #define TS_WAIT_SLP		(0x01U << 3)	/* Ԥ */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* ǡ塼μԤ */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* ͥ٥ǡ塼μԤ */
! #define TS_WAIT_RMBF	(0x04U << 3)	/* åХåեμԤ */
! #define TS_WAIT_SEM		(0x05U << 3)	/* ޥե񸻤γԤ */
! #define TS_WAIT_FLG		(0x06U << 3)	/* ٥ȥե饰Ԥ */
! #define TS_WAIT_SDTQ	(0x07U << 3)	/* ǡ塼ؤԤ */
! #define TS_WAIT_SPDQ	(0x08U << 3)	/* ͥ٥ǡ塼ؤԤ */
! #define TS_WAIT_MBX		(0x09U << 3)	/* ᡼ܥåμԤ */
! #define TS_WAIT_SMBF	(0x0aU << 3)	/* åХåեؤԤ */
! #define TS_WAIT_MPF		(0x0bU << 3)	/* Ĺ֥åγԤ */
! 
! /*
!  *  Ƚ̥ޥ
!  *
!  *  TSTAT_DORMANTϥٻ߾֤Ǥ뤫ɤTSTAT_RUNNABLE
!  *  ¹ԤǤ֤Ǥ뤫ɤȽ̤롥TSTAT_WAITING
!  *  ֤Ԥ֤Τ줫Ǥ뤫ɤTSTAT_SUSPENDED
!  *  Ԥ֤Ԥ֤Τ줫Ǥ뤫ɤȽ̤롥
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
--- 51,101 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  タスク優先度の内部表現・外部表現変換マクロ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  タスク状態の内部表現
   *
!  *  TCB中のタスク状態では，実行状態（RUNNING）と実行可能状態（READY）
!  *  は区別しない．両状態を総称して，実行できる状態（RUNNABLE）と呼ぶ．
!  *  二重待ち状態は，(TS_WAITING | TS_SUSPENDED)で表す．TS_WAIT_???は待
!  *  ち要因を表し，待ち状態（二重待ち状態を含む）の場合にのみ設定する．
!  */
! #define TS_DORMANT		0x00U			/* 休止状態 */
! #define TS_RUNNABLE		0x01U			/* 実行できる状態 */
! #define TS_WAITING		0x02U			/* 待ち状態 */
! #define TS_SUSPENDED	0x04U			/* 強制待ち状態 */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* 時間経過待ち */
! #define TS_WAIT_SLP		(0x01U << 3)	/* 起床待ち */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* データキューからの受信待ち */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* 優先度データキューからの受信待ち */
! #define TS_WAIT_RMBF	(0x04U << 3)	/* メッセージバッファからの受信待ち */
! #define TS_WAIT_SEM		(0x05U << 3)	/* セマフォ資源の獲得待ち */
! #define TS_WAIT_FLG		(0x06U << 3)	/* イベントフラグ待ち */
! #define TS_WAIT_SDTQ	(0x07U << 3)	/* データキューへの送信待ち */
! #define TS_WAIT_SPDQ	(0x08U << 3)	/* 優先度データキューへの送信待ち */
! #define TS_WAIT_MBX		(0x09U << 3)	/* メールボックスからの受信待ち */
! #define TS_WAIT_SMBF	(0x0aU << 3)	/* メッセージバッファへの送信待ち */
! #define TS_WAIT_MPF		(0x0bU << 3)	/* 固定長メモリブロックの獲得待ち */
! 
! /*
!  *  タスク状態判別マクロ
!  *
!  *  TSTAT_DORMANTはタスクが休止状態であるかどうかを，TSTAT_RUNNABLEは
!  *  タスクが実行できる状態であるかどうかを判別する．TSTAT_WAITINGは待
!  *  ち状態と二重待ち状態のいずれかであるかどうかを，TSTAT_SUSPENDEDは
!  *  強制待ち状態と二重待ち状態のいずれかであるかどうかを判別する．
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
***************
*** 103,126 ****
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  ԤװȽ̥ޥ
   *
!  *  TSTAT_WAIT_SLPϥԤǤ뤫ɤTSTAT_WAIT_WOBJ
!  *  ϥƱ֥̿ȤФԤǤ뤫ʸȡ
!  *  Ʊ֥̿ȤԤ塼ˤĤʤƤ뤫ˤɤȽ̤
!  *  롥ޤTSTAT_WAIT_WOBJCBϥƱ֥̿Ȥδ
!  *  ֥åζʬWOBJCBˤԤ塼ˤĤʤƤ뤫ɤ
!  *  Ƚ̤롥
!  *
!  *  TSTAT_WAIT_SLPϡǤդΥ֤椫顤ԤǤ
!  *  ȤȽ̤Ǥ롥ʤTSTAT_WAITINGˤԤ֤Ǥ뤳Ȥ
!  *  Ƚ̤ˡTSTAT_SLPѤƵԤ֤Ǥ뤳ȤȽ̤Ǥ롥
!  *  ΨŪ˼¸뤿ˡTS_WAIT_SLPͤ(0x00U << 3)ǤϤ
!  *  (0x01U << 3)ȤƤ롥ΤᡤַвԤ֤Ǥ
!  *  ȤȽ̤뤿TSTAT_WAIT_DLYTSTAT_WAIT_SLPƱͤˡ
!  *  ¸뤳ȤϤǤʤ
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* ԤװμФޥ */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
--- 103,126 ----
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  タスク待ち要因判別マクロ
   *
!  *  TSTAT_WAIT_SLPはタスクが起床待ちであるかどうかを，TSTAT_WAIT_WOBJ
!  *  はタスクが同期・通信オブジェクトに対する待ちであるか（言い換えると，
!  *  同期通信オブジェクトの待ちキューにつながれているか）どうかを判別す
!  *  る．また，TSTAT_WAIT_WOBJCBはタスクが同期・通信オブジェクトの管理
!  *  ブロックの共通部分（WOBJCB）の待ちキューにつながれているかどうかを
!  *  判別する．
!  *
!  *  TSTAT_WAIT_SLPは，任意のタスク状態の中から，タスクが起床待ちである
!  *  ことを判別できる．すなわち，TSTAT_WAITINGにより待ち状態であることを
!  *  判別せずに，TSTAT_SLPだけを用いて起床待ち状態であることを判別できる．
!  *  これを効率的に実現するために，TS_WAIT_SLPの値を，(0x00U << 3)ではな
!  *  く(0x01U << 3)としている．そのため，タスクが時間経過待ち状態である
!  *  ことを判別するためのTSTAT_WAIT_DLYを，TSTAT_WAIT_SLPと同様の方法で
!  *  実現することはできない．
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* 待ち要因の取出しマスク */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
***************
*** 128,482 ****
  #define TSTAT_WAIT_SMBF(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SMBF)
  
  /*
!  *  Ԥ֥åWINFOˤ
   *
!  *  Ԥ֤δ֤ϡTCBӤp_winfoǻؤWINFO򼡤
!  *  褦ꤷʤФʤʤ
   *
!  *  (a) TCBΥ֤Ԥ֡TS_WAITINGˤˤ롥κݤˡԤ
!  *  װTS_WAIT_???ˤꤹ롥
   *
!  *  (b) ॢȤƻ뤹뤿ˡ।٥ȥ֥åϿ롥
!  *  Ͽ륿।٥ȥ֥åϡԤ륵ӥؿ
!  *  ΥѿȤƳݤؤΥݥ󥿤WINFOp_tmevtb˵
!  *  롥ॢȤδƻ뤬ɬפʤʱʵԤξˤˤϡ
!  *  p_tmevtbNULLˤ롥
!  *
!  *  Ʊ֥̿ȤФԤ֤ξˤϡɸWINFO
!  *  p_wobjcbեɤɲä¤ΡWINFO_WOBJwait.hˤ
!  *  ޤʲ(c)(e)Ԥɬפ롥Ʊ֥̿
!  *  Ȥ˴طʤԤʵԤַвԤˤξˤϡ(c)(e)
!  *  ɬפʤ
!  *
!  *  (c) TCBԤоݤƱ֥̿ȤԤ塼ˤĤʤ
!  *  塼ˤĤʤˡtask_queueȤ
!  *
!  *  (d) ԤоݤƱ֥̿Ȥδ֥åؤΥݥ󥿤
!  *  WINFO_WOBJp_wobjcb˵롥
!  *
!  *  (e) ԤоݤƱ֥̿Ȥ˰¸Ƶ뤳Ȥɬפ
!  *  󤬤ˤϡWINFO_WOBJɬפʾΤΥեɤɲ
!  *  ¤ΤWINFO_WOBJѤ롥
!  *
!  *  Ԥ֤ݤˤϡԤФͤWINFO
!  *  wercdꤹ롥wercdɬפʤΤԤʹߤǤΤФơ
!  *  p_tmevtbԤɬפʤᡤΤ˶ΤȤ
!  *  Ƥ롥Τᡤwercdإ顼ɤꤹΤϡ।٥
!  *  ֥åϿˤʤФʤʤ
   */
  typedef union waiting_information {
! 	ER		wercd;			/* ԤΥ顼 */
! 	TMEVTB	*p_tmevtb;		/* ԤѤΥ।٥ȥ֥å */
  } WINFO;
  
  /*
!  *  ֥å
   *
!  *  ˴ؤͤѤʤROM֤ʬʥ
!  *  ֥åˤȡͤѲ뤿RAM֤ʤФʤʤ
!  *  ʬʥ֥åTCBˤʬΥTCBб륿
!  *  ֥åؤݥ󥿤롥֥åб
!  *  TCBؤݥ󥿤ˡRAMδ˾ޤ
!  *  ¹ԸΨʤ뤿˺ѤƤʤ¾Υ֥ȤˤĤ
!  *  ƤƱͤ˰
   *
!  *  ֥åˤϡDEF_TEX륿㳰롼
!  *  ˴ؤޤࡥ
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* ° */
! 	intptr_t	exinf;			/* γĥ */
! 	TASK		task;			/* εư */
! 	uint_t		ipriority;		/* εưͥ١ɽ */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* ƥȥ֥å */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* åΰΥʴݤ᤿͡ */
! 	void		*stk;			/* åΰƬ */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* 㳰롼° */
! 	TEXRTN		texrtn;			/* 㳰롼εư */
  } TINIB;
  
  /*
!  *  TCBΥեɤΥӥå
   *
!  *  ץåˤäƤϡTCBΥեɤΥӥåǥ̤
!  *  ǽȥ졼ɥդˤʤ뤿ᡤåȰ¸˥եɤΥӥå
!  *  ѹ뤳ȤƤ롥
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityեɤΥӥå */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  ֥åTCB
   *
!  *  ASPͥǤϡεư׵ᥭ塼󥰿κ͡TMAX_ACTCNT
!  *  ȵ׵ᥭ塼󥰿κ͡TMAX_WUPCNTˤ1˸ꤵƤ
!  *  ᡤ塼󥰤Ƥ뤫ɤοͤɽ뤳ȤǤ롥
!  *  ޤԤ׵ͥȿκ͡TMAX_SUSCNTˤ1˸ꤵƤ
!  *  ΤǡԤ׵ͥȿsuscntˤɬפʤ
!  *
!  *  TCBΤĤΥեɤϡΥ֤ǤΤͭͤݻ
!  *  ʳξͤݾڤʤʤäơȤƤϤʤʤˡ
!  *  եɤͭͤݻϼ̤ꡥ
!  *
!  *  Ͼͭ
!  *  		p_tinibtstatactque
!  *  ٻ߾ְʳͭʵٻ߾֤ǤϽͤˤʤäƤˡ
!  *  		prioritywupqueenatextexptn
!  *  Ԥ֡Ԥ֤ޤˤͭ
   *  		p_winfo
!  *  ¹ԤǤ֤Ʊ֥̿ȤФԤ֤ͭ
   *  		task_queue
!  *  ¹Բǽ֡Ԥ֡Ԥ֡Ԥ֤ͭ
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* 塼 */
! 	const TINIB		*p_tinib;		/* ֥åؤΥݥ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* ֡ɽ*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* ֡ɽ*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* ߤͥ١ɽ*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* ߤͥ١ɽ*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* ư׵ᥭ塼 */
! 	BIT_FIELD_BOOL	wupque : 1;		/* ׵ᥭ塼 */
! 	BIT_FIELD_BOOL	enatex : 1;		/* 㳰ľ */
! 
! 	TEXPTN			texptn;			/* α㳰װ */
! 	WINFO			*p_winfo;		/* Ԥ֥åؤΥݥ */
! 	TSKCTXB			tskctxb;		/* ƥȥ֥å */
  } TCB;
  
  /*
!  *  ¹Ծ֤Υ
   *
!  *  ¹Ծ֤ΥʡץåƥȤäƤ륿ˤ
!  *  TCBؤݥ󥿡¹Ծ֤ΥʤNULLˤ롥
   *
!  *  ӥνǡʥӥƤӽФ
!  *  ˤ˴ؤ򻲾Ȥp_runtskȤp_runtsk񤭴
!  *  ΤϡǥѥåʤȽˤΤߤǤ롥
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   *
!  *  ¹ԤǤ륿Ǻǹ̤ͥΥTCBؤݥ󥿡
!  *  ԤǤ륿ʤNULLˤ롥
   *
!  *  ǥѥåػ߾֤ʤɡǥѥåαƤ֤p_runtsk
!  *  ȰפƤȤϸ¤ʤ
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   *
!  *  ߥϥɥ顿CPU㳰ϥɥνиˡǥѥåޤ
!  *  㳰롼εư׵᤹뤳Ȥ򼨤ե饰
   */
  extern bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   *
!  *  ͥ٥ޥ֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   *
!  *  ǥѥåػ߾֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   *
!  *  ͥ٥ޥ֤Ǥꡤǥѥåľ֤Ǥʥǥ
!  *  ѥåػ߾֤ǤʤˤȤ򼨤ե饰
   */
  extern bool_t	dspflg;
  
  /*
!  *  ǥ塼
   *
!  *  ǥ塼ϡ¹ԤǤ֤Υ뤿Υ塼Ǥ롥
!  *  ¹Ծ֤ΥƤ뤿ᡤǥʼ¹Բǽ˥塼Ȥ
!  *  ̾ΤΤǤϤʤǥ塼Ȥ̾Τ夷Ƥ뤿ᡤ
!  *  ̾ΤǸƤ֤Ȥˤ롥
   *
!  *  ǥ塼ϡͥ٤ȤΥ塼ǹƤ롥
!  *  TCBϡͥ٤Υ塼Ͽ롥
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   *
!  *  ǥ塼ΥΨ褯Ԥˡͥ٤ȤΥ塼
!  *  ˥äƤ뤫ɤ򼨤ӥåȥޥåפѰդƤ롥ӥ
!  *  ȥޥåפȤȤǡꥢβ򸺤餹ȤǤ뤬
!  *  ӥå̿᤬¤Ƥʤץåǡͥ٤ʳʤ
!  *  ˤϡӥåȥޥåΥСإåɤΤˡդ˸Ψ
!  *  ǽ⤢롥
   *
!  *  ͥ٤16ʳǤ뤳ȤꤷƤ뤿ᡤuint16_tȤƤ롥
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  ֥åΥꥢkernel_cfg.c
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  ơ֥kernel_cfg.c
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBΥꥢkernel_cfg.c
   */
  extern TCB	tcb_table[];
  
  /*
!  *  ο
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  IDTCBФΥޥ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCB饿IDФΥޥ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  ⥸塼ν
   */
  extern void	initialize_task(void);
  
  /*
!  *  ǹ̥ͥΥ
   *
!  *  ǥ塼κǹ̤ͥΥ򥵡TCBؤΥݥ
!  *  ֤ǥ塼ξˤϡδؿƤӽФƤϤʤʤ
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥ǥ塼
!  *  ͥ٤ǹ̤ͥΥͥ٤⤤ϡ
!  *  ǹ̤ͥΥ򹹿ǥѥåľ֤Ǥtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥p_tcbǻꤷ
!  *  ǹ̤ͥΥǤäˤϡǹ̤ͥΥ
!  *  ꤷʤǥѥåľ֤Ǥtrue֤Ǥʤ
!  *  false֤ξ֤Ϲʤ
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤Ȥ롥ޤεư
!  *  ˽٤ѿνȡưΤΥƥȤ
!  *  ꤹ롥
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤¹ԤǤ֤Ȥ롥
!  *  ¹ԤǤ֤ܤؤΥǥѥåɬפʾtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  ͥ٤ѹ
   *
!  *  p_tcbǻꤵ륿ͥ٤newpriɽˤѹ롥ޤ
!  *  ɬפʾˤϺǹ̤ͥΥ򹹿ǥѥåľ֤
!  *  true֤Ǥʤfalse֤
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  ǥ塼βž
   *
!  *  ǥ塼Ρpriǻꤵͥ٤Υ塼ž롥
!  *  ޤɬפʾˤϺǹ̤ͥΥѹǥѥå
!  *  αƤʤtrue֤Ǥʤfalse֤
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  㳰롼θƽФ
   *
!  *  㳰롼ƤӽФƤӽФˡ¹Ծ֤Υ
!  *  α㳰װ򥯥ꥢ㳰ػ߾֤ˤCPUå
!  *  롥
!  *
!  *  㳰롼󤫤ȡޤCPUå֤ᤷδ
!  *  α㳰װ0ǤʤʤäƤСƤӥ㳰롼
!  *  ƤӽФα㳰װ0ξˤϡ㳰ľ֤ˤƴؿ
!  *  ꥿󤹤롥
!  *
!  *  δؿϡ¹Ծ֤Υ㳰ľ֡enatex
!  *  trueˤǡα㳰װ0Ǥʤtexptn0Ǥʤ˾˸ƤӽФ
!  *  ȤꤷƤ롥δؿϡCPUå֤ǸƤӽФʤФʤ
!  *  ʤ
   */
  extern void	call_texrtn(void);
  
  /*
!  *  㳰롼εư
   *
!  *  ¹Ծ֤Υ㳰롼εưƤС
!  *  㳰롼ƤӽФCPU㳰롼ƤӽФ
!  *  ϡŪCPUå롥
!  *
!  *  δؿϡǥѥåߥϥɥ顿CPU㳰ϥɥνи
!  *  ƤӽФ뤳ȤꤷƤ롥δؿϡCPUå
!  *  ǸƤӽФʤФʤʤ
   *
!  *  ¹ԸΨ夲뤿ˡδؿ򥿡åȰ¸ǵҤƤ褤
!  *  ξˤϡOMIT_CALLTEXޥ롥
   */
  extern void	calltex(void);
  
--- 128,482 ----
  #define TSTAT_WAIT_SMBF(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SMBF)
  
  /*
!  *  待ち情報ブロック（WINFO）の定義
   *
!  *  タスクが待ち状態の間は，TCBおよびそのp_winfoで指されるWINFOを次の
!  *  ように設定しなければならない．
   *
!  *  (a) TCBのタスク状態を待ち状態（TS_WAITING）にする．その際に，待ち
!  *  要因（TS_WAIT_???）も設定する．
   *
!  *  (b) タイムアウトを監視するために，タイムイベントブロックを登録する．
!  *  登録するタイムイベントブロックは，待ちに入るサービスコール処理関数
!  *  のローカル変数として確保し，それへのポインタをWINFOのp_tmevtbに記
!  *  憶する．タイムアウトの監視が必要ない場合（永久待ちの場合）には，
!  *  p_tmevtbをNULLにする．
!  *
!  *  同期・通信オブジェクトに対する待ち状態の場合には，標準のWINFOに
!  *  p_wobjcbフィールドを追加した構造体（WINFO_WOBJ，wait.hで定義）を使
!  *  う．また，以下の(c)〜(e)の設定を行う必要がある．同期・通信オブジェ
!  *  クトに関係しない待ち（起床待ち，時間経過待ち）の場合には，(c)〜(e)
!  *  は必要ない．
!  *
!  *  (c) TCBを待ち対象の同期・通信オブジェクトの待ちキューにつなぐ．待
!  *  ちキューにつなぐために，task_queueを使う．
!  *
!  *  (d) 待ち対象の同期・通信オブジェクトの管理ブロックへのポインタを，
!  *  WINFO_WOBJのp_wobjcbに記憶する．
!  *
!  *  (e) 待ち対象の同期・通信オブジェクトに依存して記憶することが必要な
!  *  情報がある場合には，WINFO_WOBJに必要な情報のためのフィールドを追加
!  *  した構造体を定義し，WINFO_WOBJの代わりに用いる．
!  *
!  *  待ち状態を解除する際には，待ち解除したタスクに対する返値をWINFOの
!  *  wercdに設定する．wercdが必要なのは待ち解除以降であるのに対して，
!  *  p_tmevtbは待ち解除後は必要ないため，メモリ節約のために共用体を使っ
!  *  ている．そのため，wercdへエラーコードを設定するのは，タイムイベント
!  *  ブロックを登録解除した後にしなければならない．
   */
  typedef union waiting_information {
! 	ER		wercd;			/* 待ち解除時のエラーコード */
! 	TMEVTB	*p_tmevtb;		/* 待ち状態用のタイムイベントブロック */
  } WINFO;
  
  /*
!  *  タスク初期化ブロック
   *
!  *  タスクに関する情報を，値が変わらないためにROMに置ける部分（タスク
!  *  初期化ブロック）と，値が変化するためにRAMに置かなければならない部
!  *  分（タスク管理ブロック，TCB）に分離し，TCB内に対応するタスク初期化
!  *  ブロックを指すポインタを入れる．タスク初期化ブロック内に対応する
!  *  TCBを指すポインタを入れる方法の方が，RAMの節約の観点からは望ましい
!  *  が，実行効率が悪くなるために採用していない．他のオブジェクトについ
!  *  ても同様に扱う．
   *
!  *  タスク初期化ブロックには，DEF_TEXで定義されるタスク例外処理ルーチ
!  *  ンに関する情報も含む．
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* タスク属性 */
! 	intptr_t	exinf;			/* タスクの拡張情報 */
! 	TASK		task;			/* タスクの起動番地 */
! 	uint_t		ipriority;		/* タスクの起動時優先度（内部表現） */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* タスク初期化コンテキストブロック */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* スタック領域のサイズ（丸めた値） */
! 	void		*stk;			/* スタック領域の先頭番地 */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* タスク例外処理ルーチン属性 */
! 	TEXRTN		texrtn;			/* タスク例外処理ルーチンの起動番地 */
  } TINIB;
  
  /*
!  *  TCB中のフィールドのビット幅の定義
   *
!  *  プロセッサによっては，TCB中のフィールドのビット幅でメモリ使用量と
!  *  性能がトレードオフになるため，ターゲット依存にフィールドのビット幅
!  *  を変更することを許している．
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityフィールドのビット幅 */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  タスク管理ブロック（TCB）
   *
!  *  ASPカーネルでは，タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）
!  *  と起床要求キューイング数の最大値（TMAX_WUPCNT）は1に固定されている
!  *  ため，キューイングされているかどうかの真偽値で表現することができる．
!  *  また，強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が1に固定されてい
!  *  るので，強制待ち要求ネスト数（suscnt）は必要ない．
!  *
!  *  TCBのいくつかのフィールドは，特定のタスク状態でのみ有効な値を保持し，
!  *  それ以外の場合は値が保証されない（よって，参照してはならない）．各
!  *  フィールドが有効な値を保持する条件は次の通り．
!  *
!  *  ・初期化後は常に有効：
!  *  		p_tinib，tstat，actque
!  *  ・休止状態以外で有効（休止状態では初期値になっている）：
!  *  		priority，wupque，enatex，texptn
!  *  ・待ち状態（二重待ち状態を含む）で有効：
   *  		p_winfo
!  *  ・実行できる状態と同期・通信オブジェクトに対する待ち状態で有効：
   *  		task_queue
!  *  ・実行可能状態，待ち状態，強制待ち状態，二重待ち状態で有効：
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* タスクキュー */
! 	const TINIB		*p_tinib;		/* 初期化ブロックへのポインタ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* タスク状態（内部表現）*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* タスク状態（内部表現）*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* 現在の優先度（内部表現）*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* 現在の優先度（内部表現）*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* 起動要求キューイング */
! 	BIT_FIELD_BOOL	wupque : 1;		/* 起床要求キューイング */
! 	BIT_FIELD_BOOL	enatex : 1;		/* タスク例外処理許可状態 */
! 
! 	TEXPTN			texptn;			/* 保留例外要因 */
! 	WINFO			*p_winfo;		/* 待ち情報ブロックへのポインタ */
! 	TSKCTXB			tskctxb;		/* タスクコンテキストブロック */
  } TCB;
  
  /*
!  *  実行状態のタスク
   *
!  *  実行状態のタスク（＝プロセッサがコンテキストを持っているタスク）の
!  *  TCBを指すポインタ．実行状態のタスクがない場合はNULLにする．
   *
!  *  サービスコールの処理中で，自タスク（サービスコールを呼び出したタス
!  *  ク）に関する情報を参照する場合はp_runtskを使う．p_runtskを書き換え
!  *  るのは，ディスパッチャ（と初期化処理）のみである．
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   *
!  *  実行できるタスクの中で最高優先順位のタスクのTCBを指すポインタ．実
!  *  行できるタスクがない場合はNULLにする．
   *
!  *  ディスパッチ禁止状態など，ディスパッチが保留されている間はp_runtsk
!  *  と一致しているとは限らない．
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ディスパッチ／タスク例外処理ルーチン起動要求フラグ
   *
!  *  割込みハンドラ／CPU例外ハンドラの出口処理に，ディスパッチまたは
!  *  タスク例外処理ルーチンの起動を要求することを示すフラグ．
   */
  extern bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   *
!  *  割込み優先度マスク全解除状態であることを示すフラグ．
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   *
!  *  ディスパッチ禁止状態であることを示すフラグ．
   */
  extern bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   *
!  *  割込み優先度マスク全解除状態であり，ディスパッチ許可状態である（ディ
!  *  スパッチ禁止状態でない）ことを示すフラグ．
   */
  extern bool_t	dspflg;
  
  /*
!  *  レディキュー
   *
!  *  レディキューは，実行できる状態のタスクを管理するためのキューである．
!  *  実行状態のタスクも管理しているため，レディ（実行可能）キューという
!  *  名称は正確ではないが，レディキューという名称が定着しているため，こ
!  *  の名称で呼ぶことにする．
   *
!  *  レディキューは，優先度ごとのタスクキューで構成されている．タスクの
!  *  TCBは，該当する優先度のキューに登録される．
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   *
!  *  レディキューのサーチを効率よく行うために，優先度ごとのタスクキュー
!  *  にタスクが入っているかどうかを示すビットマップを用意している．ビッ
!  *  トマップを使うことで，メモリアクセスの回数を減らすことができるが，
!  *  ビット操作命令が充実していないプロセッサで，優先度の段階数が少ない
!  *  場合には，ビットマップ操作のオーバーヘッドのために，逆に効率が落ち
!  *  る可能性もある．
   *
!  *  優先度が16段階であることを仮定しているため，uint16_t型としている．
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  タスクIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  タスク初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  タスク生成順序テーブル（kernel_cfg.c）
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBのエリア（kernel_cfg.c）
   */
  extern TCB	tcb_table[];
  
  /*
!  *  タスクの数
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  タスクIDからTCBを取り出すためのマクロ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCBからタスクIDを取り出すためのマクロ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  タスク管理モジュールの初期化
   */
  extern void	initialize_task(void);
  
  /*
!  *  最高優先順位タスクのサーチ
   *
!  *  レディキュー中の最高優先順位のタスクをサーチし，そのTCBへのポインタ
!  *  を返す．レディキューが空の場合には，この関数を呼び出してはならない．
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューに挿入する．レディキューに挿入
!  *  したタスクの優先度が，最高優先順位のタスクの優先度よりも高い場合は，
!  *  最高優先順位のタスクを更新し，ディスパッチ許可状態であればtrueを返
!  *  す．そうでない場合はfalseを返す．
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューから削除する．p_tcbで指定した
!  *  タスクが最高優先順位のタスクであった場合には，最高優先順位のタスク
!  *  を設定しなおし，ディスパッチ許可状態であればtrueを返す．そうでない
!  *  場合はfalseを返す．タスクの状態は更新しない．
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  休止状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態とする．また，タスクの起動
!  *  時に初期化すべき変数の初期化と，タスク起動のためのコンテキストを設
!  *  定する．
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  休止状態から実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態から実行できる状態とする．
!  *  実行できる状態に遷移したタスクへのディスパッチが必要な場合はtrue，
!  *  そうでない場合はfalseを返す．
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  タスクの優先度の変更
   *
!  *  p_tcbで指定されるタスクの優先度をnewpri（内部表現）に変更する．また，
!  *  必要な場合には最高優先順位のタスクを更新し，ディスパッチ許可状態で
!  *  あればtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  レディキューの回転
   *
!  *  レディキュー中の，priで指定される優先度のタスクキューを回転させる．
!  *  また，必要な場合には最高優先順位のタスクを変更し，ディスパッチが保
!  *  留されていなければtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  タスク例外処理ルーチンを呼び出す．呼び出す前に，実行状態のタスクの
!  *  保留例外要因をクリアし，タスク例外処理禁止状態にし，CPUロックを解
!  *  除する．
!  *
!  *  タスク例外処理ルーチンから戻ると，まずCPUロック状態に戻し，その間
!  *  に保留例外要因が0でなくなっていれば，再びタスク例外処理ルーチンを
!  *  呼び出す．保留例外要因が0の場合には，例外処理許可状態にして関数か
!  *  らリターンする．
!  *
!  *  この関数は，実行状態のタスクが，タスク例外処理許可状態（enatexが
!  *  true）で，保留例外要因が0でない（texptnが0でない）場合に呼び出すこ
!  *  とを想定している．この関数は，CPUロック状態で呼び出さなければなら
!  *  ない．
   */
  extern void	call_texrtn(void);
  
  /*
!  *  タスク例外処理ルーチンの起動
   *
!  *  実行状態のタスクがタスク例外処理ルーチンの起動条件を満たしていれば，
!  *  タスク例外処理ルーチンを呼び出す．CPU例外処理ルーチンを呼び出す時
!  *  は，一時的にCPUロックを解除する．
!  *
!  *  この関数は，ディスパッチャや割込みハンドラ／CPU例外ハンドラの出口
!  *  処理から呼び出されることを想定している．この関数は，CPUロック状態
!  *  で呼び出さなければならない．
   *
!  *  実行効率を上げるために，この関数をターゲット依存部で記述してもよい．
!  *  その場合には，OMIT_CALLTEXをマクロ定義する．
   */
  extern void	calltex(void);
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/task_manage.c ASPs/asp/extension/messagebuf/kernel/task_manage.c
*** 1.9.1/asp/extension/messagebuf/kernel/task_manage.c	Thu Jan  2 14:18:13 2014
--- ASPs/asp/extension/messagebuf/kernel/task_manage.c	Fri Dec  9 13:54:01 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task_manage.c 2590 2014-01-02 05:18:11Z ertl-hiro $
   */
  
  /*
!  *		ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task_manage.c 2590 2014-01-02 05:18:11Z ertl-hiro $
   */
  
  /*
!  *		タスク管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 50,56 ****
  #include "wait.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
--- 50,56 ----
  #include "wait.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
***************
*** 117,123 ****
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  εư
   */
  #ifdef TOPPERS_act_tsk
  
--- 117,123 ----
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  タスクの起動
   */
  #ifdef TOPPERS_act_tsk
  
***************
*** 156,162 ****
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  εư󥿥ƥѡ
   */
  #ifdef TOPPERS_iact_tsk
  
--- 156,162 ----
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  タスクの起動（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iact_tsk
  
***************
*** 195,201 ****
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  ư׵Υ󥻥
   */
  #ifdef TOPPERS_can_act
  
--- 195,201 ----
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  タスク起動要求のキャンセル
   */
  #ifdef TOPPERS_can_act
  
***************
*** 223,229 ****
  #endif /* TOPPERS_can_act */
  
  /*
!  *  νλ
   */
  #ifdef TOPPERS_ext_tsk
  
--- 223,229 ----
  #endif /* TOPPERS_can_act */
  
  /*
!  *  自タスクの終了
   */
  #ifdef TOPPERS_ext_tsk
  
***************
*** 237,245 ****
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUå֤ext_tskƤФ줿ϡCPUå
! 		 *  Ƥ饿λ롥ϡӥǤCPU
! 		 *  åάФ褤
  		 */
  	}
  	else {
--- 237,245 ----
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUロック状態でext_tskが呼ばれた場合は，CPUロックを解除し
! 		 *  てからタスクを終了する．実装上は，サービスコール内でのCPU
! 		 *  ロックを省略すればよいだけ．
  		 */
  	}
  	else {
***************
*** 247,262 ****
  	}
  	if (disdsp) {
  		/*
! 		 *  ǥѥåػ߾֤ext_tskƤФ줿ϡǥѥ
! 		 *  ľ֤ˤƤ饿λ롥
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  ͥ٥ޥIPMˤTIPM_ENAALLʳξ֤ext_tsk
! 		 *  ƤФ줿ϡIPMTIPM_ENAALLˤƤ饿λ
! 		 *  롥
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
--- 247,262 ----
  	}
  	if (disdsp) {
  		/*
! 		 *  ディスパッチ禁止状態でext_tskが呼ばれた場合は，ディスパッ
! 		 *  チ許可状態にしてからタスクを終了する．
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  割込み優先度マスク（IPM）がTIPM_ENAALL以外の状態でext_tsk
! 		 *  が呼ばれた場合は，IPMをTIPM_ENAALLにしてからタスクを終了す
! 		 *  る．
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
***************
*** 280,286 ****
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  ζλ
   */
  #ifdef TOPPERS_ter_tsk
  
--- 280,286 ----
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  タスクの強制終了
   */
  #ifdef TOPPERS_ter_tsk
  
***************
*** 304,312 ****
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbϼǤʤᡤʥ󥰥ץåǤϡ˼
! 			 *  Ծ֤Ǥʤmake_non_runnable(p_tcb)ǥǥѥ
! 			 *  ɬפˤʤ뤳ȤϤʤ
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
--- 304,312 ----
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbは自タスクでないため，（シングルプロセッサでは）実
! 			 *  行状態でなく，make_non_runnable(p_tcb)でタスクディスパッ
! 			 *  チが必要になることはない．
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
***************
*** 338,344 ****
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  Υ١ͥ٤ѹ
   */
  #ifdef TOPPERS_chg_pri
  
--- 338,344 ----
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  タスクのベース優先度の変更
   */
  #ifdef TOPPERS_chg_pri
  
***************
*** 377,383 ****
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  ͥ٤λ
   */
  #ifdef TOPPERS_get_pri
  
--- 377,383 ----
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  タスク優先度の参照
   */
  #ifdef TOPPERS_get_pri
  
***************
*** 410,416 ****
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  γĥλ
   */
  #ifdef TOPPERS_get_inf
  
--- 410,416 ----
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  自タスクの拡張情報の参照
   */
  #ifdef TOPPERS_get_inf
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/task_refer.c ASPs/asp/extension/messagebuf/kernel/task_refer.c
*** 1.9.1/asp/extension/messagebuf/kernel/task_refer.c	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/task_refer.c	Fri Dec  9 13:54:01 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task_refer.c 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		ξֻȵǽ
   */
  
  #include "kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task_refer.c 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		タスクの状態参照機能
   */
  
  #include "kernel_impl.h"
***************
*** 56,62 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_REF_TSK_ENTER
  #define LOG_REF_TSK_ENTER(tskid, pk_rtsk)
--- 56,62 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_REF_TSK_ENTER
  #define LOG_REF_TSK_ENTER(tskid, pk_rtsk)
***************
*** 67,73 ****
  #endif /* LOG_REF_TSK_LEAVE */
  
  /*
!  *  ξֻ
   */
  #ifdef TOPPERS_ref_tsk
  
--- 67,73 ----
  #endif /* LOG_REF_TSK_LEAVE */
  
  /*
!  *  タスクの状態参照
   */
  #ifdef TOPPERS_ref_tsk
  
***************
*** 87,99 ****
  	tstat = p_tcb->tstat;
  	if (TSTAT_DORMANT(tstat)) {
  		/*
!  		 *  оݥٻ߾֤ξ
  		 */
  		pk_rtsk->tskstat = TTS_DMT;
  	}
  	else {
  		/*
!  		 *  ֤μФ
  		 */
  		if (TSTAT_SUSPENDED(tstat)) {
  			if (TSTAT_WAITING(tstat)) {
--- 87,99 ----
  	tstat = p_tcb->tstat;
  	if (TSTAT_DORMANT(tstat)) {
  		/*
!  		 *  対象タスクが休止状態の場合
  		 */
  		pk_rtsk->tskstat = TTS_DMT;
  	}
  	else {
  		/*
!  		 *  タスク状態の取出し
  		 */
  		if (TSTAT_SUSPENDED(tstat)) {
  			if (TSTAT_WAITING(tstat)) {
***************
*** 114,127 ****
  		}
  
  		/*
!  		 *  ͥ٤ȥ١ͥ٤μФ
  		 */
  		pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
  		pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->priority);
  
  		if (TSTAT_WAITING(tstat)) {
  			/*
! 	 		 *  ԤװԤоݤΥ֥ȤIDμФ
  			 */
  			switch (tstat & TS_WAIT_MASK) {
  			case TS_WAIT_SLP:
--- 114,127 ----
  		}
  
  		/*
!  		 *  現在優先度とベース優先度の取出し
  		 */
  		pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
  		pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->priority);
  
  		if (TSTAT_WAITING(tstat)) {
  			/*
! 	 		 *  待ち要因と待ち対象のオブジェクトのIDの取出し
  			 */
  			switch (tstat & TS_WAIT_MASK) {
  			case TS_WAIT_SLP:
***************
*** 183,189 ****
  			}
  
  			/*
! 	 		 *  ॢȤޤǤλ֤μФ
  			 */
  			if (p_tcb->p_winfo->p_tmevtb != NULL) {
  				pk_rtsk->lefttmo
--- 183,189 ----
  			}
  
  			/*
! 	 		 *  タイムアウトするまでの時間の取出し
  			 */
  			if (p_tcb->p_winfo->p_tmevtb != NULL) {
  				pk_rtsk->lefttmo
***************
*** 195,207 ****
  		}
  
  		/*
!  		 *  ׵ᥭ塼󥰿μФ
  		 */
  		pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
  	}
  
  	/*
! 	 *  ư׵ᥭ塼󥰿μФ
  	 */
  	pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
  	ercd = E_OK;
--- 195,207 ----
  		}
  
  		/*
!  		 *  起床要求キューイング数の取出し
  		 */
  		pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
  	}
  
  	/*
! 	 *  起動要求キューイング数の取出し
  	 */
  	pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
  	ercd = E_OK;
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/wait.c ASPs/asp/extension/messagebuf/kernel/wait.c
*** 1.9.1/asp/extension/messagebuf/kernel/wait.c	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/wait.c	Fri Dec  9 13:54:01 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: wait.c 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		Ԥִ⥸塼
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: wait.c 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		待ち状態管理モジュール
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "messagebuf.h"
  
  /*
!  *  Ԥ֤ؤܡʥॢȻ
   */
  #ifdef TOPPERS_waimake
  
--- 49,55 ----
  #include "messagebuf.h"
  
  /*
!  *  待ち状態への遷移（タイムアウト指定）
   */
  #ifdef TOPPERS_waimake
  
***************
*** 72,78 ****
  #endif /* TOPPERS_waimake */
  
  /*
!  *  ֥Ԥ塼κ
   */
  #ifdef TOPPERS_waiwobj
  
--- 72,78 ----
  #endif /* TOPPERS_waimake */
  
  /*
!  *  オブジェクト待ちキューからの削除
   */
  #ifdef TOPPERS_waiwobj
  
***************
*** 91,97 ****
  #endif /* TOPPERS_waiwobj */
  
  /*
!  *  Ԥ
   */
  #ifdef TOPPERS_waicmp
  
--- 91,97 ----
  #endif /* TOPPERS_waiwobj */
  
  /*
!  *  待ち解除
   */
  #ifdef TOPPERS_waicmp
  
***************
*** 106,112 ****
  #endif /* TOPPERS_waicmp */
  
  /*
!  *  ॢȤȼԤ
   */
  #ifdef TOPPERS_waitmo
  
--- 106,112 ----
  #endif /* TOPPERS_waicmp */
  
  /*
!  *  タイムアウトに伴う待ち解除
   */
  #ifdef TOPPERS_waitmo
  
***************
*** 122,128 ****
  	}
  
  	/*
! 	 *  ͥ٤ι⤤ߤդ롥
  	 */
  	i_unlock_cpu();
  	i_lock_cpu();
--- 122,128 ----
  	}
  
  	/*
! 	 *  ここで優先度の高い割込みを受け付ける．
  	 */
  	i_unlock_cpu();
  	i_lock_cpu();
***************
*** 140,146 ****
  	}
  
  	/*
! 	 *  ͥ٤ι⤤ߤդ롥
  	 */
  	i_unlock_cpu();
  	i_lock_cpu();
--- 140,146 ----
  	}
  
  	/*
! 	 *  ここで優先度の高い割込みを受け付ける．
  	 */
  	i_unlock_cpu();
  	i_lock_cpu();
***************
*** 149,155 ****
  #endif /* TOPPERS_waitmook */
  
  /*
!  *  Ԥ֤ζ
   */
  #ifdef TOPPERS_wairel
  
--- 149,155 ----
  #endif /* TOPPERS_waitmook */
  
  /*
!  *  待ち状態の強制解除
   */
  #ifdef TOPPERS_wairel
  
***************
*** 172,181 ****
  #endif /* TOPPERS_wairel */
  
  /*
!  *  ¹ΥƱ֥̿ȤԤ塼ؤ
   *
!  *  ¹ΥƱ֥̿ȤԤ塼롥
!  *  ֥Ȥ°˱ơFIFOޤϥͥٽ롥
   */
  Inline void
  wobj_queue_insert(WOBJCB *p_wobjcb)
--- 172,181 ----
  #endif /* TOPPERS_wairel */
  
  /*
!  *  実行中のタスクの同期・通信オブジェクトの待ちキューへの挿入
   *
!  *  実行中のタスクを，同期・通信オブジェクトの待ちキューへ挿入する．オ
!  *  ブジェクトの属性に応じて，FIFO順またはタスク優先度順で挿入する．
   */
  Inline void
  wobj_queue_insert(WOBJCB *p_wobjcb)
***************
*** 189,195 ****
  }
  
  /*
!  *  Ʊ֥̿ȤФԤ֤ؤ
   */
  #ifdef TOPPERS_wobjwai
  
--- 189,195 ----
  }
  
  /*
!  *  同期・通信オブジェクトに対する待ち状態への遷移
   */
  #ifdef TOPPERS_wobjwai
  
***************
*** 218,224 ****
  #endif /* TOPPERS_wobjwaitmo */
  
  /*
!  *  ͥѹν
   */
  #ifdef TOPPERS_wobjpri
  
--- 218,224 ----
  #endif /* TOPPERS_wobjwaitmo */
  
  /*
!  *  タスク優先度変更時の処理
   */
  #ifdef TOPPERS_wobjpri
  
***************
*** 238,244 ****
  #endif /* TOPPERS_wobjpri */
  
  /*
!  *  Ԥ塼ν
   */
  #ifdef TOPPERS_iniwque
  
--- 238,244 ----
  #endif /* TOPPERS_wobjpri */
  
  /*
!  *  待ちキューの初期化
   */
  #ifdef TOPPERS_iniwque
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/kernel/wait.h ASPs/asp/extension/messagebuf/kernel/wait.h
*** 1.9.1/asp/extension/messagebuf/kernel/wait.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/kernel/wait.h	Fri Dec  9 13:54:01 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: wait.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		Ԥִ⥸塼
   */
  
  #ifndef TOPPERS_WAIT_H
--- 8,47 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: wait.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		待ち状態管理モジュール
   */
  
  #ifndef TOPPERS_WAIT_H
***************
*** 51,60 ****
  #include "time_event.h"
  
  /*
!  *  ͥٽԤ塼ؤ
   *
!  *  p_tcbǻꤵ륿򡤥ͥٽΥ塼p_queue롥
!  *  塼Ʊͥ٤ΥˤϡκǸ롥
   */
  Inline void
  queue_insert_tpri(QUEUE *p_queue, TCB *p_tcb)
--- 51,60 ----
  #include "time_event.h"
  
  /*
!  *  タスクの優先度順の待ちキューへの挿入
   *
!  *  p_tcbで指定されるタスクを，タスク優先度順のキューp_queueに挿入する．
!  *  キューの中に同じ優先度のタスクがある場合には，その最後に挿入する．
   */
  Inline void
  queue_insert_tpri(QUEUE *p_queue, TCB *p_tcb)
***************
*** 72,82 ****
  }
  
  /*
!  *  Ԥ֤ؤ
   *
!  *  ¹ΥԤ֤ܤ롥Ūˤϡ¹Υ
!  *  ǥ塼TCBp_winfoեɡWINFOp_tmevtbե
!  *  ɤꤹ롥
   */
  Inline void
  make_wait(WINFO *p_winfo)
--- 72,82 ----
  }
  
  /*
!  *  待ち状態への遷移
   *
!  *  実行中のタスクを待ち状態に遷移させる．具体的には，実行中のタスクを
!  *  レディキューから削除し，TCBのp_winfoフィールド，WINFOのp_tmevtbフィー
!  *  ルドを設定する．
   */
  Inline void
  make_wait(WINFO *p_winfo)
***************
*** 87,107 ****
  }
  
  /*
!  *  Ԥ֤ؤܡʥॢȻ
   *
!  *  ¹Υ򡤥ॢȻդԤ֤ܤ롥
!  *  Ūˤϡ¹Υǥ塼TCBp_winfoե
!  *  ɡWINFOp_tmevtbեɤꤹ롥ޤ।٥ȥ
!  *  åϿ롥
   */
  extern void	make_wait_tmout(WINFO *p_winfo, TMEVTB *p_tmevtb, TMO tmout);
  
  /*
!  *  ԤΤΥ֤ι
   *
!  *  p_tcbǻꤵ륿Ԥ褦֤򹹿롥
!  *  Ԥ륿¹ԤǤ֤ˤʤϡǥ塼ˤĤ
!  *  ޤǥѥåɬפʾˤtrue֤
   */
  Inline bool_t
  make_non_wait(TCB *p_tcb)
--- 87,107 ----
  }
  
  /*
!  *  待ち状態への遷移（タイムアウト指定）
   *
!  *  実行中のタスクを，タイムアウト指定付きで待ち状態に遷移させる．具体
!  *  的には，実行中のタスクをレディキューから削除し，TCBのp_winfoフィー
!  *  ルド，WINFOのp_tmevtbフィールドを設定する．また，タイムイベントブ
!  *  ロックを登録する．
   */
  extern void	make_wait_tmout(WINFO *p_winfo, TMEVTB *p_tmevtb, TMO tmout);
  
  /*
!  *  待ち解除のためのタスク状態の更新
   *
!  *  p_tcbで指定されるタスクを，待ち解除するようタスク状態を更新する．
!  *  待ち解除するタスクが実行できる状態になる場合は，レディキューにつな
!  *  ぐ．また，ディスパッチが必要な場合にはtrueを返す．
   */
  Inline bool_t
  make_non_wait(TCB *p_tcb)
***************
*** 110,116 ****
  
  	if (!TSTAT_SUSPENDED(p_tcb->tstat)) {
  		/*
! 		 *  Ԥ֤¹ԤǤ֤ؤ
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
--- 110,116 ----
  
  	if (!TSTAT_SUSPENDED(p_tcb->tstat)) {
  		/*
! 		 *  待ち状態から実行できる状態への遷移
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
***************
*** 118,124 ****
  	}
  	else {
  		/*
! 		 *  Ԥ֤鶯Ԥ֤ؤ
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 118,124 ----
  	}
  	else {
  		/*
! 		 *  二重待ち状態から強制待ち状態への遷移
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 127,145 ****
  }
  
  /*
!  *  ֥Ԥ塼κ
   *
!  *  p_tcbǻꤵ륿Ʊ֥̿ȤԤ塼ˤ
!  *  ʤƤСԤ塼롥ǥѥåɬפʾ
!  *  true֤
   */
  extern bool_t	wait_dequeue_wobj(TCB *p_tcb);
  
  /*
!  *  ԤΤΥ।٥ȥ֥åϿ
   *
!  *  p_tcbǻꤵ륿ФơԤΤΥ।٥ȥ
!  *  åϿƤСϿ롥
   */
  Inline void
  wait_dequeue_tmevtb(TCB *p_tcb)
--- 127,145 ----
  }
  
  /*
!  *  オブジェクト待ちキューからの削除
   *
!  *  p_tcbで指定されるタスクが，同期・通信オブジェクトの待ちキューにつ
!  *  ながれていれば，待ちキューから削除する．ディスパッチが必要な場合に
!  *  はtrueを返す．
   */
  extern bool_t	wait_dequeue_wobj(TCB *p_tcb);
  
  /*
!  *  時間待ちのためのタイムイベントブロックの登録解除
   *
!  *  p_tcbで指定されるタスクに対して，時間待ちのためのタイムイベントブ
!  *  ロックが登録されていれば，それを登録解除する．
   */
  Inline void
  wait_dequeue_tmevtb(TCB *p_tcb)
***************
*** 150,198 ****
  }
  
  /*
!  *  Ԥ
   *
!  *  p_tcbǻꤵ륿Ԥ֤롥Ūˤϡ।
!  *  ٥ȥ֥åϿƤСϿ롥ޤ
!  *  ֤򹹿ԤͤE_OKȤ롥Ԥ塼
!  *  κϹԤʤԤؤΥǥѥåɬפʾ
!  *  ˤtrue֤
   */
  extern bool_t	wait_complete(TCB *p_tcb);
  
  /*
!  *  ॢȤȼԤ
   *
!  *  p_tcbǻꤵ륿Ԥ塼ˤĤʤƤԤ塼
!  *  ֤򹹿롥ޤԤ
!  *  ͤwait_tmoutǤE_TMOUTwait_tmout_okǤE_OKȤ롥Ԥ
!  *  ؤΥǥѥåɬפʻϡreqflgtrueˤ롥
   *
!  *  wait_tmout_okϡdly_tskǻȤΤΤǡԤ塼
!  *  Ԥʤ
   *
!  *  δؿ⡤।٥ȤΥХåؿȤѤ뤿
!  *  Τǡߥϥɥ餫ƤӽФ뤳ȤꤷƤ롥
   */
  extern void	wait_tmout(TCB *p_tcb);
  extern void	wait_tmout_ok(TCB *p_tcb);
  
  /*
!  *  Ԥ֤ζ
   *
!  *  p_tcbǻꤵ륿Ԥ֤Ū˲롥Ūˤϡ
!  *  Ԥ塼ˤĤʤƤԤ塼।
!  *  ٥ȥ֥åϿƤФϿ롥ޤ
!  *  ֤򹹿ԤͤE_RLWAIȤ롥ޤ
!  *  ԤؤΥǥѥåɬפʾˤtrue֤
   */
  extern bool_t	wait_release(TCB *p_tcb);
  
  /*
!  *  Ԥ塼ƬΥID
   *
!  *  p_wait_queueǻꤷԤ塼ƬΥID֤Ԥ塼
!  *  ξˤϡTSK_NONE֤
   */
  Inline ID
  wait_tskid(QUEUE *p_wait_queue)
--- 150,198 ----
  }
  
  /*
!  *  待ち解除
   *
!  *  p_tcbで指定されるタスクの待ち状態を解除する．具体的には，タイムイ
!  *  ベントブロックが登録されていれば，それを登録解除する．また，タスク
!  *  状態を更新し，待ち解除したタスクからの返値をE_OKとする．待ちキュー
!  *  からの削除は行わない．待ち解除したタスクへのディスパッチが必要な場
!  *  合にはtrueを返す．
   */
  extern bool_t	wait_complete(TCB *p_tcb);
  
  /*
!  *  タイムアウトに伴う待ち解除
   *
!  *  p_tcbで指定されるタスクが，待ちキューにつながれていれば待ちキュー
!  *  から削除し，タスク状態を更新する．また，待ち解除したタスクからの返
!  *  値を，wait_tmoutではE_TMOUT，wait_tmout_okではE_OKとする．待ち解除
!  *  したタスクへのディスパッチが必要な時は，reqflgをtrueにする．
   *
!  *  wait_tmout_okは，dly_tskで使うためのもので，待ちキューから削除する
!  *  処理を行わない．
   *
!  *  いずれの関数も，タイムイベントのコールバック関数として用いるための
!  *  もので，割込みハンドラから呼び出されることを想定している．
   */
  extern void	wait_tmout(TCB *p_tcb);
  extern void	wait_tmout_ok(TCB *p_tcb);
  
  /*
!  *  待ち状態の強制解除
   *
!  *  p_tcbで指定されるタスクの待ち状態を強制的に解除する．具体的には，
!  *  タスクが待ちキューにつながれていれば待ちキューから削除し，タイムイ
!  *  ベントブロックが登録されていればそれを登録解除する．また，タスクの
!  *  状態を更新し，待ち解除したタスクからの返値をE_RLWAIとする．また，
!  *  待ち解除したタスクへのディスパッチが必要な場合にはtrueを返す．
   */
  extern bool_t	wait_release(TCB *p_tcb);
  
  /*
!  *  待ちキューの先頭のタスクID
   *
!  *  p_wait_queueで指定した待ちキューの先頭のタスクIDを返す．待ちキュー
!  *  が空の場合には，TSK_NONEを返す．
   */
  Inline ID
  wait_tskid(QUEUE *p_wait_queue)
***************
*** 206,276 ****
  }
  
  /*
!  *  Ʊ֥̿Ȥδ֥åζʬ롼
   *
!  *  Ʊ֥̿Ȥν֥åȴ֥åƬʬ϶
!  *  ̤ˤʤäƤ롥ʲϡζʬ򰷤ηӥ롼
!  *  Ǥ롥
   *
!  *  ʣԤ塼Ʊ֥̿Ȥξ硤ƬʳԤ
!  *  塼ˤϡΥ롼ϻȤʤޤ֥
!  *  °TA_TPRIӥåȤ򻲾ȤΤǡΥӥåȤ¾Ū˻Ȥä
!  *  ⡤Υ롼ϻȤʤ
   */
  
  /*
!  *  Ʊ֥̿Ȥν֥åζʬ
   */
  typedef struct wait_object_initialization_block {
! 	ATR			wobjatr;		/* ֥° */
  } WOBJINIB;
  
  /*
!  *  Ʊ֥̿Ȥδ֥åζʬ
   */
  typedef struct wait_object_control_block {
! 	QUEUE		wait_queue;		/* Ԥ塼 */
! 	const WOBJINIB *p_wobjinib;	/* ֥åؤΥݥ */
  } WOBJCB;
  
  /*
!  *  Ʊ֥̿ȤԤ֥åζʬ
   *
!  *  ι¤ΤϡԤ֥åWINFOˤĥʥ֥Ȼظ
!  *  ηѾˤΤǤ뤬WINFOΤƤ뤿
!  *  ˡ1ĤΥեɤȤƴޤƤ롥
   */
  typedef struct wait_object_waiting_information {
! 	WINFO	winfo;			/* ɸԤ֥å */
! 	WOBJCB	*p_wobjcb;		/* Ԥ֥Ȥδ֥å */
  } WINFO_WOBJ;
  
  /*
!  *  Ʊ֥̿ȤФԤ֤ؤ
   *  
!  *  ¹ΥԤ֤ܤƱ֥̿ȤԤ塼
!  *  ˤĤʤޤԤ֥åWINFOˤp_wobjcbꤹ롥
!  *  wobj_make_wait_tmoutϡ।٥ȥ֥åϿԤ
   */
  extern void	wobj_make_wait(WOBJCB *p_wobjcb, WINFO_WOBJ *p_winfo);
  extern void	wobj_make_wait_tmout(WOBJCB *p_wobjcb, WINFO_WOBJ *p_winfo,
  											TMEVTB *p_tmevtb, TMO tmout);
  
  /*
!  *  ͥѹν
   *
!  *  Ʊ֥̿ȤФԤ֤ˤ륿ͥ٤ѹ
!  *  줿ˡԤ塼ǤΥΰ֤롥ǥѥå
!  *  ɬפʾˤtrue֤
   */
  extern bool_t	wobj_change_priority(WOBJCB *p_wobjcb, TCB *p_tcb);
  
  /*
!  *  Ԥ塼ν
   *
!  *  Ԥ塼ˤĤʤƤ륿򤹤٤Ԥ롥Ԥ
!  *  ͤϡE_DLTȤ롥ԤؤΥǥѥå
!  *  ɬפʾtrueǤʤfalse֤
   */
  extern bool_t	init_wait_queue(QUEUE *p_wait_queue);
  
--- 206,276 ----
  }
  
  /*
!  *  同期・通信オブジェクトの管理ブロックの共通部分操作ルーチン
   *
!  *  同期・通信オブジェクトの初期化ブロックと管理ブロックの先頭部分は共
!  *  通になっている．以下は，その共通部分を扱うための型およびルーチン群
!  *  である．
   *
!  *  複数の待ちキューを持つ同期・通信オブジェクトの場合，先頭以外の待ち
!  *  キューを操作する場合には，これらのルーチンは使えない．また，オブジェ
!  *  クト属性のTA_TPRIビットを参照するので，このビットを他の目的に使って
!  *  いる場合も，これらのルーチンは使えない．
   */
  
  /*
!  *  同期・通信オブジェクトの初期化ブロックの共通部分
   */
  typedef struct wait_object_initialization_block {
! 	ATR			wobjatr;		/* オブジェクト属性 */
  } WOBJINIB;
  
  /*
!  *  同期・通信オブジェクトの管理ブロックの共通部分
   */
  typedef struct wait_object_control_block {
! 	QUEUE		wait_queue;		/* 待ちキュー */
! 	const WOBJINIB *p_wobjinib;	/* 初期化ブロックへのポインタ */
  } WOBJCB;
  
  /*
!  *  同期・通信オブジェクトの待ち情報ブロックの共通部分
   *
!  *  この構造体は，待ち情報ブロック（WINFO）を拡張（オブジェクト指向言
!  *  語の継承に相当）したものであるが，WINFOが共用体で定義されているた
!  *  めに，1つのフィールドとして含めている．
   */
  typedef struct wait_object_waiting_information {
! 	WINFO	winfo;			/* 標準の待ち情報ブロック */
! 	WOBJCB	*p_wobjcb;		/* 待ちオブジェクトの管理ブロック */
  } WINFO_WOBJ;
  
  /*
!  *  同期・通信オブジェクトに対する待ち状態への遷移
   *  
!  *  実行中のタスクを待ち状態に遷移させ，同期・通信オブジェクトの待ちキュー
!  *  につなぐ．また，待ち情報ブロック（WINFO）のp_wobjcbを設定する．
!  *  wobj_make_wait_tmoutは，タイムイベントブロックの登録も行う．
   */
  extern void	wobj_make_wait(WOBJCB *p_wobjcb, WINFO_WOBJ *p_winfo);
  extern void	wobj_make_wait_tmout(WOBJCB *p_wobjcb, WINFO_WOBJ *p_winfo,
  											TMEVTB *p_tmevtb, TMO tmout);
  
  /*
!  *  タスク優先度変更時の処理
   *
!  *  同期・通信オブジェクトに対する待ち状態にあるタスクの優先度が変更さ
!  *  れた場合に，待ちキューの中でのタスクの位置を修正する．ディスパッチ
!  *  が必要な場合にはtrueを返す．
   */
  extern bool_t	wobj_change_priority(WOBJCB *p_wobjcb, TCB *p_tcb);
  
  /*
!  *  待ちキューの初期化
   *
!  *  待ちキューにつながれているタスクをすべて待ち解除する．待ち解除した
!  *  タスクからの返値は，E_DLTとする．待ち解除したタスクへのディスパッチ
!  *  が必要な場合はtrue，そうでない場合はfalseを返す．
   */
  extern bool_t	init_wait_queue(QUEUE *p_wait_queue);
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/bit_kernel.c ASPs/asp/extension/messagebuf/test/bit_kernel.c
*** 1.9.1/asp/extension/messagebuf/test/bit_kernel.c	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/test/bit_kernel.c	Fri Dec  9 13:54:01 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: bit_kernel.c 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		ͥ
   */
  
  #include "kernel/kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: bit_kernel.c 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /*
!  *		カーネルの整合性検査
   */
  
  #include "kernel/kernel_impl.h"
***************
*** 55,66 ****
  #include "kernel/time_event.h"
  
  /*
!  *   顼ɤ
   */
  #define E_SYS_LINENO	ERCD(E_SYS, -(__LINE__))
  
  /*
!  *  ֥åΥɥ쥹Υå
   */
  #define VALID_TCB(p_tcb) \
  		((((char *) p_tcb) - ((char *) tcb_table)) % sizeof(TCB) == 0 \
--- 55,66 ----
  #include "kernel/time_event.h"
  
  /*
!  *   エラーコードの定義
   */
  #define E_SYS_LINENO	ERCD(E_SYS, -(__LINE__))
  
  /*
!  *  管理ブロックのアドレスの正当性のチェック
   */
  #define VALID_TCB(p_tcb) \
  		((((char *) p_tcb) - ((char *) tcb_table)) % sizeof(TCB) == 0 \
***************
*** 95,105 ****
  			&& TMIN_MPFID <= MPFID(p_mpfcb) && MPFID(p_mpfcb) <= tmax_mpfid)
  
  /*
!  *  塼ΥåΤδؿ
   *
!  *  p_queuep_entryޤޤƤ뤫Ĵ٤롥ޤޤƤtrueޤ
!  *  Ƥʤˤfalse֤֥󥯤ξˤ⡤
!  *  false֤
   */
  static bool_t
  in_queue(QUEUE *p_queue, QUEUE *p_entry)
--- 95,105 ----
  			&& TMIN_MPFID <= MPFID(p_mpfcb) && MPFID(p_mpfcb) <= tmax_mpfid)
  
  /*
!  *  キューのチェックのための関数
   *
!  *  p_queueにp_entryが含まれているかを調べる．含まれていればtrue，含ま
!  *  れていない場合にはfalseを返す．ダブルリンクの不整合の場合にも，
!  *  falseを返す．
   */
  static bool_t
  in_queue(QUEUE *p_queue, QUEUE *p_entry)
***************
*** 108,126 ****
  
  	p_current = p_queue->p_next;
  	if (p_current->p_prev != p_queue) {
! 		return(false);					/* ֥󥯤 */
  	}
  	while (p_current != p_queue) {
  		if (p_current == p_entry) {
! 			return(true);				/* p_entryޤޤƤ */
  		}
  
  		/*
! 		 *  塼μǤ˿ʤ
  		 */
  		p_next = p_current->p_next;
  		if (p_next->p_prev != p_current) {
! 			return(false);				 /* ֥󥯤 */
  		}
  		p_current = p_next;
  	}
--- 108,126 ----
  
  	p_current = p_queue->p_next;
  	if (p_current->p_prev != p_queue) {
! 		return(false);					/* ダブルリンクの不整合 */
  	}
  	while (p_current != p_queue) {
  		if (p_current == p_entry) {
! 			return(true);				/* p_entryが含まれていた */
  		}
  
  		/*
! 		 *  キューの次の要素に進む
  		 */
  		p_next = p_current->p_next;
  		if (p_next->p_prev != p_current) {
! 			return(false);				 /* ダブルリンクの不整合 */
  		}
  		p_current = p_next;
  	}
***************
*** 128,134 ****
  }
  
  /*
!  *  åؤƤ뤫θ
   */
  static bool_t
  on_stack(void *addr, const TINIB *p_tinib)
--- 128,134 ----
  }
  
  /*
!  *  スタック上を指しているかの検査
   */
  static bool_t
  on_stack(void *addr, const TINIB *p_tinib)
***************
*** 141,147 ****
  }
  
  /*
!  *  
   */
  static ER
  bit_task(ID tskid)
--- 141,147 ----
  }
  
  /*
!  *  タスク毎の整合性検査
   */
  static ER
  bit_task(ID tskid)
***************
*** 168,181 ****
  	pri = p_tcb->priority;
  
  	/*
! 	 *  ֥åؤΥݥ󥿤θ
  	 */
  	if (p_tinib != &(tinib_table[INDEX_TSK(tskid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  tstatθ
  	 */
  	switch (tstat & (TS_RUNNABLE | TS_WAITING | TS_SUSPENDED)) {
  	case TS_DORMANT:
--- 168,181 ----
  	pri = p_tcb->priority;
  
  	/*
! 	 *  初期化ブロックへのポインタの検査
  	 */
  	if (p_tinib != &(tinib_table[INDEX_TSK(tskid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  tstatの検査
  	 */
  	switch (tstat & (TS_RUNNABLE | TS_WAITING | TS_SUSPENDED)) {
  	case TS_DORMANT:
***************
*** 208,235 ****
  	}
  
  	/*
! 	 *  actqueθ
  	 */
  	if (TSTAT_DORMANT(tstat) && p_tcb->actque) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  ͥ٤θ
  	 */
  	if (pri >= TNUM_TPRI) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  texptnθ
  	 */
  	if (p_tcb->p_tinib->texrtn == NULL && p_tcb->texptn != 0U) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  ٻ߾֤ˤå
  	 */
  	if (TSTAT_DORMANT(tstat)) {
  		if (!(pri == p_tinib->ipriority)
--- 208,235 ----
  	}
  
  	/*
! 	 *  actqueの検査
  	 */
  	if (TSTAT_DORMANT(tstat) && p_tcb->actque) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  タスク優先度の検査
  	 */
  	if (pri >= TNUM_TPRI) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  texptnの検査
  	 */
  	if (p_tcb->p_tinib->texrtn == NULL && p_tcb->texptn != 0U) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  休止状態におけるチェック
  	 */
  	if (TSTAT_DORMANT(tstat)) {
  		if (!(pri == p_tinib->ipriority)
***************
*** 241,247 ****
  	}
  
  	/*
! 	 *  ¹ԤǤ֤ˤå
  	 */
  	if (TSTAT_RUNNABLE(tstat)) {
  		if (!in_queue(&ready_queue[pri], &(p_tcb->task_queue))) {
--- 241,247 ----
  	}
  
  	/*
! 	 *  実行できる状態におけるチェック
  	 */
  	if (TSTAT_RUNNABLE(tstat)) {
  		if (!in_queue(&ready_queue[pri], &(p_tcb->task_queue))) {
***************
*** 250,256 ****
  	}
  
  	/*
! 	 *  Ԥ֤ˤå
  	 */
  	if (TSTAT_WAITING(tstat)) {
  		if (!on_stack(p_tcb->p_winfo, p_tinib)) {
--- 250,256 ----
  	}
  
  	/*
! 	 *  待ち状態におけるチェック
  	 */
  	if (TSTAT_WAITING(tstat)) {
  		if (!on_stack(p_tcb->p_winfo, p_tinib)) {
***************
*** 262,268 ****
  				return(E_SYS_LINENO);
  			}
  			/*
! 			 *  (*p_tmevtb)θ̤
  			 */
  		}
  
--- 262,268 ----
  				return(E_SYS_LINENO);
  			}
  			/*
! 			 *  (*p_tmevtb)の検査（未完成）
  			 */
  		}
  
***************
*** 382,392 ****
  	}
  
  	/*
! 	 *  tskctxbθ
  	 */
  	if (!TSTAT_DORMANT(tstat) && p_tcb != p_runtsk) {
  		/*
! 		 *  åȰ¸θ
  		 */
  #if 0
  		if (bit_tskctxb(&(p_tcb->tskctxb))) {
--- 382,392 ----
  	}
  
  	/*
! 	 *  tskctxbの検査
  	 */
  	if (!TSTAT_DORMANT(tstat) && p_tcb != p_runtsk) {
  		/*
! 		 *  ターゲット依存の検査
  		 */
  #if 0
  		if (bit_tskctxb(&(p_tcb->tskctxb))) {
***************
*** 398,404 ****
  }
  
  /*
!  *  ޥե
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
--- 398,404 ----
  }
  
  /*
!  *  セマフォ毎の整合性検査
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
***************
*** 420,440 ****
  	semcnt = p_semcb->semcnt;
  
  	/*
! 	 *  ֥åؤΥݥ󥿤θ
  	 */
  	if (p_seminib != &(seminib_table[INDEX_SEM(semid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  semcntθ
  	 */
  	if (semcnt > p_seminib->maxsem) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  wait_queueθ
  	 */
  	if (semcnt == 0) {
  		p_queue = p_semcb->wait_queue.p_next;
--- 420,440 ----
  	semcnt = p_semcb->semcnt;
  
  	/*
! 	 *  初期化ブロックへのポインタの検査
  	 */
  	if (p_seminib != &(seminib_table[INDEX_SEM(semid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  semcntの検査
  	 */
  	if (semcnt > p_seminib->maxsem) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  wait_queueの検査
  	 */
  	if (semcnt == 0) {
  		p_queue = p_semcb->wait_queue.p_next;
***************
*** 461,467 ****
  }
  
  /*
!  *  롼
   */
  ER
  bit_kernel(void)
--- 461,467 ----
  }
  
  /*
!  *  整合性検査ルーチン本体
   */
  ER
  bit_kernel(void)
***************
*** 471,477 ****
  	ER		ercd;
  
  	/*
! 	 *  θ
  	 */
  	for (tskid = TMIN_TSKID; tskid <= tmax_tskid; tskid++) {
  		ercd = bit_task(tskid);
--- 471,477 ----
  	ER		ercd;
  
  	/*
! 	 *  タスク毎の検査
  	 */
  	for (tskid = TMIN_TSKID; tskid <= tmax_tskid; tskid++) {
  		ercd = bit_task(tskid);
***************
*** 481,487 ****
  	}
  
  	/*
! 	 *  ޥեθ
  	 */
  	for (semid = TMIN_SEMID; semid <= tmax_semid; semid++) {
  		ercd = bit_semaphore(semid);
--- 481,487 ----
  	}
  
  	/*
! 	 *  セマフォ毎の検査
  	 */
  	for (semid = TMIN_SEMID; semid <= tmax_semid; semid++) {
  		ercd = bit_semaphore(semid);
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/test_messagebuf1.c ASPs/asp/extension/messagebuf/test/test_messagebuf1.c
*** 1.9.1/asp/extension/messagebuf/test/test_messagebuf1.c	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/messagebuf/test/test_messagebuf1.c	Fri Dec  9 13:54:01 2022
***************
*** 5,91 ****
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_messagebuf1.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		åХåեΥƥ(1)
   *
!  * ڥƥȤŪ
   *
!  *  FIFOåХåեˡåȼ
!  *  ̤ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) åХåեؤsnd_mbfsend_message
!  *		(A-1) Ԥ塼Ƭʥڴʤ
!  *		(A-2) Ԥ塼Ƭʥڴ
!  *		(A-3) åХåեΰ˳Ǽ
!  *		(A-4) Ԥ塼˥뤿Ԥ֤
!  *		(A-5) åХåեΰ˶ʤԤ֤
!  *	(B) åХåեμrcv_mbfreceive_message
!  *		(B-1) åХåեΰ褫
!  *		(B-2) (B-1)Ԥ1ĤޤʣˤԤʥ
!  *			  ڴʤ
!  *		(B-3) (B-1)Ԥ1ĤޤʣˤԤʥ
!  *			  ڴ
!  *		(B-4) Ԥ塼ƬΥΥåʥ
!  *			  ʤ
!  *		(B-5) Ԥ塼ƬΥΥåʥ
!  *			  
!  *		(B-6) Ԥ֤
!  *	(C) åХåեΰؤΥåγǼenqueue_message
!  *		(C-1) ȥåΤϢΰ˳Ǽ
!  *		(C-2) Ǽ˴ΰƬ
!  *		(C-3) åΤγǼǴΰƬ
!  *		(C-4) åΤγǼ˴ΰƬ
!  *	(D) åХåեΰ褫ΥåμФdequeue_message
!  *		(D-1) ȥåΤϢΰ褫Ф
!  *		(D-2) Ф˴ΰƬ
!  *		(D-3) åΤμФǴΰƬ
!  *		(D-4) åΤμФ˴ΰƬ
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	MBF1: åХåեTA_NULL°å26
!  *		  ХåեΰΥ26ºݤˤ28
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_kernel))
   *	1:	act_tsk(TASK2)
   *		act_tsk(TASK3)
--- 5,91 ----
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_messagebuf1.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		メッセージバッファのテスト(1)
   *
!  * 【テストの目的】
   *
!  *  FIFO順メッセージバッファに，メッセージを送信する処理と受信する処理
!  *  を一通りテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) メッセージバッファへの送信処理（snd_mbf，send_message）
!  *		(A-1) 受信待ちキューの先頭タスクが受信（タスク切換えなし）
!  *		(A-2) 受信待ちキューの先頭タスクが受信（タスク切換えあり）
!  *		(A-3) メッセージバッファ管理領域に格納
!  *		(A-4) 送信待ちキューにタスクがあるために送信待ち状態に
!  *		(A-5) メッセージバッファ管理領域に空きがないために送信待ち状態に
!  *	(B) メッセージバッファからの受信処理（rcv_mbf，receive_message）
!  *		(B-1) メッセージバッファ管理領域から受信
!  *		(B-2) (B-1)＋送信待ちタスク（1つまたは複数）が待ち解除（タスク
!  *			  切換えなし）
!  *		(B-3) (B-1)＋送信待ちタスク（1つまたは複数）が待ち解除（タスク
!  *			  切換えあり）
!  *		(B-4) 送信待ちキューの先頭のタスクのメッセージを受信（タスク切
!  *			  換えなし）
!  *		(B-5) 送信待ちキューの先頭のタスクのメッセージを受信（タスク切
!  *			  換えあり）
!  *		(B-6) 受信待ち状態に
!  *	(C) メッセージバッファ管理領域へのメッセージの格納（enqueue_message）
!  *		(C-1) サイズとメッセージ本体を一連の領域に格納
!  *		(C-2) サイズを格納後に管理領域の先頭に戻る
!  *		(C-3) メッセージ本体の格納途中で管理領域の先頭に戻る
!  *		(C-4) メッセージ本体の格納後に管理領域の先頭に戻る
!  *	(D) メッセージバッファ管理領域からのメッセージの取出し（dequeue_message）
!  *		(D-1) サイズとメッセージ本体を一連の領域から取出し
!  *		(D-2) サイズを取出し後に管理領域の先頭に戻る
!  *		(D-3) メッセージ本体の取出し途中で管理領域の先頭に戻る
!  *		(D-4) メッセージ本体の取出し後に管理領域の先頭に戻る
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 高優先度タスク，メインタスク，最初から起動
!  *	TASK2: 中優先度タスク
!  *	TASK3: 低優先度タスク
!  *	MBF1: メッセージバッファ（TA_NULL属性，最大メッセージサイズ：26，メッ
!  *		  セージバッファ管理領域のサイズ：26→実際には28）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：高）==
   *		call(set_bit_func(bit_kernel))
   *	1:	act_tsk(TASK2)
   *		act_tsk(TASK3)
***************
*** 93,170 ****
   *		assert(rmbf.stskid == TSK_NONE)
   *		assert(rmbf.rtskid == TSK_NONE)
   *		assert(rmbf.smbfcnt == 0)
!  *		snd_mbf(MBF1, string1, 9)		... (A-3)(C-1)ѡ015
!  *	2:	snd_mbf(MBF1, string2, 5)		... (A-3)(C-4)ѡ027
   *	3:	snd_mbf(MBF1, string3, 4)		... (A-5)
!  *	== TASK2ͥ١==
   *	4:	ref_mbf(MBF1, &rmbf)
   *		assert(rmbf.stskid == TASK1)
   *		assert(rmbf.rtskid == TSK_NONE)
   *		assert(rmbf.smbfcnt == 2)
   *	5:	snd_mbf(MBF1, string1, 4)		... (A-4)
!  *	== TASK3ͥ١==
!  *	6:	rcv_mbf(MBF1, buf1) -> 9		... (B-3)(D-1)(C-1)ѡ1627,015
!  *	== TASK1³==
   *	7:	assert(strncmp(buf1, string1, 9) == 0)
   *		slp_tsk()
!  *	== TASK2³==
!  *	8:	rcv_mbf(MBF1, buf1) -> 5		... (B-1)(D-4)ѡ015
   *		assert(strncmp(buf1, string2, 5) == 0)
!  *		rcv_mbf(MBF1, buf1) -> 4		... (B-1)(D-1)ѡ815
   *		assert(strncmp(buf1, string3, 4) == 0)
!  *		rcv_mbf(MBF1, buf1) -> 4		... (B-1)(D-1)ѡʤ
   *		assert(strncmp(buf1, string1, 4) == 0)
   *	9:	rcv_mbf(MBF1, buf1) -> 10		... (B-6)
!  *	== TASK3³==
   *	10:	ref_mbf(MBF1, &rmbf)
   *		assert(rmbf.stskid == TSK_NONE)
   *		assert(rmbf.rtskid == TASK2)
   *		assert(rmbf.smbfcnt == 0)
   *	11:	snd_mbf(MBF1, string2, 10)		... (A-2)
!  *	== TASK2³==
   *	12:	assert(strncmp(buf1, string2, 10) == 0)
   *		rcv_mbf(MBF1, buf1) -> 11		... (B-6)
!  *	== TASK3³==
   *	13:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	14:	snd_mbf(MBF1, string3, 11)		... (A-1)
   *		assert(strncmp(buf1, string3, 11) == 0)
!  *		snd_mbf(MBF1, string1, 16)		... (A-3)(C-3)ѡ1627,07
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2³==
   *	15:	slp_tsk()
!  *	== TASK3³==
   *	16:	snd_mbf(MBF1, string2, 12)		... (A-5)
!  *	== TASK1³==
   *	17:	wup_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2³==
   *	18:	snd_mbf(MBF1, string3, 4)		... (A-4)
!  *	== TASK1³==
!  *	19:	rcv_mbf(MBF1, buf1) -> 16		... (B-2)(D-3)(C-1)(C-2)
!  *										... 				ѡ827,03
   *		assert(strncmp(buf1, string1, 16) == 0)
   *		slp_tsk()
!  *	== TASK2³==
!  *	20:	rcv_mbf(MBF1, buf1) -> 12		... (B-1)(D-1)ѡ242703
   *		assert(strncmp(buf1, string2, 12) == 0)
   *	21:	snd_mbf(MBF1, string1, 25)		... (A-5)
!  *	== TASK3³==
!  *	22:	rcv_mbf(MBF1, buf1) -> 4		... (B-1)(D-2)ѡʤ
   *		assert(strncmp(buf1, string3, 4) == 0)
   *		rcv_mbf(MBF1, buf1) -> 25		... (B-5)
!  *	== TASK2³==
   *	23:	assert(strncmp(buf1, string1, 25) == 0)
   *		snd_mbf(MBF1, string2, 26)		... (A-5)
!  *	== TASK3³==
   *	24:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	25:	rcv_mbf(MBF1, buf1) -> 26		... (B-4)
   *		assert(strncmp(buf1, string2, 26) == 0)
   *		slp_tsk()
!  *	== TASK2³==
   *	26:	slp_tsk()
!  *	== TASK3³==
   *	27:	END
   */
  
--- 93,170 ----
   *		assert(rmbf.stskid == TSK_NONE)
   *		assert(rmbf.rtskid == TSK_NONE)
   *		assert(rmbf.smbfcnt == 0)
!  *		snd_mbf(MBF1, string1, 9)		... (A-3)(C-1)，使用：0〜15
!  *	2:	snd_mbf(MBF1, string2, 5)		... (A-3)(C-4)，使用：0〜27
   *	3:	snd_mbf(MBF1, string3, 4)		... (A-5)
!  *	== TASK2（優先度：中）==
   *	4:	ref_mbf(MBF1, &rmbf)
   *		assert(rmbf.stskid == TASK1)
   *		assert(rmbf.rtskid == TSK_NONE)
   *		assert(rmbf.smbfcnt == 2)
   *	5:	snd_mbf(MBF1, string1, 4)		... (A-4)
!  *	== TASK3（優先度：低）==
!  *	6:	rcv_mbf(MBF1, buf1) -> 9		... (B-3)(D-1)(C-1)，使用：16〜27,0〜15
!  *	== TASK1（続き）==
   *	7:	assert(strncmp(buf1, string1, 9) == 0)
   *		slp_tsk()
!  *	== TASK2（続き）==
!  *	8:	rcv_mbf(MBF1, buf1) -> 5		... (B-1)(D-4)，使用：0〜15
   *		assert(strncmp(buf1, string2, 5) == 0)
!  *		rcv_mbf(MBF1, buf1) -> 4		... (B-1)(D-1)，使用：8〜15
   *		assert(strncmp(buf1, string3, 4) == 0)
!  *		rcv_mbf(MBF1, buf1) -> 4		... (B-1)(D-1)，使用：なし
   *		assert(strncmp(buf1, string1, 4) == 0)
   *	9:	rcv_mbf(MBF1, buf1) -> 10		... (B-6)
!  *	== TASK3（続き）==
   *	10:	ref_mbf(MBF1, &rmbf)
   *		assert(rmbf.stskid == TSK_NONE)
   *		assert(rmbf.rtskid == TASK2)
   *		assert(rmbf.smbfcnt == 0)
   *	11:	snd_mbf(MBF1, string2, 10)		... (A-2)
!  *	== TASK2（続き）==
   *	12:	assert(strncmp(buf1, string2, 10) == 0)
   *		rcv_mbf(MBF1, buf1) -> 11		... (B-6)
!  *	== TASK3（続き）==
   *	13:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	14:	snd_mbf(MBF1, string3, 11)		... (A-1)
   *		assert(strncmp(buf1, string3, 11) == 0)
!  *		snd_mbf(MBF1, string1, 16)		... (A-3)(C-3)，使用：16〜27,0〜7
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2（続き）==
   *	15:	slp_tsk()
!  *	== TASK3（続き）==
   *	16:	snd_mbf(MBF1, string2, 12)		... (A-5)
!  *	== TASK1（続き）==
   *	17:	wup_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2（続き）==
   *	18:	snd_mbf(MBF1, string3, 4)		... (A-4)
!  *	== TASK1（続き）==
!  *	19:	rcv_mbf(MBF1, buf1) -> 16		... (B-2)(D-3)(C-1)(C-2)，
!  *										... 				使用：8〜27,0〜3
   *		assert(strncmp(buf1, string1, 16) == 0)
   *		slp_tsk()
!  *	== TASK2（続き）==
!  *	20:	rcv_mbf(MBF1, buf1) -> 12		... (B-1)(D-1)，使用：24〜27，0〜3
   *		assert(strncmp(buf1, string2, 12) == 0)
   *	21:	snd_mbf(MBF1, string1, 25)		... (A-5)
!  *	== TASK3（続き）==
!  *	22:	rcv_mbf(MBF1, buf1) -> 4		... (B-1)(D-2)，使用：なし
   *		assert(strncmp(buf1, string3, 4) == 0)
   *		rcv_mbf(MBF1, buf1) -> 25		... (B-5)
!  *	== TASK2（続き）==
   *	23:	assert(strncmp(buf1, string1, 25) == 0)
   *		snd_mbf(MBF1, string2, 26)		... (A-5)
!  *	== TASK3（続き）==
   *	24:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	25:	rcv_mbf(MBF1, buf1) -> 26		... (B-4)
   *		assert(strncmp(buf1, string2, 26) == 0)
   *		slp_tsk()
!  *	== TASK2（続き）==
   *	26:	slp_tsk()
!  *	== TASK3（続き）==
   *	27:	END
   */
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/test_messagebuf1.cfg ASPs/asp/extension/messagebuf/test/test_messagebuf1.cfg
*** 1.9.1/asp/extension/messagebuf/test/test_messagebuf1.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/messagebuf/test/test_messagebuf1.cfg	Fri Dec  9 13:54:01 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  åХåեΥƥ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  メッセージバッファのテスト(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/test_messagebuf1.h ASPs/asp/extension/messagebuf/test/test_messagebuf1.h
*** 1.9.1/asp/extension/messagebuf/test/test_messagebuf1.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/test/test_messagebuf1.h	Fri Dec  9 13:54:01 2022
***************
*** 5,67 ****
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_messagebuf1.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /* 
!  *		åХåեΥƥ(1)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_messagebuf1.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /* 
!  *		メッセージバッファのテスト(1)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/test_messagebuf2.c ASPs/asp/extension/messagebuf/test/test_messagebuf2.c
*** 1.9.1/asp/extension/messagebuf/test/test_messagebuf2.c	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/messagebuf/test/test_messagebuf2.c	Fri Dec  9 13:54:01 2022
***************
*** 5,243 ****
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_messagebuf2.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		åХåեΥƥ(2)
   *
!  * ڥƥȤŪ
   *
!  *  FIFOåХåեԤŪԤ줿
!  *  ̤ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) Ԥλter_tsk
!  *		(A-1) ԤԤʤ
!  *		(A-2) Ԥ1ĤޤʣˤԤʥڴʤ
!  *		(A-3) Ԥ1ĤޤʣˤԤʥڴ
!  *	(B) ԤԤrel_wai
!  *		(B-1) ԤԤʤ
!  *		(B-2) Ԥ1ĤޤʣˤԤʥڴʤ
!  *		(B-3) Ԥ1ĤޤʣˤԤʥڴ
!  *	(C) ԤԤirel_wai
!  *		(C-1) ԤԤʤ
!  *		(C-2) Ԥ1ĤޤʣˤԤʥڴʤ
!  *		(C-3) Ԥ1ĤޤʣˤԤʥڴ
!  *	(D) ԤॢȤԤ
!  *		(D-1) ԤԤʤ
!  *		(D-2) Ԥ1ĤޤʣˤԤʥڴʤ
!  *		(D-3) Ԥ1ĤޤʣˤԤʥڴ
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	MBF1: åХåեTA_NULL°å26
!  *		  ХåեΰΥ26ºݤˤ28
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_kernel))
   *	1:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-1ͥ١1 ==
   *	2:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3ͥ١==
   *	3:	snd_mbf(MBF1, string2, 26)
!  *	== TASK1³==
   *	4:	ter_tsk(TASK2)									... (A-1)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK1³==
   *	5:	rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
   *		act_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-2ͥ١2 ==
   *	6:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3³==
   *	7:	snd_mbf(MBF1, string3, 10)
!  *	== TASK1³==
   *	8:	ter_tsk(TASK2)									... (A-2)
   *		slp_tsk()
!  *	== TASK3³==
   *	9:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	10:	act_tsk(TASK2)
!  *	== TASK2-3ͥ١3 ==
   *	11:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3³==
   *	12:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	13:	snd_mbf(MBF1, string3, 10)
!  *	== TASK3³==
   *	14:	ter_tsk(TASK2)									... (A-3)
!  *	== TASK1³==
   *	15:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		act_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4ͥ١4 ==
   *	16:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3³==
   *	17:	snd_mbf(MBF1, string2, 26)
!  *	== TASK1³==
   *	18:	rel_wai(TASK2)									... (B-1)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4³==
   *	19:	slp_tsk()
!  *	== TASK1³==
   *	20:	rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
   *		wup_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4³==
   *	21:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3³==
   *	22:	snd_mbf(MBF1, string3, 10)
!  *	== TASK1³==
   *	23:	rel_wai(TASK2)									... (B-2)
   *		slp_tsk()
!  *	== TASK2-4³==
   *	24:	slp_tsk()
!  *	== TASK3³==
   *	25:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	26:	wup_tsk(TASK2)
!  *	== TASK2-4³==
   *	27:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3³==
   *	28:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	29:	snd_mbf(MBF1, string3, 10)
!  *	== TASK3³==
   *	30:	rel_wai(TASK2)									... (B-3)
!  *	== TASK1³==
   *	31:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4³==
   *	32:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3³==
   *	33:	snd_mbf(MBF1, string2, 26)
!  *	== TASK1³==
   *	34:	sta_alm(ALM1, 1U)
   *		slp_tsk()
   *	== ALM1-1 ==
   *	35:	irel_wai(TASK2)									... (C-1)
   *		iwup_tsk(TASK1)
   *		RETURN
!  *	== TASK1³==
   *	36:	tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4³==
   *	37:	slp_tsk()
!  *	== TASK1³==
   *	38:	rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
   *		wup_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4³==
   *	39:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3³==
   *	40:	snd_mbf(MBF1, string3, 10)
!  *	== TASK1³==
   *	41:	sta_alm(ALM1, 1U)
   *		slp_tsk()
   *	== ALM1-2 ==
   *	42:	irel_wai(TASK2)									... (C-2)
   *		RETURN
!  *	== TASK2-4³==
   *	43:	slp_tsk()
!  *	== TASK3³==
   *	44:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	45:	wup_tsk(TASK2)
!  *	== TASK2-4³==
   *	46:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3³==
   *	47:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	48:	snd_mbf(MBF1, string3, 10)
!  *	== TASK3³==
   *	49:	sta_alm(ALM1, 1U)
   *		slp_tsk()
   *	== ALM1-3 ==
   *	50:	irel_wai(TASK2)									... (C-3)
   *		RETURN
!  *	== TASK1³==
   *	51:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		wup_tsk(TASK3)
   *		slp_tsk()
!  *	== TASK2-4³==
    *	52:	tsnd_mbf(MBF1, string1, 26, 1) -> E_TMOUT		... (D-1)
!  *	== TASK3³==
   *	53:	snd_mbf(MBF1, string2, 26)
!  *	== TASK2-4³==
   *	54:	tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4³==
   *	55:	rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
   *	56:	tsnd_mbf(MBF1, string1, 26, 1) -> E_TMOUT		... (D-2)
!  *	== TASK3³==
   *	57:	snd_mbf(MBF1, string3, 10)
!  *	== TASK2-4³==
   *	58:	slp_tsk()
!  *	== TASK3³==
   *	59:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	60:	wup_tsk(TASK2)
!  *	== TASK2-4³==
   *	61:	tsnd_mbf(MBF1, string1, 26, 1) -> E_TMOUT		... (D-3)
!  *	== TASK3³==
   *	62:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	63:	snd_mbf(MBF1, string3, 10)
!  *	== TASK3³==
   *	64:	slp_tsk()
!  *	== TASK1³==
   *	65:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		slp_tsk()
!  *	== TASK2-4³==
   *	66:	END
   */
  
--- 5,243 ----
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_messagebuf2.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		メッセージバッファのテスト(2)
   *
!  * 【テストの目的】
   *
!  *  FIFO順メッセージバッファの送信待ちタスクが，強制的に待ち解除された
!  *  場合を一通りテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) 送信待ちタスクが強制終了（ter_tsk）
!  *		(A-1) 送信待ちタスクの待ち解除なし
!  *		(A-2) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えなし）
!  *		(A-3) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えあり）
!  *	(B) 送信待ちタスクが強制待ち解除（rel_wai）
!  *		(B-1) 送信待ちタスクの待ち解除なし
!  *		(B-2) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えなし）
!  *		(B-3) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えあり）
!  *	(C) 送信待ちタスクが強制待ち解除（irel_wai）
!  *		(C-1) 送信待ちタスクの待ち解除なし
!  *		(C-2) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えなし）
!  *		(C-3) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えあり）
!  *	(D) 送信待ちタスクがタイムアウトで待ち解除
!  *		(D-1) 送信待ちタスクの待ち解除なし
!  *		(D-2) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えなし）
!  *		(D-3) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えあり）
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 高優先度タスク，メインタスク，最初から起動
!  *	TASK2: 中優先度タスク
!  *	TASK3: 低優先度タスク
!  *	MBF1: メッセージバッファ（TA_NULL属性，最大メッセージサイズ：26，メッ
!  *		  セージバッファ管理領域のサイズ：26→実際には28）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：高）==
   *		call(set_bit_func(bit_kernel))
   *	1:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-1（優先度：中）1回め ==
   *	2:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3（優先度：低）==
   *	3:	snd_mbf(MBF1, string2, 26)
!  *	== TASK1（続き）==
   *	4:	ter_tsk(TASK2)									... (A-1)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK1（続き）==
   *	5:	rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
   *		act_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-2（優先度：中）2回め ==
   *	6:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3（続き）==
   *	7:	snd_mbf(MBF1, string3, 10)
!  *	== TASK1（続き）==
   *	8:	ter_tsk(TASK2)									... (A-2)
   *		slp_tsk()
!  *	== TASK3（続き）==
   *	9:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	10:	act_tsk(TASK2)
!  *	== TASK2-3（優先度：中）3回め ==
   *	11:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3（続き）==
   *	12:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	13:	snd_mbf(MBF1, string3, 10)
!  *	== TASK3（続き）==
   *	14:	ter_tsk(TASK2)									... (A-3)
!  *	== TASK1（続き）==
   *	15:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		act_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4（優先度：中）4回め ==
   *	16:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3（続き）==
   *	17:	snd_mbf(MBF1, string2, 26)
!  *	== TASK1（続き）==
   *	18:	rel_wai(TASK2)									... (B-1)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4（続き）==
   *	19:	slp_tsk()
!  *	== TASK1（続き）==
   *	20:	rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
   *		wup_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4（続き）==
   *	21:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3（続き）==
   *	22:	snd_mbf(MBF1, string3, 10)
!  *	== TASK1（続き）==
   *	23:	rel_wai(TASK2)									... (B-2)
   *		slp_tsk()
!  *	== TASK2-4（続き）==
   *	24:	slp_tsk()
!  *	== TASK3（続き）==
   *	25:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	26:	wup_tsk(TASK2)
!  *	== TASK2-4（続き）==
   *	27:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3（続き）==
   *	28:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	29:	snd_mbf(MBF1, string3, 10)
!  *	== TASK3（続き）==
   *	30:	rel_wai(TASK2)									... (B-3)
!  *	== TASK1（続き）==
   *	31:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4（続き）==
   *	32:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3（続き）==
   *	33:	snd_mbf(MBF1, string2, 26)
!  *	== TASK1（続き）==
   *	34:	sta_alm(ALM1, 1U)
   *		slp_tsk()
   *	== ALM1-1 ==
   *	35:	irel_wai(TASK2)									... (C-1)
   *		iwup_tsk(TASK1)
   *		RETURN
!  *	== TASK1（続き）==
   *	36:	tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4（続き）==
   *	37:	slp_tsk()
!  *	== TASK1（続き）==
   *	38:	rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
   *		wup_tsk(TASK2)
   *		tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4（続き）==
   *	39:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3（続き）==
   *	40:	snd_mbf(MBF1, string3, 10)
!  *	== TASK1（続き）==
   *	41:	sta_alm(ALM1, 1U)
   *		slp_tsk()
   *	== ALM1-2 ==
   *	42:	irel_wai(TASK2)									... (C-2)
   *		RETURN
!  *	== TASK2-4（続き）==
   *	43:	slp_tsk()
!  *	== TASK3（続き）==
   *	44:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	45:	wup_tsk(TASK2)
!  *	== TASK2-4（続き）==
   *	46:	snd_mbf(MBF1, string1, 26) -> E_RLWAI
!  *	== TASK3（続き）==
   *	47:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	48:	snd_mbf(MBF1, string3, 10)
!  *	== TASK3（続き）==
   *	49:	sta_alm(ALM1, 1U)
   *		slp_tsk()
   *	== ALM1-3 ==
   *	50:	irel_wai(TASK2)									... (C-3)
   *		RETURN
!  *	== TASK1（続き）==
   *	51:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		wup_tsk(TASK3)
   *		slp_tsk()
!  *	== TASK2-4（続き）==
    *	52:	tsnd_mbf(MBF1, string1, 26, 1) -> E_TMOUT		... (D-1)
!  *	== TASK3（続き）==
   *	53:	snd_mbf(MBF1, string2, 26)
!  *	== TASK2-4（続き）==
   *	54:	tslp_tsk(1) -> E_TMOUT
!  *	== TASK2-4（続き）==
   *	55:	rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
   *	56:	tsnd_mbf(MBF1, string1, 26, 1) -> E_TMOUT		... (D-2)
!  *	== TASK3（続き）==
   *	57:	snd_mbf(MBF1, string3, 10)
!  *	== TASK2-4（続き）==
   *	58:	slp_tsk()
!  *	== TASK3（続き）==
   *	59:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	60:	wup_tsk(TASK2)
!  *	== TASK2-4（続き）==
   *	61:	tsnd_mbf(MBF1, string1, 26, 1) -> E_TMOUT		... (D-3)
!  *	== TASK3（続き）==
   *	62:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	63:	snd_mbf(MBF1, string3, 10)
!  *	== TASK3（続き）==
   *	64:	slp_tsk()
!  *	== TASK1（続き）==
   *	65:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		slp_tsk()
!  *	== TASK2-4（続き）==
   *	66:	END
   */
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/test_messagebuf2.cfg ASPs/asp/extension/messagebuf/test/test_messagebuf2.cfg
*** 1.9.1/asp/extension/messagebuf/test/test_messagebuf2.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/messagebuf/test/test_messagebuf2.cfg	Fri Dec  9 13:54:01 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  åХåեΥƥ(2)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  メッセージバッファのテスト(2)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/test_messagebuf2.h ASPs/asp/extension/messagebuf/test/test_messagebuf2.h
*** 1.9.1/asp/extension/messagebuf/test/test_messagebuf2.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/test/test_messagebuf2.h	Fri Dec  9 13:54:01 2022
***************
*** 5,67 ****
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_messagebuf2.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /* 
!  *		åХåեΥƥ(2)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_messagebuf2.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /* 
!  *		メッセージバッファのテスト(2)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/test_messagebuf3.c ASPs/asp/extension/messagebuf/test/test_messagebuf3.c
*** 1.9.1/asp/extension/messagebuf/test/test_messagebuf3.c	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/messagebuf/test/test_messagebuf3.c	Fri Dec  9 13:54:01 2022
***************
*** 5,105 ****
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_messagebuf3.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		åХåեΥƥ(3)
   *
!  * ڥƥȤŪ
   *
!  *  ͥٽåХåեΡFIFOåХåեȰۤ
!  *  뿶񤤤ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) Ԥ塼ͥ٤Ǥ뤳
!  *		(A-1) 夫夷ͥ٥ˤĤʤ뤳
!  *		(A-2) Ʊͥ٤ΥFIFOǤ뤳
!  *	(B) Ԥ塼˥뤿Ԥ֤ˤʤΰ㤤
!  *		(B-1) Ԥ塼ξ
!  *		(B-2) Ԥ塼㤤ͥ٤ΥΤߤ
!  *		(B-3) Ԥ塼Ʊ⤤ͥ٤Υ
!  *	(C) Ԥ塼Ƭͥ٤򲼤ƬѤ
!  *		(C-1) ԤԤʤ
!  *		(C-2) Ԥ1ĤޤʣˤԤʥڴʤ
!  *		(C-3) Ԥ1ĤޤʣˤԤʥڴ
!  *	(D) Ԥ塼楿ͥ٤夲ƬѤ
!  *		(D-1) ԤԤʤ
!  *		(D-2) Ԥ1ĤޤʣˤԤʥڴʤ
!  *		(D-3) Ԥ1ĤޤʣˤԤʥڴ
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	TASK4: ͥ٥
!  *	MBF1: åХåեTA_TPRI°å26
!  *		  ХåեΰΥ26ºݤˤ28
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_kernel))
   *	1:	act_tsk(TASK2)
   *		act_tsk(TASK4)
   *		slp_tsk()
!  *	== TASK2ͥ١==
   *	2:	snd_mbf(MBF1, string1, 26)
!  *	== TASK4ͥ١==
   *	3:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	4:	snd_mbf(MBF1, string2, 25)						... (A-1)
!  *	== TASK4³==
   *	5:	ref_mbf(MBF1, &rmbf)
   *		assert(rmbf.stskid == TASK1)
   *		assert(rmbf.rtskid == TSK_NONE)
   *		assert(rmbf.smbfcnt == 0)
   *		rcv_mbf(MBF1, buf1) -> 25
!  *	== TASK1³==
   *	6:	assert(strncmp(buf1, string2, 25) == 0)
   *		act_tsk(TASK3)
   *		slp_tsk()
!  *	== TASK3ͥ١==
   *	7:	snd_mbf(MBF1, string2, 26)						... (A-2)
!  *	== TASK4³==
   *	8:	rcv_mbf(MBF1, buf1) -> 26
!  *	== TASK2³==
   *	9:	assert(strncmp(buf1, string1, 26) == 0)
   *		rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
--- 5,105 ----
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_messagebuf3.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		メッセージバッファのテスト(3)
   *
!  * 【テストの目的】
   *
!  *  タスク優先度順メッセージバッファの，FIFO順メッセージバッファと異な
!  *  る振舞いをテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) 送信待ちキューがタスク優先度であること
!  *		(A-1) 後から到着した高優先度タスクが前につながれること
!  *		(A-2) 同じ優先度のタスクはFIFO順であること
!  *	(B) 送信待ちキューにタスクがあるために送信待ち状態になる条件の違い
!  *		(B-1) 送信待ちキューが空の場合
!  *		(B-2) 送信待ちキューに低い優先度のタスクのみがある場合
!  *		(B-3) 送信待ちキューに同じか高い優先度のタスクがある場合
!  *	(C) 送信待ちキューの先頭タスクの優先度を下げて先頭タスクが変わる場合
!  *		(C-1) 送信待ちタスクの待ち解除なし
!  *		(C-2) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えなし）
!  *		(C-3) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えあり）
!  *	(D) 送信待ちキューの途中タスクの優先度を上げて先頭タスクが変わる場合
!  *		(D-1) 送信待ちタスクの待ち解除なし
!  *		(D-2) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えなし）
!  *		(D-3) 送信待ちタスク（1つまたは複数）が待ち解除（タスク切換えあり）
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 高優先度タスク，メインタスク，最初から起動
!  *	TASK2: 中優先度タスク
!  *	TASK3: 中優先度タスク
!  *	TASK4: 低優先度タスク
!  *	MBF1: メッセージバッファ（TA_TPRI属性，最大メッセージサイズ：26，メッ
!  *		  セージバッファ管理領域のサイズ：26→実際には28）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：高）==
   *		call(set_bit_func(bit_kernel))
   *	1:	act_tsk(TASK2)
   *		act_tsk(TASK4)
   *		slp_tsk()
!  *	== TASK2（優先度：中）==
   *	2:	snd_mbf(MBF1, string1, 26)
!  *	== TASK4（優先度：低）==
   *	3:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	4:	snd_mbf(MBF1, string2, 25)						... (A-1)
!  *	== TASK4（続き）==
   *	5:	ref_mbf(MBF1, &rmbf)
   *		assert(rmbf.stskid == TASK1)
   *		assert(rmbf.rtskid == TSK_NONE)
   *		assert(rmbf.smbfcnt == 0)
   *		rcv_mbf(MBF1, buf1) -> 25
!  *	== TASK1（続き）==
   *	6:	assert(strncmp(buf1, string2, 25) == 0)
   *		act_tsk(TASK3)
   *		slp_tsk()
!  *	== TASK3（優先度：中）==
   *	7:	snd_mbf(MBF1, string2, 26)						... (A-2)
!  *	== TASK4（続き）==
   *	8:	rcv_mbf(MBF1, buf1) -> 26
!  *	== TASK2（続き）==
   *	9:	assert(strncmp(buf1, string1, 26) == 0)
   *		rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string2, 26) == 0)
***************
*** 107,178 ****
   *		rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	11:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3³==
   *	12:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	13:	snd_mbf(MBF1, string2, 10)						... (B-2)
   *		rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string2, 10) == 0)
   *		slp_tsk()
!  *	== TASK3³==
   *	14:	snd_mbf(MBF1, string3, 10)						... (B-3)
!  *	== TASK4³==
   *	15:	rcv_mbf(MBF1, buf1) -> 26
!  *	== TASK2³==
   *	16:	assert(strncmp(buf1, string1, 26) == 0)
   *		rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	17:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3³==
   *	18:	snd_mbf(MBF1, string2, 26)
!  *	== TASK4³==
   *	19:	chg_pri(TASK2, LOW_PRIORITY)					... (C-1)
   *		rcv_mbf(MBF1, buf1) -> 26
!  *	== TASK3³==
   *	20:	assert(strncmp(buf1, string2, 26) == 0)
   *		rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string1, 26) == 0)
!  *		chg_pri(TASK2, TPRI_INI)						... ᤹
   *	21:	snd_mbf(MBF1, string1, 26)
!  *	== TASK2³==
   *	22:	snd_mbf(MBF1, string2, 10)
!  *	== TASK4³==
   *	23:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	24:	chg_pri(TASK3, LOW_PRIORITY)					... (C-2)
   *		slp_tsk()
!  *	== TASK2³==
   *	25:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string2, 10) == 0)
!  *		chg_pri(TASK3, TPRI_INI)						... ᤹
   *	26:	snd_mbf(MBF1, string3, 10)
!  *	== TASK4³==
   *	27:	chg_pri(TASK3, LOW_PRIORITY)					... (C-3)
!  *	== TASK2³==
   *	28:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
!  *		chg_pri(TASK3, TPRI_INI)						... ᤹
   *	29:	snd_mbf(MBF1, string1, 26)
!  *	== TASK4³==
   *	30:	chg_pri(TASK2, HIGH_PRIORITY)					... (D-1)
   *		rcv_mbf(MBF1, buf1) -> 26
!  *	== TASK2³==
   *	31:	assert(strncmp(buf1, string1, 26) == 0)
!  *		chg_pri(TSK_SELF, TPRI_INI)						... ᤹
   *	32:	snd_mbf(MBF1, string2, 10)
!  *	== TASK4³==
   *	33:	wup_tsk(TASK1)
!  *	== TASK1³==
   *	34:	chg_pri(TASK2, HIGH_PRIORITY)					... (D-2)
   *		slp_tsk()
!  *	== TASK2³==
   *	35:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string2, 10) == 0)
!  *		chg_pri(TSK_SELF, TPRI_INI)						... ᤹
   *	36:	snd_mbf(MBF1, string3, 10)
!  *	== TASK4³==
   *	37:	chg_pri(TASK2, HIGH_PRIORITY)					... (D-3)
!  *	== TASK2³==
   *	38:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		rcv_mbf(MBF1, buf1) -> 26
--- 107,178 ----
   *		rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	11:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3（続き）==
   *	12:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	13:	snd_mbf(MBF1, string2, 10)						... (B-2)
   *		rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string2, 10) == 0)
   *		slp_tsk()
!  *	== TASK3（続き）==
   *	14:	snd_mbf(MBF1, string3, 10)						... (B-3)
!  *	== TASK4（続き）==
   *	15:	rcv_mbf(MBF1, buf1) -> 26
!  *	== TASK2（続き）==
   *	16:	assert(strncmp(buf1, string1, 26) == 0)
   *		rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *	17:	snd_mbf(MBF1, string1, 26)
!  *	== TASK3（続き）==
   *	18:	snd_mbf(MBF1, string2, 26)
!  *	== TASK4（続き）==
   *	19:	chg_pri(TASK2, LOW_PRIORITY)					... (C-1)
   *		rcv_mbf(MBF1, buf1) -> 26
!  *	== TASK3（続き）==
   *	20:	assert(strncmp(buf1, string2, 26) == 0)
   *		rcv_mbf(MBF1, buf1) -> 26
   *		assert(strncmp(buf1, string1, 26) == 0)
!  *		chg_pri(TASK2, TPRI_INI)						... 元に戻す
   *	21:	snd_mbf(MBF1, string1, 26)
!  *	== TASK2（続き）==
   *	22:	snd_mbf(MBF1, string2, 10)
!  *	== TASK4（続き）==
   *	23:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	24:	chg_pri(TASK3, LOW_PRIORITY)					... (C-2)
   *		slp_tsk()
!  *	== TASK2（続き）==
   *	25:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string2, 10) == 0)
!  *		chg_pri(TASK3, TPRI_INI)						... 元に戻す
   *	26:	snd_mbf(MBF1, string3, 10)
!  *	== TASK4（続き）==
   *	27:	chg_pri(TASK3, LOW_PRIORITY)					... (C-3)
!  *	== TASK2（続き）==
   *	28:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
!  *		chg_pri(TASK3, TPRI_INI)						... 元に戻す
   *	29:	snd_mbf(MBF1, string1, 26)
!  *	== TASK4（続き）==
   *	30:	chg_pri(TASK2, HIGH_PRIORITY)					... (D-1)
   *		rcv_mbf(MBF1, buf1) -> 26
!  *	== TASK2（続き）==
   *	31:	assert(strncmp(buf1, string1, 26) == 0)
!  *		chg_pri(TSK_SELF, TPRI_INI)						... 元に戻す
   *	32:	snd_mbf(MBF1, string2, 10)
!  *	== TASK4（続き）==
   *	33:	wup_tsk(TASK1)
!  *	== TASK1（続き）==
   *	34:	chg_pri(TASK2, HIGH_PRIORITY)					... (D-2)
   *		slp_tsk()
!  *	== TASK2（続き）==
   *	35:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string2, 10) == 0)
!  *		chg_pri(TSK_SELF, TPRI_INI)						... 元に戻す
   *	36:	snd_mbf(MBF1, string3, 10)
!  *	== TASK4（続き）==
   *	37:	chg_pri(TASK2, HIGH_PRIORITY)					... (D-3)
!  *	== TASK2（続き）==
   *	38:	rcv_mbf(MBF1, buf1) -> 10
   *		assert(strncmp(buf1, string3, 10) == 0)
   *		rcv_mbf(MBF1, buf1) -> 26
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/test_messagebuf3.cfg ASPs/asp/extension/messagebuf/test/test_messagebuf3.cfg
*** 1.9.1/asp/extension/messagebuf/test/test_messagebuf3.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/messagebuf/test/test_messagebuf3.cfg	Fri Dec  9 13:54:01 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  åХåեΥƥ(3)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  メッセージバッファのテスト(3)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/messagebuf/test/test_messagebuf3.h ASPs/asp/extension/messagebuf/test/test_messagebuf3.h
*** 1.9.1/asp/extension/messagebuf/test/test_messagebuf3.h	Thu Jan  2 14:10:55 2014
--- ASPs/asp/extension/messagebuf/test/test_messagebuf3.h	Fri Dec  9 13:54:01 2022
***************
*** 5,67 ****
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_messagebuf3.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /* 
!  *		åХåեΥƥ(3)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_messagebuf3.h 2589 2014-01-02 05:10:53Z ertl-hiro $
   */
  
  /* 
!  *		メッセージバッファのテスト(3)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/mutex/include/kernel.h ASPs/asp/extension/mutex/include/kernel.h
*** 1.9.1/asp/extension/mutex/include/kernel.h	Sun Aug 17 21:42:45 2014
--- ASPs/asp/extension/mutex/include/kernel.h	Fri Dec  9 13:54:01 2022
***************
*** 8,57 ****
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥ ɸإåե
   *
!  *  TOPPERS/ASPͥ뤬ݡȤ륵ӥȡɬפʥǡ
!  *  ޥޤإåե롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   *
!  *  Υե򥤥󥯥롼ɤ˥󥯥롼ɤƤ٤ե
!  *  Ϥʤ
   */
  
  #ifndef TOPPERS_KERNEL_H
--- 8,57 ----
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル 標準ヘッダファイル
   *
!  *  TOPPERS/ASPカーネルがサポートするサービスコールの宣言と，必要なデー
!  *  タ型，定数，マクロの定義を含むヘッダファイル．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   *
!  *  このファイルをインクルードする前にインクルードしておくべきファイル
!  *  はない．
   */
  
  #ifndef TOPPERS_KERNEL_H
***************
*** 62,93 ****
  #endif
  
  /*
!  *	TOPPERS̤Υǡޥ
   */
  #include <t_stddef.h>
  
  /*
!  *  åȰ¸
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ǡ
   */
  
  /*
!  *  ӥåȥѥ䥪ֹ֥η
   */
! typedef	uint_t		TEXPTN;		/* 㳰װΥӥåȥѥ */
! typedef	uint_t		FLGPTN;		/* ٥ȥե饰Υӥåȥѥ */
! typedef	uint_t		INTNO;		/* ֹ */
! typedef	uint_t		INHNO;		/* ߥϥɥֹ */
! typedef	uint_t		EXCNO;		/* CPU㳰ϥɥֹ */
  
  /*
!  *  ñ̤η
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
--- 62,93 ----
  #endif
  
  /*
!  *	TOPPERS共通のデータ型・定数・マクロ
   */
  #include <t_stddef.h>
  
  /*
!  *  ターゲット依存部
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  データ型の定義
   */
  
  /*
!  *  ビットパターンやオブジェクト番号の型定義
   */
! typedef	uint_t		TEXPTN;		/* タスク例外要因のビットパターン */
! typedef	uint_t		FLGPTN;		/* イベントフラグのビットパターン */
! typedef	uint_t		INTNO;		/* 割込み番号 */
! typedef	uint_t		INHNO;		/* 割込みハンドラ番号 */
! typedef	uint_t		EXCNO;		/* CPU例外ハンドラ番号 */
  
  /*
!  *  処理単位の型定義
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
***************
*** 100,207 ****
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  ΰݤΤη
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* åΰݤ뤿η */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* Ĺסΰݤ뤿η */
  
  /*
!  *  åإåη
   */
! typedef	struct t_msg {			/* ᡼ܥåΥåإå */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* ͥդåإå */
! 	T_MSG	msgque;				/* åإå */
! 	PRI		msgpri;				/* åͥ */
  } T_MSG_PRI;
  
  /*
!  *  ѥåȷ
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/*  */
! 	PRI		tskpri;		/* θͥ */
! 	PRI		tskbpri;	/* Υ١ͥ */
! 	STAT	tskwait;	/* Ԥװ */
! 	ID		wobjid;		/* ԤоݤΥ֥ȤID */
! 	TMO		lefttmo;	/* ॢȤޤǤλ */
! 	uint_t	actcnt;		/* ư׵ᥭ塼󥰿 */
! 	uint_t	wupcnt;		/* ׵ᥭ塼󥰿 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* 㳰ξ */
! 	TEXPTN	pndptn;		/* α㳰װ */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* ޥեԤƬΥIDֹ */
! 	uint_t	semcnt;		/* ޥեθߤλ񸻿 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* ٥ȥե饰ԤƬΥIDֹ */
! 	FLGPTN	flgptn;		/* ٥ȥե饰θߤΥӥåȥѥ */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* ǡ塼ԤƬΥIDֹ */
! 	ID		rtskid;		/* ǡ塼μԤƬΥIDֹ */
! 	uint_t	sdtqcnt;	/* ǡ塼ΰ˳ǼƤǡο */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* ͥ٥ǡ塼ԤƬΥ
! 						   IDֹ */
! 	ID		rtskid;		/* ͥ٥ǡ塼μԤƬΥ
! 						   IDֹ */
! 	uint_t	spdqcnt;	/* ͥ٥ǡ塼ΰ˳ǼƤǡ
! 						   ο */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* ᡼ܥåԤƬΥIDֹ */
! 	T_MSG	*pk_msg;	/* å塼ƬˤĤʤ줿å
! 						   Ƭ */
  } T_RMBX;
  
  typedef struct t_rmtx {
! 	ID		htskid;		/* ߥ塼ƥååƤ륿IDֹ */
! 	ID		wtskid;		/* ߥ塼ƥåԤƬΥIDֹ */
  } T_RMTX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* ĹסԤƬΥ
! 						   IDֹ */
! 	uint_t	fblkcnt;	/* Ĺסΰζΰ˳
! 						   դ뤳ȤǤĹ֥åο */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* ϥɥư */
! 	RELTIM	lefttim;	/* ˼ϥɥưޤǤл */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* 顼ϥɥư */
! 	RELTIM	lefttim;	/* 顼ϥɥưޤǤл */
  } T_RALM;
  
  /*
!  *  ӥ
   */
  
  /*
!  *  ǽ
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
--- 100,207 ----
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  メモリ領域確保のための型定義
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* スタック領域を確保するための型 */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* 固定長メモリプール領域を確保するための型 */
  
  /*
!  *  メッセージヘッダの型定義
   */
! typedef	struct t_msg {			/* メールボックスのメッセージヘッダ */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* 優先度付きメッセージヘッダ */
! 	T_MSG	msgque;				/* メッセージヘッダ */
! 	PRI		msgpri;				/* メッセージ優先度 */
  } T_MSG_PRI;
  
  /*
!  *  パケット形式の定義
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/* タスク状態 */
! 	PRI		tskpri;		/* タスクの現在優先度 */
! 	PRI		tskbpri;	/* タスクのベース優先度 */
! 	STAT	tskwait;	/* 待ち要因 */
! 	ID		wobjid;		/* 待ち対象のオブジェクトのID */
! 	TMO		lefttmo;	/* タイムアウトするまでの時間 */
! 	uint_t	actcnt;		/* 起動要求キューイング数 */
! 	uint_t	wupcnt;		/* 起床要求キューイング数 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* タスク例外処理の状態 */
! 	TEXPTN	pndptn;		/* 保留例外要因 */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* セマフォの待ち行列の先頭のタスクのID番号 */
! 	uint_t	semcnt;		/* セマフォの現在の資源数 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* イベントフラグの待ち行列の先頭のタスクのID番号 */
! 	FLGPTN	flgptn;		/* イベントフラグの現在のビットパターン */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* データキューの送信待ち行列の先頭のタスクのID番号 */
! 	ID		rtskid;		/* データキューの受信待ち行列の先頭のタスクのID番号 */
! 	uint_t	sdtqcnt;	/* データキュー管理領域に格納されているデータの数 */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* 優先度データキューの送信待ち行列の先頭のタスク
! 						   のID番号 */
! 	ID		rtskid;		/* 優先度データキューの受信待ち行列の先頭のタスク
! 						   のID番号 */
! 	uint_t	spdqcnt;	/* 優先度データキュー管理領域に格納されているデー
! 						   タの数 */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* メールボックスの待ち行列の先頭のタスクのID番号 */
! 	T_MSG	*pk_msg;	/* メッセージキューの先頭につながれたメッセージ
! 						   の先頭番地 */
  } T_RMBX;
  
  typedef struct t_rmtx {
! 	ID		htskid;		/* ミューテックスをロックしているタスクのID番号 */
! 	ID		wtskid;		/* ミューテックスの待ち行列の先頭のタスクのID番号 */
  } T_RMTX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* 固定長メモリプールの待ち行列の先頭のタスクの
! 						   ID番号 */
! 	uint_t	fblkcnt;	/* 固定長メモリプール領域の空きメモリ領域に割り
! 						   付けることができる固定長メモリブロックの数 */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* 周期ハンドラの動作状態 */
! 	RELTIM	lefttim;	/* 次に周期ハンドラを起動する時刻までの相対時間 */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* アラームハンドラの動作状態 */
! 	RELTIM	lefttim;	/* アラームハンドラを起動する時刻までの相対時間 */
  } T_RALM;
  
  /*
!  *  サービスコールの宣言
   */
  
  /*
!  *  タスク管理機能
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
***************
*** 214,220 ****
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  °Ʊǽ
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
--- 214,220 ----
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  タスク付属同期機能
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
***************
*** 228,234 ****
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  㳰ǽ
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
--- 228,234 ----
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  タスク例外処理機能
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
***************
*** 238,244 ****
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  Ʊ̿ǽ
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
--- 238,244 ----
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  同期・通信機能
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
***************
*** 299,305 ****
  extern ER		ref_mtx(ID mtxid, T_RMTX *pk_rmtx) throw();
  
  /*
!  *  סǽ
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
--- 299,305 ----
  extern ER		ref_mtx(ID mtxid, T_RMTX *pk_rmtx) throw();
  
  /*
!  *  メモリプール管理機能
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
***************
*** 309,315 ****
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  ִǽ
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
--- 309,315 ----
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  時間管理機能
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
***************
*** 325,331 ****
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  ƥִǽ
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
--- 325,331 ----
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  システム状態管理機能
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
***************
*** 345,351 ****
  extern ER		ext_ker(void) throw();
  
  /*
!  *  ߴǽ
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
--- 345,351 ----
  extern ER		ext_ker(void) throw();
  
  /*
!  *  割込み管理機能
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
***************
*** 353,359 ****
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU㳰ǽ
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
--- 353,359 ----
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU例外管理機能
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
***************
*** 361,496 ****
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ֥°
   */
! #define TA_ACT			UINT_C(0x02)	/* ư줿֤ */
  
! #define TA_TPRI			UINT_C(0x01)	/* Ԥͥٽ */
! #define TA_MPRI			UINT_C(0x02)	/* å塼ͥٽ */
  
! #define TA_WMUL			UINT_C(0x02)	/* ʣԤ */
! #define TA_CLR			UINT_C(0x04)	/* ٥ȥե饰Υꥢ */
  
! #define TA_CEILING		UINT_C(0x03)	/* ͥپ¥ץȥ */
  
! #define TA_STA			UINT_C(0x02)	/* ϥɥư֤ */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* ͥγ */
  
! #define TA_ENAINT		UINT_C(0x01)	/* ׵ػߥե饰򥯥ꥢ */
! #define TA_EDGE			UINT_C(0x02)	/* åȥꥬ */
  
  /*
!  *  ӥư⡼ɤ
   */
! #define TWF_ORW			UINT_C(0x01)	/* ٥ȥե饰ORԤ */
! #define TWF_ANDW		UINT_C(0x02)	/* ٥ȥե饰ANDԤ */
  
  /*
!  *  ֥Ȥξ֤
   */
! #define TTS_RUN			UINT_C(0x01)	/* ¹Ծ */
! #define TTS_RDY			UINT_C(0x02)	/* ¹Բǽ */
! #define TTS_WAI			UINT_C(0x04)	/* Ԥ */
! #define TTS_SUS			UINT_C(0x08)	/* Ԥ */
! #define TTS_WAS			UINT_C(0x0c)	/* Ԥ */
! #define TTS_DMT			UINT_C(0x10)	/* ٻ߾ */
  
! #define TTW_SLP			UINT_C(0x0001)	/* Ԥ */
! #define TTW_DLY			UINT_C(0x0002)	/* ַвԤ */
! #define TTW_SEM			UINT_C(0x0004)	/* ޥեλ񸻳Ԥ */
! #define TTW_FLG			UINT_C(0x0008)	/* ٥ȥե饰Ԥ */
! #define TTW_SDTQ		UINT_C(0x0010)	/* ǡ塼ؤԤ */
! #define TTW_RDTQ		UINT_C(0x0020)	/* ǡ塼μԤ */
! #define TTW_SPDQ		UINT_C(0x0100)	/* ͥ٥ǡ塼ؤԤ */
! #define TTW_RPDQ		UINT_C(0x0200)	/* ͥ٥ǡ塼μԤ */
! #define TTW_MBX			UINT_C(0x0040)	/* ᡼ܥåμԤ */
! #define TTW_MTX			UINT_C(0x0080)	/* ߥ塼ƥåΥåԤ */
! #define TTW_MPF			UINT_C(0x2000)	/* Ĺ֥åγԤ */
  
! #define TTEX_ENA		UINT_C(0x01)	/* 㳰ľ */
! #define TTEX_DIS		UINT_C(0x02)	/* 㳰ػ߾ */
  
! #define TCYC_STP		UINT_C(0x01)	/* ϥɥ餬ưƤʤ */
! #define TCYC_STA		UINT_C(0x02)	/* ϥɥ餬ưƤ */
  
! #define TALM_STP		UINT_C(0x01)	/* 顼ϥɥ餬ưƤʤ */
! #define TALM_STA		UINT_C(0x02)	/* 顼ϥɥ餬ưƤ */
  
  /*
!  *  ¾
   */
! #define TSK_SELF		0			/*  */
! #define TSK_NONE		0			/* 륿ʤ */
  
! #define TPRI_SELF		0			/* Υ١ͥ */
! #define TPRI_INI		0			/* εưͥ */
  
! #define TIPM_ENAALL		0			/* ͥ٥ޥ */
  
  /*
!  *  ȥޥ
   */
  
  /*
!  *  ݡȤ뵡ǽ
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_MUTEX			/* ߥ塼ƥåǽĥ */
  
  /*
!  *  ͥ٤ϰ
   */
! #define TMIN_TPRI		1			/* ͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_TPRI		16			/* ͥ٤κ͡ʺ͡*/
! #define TMIN_DPRI		1			/* ǡͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_DPRI		16			/* ǡͥ٤κ͡ʺ͡*/
! #define TMIN_MPRI		1			/* åͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_MPRI		16			/* åͥ٤κ͡ʺ͡*/
! #define TMIN_ISRPRI		1			/* ߥӥ롼ͥ٤κǾ */
! #define TMAX_ISRPRI		16			/* ߥӥ롼ͥ٤κ */
  
  /*
!  *  С
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* ͥΥ᡼ */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* ͥμֹ */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* ͥͤΥСֹ */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* ͥΥСֹ */
  
  /*
!  *  塼󥰲κ
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* ư׵ᥭ塼󥰿κ */
! #define TMAX_WUPCNT		UINT_C(1)		/* ׵ᥭ塼󥰿κ */
  
  /*
!  *  ӥåȥѥΥӥåȿ
   */
! #ifndef TBIT_TEXPTN					/* 㳰װΥӥåȿ */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* ٥ȥե饰Υӥåȿ */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  ΰݤΤΥޥ
   *
!  *  ʲTOPPERS_COUNT_SZTOPPERS_ROUND_SZϡunit2ζҾǤ
!  *  뤳ȤꤷƤ롥
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
--- 361,496 ----
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  オブジェクト属性の定義
   */
! #define TA_ACT			UINT_C(0x02)	/* タスクを起動された状態で生成 */
  
! #define TA_TPRI			UINT_C(0x01)	/* タスクの待ち行列を優先度順に */
! #define TA_MPRI			UINT_C(0x02)	/* メッセージキューを優先度順に */
  
! #define TA_WMUL			UINT_C(0x02)	/* 複数の待ちタスク */
! #define TA_CLR			UINT_C(0x04)	/* イベントフラグのクリア指定 */
  
! #define TA_CEILING		UINT_C(0x03)	/* 優先度上限プロトコル */
  
! #define TA_STA			UINT_C(0x02)	/* 周期ハンドラを動作状態で生成 */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* カーネル管理外の割込み */
  
! #define TA_ENAINT		UINT_C(0x01)	/* 割込み要求禁止フラグをクリア */
! #define TA_EDGE			UINT_C(0x02)	/* エッジトリガ */
  
  /*
!  *  サービスコールの動作モードの定義
   */
! #define TWF_ORW			UINT_C(0x01)	/* イベントフラグのOR待ち */
! #define TWF_ANDW		UINT_C(0x02)	/* イベントフラグのAND待ち */
  
  /*
!  *  オブジェクトの状態の定義
   */
! #define TTS_RUN			UINT_C(0x01)	/* 実行状態 */
! #define TTS_RDY			UINT_C(0x02)	/* 実行可能状態 */
! #define TTS_WAI			UINT_C(0x04)	/* 待ち状態 */
! #define TTS_SUS			UINT_C(0x08)	/* 強制待ち状態 */
! #define TTS_WAS			UINT_C(0x0c)	/* 二重待ち状態 */
! #define TTS_DMT			UINT_C(0x10)	/* 休止状態 */
  
! #define TTW_SLP			UINT_C(0x0001)	/* 起床待ち */
! #define TTW_DLY			UINT_C(0x0002)	/* 時間経過待ち */
! #define TTW_SEM			UINT_C(0x0004)	/* セマフォの資源獲得待ち */
! #define TTW_FLG			UINT_C(0x0008)	/* イベントフラグ待ち */
! #define TTW_SDTQ		UINT_C(0x0010)	/* データキューへの送信待ち */
! #define TTW_RDTQ		UINT_C(0x0020)	/* データキューからの受信待ち */
! #define TTW_SPDQ		UINT_C(0x0100)	/* 優先度データキューへの送信待ち */
! #define TTW_RPDQ		UINT_C(0x0200)	/* 優先度データキューからの受信待ち */
! #define TTW_MBX			UINT_C(0x0040)	/* メールボックスからの受信待ち */
! #define TTW_MTX			UINT_C(0x0080)	/* ミューテックスのロック待ち状態 */
! #define TTW_MPF			UINT_C(0x2000)	/* 固定長メモリブロックの獲得待ち */
  
! #define TTEX_ENA		UINT_C(0x01)	/* タスク例外処理許可状態 */
! #define TTEX_DIS		UINT_C(0x02)	/* タスク例外処理禁止状態 */
  
! #define TCYC_STP		UINT_C(0x01)	/* 周期ハンドラが動作していない */
! #define TCYC_STA		UINT_C(0x02)	/* 周期ハンドラが動作している */
  
! #define TALM_STP		UINT_C(0x01)	/* アラームハンドラが動作していない */
! #define TALM_STA		UINT_C(0x02)	/* アラームハンドラが動作している */
  
  /*
!  *  その他の定数の定義
   */
! #define TSK_SELF		0			/* 自タスク指定 */
! #define TSK_NONE		0			/* 該当するタスクがない */
  
! #define TPRI_SELF		0			/* 自タスクのベース優先度 */
! #define TPRI_INI		0			/* タスクの起動時優先度 */
  
! #define TIPM_ENAALL		0			/* 割込み優先度マスク全解除 */
  
  /*
!  *  構成定数とマクロ
   */
  
  /*
!  *  サポートする機能
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_MUTEX			/* ミューテックス機能拡張 */
  
  /*
!  *  優先度の範囲
   */
! #define TMIN_TPRI		1			/* タスク優先度の最小値（最高値）*/
! #define TMAX_TPRI		16			/* タスク優先度の最大値（最低値）*/
! #define TMIN_DPRI		1			/* データ優先度の最小値（最高値）*/
! #define TMAX_DPRI		16			/* データ優先度の最大値（最低値）*/
! #define TMIN_MPRI		1			/* メッセージ優先度の最小値（最高値）*/
! #define TMAX_MPRI		16			/* メッセージ優先度の最大値（最低値）*/
! #define TMIN_ISRPRI		1			/* 割込みサービスルーチン優先度の最小値 */
! #define TMAX_ISRPRI		16			/* 割込みサービスルーチン優先度の最大値 */
  
  /*
!  *  バージョン情報
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* カーネルのメーカーコード */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* カーネルの識別番号 */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* カーネル仕様のバージョン番号 */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* カーネルのバージョン番号 */
  
  /*
!  *  キューイング回数の最大値
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* 起動要求キューイング数の最大値 */
! #define TMAX_WUPCNT		UINT_C(1)		/* 起床要求キューイング数の最大値 */
  
  /*
!  *  ビットパターンのビット数
   */
! #ifndef TBIT_TEXPTN					/* タスク例外要因のビット数 */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* イベントフラグのビット数 */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  メモリ領域確保のためのマクロ
   *
!  *  以下のTOPPERS_COUNT_SZとTOPPERS_ROUND_SZの定義は，unitが2の巾乗であ
!  *  ることを仮定している．
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
***************
*** 506,514 ****
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  ¾ι
   */
! #define TMAX_MAXSEM		UINT_MAX	/* ޥեκ񸻿κ */
  
  #ifdef __cplusplus
  }
--- 506,514 ----
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  その他の構成定数
   */
! #define TMAX_MAXSEM		UINT_MAX	/* セマフォの最大資源数の最大値 */
  
  #ifdef __cplusplus
  }
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/Makefile.kernel ASPs/asp/extension/mutex/kernel/Makefile.kernel
*** 1.9.1/asp/extension/mutex/kernel/Makefile.kernel	Sat Jan  2 00:59:29 2010
--- ASPs/asp/extension/mutex/kernel/Makefile.kernel	Fri Dec  9 13:54:01 2022
***************
*** 8,52 ****
  #  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! #  ܥեȥѤΤޤࡥʲƱˤѡʣ
! #  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! #  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! #      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! #      ˴ޤޤƤ뤳ȡ
! #  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! #      ѤǤǺۤˤϡۤȼɥȡ
! #      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! #      ̵ݾڵǺܤ뤳ȡ
! #  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! #      ѤǤʤǺۤˤϡΤ줫ξ
! #      ȡ
! #    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! #        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! #    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! #        𤹤뤳ȡ
! #  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! #      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! #      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! #      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! #      դ뤳ȡ
  # 
! #  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! #  TOPPERSץȤϡܥեȥ˴ؤơλŪ
! #  ФŬޤơʤݾڤԤʤޤܥեȥ
! #  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! #  Ǥʤ
  # 
  #  @(#) $Id: Makefile.kernel 1694 2010-01-01 15:59:09Z ertl-hiro $
  # 
  
  #
! #		ͥΥե빽
  #
  
  #
! #  1ĤΥե뤫ʣΥ֥ȥե褦˺
! #  줿եΥꥹ
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
--- 8,52 ----
  #  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! #  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! #  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! #  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! #      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! #      スコード中に含まれていること．
! #  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! #      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! #      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! #      の無保証規定を掲載すること．
! #  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! #      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! #      と．
! #    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! #        作権表示，この利用条件および下記の無保証規定を掲載すること．
! #    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! #        報告すること．
! #  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! #      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! #      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! #      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! #      免責すること．
  # 
! #  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! #  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! #  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! #  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! #  の責任を負わない．
  # 
  #  @(#) $Id: Makefile.kernel 1694 2010-01-01 15:59:09Z ertl-hiro $
  # 
  
  #
! #		カーネルのファイル構成の定義
  #
  
  #
! #  1つのソースファイルから複数のオブジェクトファイルを生成するように作
! #  成されたソースファイルのリスト
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
***************
*** 55,61 ****
  				sys_manage.c interrupt.c exception.c
  
  #
! #  ƥե뤫륪֥ȥեΥꥹ
  #
  startup = sta_ker.o ext_ker.o
  
--- 55,61 ----
  				sys_manage.c interrupt.c exception.c
  
  #
! #  各ソースファイルから生成されるオブジェクトファイルのリスト
  #
  startup = sta_ker.o ext_ker.o
  
***************
*** 115,121 ****
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  륪֥ȥեΰ¸ط
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
--- 115,121 ----
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  生成されるオブジェクトファイルの依存関係の定義
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/allfunc.h ASPs/asp/extension/mutex/kernel/allfunc.h
*** 1.9.1/asp/extension/mutex/kernel/allfunc.h	Sat Jan  2 00:59:29 2010
--- ASPs/asp/extension/mutex/kernel/allfunc.h	Fri Dec  9 13:54:01 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: allfunc.h 1694 2010-01-01 15:59:09Z ertl-hiro $
   */
  
  /*
!  *		٤Ƥδؿ򥳥ѥ뤹뤿
   */
  
  #ifndef TOPPERS_ALLFUNC_H
--- 6,45 ----
   *  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: allfunc.h 1694 2010-01-01 15:59:09Z ertl-hiro $
   */
  
  /*
!  *		すべての関数をコンパイルするための定義
   */
  
  #ifndef TOPPERS_ALLFUNC_H
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/check.h ASPs/asp/extension/mutex/kernel/check.h
*** 1.9.1/asp/extension/mutex/kernel/check.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/mutex/kernel/check.h	Fri Dec  9 13:54:01 2022
***************
*** 8,54 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: check.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		顼åѥޥ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  ͥ٤ϰϤȽ
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
--- 8,54 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: check.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		エラーチェック用マクロ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  優先度の範囲の判定
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
***************
*** 58,64 ****
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
--- 58,64 ----
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  タスク優先度のチェック（E_PAR）
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
***************
*** 82,88 ****
  } while (false)
  
  /*
!  *  ॢȻͤΥåE_PAR
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
--- 82,88 ----
  } while (false)
  
  /*
!  *  タイムアウト指定値のチェック（E_PAR）
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
***************
*** 92,98 ****
  } while (false)
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
--- 92,98 ----
  } while (false)
  
  /*
!  *  割込み優先度のチェック（E_PAR）
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
***************
*** 102,108 ****
  } while (false)
  
  /*
!  *  ֹΥåE_PAR
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
--- 102,108 ----
  } while (false)
  
  /*
!  *  割込み番号のチェック（E_PAR）
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
***************
*** 112,118 ****
  } while (false)
  
  /*
!  *  ¾Υѥ᡼顼ΥåE_PAR
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
--- 112,118 ----
  } while (false)
  
  /*
!  *  その他のパラメータエラーのチェック（E_PAR）
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
***************
*** 122,128 ****
  } while (false)
  
  /*
!  *  ֥IDϰϤȽ
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
--- 122,128 ----
  } while (false)
  
  /*
!  *  オブジェクトIDの範囲の判定
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
***************
*** 136,142 ****
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  ֥IDΥåE_ID
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
--- 136,142 ----
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  オブジェクトIDのチェック（E_ID）
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
***************
*** 216,222 ****
  } while (false)
  
  /*
!  *  ƽФƥȤΥåE_CTX
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
--- 216,222 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストのチェック（E_CTX）
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
***************
*** 233,239 ****
  } while (false)
  
  /*
!  *  ƽФƥȤCPUå֤ΥåE_CTX
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
--- 233,239 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストとCPUロック状態のチェック（E_CTX）
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
***************
*** 250,256 ****
  } while (false)
  
  /*
!  *  ǥѥåα֤ǤʤΥåE_CTX
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
--- 250,256 ----
  } while (false)
  
  /*
!  *  ディスパッチ保留状態でないかのチェック（E_CTX）
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
***************
*** 260,266 ****
  } while (false)
  
  /*
!  *  ¾Υƥȥ顼ΥåE_CTX
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
--- 260,266 ----
  } while (false)
  
  /*
!  *  その他のコンテキストエラーのチェック（E_CTX）
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
***************
*** 270,276 ****
  } while (false)
  
  /*
!  *  ꤷƤʤΥåE_ILUSE
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
--- 270,276 ----
  } while (false)
  
  /*
!  *  自タスクを指定していないかのチェック（E_ILUSE）
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
***************
*** 280,286 ****
  } while (false)
  
  /*
!  *  ¾ѥ顼ΥåE_ILUSE
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
--- 280,286 ----
  } while (false)
  
  /*
!  *  その他の不正使用エラーのチェック（E_ILUSE）
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/kernel.tf ASPs/asp/extension/mutex/kernel/kernel.tf
*** 1.9.1/asp/extension/mutex/kernel/kernel.tf	Sun May  4 22:18:02 2014
--- ASPs/asp/extension/mutex/kernel/kernel.tf	Fri Dec  9 13:54:01 2022
***************
*** 8,48 ****
  $   Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   $Id: kernel.tf 2595 2014-01-02 12:00:09Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.h
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
--- 8,48 ----
  $   Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   $Id: kernel.tf 2595 2014-01-02 12:00:09Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.hの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
***************
*** 95,101 ****
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.c
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
--- 95,101 ----
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.cの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
***************
*** 109,115 ****
  $NL$
  
  $ 
! $  󥯥롼ɥǥ쥯ƥ֡#include
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
--- 109,115 ----
  $NL$
  
  $ 
! $  インクルードディレクティブ（#include）
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
***************
*** 119,125 ****
  $NL$
  
  $ 
! $  ֥ȤIDֹݻѿ
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
--- 119,125 ----
  $NL$
  
  $ 
! $  オブジェクトのID番号を保持する変数
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
***************
*** 159,165 ****
  $END$
  
  $ 
! $  ȥ졼ޥΥǥե
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
--- 159,165 ----
  $END$
  
  $ 
! $  トレースログマクロのデフォルト定義
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
***************
*** 175,224 ****
  $NL$
  
  $ 
! $  
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 1İʾ¸ߤ뤳ȤΥå
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ IDֹκ
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ 顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrʡTA_ACTϡˤǤʤE_RSATR
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)ǤʤE_PAR
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrTA_NULLˤǤʤE_RSATR
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ åΰȤ˴ؤ륨顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// stksz0ʲåκǾ͡TARGET_MIN_STKSZˤ
! $	// E_PAR
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszåΰΥȤʤE_PAR
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
--- 175,224 ----
  $NL$
  
  $ 
! $  タスク
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ タスクが1個以上存在することのチェック
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ タスクID番号の最大値
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ エラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrが（［TA_ACT］）でない場合（E_RSATR）
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)でない場合（E_PAR）
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrが（TA_NULL）でない場合（E_RSATR）
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ スタック領域の生成とそれに関するエラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// stkszが0以下か，ターゲット定義の最小値（TARGET_MIN_STKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
***************
*** 235,309 ****
  $END$
  $NL$
  
! $ ֥åʥ1İʾ¸ߤ
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// °ĥ󡤵ưϡưͥ
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// ƥȥ֥ååΰ
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// 㳰롼°ȵư
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ ֥å
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ ơ֥
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  ޥե
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ޥեIDֹκ
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ ޥե֥å
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)ǤʤE_PAR
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)ǤʤE_PAR
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// ޥե֥å
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ޥե֥å
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
--- 235,309 ----
  $END$
  $NL$
  
! $ タスク初期化ブロックの生成（タスクは1個以上存在する）
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// タスク属性，拡張情報，起動番地，起動時優先度
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// タスク初期化コンテキストブロック，スタック領域
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// タスク例外処理ルーチンの属性と起動番地
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ タスク管理ブロックの生成
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ タスク生成順序テーブルの生成
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  セマフォ
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ セマフォID番号の最大値
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ セマフォ初期化ブロックの生成
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)でない場合（E_PAR）
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)でない場合（E_PAR）
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// セマフォ初期化ブロック
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// セマフォ管理ブロック
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
***************
*** 311,348 ****
  $END$$NL$
  
  $ 
! $  ٥ȥե饰
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ٥ȥե饰IDֹκ
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ ٥ȥե饰֥å
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrʡTA_TPRIϡáTA_WMULϡáTA_CLRϡˤǤʤE_RSATR
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnFLGPTN˳ǼǤʤE_PAR
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// ٥ȥե饰֥å
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ٥ȥե饰֥å
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
--- 311,348 ----
  $END$$NL$
  
  $ 
! $  イベントフラグ
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ イベントフラグID番号の最大値
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ イベントフラグ初期化ブロックの生成
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrが（［TA_TPRI］｜［TA_WMUL］｜［TA_CLR］）でない場合（E_RSATR）
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnがFLGPTNに格納できない場合（E_PAR）
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// イベントフラグ初期化ブロック
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// イベントフラグ管理ブロック
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
***************
*** 350,390 ****
  $END$$NL$
  
  $ 
! $  ǡ塼
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ǡ塼IDֹκ
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntξE_PAR
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbNULLǤʤE_NOSPT
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// ǡ塼ΰ
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// ǡ塼֥å
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
--- 350,390 ----
  $END$$NL$
  
  $ 
! $  データキュー
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ データキューID番号の最大値
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntが負の場合（E_PAR）
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// データキュー管理領域
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// データキュー初期化ブロックの生成
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
***************
*** 392,398 ****
  	};$NL$
  	$NL$
  
! $	// ǡ塼֥å
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
--- 392,398 ----
  	};$NL$
  	$NL$
  
! $	// データキュー管理ブロック
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
***************
*** 400,445 ****
  $END$$NL$
  
  $ 
! $  ͥ٥ǡ塼
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ͥ٥ǡ塼IDֹκ
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntξE_PAR
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)ǤʤE_PAR
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbNULLǤʤE_NOSPT
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// ͥ٥ǡ塼ΰ
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// ͥ٥ǡ塼֥å
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
--- 400,445 ----
  $END$$NL$
  
  $ 
! $  優先度データキュー
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 優先度データキューID番号の最大値
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntが負の場合（E_PAR）
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)でない場合（E_PAR）
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// 優先度データキュー管理領域
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// 優先度データキュー初期化ブロックの生成
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
***************
*** 447,453 ****
  	};$NL$
  	$NL$
  
! $	// ͥ٥ǡ塼֥å
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
--- 447,453 ----
  	};$NL$
  	$NL$
  
! $	// 優先度データキュー管理ブロック
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
***************
*** 455,497 ****
  $END$$NL$
  
  $ 
! $  ᡼ܥå
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ᡼ܥåIDֹκ
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ ᡼ܥå֥å
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrʡTA_TPRIϡáTA_MPRIϡˤǤʤE_RSATR
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)ǤʤE_PAR
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdNULLǤʤE_NOSPT
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// ᡼ܥå֥å
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ᡼ܥå֥å
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
--- 455,497 ----
  $END$$NL$
  
  $ 
! $  メールボックス
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ メールボックスID番号の最大値
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ メールボックス初期化ブロックの生成
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrが（［TA_TPRI］｜［TA_MPRI］）でない場合（E_RSATR）
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)でない場合（E_PAR）
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdがNULLでない場合（E_NOSPT）
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// メールボックス初期化ブロック
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// メールボックス管理ブロック
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
***************
*** 499,540 ****
  $END$$NL$
  
  $ 
! $  ߥ塼ƥå
  $ 
  /*$NL$
  $SPC$*  Mutex Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ߥ塼ƥåIDֹκ
  const ID _kernel_tmax_mtxid = (TMIN_MTXID + TNUM_MTXID - 1);$NL$
  $NL$
  
! $ ߥ塼ƥå֥å
  $IF LENGTH(MTX.ID_LIST)$
  	const MTXINIB _kernel_mtxinib_table[TNUM_MTXID] = {$NL$
  	$JOINEACH mtxid MTX.ID_LIST ",\n"$
! $		// mtxatrʡTA_TPRITA_CEILINGϡˤǤʤE_RSATR
  		$IF !(MTX.MTXATR[mtxid] == 0 || MTX.MTXATR[mtxid] == TA_TPRI || MTX.MTXATR[mtxid] == TA_CEILING)$
  			$ERROR MTX.TEXT_LINE[mtxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mtxatr", MTX.MTXATR[mtxid], mtxid, "CRE_MTX")$$END$
  		$END$
  
! $		// ceilpri̤ξ0ȸʤ
  		$IF !LENGTH(MTX.CEILPRI[mtxid])$
  			$MTX.CEILPRI[mtxid] = 0$
  		$END$
! $		// (TMIN_TPRI <= ceilpri && ceilpri <= TMAX_TPRI)ǤʤE_PAR
  		$IF MTX.MTXATR[mtxid] == TA_CEILING && (MTX.CEILPRI[mtxid] < TMIN_TPRI || TMAX_TPRI < MTX.CEILPRI[mtxid])$
  			$ERROR MTX.TEXT_LINE[mtxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "ceilpri", MTX.CEILPRI[mtxid], mtxid, "CRE_MTX")$$END$
  		$END$
  
! $		// ߥ塼ƥå֥å
  		$TAB${ ($MTX.MTXATR[mtxid]$), INT_PRIORITY($MTX.CEILPRI[mtxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ߥ塼ƥå֥å
  	MTXCB _kernel_mtxcb_table[TNUM_MTXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MTXINIB, _kernel_mtxinib_table);$NL$
--- 499,540 ----
  $END$$NL$
  
  $ 
! $  ミューテックス
  $ 
  /*$NL$
  $SPC$*  Mutex Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ミューテックスID番号の最大値
  const ID _kernel_tmax_mtxid = (TMIN_MTXID + TNUM_MTXID - 1);$NL$
  $NL$
  
! $ ミューテックス初期化ブロックの生成
  $IF LENGTH(MTX.ID_LIST)$
  	const MTXINIB _kernel_mtxinib_table[TNUM_MTXID] = {$NL$
  	$JOINEACH mtxid MTX.ID_LIST ",\n"$
! $		// mtxatrが（［TA_TPRI｜TA_CEILING］）でない場合（E_RSATR）
  		$IF !(MTX.MTXATR[mtxid] == 0 || MTX.MTXATR[mtxid] == TA_TPRI || MTX.MTXATR[mtxid] == TA_CEILING)$
  			$ERROR MTX.TEXT_LINE[mtxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mtxatr", MTX.MTXATR[mtxid], mtxid, "CRE_MTX")$$END$
  		$END$
  
! $		// ceilpriが未指定の場合は0と見なす
  		$IF !LENGTH(MTX.CEILPRI[mtxid])$
  			$MTX.CEILPRI[mtxid] = 0$
  		$END$
! $		// (TMIN_TPRI <= ceilpri && ceilpri <= TMAX_TPRI)でない場合（E_PAR）
  		$IF MTX.MTXATR[mtxid] == TA_CEILING && (MTX.CEILPRI[mtxid] < TMIN_TPRI || TMAX_TPRI < MTX.CEILPRI[mtxid])$
  			$ERROR MTX.TEXT_LINE[mtxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "ceilpri", MTX.CEILPRI[mtxid], mtxid, "CRE_MTX")$$END$
  		$END$
  
! $		// ミューテックス初期化ブロック
  		$TAB${ ($MTX.MTXATR[mtxid]$), INT_PRIORITY($MTX.CEILPRI[mtxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ミューテックス管理ブロック
  	MTXCB _kernel_mtxcb_table[TNUM_MTXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MTXINIB, _kernel_mtxinib_table);$NL$
***************
*** 542,590 ****
  $END$$NL$
  
  $ 
! $  Ĺס
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ĹסIDֹκ
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcnt0ʲξE_PAR
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blksz0ʲξE_PAR
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbNULLǤʤE_NOSPT
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// Ĺס֥å
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
--- 542,590 ----
  $END$$NL$
  
  $ 
! $  固定長メモリプール
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 固定長メモリプールID番号の最大値
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcntが0以下の場合（E_PAR）
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkszが0以下の場合（E_PAR）
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール領域
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール管理領域
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// 固定長メモリプール初期化ブロックの生成
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
***************
*** 592,598 ****
  	};$NL$
  	$NL$
  
! $	// Ĺס֥å
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
--- 592,598 ----
  	};$NL$
  	$NL$
  
! $	// 固定長メモリプール管理ブロック
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
***************
*** 600,647 ****
  $END$$NL$
  
  $ 
! $  ϥɥ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ϥɥIDֹκ
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ ϥɥơ֥
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrʡTA_STAϡˤǤʤE_RSATR
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// ٹcycatrTA_STAꤵƤơ(cycphs == 0)ξ
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// ϥɥ֥å
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ϥɥ֥å
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
--- 600,647 ----
  $END$$NL$
  
  $ 
! $  周期ハンドラ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 周期ハンドラID番号の最大値
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ 周期ハンドラ初期化テーブルの生成
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrが（［TA_STA］）でない場合（E_RSATR）
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// 警告：cycatrにTA_STAが設定されていて，(cycphs == 0)の場合
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// 周期ハンドラ初期化ブロック
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 周期ハンドラ管理ブロック
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
***************
*** 649,681 ****
  $END$$NL$
  
  $ 
! $  顼ϥɥ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 顼ϥɥIDֹκ
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ 顼ϥɥ֥å
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrTA_NULLˤǤʤE_RSATR
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// 顼ϥɥ֥å
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 顼ϥɥ֥å
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
--- 649,681 ----
  $END$$NL$
  
  $ 
! $  アラームハンドラ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ アラームハンドラID番号の最大値
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ アラームハンドラ初期化ブロックの生成
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrが（TA_NULL）でない場合（E_RSATR）
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// アラームハンドラ初期化ブロック
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// アラームハンドラ管理ブロック
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
***************
*** 683,696 ****
  $END$$NL$
  
  $ 
! $  ߴǽ
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ֹȳߥϥɥֹѴơ֥κ
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
--- 683,696 ----
  $END$$NL$
  
  $ 
! $  割込み管理機能
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 割込み番号と割込みハンドラ番号の変換テーブルの作成
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
***************
*** 702,716 ****
  	$i = i + 1$
  $END$
  
! $ ׵饤˴ؤ륨顼å
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoCFG_INTФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoCFG_INTˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
--- 702,716 ----
  	$i = i + 1$
  $END$
  
! $ 割込み要求ラインに関するエラーチェック
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoがCFG_INTに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoがCFG_INTによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
***************
*** 719,744 ****
  		$j = j + 1$
  	$END$
  
! $	// intatrʡTA_ENAINTϡáTA_EDGEϡˤǤʤE_RSATR
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriCFG_INTФͥ٤ȤʤE_PAR
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵ줿E_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵʤäE_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
--- 719,744 ----
  		$j = j + 1$
  	$END$
  
! $	// intatrが（［TA_ENAINT］｜［TA_EDGE］）でない場合（E_RSATR）
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriがCFG_INTに対する割込み優先度として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// カーネル管理に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定された場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定されなかった場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
***************
*** 747,761 ****
  	$i = i + 1$
  $END$
  
! $ ߥϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoDEF_INHФߥϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoDEF_INHˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
--- 747,761 ----
  	$i = i + 1$
  $END$
  
! $ 割込みハンドラに関するエラーチェック
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoがDEF_INHに対する割込みハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoがDEF_INHによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
***************
*** 764,784 ****
  		$j = j + 1$
  	$END$
  
! $	// inhatrTA_NULLˤǤʤE_RSATR
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	//ꤵƤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	// ꤵƤʤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
--- 764,784 ----
  		$j = j + 1$
  	$END$
  
! $	// inhatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// カーネル管理に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	//　が指定されている場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	// が指定されていない場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
***************
*** 787,807 ****
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoбintnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrTA_NONKERNELꤵƤ餺inhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRI⾮E_OBJ
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrTA_NONKERNELꤵƤꡤinhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRIʾǤE_OBJ
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
--- 787,807 ----
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoに対応するintnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrにTA_NONKERNELが指定されておらず，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRIよりも小さい場合（E_OBJ）
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrにTA_NONKERNELが指定されており，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRI以上である場合（E_OBJ）
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
***************
*** 811,829 ****
  	$i = i + 1$
  $END$
  
! $ ߥӥ롼ISRˤ˴ؤ륨顼åȳߥϥɥ
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrTA_NULLˤǤʤE_RSATR
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoATT_ISRФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)ǤʤE_PAR
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
--- 811,829 ----
  	$i = i + 1$
  $END$
  
! $ 割込みサービスルーチン（ISR）に関するエラーチェックと割込みハンドラの生成
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrが（TA_NULL）でない場合（E_RSATR）
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoがATT_ISRに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)でない場合（E_PAR）
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
***************
*** 832,838 ****
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// ֹintnoФϿ줿ISRΥꥹȤκ
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
--- 832,838 ----
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// 割込み番号intnoに対して登録されたISRのリストの作成
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
***************
*** 841,859 ****
  		$END$
  	$END$
  
! $	// ֹintnoФϿ줿ISR¸ߤ
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoбinhnoФDEF_INHE_OBJ
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoФCFG_INTꤵ줿ͥ٤TMIN_INTPRI
! $			// ⾮E_OBJ
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
--- 841,859 ----
  		$END$
  	$END$
  
! $	// 割込み番号intnoに対して登録されたISRが存在する場合
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoに対応するinhnoに対してDEF_INHがある場合（E_OBJ）
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoに対してCFG_INTで設定された割込み優先度がTMIN_INTPRI
! $			// よりも小さい場合（E_OBJ）
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
***************
*** 865,871 ****
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISRѤγߥϥɥ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
--- 865,871 ----
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISR用の割込みハンドラ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
***************
*** 877,883 ****
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRͥٽ˸ƤӽФ
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
--- 877,883 ----
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRを優先度順に呼び出す
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
***************
*** 890,901 ****
  $NL$
  
  $ 
! $  ߴǽΤɸŪʽ
  $ 
! $ ߥϥɥνɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ ߥϥɥ
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
--- 890,901 ----
  $NL$
  
  $ 
! $  割込み管理機能のための標準的な初期化情報の生成
  $ 
! $ 割込みハンドラの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ 割込みハンドラ数
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
***************
*** 906,912 ****
  $END$
  $NL$
  
! $ ߥϥɥơ֥
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
--- 906,912 ----
  $END$
  $NL$
  
! $ 割込みハンドラ初期化テーブル
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
***************
*** 922,936 ****
  $END$$NL$
  $END$
  
! $ ׵饤νɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ ׵饤
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ ׵饤ơ֥
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
--- 922,936 ----
  $END$$NL$
  $END$
  
! $ 割込み要求ラインの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ 割込み要求ライン数
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ 割込み要求ライン初期化テーブル
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
***************
*** 943,964 ****
  $END$
  
  $ 
! $  CPU㳰ǽ
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU㳰ϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoDEF_EXCФCPU㳰ϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoDEF_EXCˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
--- 943,964 ----
  $END$
  
  $ 
! $  CPU例外管理機能
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU例外ハンドラに関するエラーチェック
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoがDEF_EXCに対するCPU例外ハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoがDEF_EXCによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
***************
*** 967,983 ****
  		$j = j + 1$
  	$END$
  
! $	// excatrTA_NULLˤǤʤE_RSATR
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU㳰ϥɥΤɸŪʽ
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU㳰ϥɥ
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
--- 967,983 ----
  		$j = j + 1$
  	$END$
  
! $	// excatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU例外ハンドラのための標準的な初期化情報の生成
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU例外ハンドラ数
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
***************
*** 986,992 ****
  $END$
  $NL$
  
! $ CPU㳰ϥɥơ֥
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
--- 986,992 ----
  $END$
  $NL$
  
! $ CPU例外ハンドラ初期化テーブル
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
***************
*** 999,1005 ****
  $END$
  
  $ 
! $  󥿥ƥѤΥåΰ
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
--- 999,1005 ----
  $END$
  
  $ 
! $  非タスクコンテキスト用のスタック領域
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
***************
*** 1007,1013 ****
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSʤΥǥեͤ
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
--- 1007,1013 ----
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSがない場合のデフォルト値の設定
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
***************
*** 1022,1047 ****
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// ŪAPIDEF_ICSפʣE_OBJ
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istksz0ʲåκǾ͡TARGET_MIN_ISTKSZˤ
! $	// E_PAR
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszåΰΥȤʤE_PAR
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// åΰμưդ
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
--- 1022,1047 ----
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// 静的API「DEF_ICS」が複数ある（E_OBJ）
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istkszが0以下か，ターゲット定義の最小値（TARGET_MIN_ISTKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// スタック領域の自動割付け
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
***************
*** 1052,1058 ****
  $END$
  $NL$
  
! $ 󥿥ƥѤΥåΰ
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
--- 1052,1058 ----
  $END$
  $NL$
  
! $ 非タスクコンテキスト用のスタック領域
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
***************
*** 1062,1068 ****
  $NL$
  
  $ 
! $  ।٥ȴ
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
--- 1062,1068 ----
  $NL$
  
  $ 
! $  タイムイベント管理
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
***************
*** 1072,1078 ****
  $NL$
  
  $ 
! $  ƥ⥸塼νؿ
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
--- 1072,1078 ----
  $NL$
  
  $ 
! $  各モジュールの初期化関数
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
***************
*** 1097,1103 ****
  $NL$
  
  $ 
! $  롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
--- 1097,1103 ----
  $NL$
  
  $ 
! $  初期化ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
***************
*** 1107,1113 ****
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrTA_NULLˤǤʤE_RSATR
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
--- 1107,1113 ----
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrが（TA_NULL）でない場合（E_RSATR）
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
***************
*** 1117,1123 ****
  $NL$
  
  $ 
! $  λ롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
--- 1117,1123 ----
  $NL$
  
  $ 
! $  終了処理ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
***************
*** 1127,1133 ****
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrTA_NULLˤǤʤE_RSATR
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
--- 1127,1133 ----
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrが（TA_NULL）でない場合（E_RSATR）
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/kernel_impl.h ASPs/asp/extension/mutex/kernel/kernel_impl.h
*** 1.9.1/asp/extension/mutex/kernel/kernel_impl.h	Wed Jan 27 22:24:12 2010
--- ASPs/asp/extension/mutex/kernel/kernel_impl.h	Fri Dec  9 13:54:01 2022
***************
*** 8,179 ****
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: kernel_impl.h 1713 2010-01-27 13:23:29Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥɸإåե
   *
!  *  ΥإåեϡͥץΥե
!  *  ɬ󥯥롼ɤ٤ɸإåեǤ롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   */
  
  #ifndef TOPPERS_KERNEL_IMPL_H
  #define TOPPERS_KERNEL_IMPL_H
  
  /*
!  *  ͥ̾Υ͡
   */
  #include "kernel_rename.h"
  
  /*
!  *  ץꥱȶ̤Υإåե
   */
  #include <kernel.h>
  
  /*
!  *  ƥǽΤ
   */
  #include <t_syslog.h>
  
  /*
!  *  㥹ȤԤޥ
   */
  #ifndef CAST
  #define CAST(type, val)		((type)(val))
  #endif /* CAST */
  
  /*
!  *  åȰ¸
   */
  #include "target_config.h"
  
  /*
!  *  ٤Ƥδؿ򥳥ѥ뤹뤿
   */
  #ifdef ALLFUNC
  #include "allfunc.h"
  #endif /* ALLFUNC */
  
  /*
!  *  ӥåȥեɤǤ̵
   *
!  *  8ӥåȰʲΥӥåȥեɤǡ̵ͤݻ
!  *  Ѥ٤ǡANSI CǤϡӥåȥեɤΥǡˤ
!  *  intunsigned intʤᡤǥեȤunsigned
!  *  intȤƤ뤬åȤӥġ¸ǡunsigned charޤ
!  *  unsigned shortΨɤ礬롥
   */
  #ifndef BIT_FIELD_UINT
  #define BIT_FIELD_UINT		unsigned int
  #endif /* BIT_FIELD_UINT */
  
  /*
!  *  ӥåȥեɤǤΥ֡뷿
   *
!  *  1ӥåΥӥåȥեɤǡ֡ͤݻѤ٤
!  *  ǡǥեȤǤBIT_FIELD_UINTƱƤ뤬֡
!  *  ͤݻ뤳Ȥ뤿̤̾ΤȤƤ롥
   */
  #ifndef BIT_FIELD_BOOL
  #define BIT_FIELD_BOOL		BIT_FIELD_UINT
  #endif /* BIT_FIELD_BOOL */
  
  /*
!  *  ֥IDκǾͤ
   */
! #define TMIN_TSKID		1		/* IDκǾ */
! #define TMIN_SEMID		1		/* ޥեIDκǾ */
! #define TMIN_FLGID		1		/* ե饰IDκǾ */
! #define TMIN_DTQID		1		/* ǡ塼IDκǾ */
! #define TMIN_PDQID		1		/* ͥ٥ǡ塼IDκǾ */
! #define TMIN_MBXID		1		/* ᡼ܥåIDκǾ */
! #define TMIN_MTXID		1		/* ߥ塼ƥåIDκǾ */
! #define TMIN_MPFID		1		/* ĹסIDκǾ */
! #define TMIN_CYCID		1		/* ϥɥIDκǾ */
! #define TMIN_ALMID		1		/* 顼ϥɥIDκǾ */
  
  /*
!  *  ͥ٤ʳ
   */
  #define TNUM_TPRI		(TMAX_TPRI - TMIN_TPRI + 1)
  #define TNUM_MPRI		(TMAX_MPRI - TMIN_MPRI + 1)
  #define TNUM_INTPRI		(TMAX_INTPRI - TMIN_INTPRI + 1)
  
  /*
!  *  إåեʤ⥸塼δؿѿ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ƥ⥸塼νkernel_cfg.c
   */
  extern void	initialize_object(void);
  
  /*
!  *  롼μ¹ԡkernel_cfg.c
   */
  extern void	call_inirtn(void);
  
  /*
!  *  λ롼μ¹ԡkernel_cfg.c
   */
  extern void	call_terrtn(void);
  
  /*
!  *  󥿥ƥѤΥåΰkernel_cfg.c
   */
! extern const SIZE	istksz;		/* åΰΥʴݤ᤿͡ */
! extern STK_T *const	istk;		/* åΰƬ */
  #ifdef TOPPERS_ISTKPT
! extern STK_T *const	istkpt;		/* åݥ󥿤ν */
  #endif /* TOPPERS_ISTKPT */
  
  /*
!  *  ͥư֥ե饰startup.c
   */
  extern bool_t	kerflg;
  
  /*
!  *  ͥεưstartup.c
   */
  extern void	sta_ker(void);
  
  /*
!  *  ͥνλstartup.c
   */
  extern void	exit_kernel(void);
  
--- 8,179 ----
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: kernel_impl.h 1713 2010-01-27 13:23:29Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル内部向け標準ヘッダファイル
   *
!  *  このヘッダファイルは，カーネルを構成するプログラムのソースファイル
!  *  で必ずインクルードするべき標準ヘッダファイルである．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   */
  
  #ifndef TOPPERS_KERNEL_IMPL_H
  #define TOPPERS_KERNEL_IMPL_H
  
  /*
!  *  カーネルの内部識別名のリネーム
   */
  #include "kernel_rename.h"
  
  /*
!  *  アプリケーションと共通のヘッダファイル
   */
  #include <kernel.h>
  
  /*
!  *  システムログ機能のための定義
   */
  #include <t_syslog.h>
  
  /*
!  *  型キャストを行うマクロの定義
   */
  #ifndef CAST
  #define CAST(type, val)		((type)(val))
  #endif /* CAST */
  
  /*
!  *  ターゲット依存情報の定義
   */
  #include "target_config.h"
  
  /*
!  *  すべての関数をコンパイルするための定義
   */
  #ifdef ALLFUNC
  #include "allfunc.h"
  #endif /* ALLFUNC */
  
  /*
!  *  ビットフィールドでの符号無し整数型
   *
!  *  8ビット以下の幅のビットフィールドで，符号無し整数値を保持したい場合
!  *  に用いるべきデータ型．ANSI Cでは，ビットフィールドのデータ型には
!  *  intとunsigned intしか許されないため，デフォルトの定義はunsigned
!  *  intとしているが，ターゲットおよびツール依存で，unsigned charまたは
!  *  unsigned shortに定義した方が効率が良い場合がある．
   */
  #ifndef BIT_FIELD_UINT
  #define BIT_FIELD_UINT		unsigned int
  #endif /* BIT_FIELD_UINT */
  
  /*
!  *  ビットフィールドでのブール型
   *
!  *  1ビット幅のビットフィールドで，ブール値を保持したい場合に用いるべき
!  *  データ型．デフォルトではBIT_FIELD_UINTと同一に定義しているが，ブー
!  *  ル値を保持することを明示するために別の名称としている．
   */
  #ifndef BIT_FIELD_BOOL
  #define BIT_FIELD_BOOL		BIT_FIELD_UINT
  #endif /* BIT_FIELD_BOOL */
  
  /*
!  *  オブジェクトIDの最小値の定義
   */
! #define TMIN_TSKID		1		/* タスクIDの最小値 */
! #define TMIN_SEMID		1		/* セマフォIDの最小値 */
! #define TMIN_FLGID		1		/* フラグIDの最小値 */
! #define TMIN_DTQID		1		/* データキューIDの最小値 */
! #define TMIN_PDQID		1		/* 優先度データキューIDの最小値 */
! #define TMIN_MBXID		1		/* メールボックスIDの最小値 */
! #define TMIN_MTXID		1		/* ミューテックスIDの最小値 */
! #define TMIN_MPFID		1		/* 固定長メモリプールIDの最小値 */
! #define TMIN_CYCID		1		/* 周期ハンドラIDの最小値 */
! #define TMIN_ALMID		1		/* アラームハンドラIDの最小値 */
  
  /*
!  *  優先度の段階数の定義
   */
  #define TNUM_TPRI		(TMAX_TPRI - TMIN_TPRI + 1)
  #define TNUM_MPRI		(TMAX_MPRI - TMIN_MPRI + 1)
  #define TNUM_INTPRI		(TMAX_INTPRI - TMIN_INTPRI + 1)
  
  /*
!  *  ヘッダファイルを持たないモジュールの関数・変数の宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  各モジュールの初期化（kernel_cfg.c）
   */
  extern void	initialize_object(void);
  
  /*
!  *  初期化ルーチンの実行（kernel_cfg.c）
   */
  extern void	call_inirtn(void);
  
  /*
!  *  終了処理ルーチンの実行（kernel_cfg.c）
   */
  extern void	call_terrtn(void);
  
  /*
!  *  非タスクコンテキスト用のスタック領域（kernel_cfg.c）
   */
! extern const SIZE	istksz;		/* スタック領域のサイズ（丸めた値） */
! extern STK_T *const	istk;		/* スタック領域の先頭番地 */
  #ifdef TOPPERS_ISTKPT
! extern STK_T *const	istkpt;		/* スタックポインタの初期値 */
  #endif /* TOPPERS_ISTKPT */
  
  /*
!  *  カーネル動作状態フラグ（startup.c）
   */
  extern bool_t	kerflg;
  
  /*
!  *  カーネルの起動（startup.c）
   */
  extern void	sta_ker(void);
  
  /*
!  *  カーネルの終了処理（startup.c）
   */
  extern void	exit_kernel(void);
  
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/kernel_int.h ASPs/asp/extension/mutex/kernel/kernel_int.h
*** 1.9.1/asp/extension/mutex/kernel/kernel_int.h	Wed Aug 15 11:26:24 2012
--- ASPs/asp/extension/mutex/kernel/kernel_int.h	Fri Dec  9 13:54:01 2022
***************
*** 8,59 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: kernel_int.h 2396 2012-08-15 02:26:22Z ertl-hiro $
   */
  
  /*
!  *		kernel_cfg.cʤcfg1_out.cѥإåե
   */
  
  #ifndef TOPPERS_KERNEL_INT_H
  #define TOPPERS_KERNEL_INT_H
  
  /*
!  *  ͥɸإåե
   */
  #include "kernel_impl.h"
  
  /*
!  *  ͥγƥإåե
   */
  #include "task.h"
  #include "semaphore.h"
--- 8,59 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: kernel_int.h 2396 2012-08-15 02:26:22Z ertl-hiro $
   */
  
  /*
!  *		kernel_cfg.c（およびcfg1_out.c）用ヘッダファイル
   */
  
  #ifndef TOPPERS_KERNEL_INT_H
  #define TOPPERS_KERNEL_INT_H
  
  /*
!  *  カーネル標準ヘッダファイル
   */
  #include "kernel_impl.h"
  
  /*
!  *  カーネルの各ヘッダファイル
   */
  #include "task.h"
  #include "semaphore.h"
***************
*** 70,81 ****
  #include "time_event.h"
  
  /*
!  *  ͡षܥ򸵤᤹Υإåե
   */
  #include "kernel_unrename.h"
  
  /*
!  *  Ƥ뤿Υޥ
   */
  #ifndef TOPPERS_EMPTY_LABEL
  #define TOPPERS_EMPTY_LABEL(type, var)		type var[0]
--- 70,81 ----
  #include "time_event.h"
  
  /*
!  *  リネームしたシンボルを元に戻すためのヘッダファイル
   */
  #include "kernel_unrename.h"
  
  /*
!  *  内容が空の配列を生成するためのマクロ
   */
  #ifndef TOPPERS_EMPTY_LABEL
  #define TOPPERS_EMPTY_LABEL(type, var)		type var[0]
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/mutex.c ASPs/asp/extension/mutex/kernel/mutex.c
*** 1.9.1/asp/extension/mutex/kernel/mutex.c	Sun Aug 17 22:09:31 2014
--- ASPs/asp/extension/mutex/kernel/mutex.c	Fri Dec  9 13:54:01 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: mutex.c 2656 2014-08-17 13:09:30Z ertl-hiro $
   */
  
  /*
!  *		ߥ塼ƥåǽ
   */
  
  #include "kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: mutex.c 2656 2014-08-17 13:09:30Z ertl-hiro $
   */
  
  /*
!  *		ミューテックス機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "mutex.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_LOC_MTX_ENTER
  #define LOG_LOC_MTX_ENTER(mtxid)
--- 49,55 ----
  #include "mutex.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_LOC_MTX_ENTER
  #define LOG_LOC_MTX_ENTER(mtxid)
***************
*** 100,131 ****
  #endif /* LOG_REF_MTX_LEAVE */
  
  /*
!  *  ߥ塼ƥåο
   */
  #define tnum_mtx	((uint_t)(tmax_mtxid - TMIN_MTXID + 1))
  
  /*
!  *  ߥ塼ƥåIDߥ塼ƥå֥åФΥޥ
   */
  #define INDEX_MTX(mtxid)	((uint_t)((mtxid) - TMIN_MTXID))
  #define get_mtxcb(mtxid)	(&(mtxcb_table[INDEX_MTX(mtxid)]))
  
  /*
!  *  ߥ塼ƥå֥åmutex_queueؤΥݥ󥿤顤ߥ塼ƥ
!  *  ֥åؤΥݥ󥿤ФΥޥ
   */
  #define MTXCB_QUEUE(p_queue) \
  			((MTXCB *)(((char *) p_queue) - offsetof(MTXCB, mutex_queue)))
  
  /*
!  *  ߥ塼ƥåΥץȥȽǤޥ
   */
  #define MTXPROTO_MASK			0x03U
  #define MTXPROTO(p_mtxcb)		((p_mtxcb)->p_mtxinib->mtxatr & MTXPROTO_MASK)
  #define MTX_CEILING(p_mtxcb)	(MTXPROTO(p_mtxcb) == TA_CEILING)
  
  /*
!  *  եå롼ƽФѤѿ
   */
  #ifdef TOPPERS_mtxhook
  
--- 100,131 ----
  #endif /* LOG_REF_MTX_LEAVE */
  
  /*
!  *  ミューテックスの数
   */
  #define tnum_mtx	((uint_t)(tmax_mtxid - TMIN_MTXID + 1))
  
  /*
!  *  ミューテックスIDからミューテックス管理ブロックを取り出すためのマクロ
   */
  #define INDEX_MTX(mtxid)	((uint_t)((mtxid) - TMIN_MTXID))
  #define get_mtxcb(mtxid)	(&(mtxcb_table[INDEX_MTX(mtxid)]))
  
  /*
!  *  ミューテックス管理ブロック中のmutex_queueへのポインタから，ミューテッ
!  *  クス管理ブロックへのポインタを取り出すためのマクロ
   */
  #define MTXCB_QUEUE(p_queue) \
  			((MTXCB *)(((char *) p_queue) - offsetof(MTXCB, mutex_queue)))
  
  /*
!  *  ミューテックスのプロトコルを判断するマクロ
   */
  #define MTXPROTO_MASK			0x03U
  #define MTXPROTO(p_mtxcb)		((p_mtxcb)->p_mtxinib->mtxatr & MTXPROTO_MASK)
  #define MTX_CEILING(p_mtxcb)	(MTXPROTO(p_mtxcb) == TA_CEILING)
  
  /*
!  *  フックルーチン呼出し用の変数
   */
  #ifdef TOPPERS_mtxhook
  
***************
*** 136,142 ****
  #endif /* TOPPERS_mtxhook */
  
  /* 
!  *  ߥ塼ƥåǽν
   */
  #ifdef TOPPERS_mtxini
  
--- 136,142 ----
  #endif /* TOPPERS_mtxhook */
  
  /* 
!  *  ミューテックス機能の初期化
   */
  #ifdef TOPPERS_mtxini
  
***************
*** 161,167 ****
  #endif /* TOPPERS_mtxini */
  
  /* 
!  *  ٰͥȿΥå
   */
  #ifdef TOPPERS_mtxchk
  
--- 161,167 ----
  #endif /* TOPPERS_mtxini */
  
  /* 
!  *  上限優先度違反のチェック
   */
  #ifdef TOPPERS_mtxchk
  
***************
*** 172,179 ****
  	MTXCB	*p_mtxcb;
  
  	/*
! 	 *  åƤͥپ¥ߥ塼ƥåǡͥ
! 	 *  ٤bpriority㤤ΤСfalse֤
  	 */
  	p_queue = p_tcb->mutex_queue.p_next;
  	while (p_queue != &(p_tcb->mutex_queue)) {
--- 172,179 ----
  	MTXCB	*p_mtxcb;
  
  	/*
! 	 *  タスクがロックしている優先度上限ミューテックスの中で，上限優先
! 	 *  度がbpriorityよりも低いものがあれば，falseを返す．
  	 */
  	p_queue = p_tcb->mutex_queue.p_next;
  	while (p_queue != &(p_tcb->mutex_queue)) {
***************
*** 185,192 ****
  	}
  
  	/*
! 	 *  ͥپ¥ߥ塼ƥåΥåԤäƤˡ
! 	 *  ξͥ٤bpriority㤯Сfalse֤
  	 */
  	if (TSTAT_WAIT_MTX(p_tcb->tstat)) {
  		p_mtxcb = ((WINFO_MTX *)(p_tcb->p_winfo))->p_mtxcb;
--- 185,192 ----
  	}
  
  	/*
! 	 *  タスクが優先度上限ミューテックスのロックを待っている場合に，そ
! 	 *  の上限優先度がbpriorityよりも低くければ，falseを返す．
  	 */
  	if (TSTAT_WAIT_MTX(p_tcb->tstat)) {
  		p_mtxcb = ((WINFO_MTX *)(p_tcb->p_winfo))->p_mtxcb;
***************
*** 196,202 ****
  	}
  
  	/*
! 	 *  ξˤƤϤޤʤtrue֤
  	 */
  	return(true);
  }
--- 196,202 ----
  	}
  
  	/*
! 	 *  いずれの条件にも当てはまらなければtrueを返す．
  	 */
  	return(true);
  }
***************
*** 204,210 ****
  #endif /* TOPPERS_mtxchk */
  
  /* 
!  *  ͥپ¥ߥ塼ƥååƤ뤫Υå
   */
  #ifdef TOPPERS_mtxscan
  
--- 204,210 ----
  #endif /* TOPPERS_mtxchk */
  
  /* 
!  *  優先度上限ミューテックスをロックしているかのチェック
   */
  #ifdef TOPPERS_mtxscan
  
***************
*** 228,234 ****
  #endif /* TOPPERS_mtxscan */
  
  /* 
!  *  θͥ٤η׻
   */
  #ifdef TOPPERS_mtxcalc
  
--- 228,234 ----
  #endif /* TOPPERS_mtxscan */
  
  /* 
!  *  タスクの現在優先度の計算
   */
  #ifdef TOPPERS_mtxcalc
  
***************
*** 254,260 ****
  #endif /* TOPPERS_mtxcalc */
  
  /*
!  *  ͥ٤夬ʤޤ˾θͥѹ
   */
  Inline bool_t
  mutex_raise_priority(TCB *p_tcb, uint_t newpri)
--- 254,260 ----
  #endif /* TOPPERS_mtxcalc */
  
  /*
!  *  要素優先度が上がる（または増える）場合の現在優先度変更処理
   */
  Inline bool_t
  mutex_raise_priority(TCB *p_tcb, uint_t newpri)
***************
*** 266,272 ****
  }
  
  /*
!  *  ͥ٤ʤޤϸ˾θͥѹ
   */
  Inline bool_t
  mutex_drop_priority(TCB *p_tcb, uint_t oldpri)
--- 266,272 ----
  }
  
  /*
!  *  要素優先度が下がる（または減る）場合の現在優先度変更処理
   */
  Inline bool_t
  mutex_drop_priority(TCB *p_tcb, uint_t oldpri)
***************
*** 283,289 ****
  }
  
  /*
!  *  ߥ塼ƥååν
   */
  Inline bool_t
  mutex_acquire(TCB *p_loctsk, MTXCB *p_mtxcb)
--- 283,289 ----
  }
  
  /*
!  *  ミューテックスをロックした場合の処理
   */
  Inline bool_t
  mutex_acquire(TCB *p_loctsk, MTXCB *p_mtxcb)
***************
*** 297,303 ****
  }
  
  /*
!  *  ߥ塼ƥåΥå
   */
  #ifdef TOPPERS_mtxrel
  
--- 297,303 ----
  }
  
  /*
!  *  ミューテックスのロック解除
   */
  #ifdef TOPPERS_mtxrel
  
***************
*** 312,319 ****
  	}
  	else {
  		/*
! 		 *  ߥ塼ƥåԤ塼Ƭp_tcbˤˡߥ塼ƥ
! 		 *  å롥
  		 */
  		p_tcb = (TCB *) queue_delete_next(&(p_mtxcb->wait_queue));
  		wait_dequeue_tmevtb(p_tcb);
--- 312,319 ----
  	}
  	else {
  		/*
! 		 *  ミューテックス待ちキューの先頭タスク（p_tcb）に，ミューテッ
! 		 *  クスをロックさせる．
  		 */
  		p_tcb = (TCB *) queue_delete_next(&(p_mtxcb->wait_queue));
  		wait_dequeue_tmevtb(p_tcb);
***************
*** 333,339 ****
  #endif /* TOPPERS_mtxrel */
  
  /*
!  *  åƤ뤹٤ƤΥߥ塼ƥåΥå
   */
  #ifdef TOPPERS_mtxrela
  
--- 333,339 ----
  #endif /* TOPPERS_mtxrel */
  
  /*
!  *  タスクがロックしているすべてのミューテックスのロック解除
   */
  #ifdef TOPPERS_mtxrela
  
***************
*** 356,362 ****
  #endif /* TOPPERS_mtxrela */
  
  /*
!  *  ߥ塼ƥåΥå
   */
  #ifdef TOPPERS_loc_mtx
  
--- 356,362 ----
  #endif /* TOPPERS_mtxrela */
  
  /*
!  *  ミューテックスのロック
   */
  #ifdef TOPPERS_loc_mtx
  
***************
*** 380,387 ****
  	else if (p_mtxcb->p_loctsk == NULL) {
  		(void) mutex_acquire(p_runtsk, p_mtxcb);
  		/*
! 		 *  ͥپ¥ߥ塼ƥåå硤p_runtskͥ
! 		 *  夬ǽ뤬ǥѥåɬפˤʤ뤳ȤϤʤ
  		 */
  		assert(!(p_runtsk != p_schedtsk && dspflg));
  		ercd = E_OK;
--- 380,387 ----
  	else if (p_mtxcb->p_loctsk == NULL) {
  		(void) mutex_acquire(p_runtsk, p_mtxcb);
  		/*
! 		 *  優先度上限ミューテックスをロックした場合，p_runtskの優先度
! 		 *  が上がる可能性があるが，ディスパッチが必要になることはない．
  		 */
  		assert(!(p_runtsk != p_schedtsk && dspflg));
  		ercd = E_OK;
***************
*** 405,411 ****
  #endif /* TOPPERS_loc_mtx */
  
  /*
!  *  ߥ塼ƥåΥåʥݡ󥰡
   */
  #ifdef TOPPERS_ploc_mtx
  
--- 405,411 ----
  #endif /* TOPPERS_loc_mtx */
  
  /*
!  *  ミューテックスのロック（ポーリング）
   */
  #ifdef TOPPERS_ploc_mtx
  
***************
*** 428,435 ****
  	else if (p_mtxcb->p_loctsk == NULL) {
  		(void) mutex_acquire(p_runtsk, p_mtxcb);
  		/*
! 		 *  ͥپ¥ߥ塼ƥåå硤p_runtskͥ
! 		 *  夬ǽ뤬ǥѥåɬפˤʤ뤳ȤϤʤ
  		 */
  		assert(!(p_runtsk != p_schedtsk && dspflg));
  		ercd = E_OK;
--- 428,435 ----
  	else if (p_mtxcb->p_loctsk == NULL) {
  		(void) mutex_acquire(p_runtsk, p_mtxcb);
  		/*
! 		 *  優先度上限ミューテックスをロックした場合，p_runtskの優先度
! 		 *  が上がる可能性があるが，ディスパッチが必要になることはない．
  		 */
  		assert(!(p_runtsk != p_schedtsk && dspflg));
  		ercd = E_OK;
***************
*** 450,456 ****
  #endif /* TOPPERS_ploc_mtx */
  
  /*
!  *  ߥ塼ƥåΥåʥॢȤ
   */
  #ifdef TOPPERS_tloc_mtx
  
--- 450,456 ----
  #endif /* TOPPERS_ploc_mtx */
  
  /*
!  *  ミューテックスのロック（タイムアウトあり）
   */
  #ifdef TOPPERS_tloc_mtx
  
***************
*** 476,483 ****
  	else if (p_mtxcb->p_loctsk == NULL) {
  		(void) mutex_acquire(p_runtsk, p_mtxcb);
  		/*
! 		 *  ͥپ¥ߥ塼ƥåå硤p_runtskͥ
! 		 *  夬ǽ뤬ǥѥåɬפˤʤ뤳ȤϤʤ
  		 */
  		assert(!(p_runtsk != p_schedtsk && dspflg));
  		ercd = E_OK;
--- 476,483 ----
  	else if (p_mtxcb->p_loctsk == NULL) {
  		(void) mutex_acquire(p_runtsk, p_mtxcb);
  		/*
! 		 *  優先度上限ミューテックスをロックした場合，p_runtskの優先度
! 		 *  が上がる可能性があるが，ディスパッチが必要になることはない．
  		 */
  		assert(!(p_runtsk != p_schedtsk && dspflg));
  		ercd = E_OK;
***************
*** 505,511 ****
  #endif /* TOPPERS_tloc_mtx */
  
  /*
!  *  ߥ塼ƥåΥå
   */
  #ifdef TOPPERS_unl_mtx
  
--- 505,511 ----
  #endif /* TOPPERS_tloc_mtx */
  
  /*
!  *  ミューテックスのロック解除
   */
  #ifdef TOPPERS_unl_mtx
  
***************
*** 550,556 ****
  #endif /* TOPPERS_unl_mtx */
  
  /*
!  *  ߥ塼ƥåν
   */
  #ifdef TOPPERS_ini_mtx
  
--- 550,556 ----
  #endif /* TOPPERS_unl_mtx */
  
  /*
!  *  ミューテックスの初期化
   */
  #ifdef TOPPERS_ini_mtx
  
***************
*** 593,599 ****
  #endif /* TOPPERS_ini_mtx */
  
  /*
!  *  ߥ塼ƥåξֻ
   */
  #ifdef TOPPERS_ref_mtx
  
--- 593,599 ----
  #endif /* TOPPERS_ini_mtx */
  
  /*
!  *  ミューテックスの状態参照
   */
  #ifdef TOPPERS_ref_mtx
  
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/mutex.h ASPs/asp/extension/mutex/kernel/mutex.h
*** 1.9.1/asp/extension/mutex/kernel/mutex.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/mutex/kernel/mutex.h	Fri Dec  9 13:54:01 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: mutex.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		ߥ塼ƥåǽ
   */
  
  #ifndef TOPPERS_MUTEX_H
--- 6,45 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: mutex.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		ミューテックス機能
   */
  
  #ifndef TOPPERS_MUTEX_H
***************
*** 48,163 ****
  #include "wait.h"
  
  /*
!  *  ߥ塼ƥå֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct mutex_initialization_block {
! 	ATR			mtxatr;			/* ߥ塼ƥå° */
! 	uint_t		ceilpri;		/* ߥ塼ƥåξͥ١ɽ*/
  } MTXINIB;
  
  /*
!  *  ߥ塼ƥå֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct mutex_control_block {
! 	QUEUE		wait_queue;		/* ߥ塼ƥåԤ塼 */
! 	const MTXINIB *p_mtxinib;	/* ֥åؤΥݥ */
! 	TCB			*p_loctsk;		/* ߥ塼ƥååƤ륿 */
! 	QUEUE		mutex_queue;	/* åƤߥ塼ƥåΥ塼 */
  } MTXCB;
  
  /*
!  *  ߥ塼ƥåԤ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ٤ƤΥեɤ̤ˤʤäƤ롥
   */
  typedef struct mutex_waiting_information {
! 	WINFO	winfo;			/* ɸԤ֥å */
! 	MTXCB	*p_mtxcb;		/* ԤäƤߥ塼ƥåδ֥å */
  } WINFO_MTX;
  
  /*
!  *  ߥ塼ƥåIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_mtxid;
  
  /*
!  *  ߥ塼ƥå֥åΥꥢkernel_cfg.c
   */
  extern const MTXINIB	mtxinib_table[];
  
  /*
!  *  ߥ塼ƥå֥åΥꥢkernel_cfg.c
   */
  extern MTXCB	mtxcb_table[];
  
  /*
!  *  ߥ塼ƥå֥åߥ塼ƥåIDФΥޥ
   */
  #define	MTXID(p_mtxcb)	((ID)(((p_mtxcb) - mtxcb_table) + TMIN_MTXID))
  
  /*
!  *  ߥ塼ƥåǽν
   */
  extern void	initialize_mutex(void);
  
  /*
!  *  ٰͥȿΥå
   *
!  *  chg_priǾٰͥȿΥåԤѤؿǤꡤ
!  *  p_tcbǻꤵ륿åƤͥپ¥ߥ塼ƥåȡ
!  *  åԤäƤͥپ¥ߥ塼ƥåǡͥ٤
!  *  bpriority㤤Τfalse򡤤Ǥʤtrue֤
   */
  extern bool_t	(*mtxhook_check_ceilpri)(TCB *p_tcb, uint_t bpriority);
  extern bool_t	mutex_check_ceilpri(TCB *p_tcb, uint_t bpriority);
  
  /* 
!  *  ͥپ¥ߥ塼ƥååƤ뤫Υå
   *
!  *  p_tcbǻꤵ륿ͥپ¥ߥ塼ƥååƤ
!  *  trueǤʤfalse֤
   */
  extern bool_t	(*mtxhook_scan_ceilmtx)(TCB *p_tcb);
  extern bool_t	mutex_scan_ceilmtx(TCB *p_tcb);
  
  /* 
!  *  θͥ٤η׻
   *
!  *  p_tcbǻꤵ륿θͥ١ʤꤹ٤͡ˤ׻롥
   */
  extern uint_t	mutex_calc_priority(TCB *p_tcb);
  
  /*
!  *  ߥ塼ƥåΥå
   *
!  *  p_mtxcbǻꤵߥ塼ƥåå롥å
!  *  ߥ塼ƥåˡåԤ֤ΥˤϡΥ
!  *  ˥ߥ塼ƥåå롥
   */
  extern bool_t	mutex_release(MTXCB *p_mtxcb);
  
  /*
!  *  åƤ뤹٤ƤΥߥ塼ƥåΥå
   *
!  *  p_tcbǻꤵ륿ˡ줬åƤ뤹٤ƤΥߥ塼ƥå
!  *  å롥åߥ塼ƥåˡåԤ
!  *  ֤ΥˤϡΥ˥ߥ塼ƥåå롥
!  *
!  *  δؿϡνλ˻ȤΤǤ뤿ᡤp_tcbǻꤵ
!  *  륿ͥ٤ѹϹԤʤδؿ¾
!  *  Υͥ٤Ѳ¹Ԥ٤Ѥ뤳Ȥ롥
!  *  ᡤδؿäˡǥѥåɬפȽ̤ơɬפ
!  *  ˤϥǥѥåԤʤФʤʤ
   */
  extern bool_t	(*mtxhook_release_all)(TCB *p_tcb);
  extern bool_t	mutex_release_all(TCB *p_tcb);
--- 48,163 ----
  #include "wait.h"
  
  /*
!  *  ミューテックス初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct mutex_initialization_block {
! 	ATR			mtxatr;			/* ミューテックス属性 */
! 	uint_t		ceilpri;		/* ミューテックスの上限優先度（内部表現）*/
  } MTXINIB;
  
  /*
!  *  ミューテックス管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct mutex_control_block {
! 	QUEUE		wait_queue;		/* ミューテックス待ちキュー */
! 	const MTXINIB *p_mtxinib;	/* 初期化ブロックへのポインタ */
! 	TCB			*p_loctsk;		/* ミューテックスをロックしているタスク */
! 	QUEUE		mutex_queue;	/* ロックしているミューテックスのキュー */
  } MTXCB;
  
  /*
!  *  ミューテックス待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  すべてのフィールドが共通になっている．
   */
  typedef struct mutex_waiting_information {
! 	WINFO	winfo;			/* 標準の待ち情報ブロック */
! 	MTXCB	*p_mtxcb;		/* 待っているミューテックスの管理ブロック */
  } WINFO_MTX;
  
  /*
!  *  ミューテックスIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_mtxid;
  
  /*
!  *  ミューテックス初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const MTXINIB	mtxinib_table[];
  
  /*
!  *  ミューテックス管理ブロックのエリア（kernel_cfg.c）
   */
  extern MTXCB	mtxcb_table[];
  
  /*
!  *  ミューテックス管理ブロックからミューテックスIDを取り出すためのマクロ
   */
  #define	MTXID(p_mtxcb)	((ID)(((p_mtxcb) - mtxcb_table) + TMIN_MTXID))
  
  /*
!  *  ミューテックス機能の初期化
   */
  extern void	initialize_mutex(void);
  
  /*
!  *  上限優先度違反のチェック
   *
!  *  chg_priの中で上限優先度違反のチェックを行うために用いる関数であり，
!  *  p_tcbで指定されるタスクがロックしている優先度上限ミューテックスと，
!  *  ロックを待っている優先度上限ミューテックスの中で，上限優先度が
!  *  bpriorityよりも低いものがあればfalseを，そうでなければtrueを返す．
   */
  extern bool_t	(*mtxhook_check_ceilpri)(TCB *p_tcb, uint_t bpriority);
  extern bool_t	mutex_check_ceilpri(TCB *p_tcb, uint_t bpriority);
  
  /* 
!  *  優先度上限ミューテックスをロックしているかのチェック
   *
!  *  p_tcbで指定されるタスクが優先度上限ミューテックスをロックしていれば
!  *  true，そうでなければfalseを返す．
   */
  extern bool_t	(*mtxhook_scan_ceilmtx)(TCB *p_tcb);
  extern bool_t	mutex_scan_ceilmtx(TCB *p_tcb);
  
  /* 
!  *  タスクの現在優先度の計算
   *
!  *  p_tcbで指定されるタスクの現在優先度（に設定すべき値）を計算する．
   */
  extern uint_t	mutex_calc_priority(TCB *p_tcb);
  
  /*
!  *  ミューテックスのロック解除
   *
!  *  p_mtxcbで指定されるミューテックスをロック解除する．ロック解除した
!  *  ミューテックスに，ロック待ち状態のタスクがある場合には，そのタスク
!  *  にミューテックスをロックさせる．
   */
  extern bool_t	mutex_release(MTXCB *p_mtxcb);
  
  /*
!  *  タスクがロックしているすべてのミューテックスのロック解除
   *
!  *  p_tcbで指定されるタスクに，それがロックしているすべてのミューテック
!  *  スをロック解除させる．ロック解除したミューテックスに，ロック待ち状
!  *  態のタスクがある場合には，そのタスクにミューテックスをロックさせる．
!  *
!  *  この関数は，タスクの終了時に使われるものであるため，p_tcbで指定され
!  *  るタスクの優先度を変更する処理は行わない．ただし，この関数の中で他
!  *  のタスクの優先度が変化し，実行すべきタスクが変わることがある．その
!  *  ため，この関数から戻った後に，ディスパッチが必要か判別して，必要な
!  *  場合にはディスパッチを行わなければならない．
   */
  extern bool_t	(*mtxhook_release_all)(TCB *p_tcb);
  extern bool_t	mutex_release_all(TCB *p_tcb);
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/sys_manage.c ASPs/asp/extension/mutex/kernel/sys_manage.c
*** 1.9.1/asp/extension/mutex/kernel/sys_manage.c	Fri Dec 31 22:43:07 2010
--- ASPs/asp/extension/mutex/kernel/sys_manage.c	Fri Dec  9 13:54:01 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: sys_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		ƥִǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: sys_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		システム状態管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ROT_RDQ_ENTER
  #define LOG_ROT_RDQ_ENTER(tskpri)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ROT_RDQ_ENTER
  #define LOG_ROT_RDQ_ENTER(tskpri)
***************
*** 172,178 ****
  #endif /* LOG_SNS_KER_LEAVE */
  
  /*
!  *  ̤ͥβž
   */
  #ifdef TOPPERS_rot_rdq
  
--- 172,178 ----
  #endif /* LOG_SNS_KER_LEAVE */
  
  /*
!  *  タスクの優先順位の回転
   */
  #ifdef TOPPERS_rot_rdq
  
***************
*** 202,208 ****
  #endif /* TOPPERS_rot_rdq */
  
  /*
!  *  ̤ͥβž󥿥ƥѡ
   */
  #ifdef TOPPERS_irot_rdq
  
--- 202,208 ----
  #endif /* TOPPERS_rot_rdq */
  
  /*
!  *  タスクの優先順位の回転（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_irot_rdq
  
***************
*** 230,236 ****
  #endif /* TOPPERS_irot_rdq */
  
  /*
!  *  ¹Ծ֤ΥIDλ
   */
  #ifdef TOPPERS_get_tid
  
--- 230,236 ----
  #endif /* TOPPERS_irot_rdq */
  
  /*
!  *  実行状態のタスクIDの参照
   */
  #ifdef TOPPERS_get_tid
  
***************
*** 255,261 ****
  #endif /* TOPPERS_get_tid */
  
  /*
!  *  ¹Ծ֤ΥIDλȡ󥿥ƥѡ
   */
  #ifdef TOPPERS_iget_tid
  
--- 255,261 ----
  #endif /* TOPPERS_get_tid */
  
  /*
!  *  実行状態のタスクIDの参照（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iget_tid
  
***************
*** 280,286 ****
  #endif /* TOPPERS_iget_tid */
  
  /*
!  *  CPUå֤ؤΰܹ
   */
  #ifdef TOPPERS_loc_cpu
  
--- 280,286 ----
  #endif /* TOPPERS_iget_tid */
  
  /*
!  *  CPUロック状態への移行
   */
  #ifdef TOPPERS_loc_cpu
  
***************
*** 305,311 ****
  #endif /* TOPPERS_loc_cpu */
  
  /*
!  *  CPUå֤ؤΰܹԡ󥿥ƥѡ
   */
  #ifdef TOPPERS_iloc_cpu
  
--- 305,311 ----
  #endif /* TOPPERS_loc_cpu */
  
  /*
!  *  CPUロック状態への移行（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iloc_cpu
  
***************
*** 330,340 ****
  #endif /* TOPPERS_iloc_cpu */
  
  /*
!  *  CPUå֤β
   *
!  *  CPUåϡǥѥåɬפȤʤ륵ӥƤӽФ
!  *  ȤϤǤʤᡤCPUå֤β˥ǥѥåư
!  *  ɬפϤʤ
   */
  #ifdef TOPPERS_unl_cpu
  
--- 330,340 ----
  #endif /* TOPPERS_iloc_cpu */
  
  /*
!  *  CPUロック状態の解除
   *
!  *  CPUロック中は，ディスパッチが必要となるサービスコールを呼び出すこ
!  *  とはできないため，CPUロック状態の解除時にディスパッチャを起動する
!  *  必要はない．
   */
  #ifdef TOPPERS_unl_cpu
  
***************
*** 359,369 ****
  #endif /* TOPPERS_unl_cpu */
  
  /*
!  *  CPUå֤β󥿥ƥѡ
   *
!  *  CPUåϡǥѥåɬפȤʤ륵ӥƤӽФ
!  *  ȤϤǤʤᡤCPUå֤β˥ǥѥåεư
!  *  ᤹ɬפϤʤ
   */
  #ifdef TOPPERS_iunl_cpu
  
--- 359,369 ----
  #endif /* TOPPERS_unl_cpu */
  
  /*
!  *  CPUロック状態の解除（非タスクコンテキスト用）
   *
!  *  CPUロック中は，ディスパッチが必要となるサービスコールを呼び出すこ
!  *  とはできないため，CPUロック状態の解除時にディスパッチャの起動を要
!  *  求する必要はない．
   */
  #ifdef TOPPERS_iunl_cpu
  
***************
*** 388,394 ****
  #endif /* TOPPERS_iunl_cpu */
  
  /*
!  *  ǥѥåζػ
   */
  #ifdef TOPPERS_dis_dsp
  
--- 388,394 ----
  #endif /* TOPPERS_iunl_cpu */
  
  /*
!  *  ディスパッチの禁止
   */
  #ifdef TOPPERS_dis_dsp
  
***************
*** 414,420 ****
  #endif /* TOPPERS_dis_dsp */
  
  /*
!  *  ǥѥåε
   */
  #ifdef TOPPERS_ena_dsp
  
--- 414,420 ----
  #endif /* TOPPERS_dis_dsp */
  
  /*
!  *  ディスパッチの許可
   */
  #ifdef TOPPERS_ena_dsp
  
***************
*** 445,451 ****
  #endif /* TOPPERS_ena_dsp */
  
  /*
!  *  ƥȤλ
   */
  #ifdef TOPPERS_sns_ctx
  
--- 445,451 ----
  #endif /* TOPPERS_ena_dsp */
  
  /*
!  *  コンテキストの参照
   */
  #ifdef TOPPERS_sns_ctx
  
***************
*** 463,469 ****
  #endif /* TOPPERS_sns_ctx */
  
  /*
!  *  CPUå֤λ
   */
  #ifdef TOPPERS_sns_loc
  
--- 463,469 ----
  #endif /* TOPPERS_sns_ctx */
  
  /*
!  *  CPUロック状態の参照
   */
  #ifdef TOPPERS_sns_loc
  
***************
*** 481,487 ****
  #endif /* TOPPERS_sns_loc */
  
  /*
!  *  ǥѥåػ߾֤λ
   */
  #ifdef TOPPERS_sns_dsp
  
--- 481,487 ----
  #endif /* TOPPERS_sns_loc */
  
  /*
!  *  ディスパッチ禁止状態の参照
   */
  #ifdef TOPPERS_sns_dsp
  
***************
*** 499,505 ****
  #endif /* TOPPERS_sns_dsp */
  
  /*
!  *  ǥѥåα֤λ
   */
  #ifdef TOPPERS_sns_dpn
  
--- 499,505 ----
  #endif /* TOPPERS_sns_dsp */
  
  /*
!  *  ディスパッチ保留状態の参照
   */
  #ifdef TOPPERS_sns_dpn
  
***************
*** 517,523 ****
  #endif /* TOPPERS_sns_dpn */
  
  /*
!  *  ͥư֤λ
   */
  #ifdef TOPPERS_sns_ker
  
--- 517,523 ----
  #endif /* TOPPERS_sns_dpn */
  
  /*
!  *  カーネル非動作状態の参照
   */
  #ifdef TOPPERS_sns_ker
  
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/task.c ASPs/asp/extension/mutex/kernel/task.c
*** 1.9.1/asp/extension/mutex/kernel/task.c	Sat Aug 27 07:59:56 2011
--- ASPs/asp/extension/mutex/kernel/task.c	Fri Dec  9 13:54:01 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
***************
*** 62,108 ****
  #ifdef TOPPERS_tskini
  
  /*
!  *  ¹Ծ֤Υ
   */
  TCB		*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   */
  TCB		*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   */
  bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   */
  bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   */
  bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   */
  bool_t	dspflg;
  
  /*
!  *  ǥ塼
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   */
  uint16_t	ready_primap;
  
  /*
!  *  ⥸塼ν
   */
  void
  initialize_task(void)
--- 62,108 ----
  #ifdef TOPPERS_tskini
  
  /*
!  *  実行状態のタスク
   */
  TCB		*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   */
  TCB		*p_schedtsk;
  
  /*
!  *  タスクディスパッチ／タスク例外処理ルーチン起動要求フラグ
   */
  bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   */
  bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   */
  bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   */
  bool_t	dspflg;
  
  /*
!  *  レディキュー
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   */
  uint16_t	ready_primap;
  
  /*
!  *  タスク管理モジュールの初期化
   */
  void
  initialize_task(void)
***************
*** 138,159 ****
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ӥåȥޥåץؿ
   *
!  *  bitmap1ΥӥåȤ⡤ǤⲼ̡ʱˤΤΤ򥵡Υӥ
!  *  ֹ֤ӥåֹϡǲ̥ӥåȤ0Ȥ롥bitmap0
!  *  ƤϤʤʤδؿǤϡbitmap16ӥåȤǤ뤳Ȥꤷ
!  *  uint16_tȤƤ롥
   *
!  *  ӥåȥ̿ĥץåǤϡӥåȥ̿Ȥ褦
!  *  ľΨɤ礬롥Τ褦ʾˤϡå
!  *  ¸ǥӥåȥ̿Ȥäbitmap_search
!  *  OMIT_BITMAP_SEARCHޥФ褤ޤӥåȥ̿
!  *  դʤɤͳͥ٤ȥӥåȤȤбѹ
!  *  ϡPRIMAP_BITޥФ褤
   *
!  *  ޤ饤֥ffsʤ顤Τ褦ƥ饤֥ؿ
!  *  ȤäΨɤǽ⤢롥
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
--- 138,159 ----
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ビットマップサーチ関数
   *
!  *  bitmap内の1のビットの内，最も下位（右）のものをサーチし，そのビッ
!  *  ト番号を返す．ビット番号は，最下位ビットを0とする．bitmapに0を指定
!  *  してはならない．この関数では，bitmapが16ビットであることを仮定し，
!  *  uint16_t型としている．
   *
!  *  ビットサーチ命令を持つプロセッサでは，ビットサーチ命令を使うように
!  *  書き直した方が効率が良い場合がある．このような場合には，ターゲット
!  *  依存部でビットサーチ命令を使ったbitmap_searchを定義し，
!  *  OMIT_BITMAP_SEARCHをマクロ定義すればよい．また，ビットサーチ命令の
!  *  サーチ方向が逆などの理由で優先度とビットとの対応を変更したい場合に
!  *  は，PRIMAP_BITをマクロ定義すればよい．
   *
!  *  また，ライブラリにffsがあるなら，次のように定義してライブラリ関数を
!  *  使った方が効率が良い可能性もある．
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
***************
*** 185,191 ****
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline bool_t
  primap_empty(void)
--- 185,191 ----
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  優先度ビットマップが空かのチェック
   */
  Inline bool_t
  primap_empty(void)
***************
*** 194,200 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥ
   */
  Inline uint_t
  primap_search(void)
--- 194,200 ----
  }
  
  /*
!  *  優先度ビットマップのサーチ
   */
  Inline uint_t
  primap_search(void)
***************
*** 203,209 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline void
  primap_set(uint_t pri)
--- 203,209 ----
  }
  
  /*
!  *  優先度ビットマップのセット
   */
  Inline void
  primap_set(uint_t pri)
***************
*** 212,218 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥꥢ
   */
  Inline void
  primap_clear(uint_t pri)
--- 212,218 ----
  }
  
  /*
!  *  優先度ビットマップのクリア
   */
  Inline void
  primap_clear(uint_t pri)
***************
*** 221,227 ****
  }
  
  /*
!  *  ǹ̥ͥΥ
   */
  #ifdef TOPPERS_tsksched
  
--- 221,227 ----
  }
  
  /*
!  *  最高優先順位タスクのサーチ
   */
  #ifdef TOPPERS_tsksched
  
***************
*** 237,247 ****
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡ¹ԤǤ륿ʤä
!  *  ȡp_tcbͥ٤ǹ̤ͥΥͥ٤⤤Ǥ
!  *  롥
   */
  #ifdef TOPPERS_tskrun
  
--- 237,247 ----
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  実行できる状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，実行できるタスクがなかった場合
!  *  と，p_tcbの優先度が最高優先順位のタスクの優先度よりも高い場合であ
!  *  る．
   */
  #ifdef TOPPERS_tskrun
  
***************
*** 263,274 ****
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡp_tcbǹ̤ͥΥ
!  *  äǤ롥p_tcbƱͥ٤Υ¾ˤϡp_tcb
!  *  μΥǹ̤ͥˤʤ롥Ǥʤϡǥ塼
!  *  ɬפ롥
   */
  #ifdef TOPPERS_tsknrun
  
--- 263,274 ----
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，p_tcbが最高優先順位のタスクで
!  *  あった場合である．p_tcbと同じ優先度のタスクが他にある場合は，p_tcb
!  *  の次のタスクが最高優先順位になる．そうでない場合は，レディキューを
!  *  サーチする必要がある．
   */
  #ifdef TOPPERS_tsknrun
  
***************
*** 298,304 ****
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  ٻ߾֤ؤ
   */
  #ifdef TOPPERS_tskdmt
  
--- 298,304 ----
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  休止状態への遷移
   */
  #ifdef TOPPERS_tskdmt
  
***************
*** 317,323 ****
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   */
  #ifdef TOPPERS_tskact
  
--- 317,323 ----
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  休止状態から実行できる状態への遷移
   */
  #ifdef TOPPERS_tskact
  
***************
*** 333,348 ****
  #endif /* TOPPERS_tskact */
  
  /*
!  *  ͥ٤ѹ
   *
!  *  ¹ԤǤ֤ξˤϡǥ塼Ǥΰ֤ѹ
!  *  롥֥ȤԤ塼Ԥ֤ˤʤäƤˤϡ
!  *  塼Ǥΰ֤ѹ롥
   *
!  *  ǹ̤ͥΥ򹹿Τϡ(1) p_tcbǹ̤ͥΥ
!  *  Ǥäơͥ٤򲼤硤(2) p_tcbǹ̤ͥΥ
!  *  ǤϤʤѹͥ٤ǹ̤ͥΥͥ٤⤤
!  *  Ǥ롥(1)ξˤϡǥ塼򥵡ɬפ롥
   */
  #ifdef TOPPERS_tskpri
  
--- 333,348 ----
  #endif /* TOPPERS_tskact */
  
  /*
!  *  タスクの優先度の変更
   *
!  *  タスクが実行できる状態の場合には，レディキューの中での位置を変更す
!  *  る．オブジェクトの待ちキューの中で待ち状態になっている場合には，待
!  *  ちキューの中での位置を変更する．
   *
!  *  最高優先順位のタスクを更新するのは，(1) p_tcbが最高優先順位のタス
!  *  クであって，その優先度を下げた場合，(2) p_tcbが最高優先順位のタス
!  *  クではなく，変更後の優先度が最高優先順位のタスクの優先度よりも高い
!  *  場合である．(1)の場合には，レディキューをサーチする必要がある．
   */
  #ifdef TOPPERS_tskpri
  
***************
*** 356,362 ****
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤ξ
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
--- 356,362 ----
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  タスクが実行できる状態の場合
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
***************
*** 387,394 ****
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  Ʊ֥̿Ȥδ֥åζ
! 			 *  ʬWOBJCBˤԤ塼ˤĤʤƤ
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
--- 387,394 ----
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  タスクが，同期・通信オブジェクトの管理ブロックの共通部
! 			 *  分（WOBJCB）の待ちキューにつながれている場合
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
***************
*** 400,409 ****
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  ǥ塼βž
   *
!  *  ǹ̤ͥΥ򹹿Τϡǹ̤ͥΥ
!  *  塼˰ưǤ롥
   */
  #ifdef TOPPERS_tskrot
  
--- 400,409 ----
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  レディキューの回転
   *
!  *  最高優先順位のタスクを更新するのは，最高優先順位のタスクがタスクキ
!  *  ューの末尾に移動した場合である．
   */
  #ifdef TOPPERS_tskrot
  
***************
*** 427,436 ****
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  㳰롼θƽФ
   *
!  *  ASPͥǤϡ㳰롼CPUå֤ܤ
!  *  ξ֤ᤵ˥꥿󤷤硤ͥ뤬ξ֤᤹
   */
  #ifdef TOPPERS_tsktex
  
--- 427,436 ----
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  ASPカーネルでは，タスク例外処理ルーチン内でCPUロック状態に遷移し，
!  *  元の状態に戻さずにリターンした場合，カーネルが元の状態に戻す．
   */
  #ifdef TOPPERS_tsktex
  
***************
*** 463,472 ****
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  dispatchƤӽФϡߺƵƽФˤʤä
! 			 *  뤬dispatchƤp_runtsk->enatexfalseˤ
! 			 *  лپ㤬ʤͳˤĤƤϡTOPPERS/ASP 
! 			 *  ͥ ߷ץפ򻲾ȤΤȡ
  			 */
  			dispatch();
  		}
--- 463,472 ----
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  ここでdispatchを呼び出す処理は，相互再帰呼出しになって
! 			 *  いるが，dispatchを呼ぶ前にp_runtsk->enatexをfalseにして
! 			 *  おけば支障がない．その理由については，「TOPPERS/ASP カー
! 			 *  ネル 設計メモ」を参照のこと．
  			 */
  			dispatch();
  		}
***************
*** 475,481 ****
  }
  
  /*
!  *  㳰롼εư
   */
  #ifndef OMIT_CALLTEX
  
--- 475,481 ----
  }
  
  /*
!  *  タスク例外処理ルーチンの起動
   */
  #ifndef OMIT_CALLTEX
  
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/task.h ASPs/asp/extension/mutex/kernel/task.h
*** 1.9.1/asp/extension/mutex/kernel/task.h	Sun May  6 19:06:51 2012
--- ASPs/asp/extension/mutex/kernel/task.h	Fri Dec  9 13:54:02 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.h 2370 2012-05-06 10:06:50Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #ifndef TOPPERS_TASK_H
--- 8,47 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.h 2370 2012-05-06 10:06:50Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #ifndef TOPPERS_TASK_H
***************
*** 51,100 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  ͥ٤ɽɽѴޥ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  ֤ɽ
   *
!  *  TCBΥ֤Ǥϡ¹Ծ֡RUNNINGˤȼ¹Բǽ֡READY
!  *  ϶̤ʤξ֤Τơ¹ԤǤ֡RUNNABLEˤȸƤ֡
!  *  Ԥ֤ϡ(TS_WAITING | TS_SUSPENDED)ɽTS_WAIT_???
!  *  װɽԤ֡Ԥ֤ޤˤξˤΤꤹ롥
!  */
! #define TS_DORMANT		0x00U			/* ٻ߾ */
! #define TS_RUNNABLE		0x01U			/* ¹ԤǤ */
! #define TS_WAITING		0x02U			/* Ԥ */
! #define TS_SUSPENDED	0x04U			/* Ԥ */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* ַвԤ */
! #define TS_WAIT_SLP		(0x01U << 3)	/* Ԥ */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* ǡ塼μԤ */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* ͥ٥ǡ塼μԤ */
! #define TS_WAIT_SEM		(0x04U << 3)	/* ޥե񸻤γԤ */
! #define TS_WAIT_FLG		(0x05U << 3)	/* ٥ȥե饰Ԥ */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* ǡ塼ؤԤ */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* ͥ٥ǡ塼ؤԤ */
! #define TS_WAIT_MBX		(0x08U << 3)	/* ᡼ܥåμԤ */
! #define TS_WAIT_MPF		(0x09U << 3)	/* Ĺ֥åγԤ */
! #define TS_WAIT_MTX		(0x0aU << 3)	/* ߥ塼ƥåΥåԤ */
! 
! /*
!  *  Ƚ̥ޥ
!  *
!  *  TSTAT_DORMANTϥٻ߾֤Ǥ뤫ɤTSTAT_RUNNABLE
!  *  ¹ԤǤ֤Ǥ뤫ɤȽ̤롥TSTAT_WAITING
!  *  ֤Ԥ֤Τ줫Ǥ뤫ɤTSTAT_SUSPENDED
!  *  Ԥ֤Ԥ֤Τ줫Ǥ뤫ɤȽ̤롥
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
--- 51,100 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  タスク優先度の内部表現・外部表現変換マクロ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  タスク状態の内部表現
   *
!  *  TCB中のタスク状態では，実行状態（RUNNING）と実行可能状態（READY）
!  *  は区別しない．両状態を総称して，実行できる状態（RUNNABLE）と呼ぶ．
!  *  二重待ち状態は，(TS_WAITING | TS_SUSPENDED)で表す．TS_WAIT_???は待
!  *  ち要因を表し，待ち状態（二重待ち状態を含む）の場合にのみ設定する．
!  */
! #define TS_DORMANT		0x00U			/* 休止状態 */
! #define TS_RUNNABLE		0x01U			/* 実行できる状態 */
! #define TS_WAITING		0x02U			/* 待ち状態 */
! #define TS_SUSPENDED	0x04U			/* 強制待ち状態 */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* 時間経過待ち */
! #define TS_WAIT_SLP		(0x01U << 3)	/* 起床待ち */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* データキューからの受信待ち */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* 優先度データキューからの受信待ち */
! #define TS_WAIT_SEM		(0x04U << 3)	/* セマフォ資源の獲得待ち */
! #define TS_WAIT_FLG		(0x05U << 3)	/* イベントフラグ待ち */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* データキューへの送信待ち */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* 優先度データキューへの送信待ち */
! #define TS_WAIT_MBX		(0x08U << 3)	/* メールボックスからの受信待ち */
! #define TS_WAIT_MPF		(0x09U << 3)	/* 固定長メモリブロックの獲得待ち */
! #define TS_WAIT_MTX		(0x0aU << 3)	/* ミューテックスのロック待ち */
! 
! /*
!  *  タスク状態判別マクロ
!  *
!  *  TSTAT_DORMANTはタスクが休止状態であるかどうかを，TSTAT_RUNNABLEは
!  *  タスクが実行できる状態であるかどうかを判別する．TSTAT_WAITINGは待
!  *  ち状態と二重待ち状態のいずれかであるかどうかを，TSTAT_SUSPENDEDは
!  *  強制待ち状態と二重待ち状態のいずれかであるかどうかを判別する．
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
***************
*** 102,125 ****
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  ԤװȽ̥ޥ
   *
!  *  TSTAT_WAIT_SLPϥԤǤ뤫ɤTSTAT_WAIT_WOBJ
!  *  ϥƱ֥̿ȤФԤǤ뤫ʸȡ
!  *  Ʊ֥̿ȤԤ塼ˤĤʤƤ뤫ˤɤȽ̤
!  *  롥ޤTSTAT_WAIT_WOBJCBϥƱ֥̿Ȥδ
!  *  ֥åζʬWOBJCBˤԤ塼ˤĤʤƤ뤫ɤ
!  *  Ƚ̤롥
!  *
!  *  TSTAT_WAIT_SLPϡǤդΥ֤椫顤ԤǤ
!  *  ȤȽ̤Ǥ롥ʤTSTAT_WAITINGˤԤ֤Ǥ뤳Ȥ
!  *  Ƚ̤ˡTSTAT_SLPѤƵԤ֤Ǥ뤳ȤȽ̤Ǥ롥
!  *  ΨŪ˼¸뤿ˡTS_WAIT_SLPͤ(0x00U << 3)ǤϤ
!  *  (0x01U << 3)ȤƤ롥ΤᡤַвԤ֤Ǥ
!  *  ȤȽ̤뤿TSTAT_WAIT_DLYTSTAT_WAIT_SLPƱͤˡ
!  *  ¸뤳ȤϤǤʤ
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* ԤװμФޥ */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
--- 102,125 ----
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  タスク待ち要因判別マクロ
   *
!  *  TSTAT_WAIT_SLPはタスクが起床待ちであるかどうかを，TSTAT_WAIT_WOBJ
!  *  はタスクが同期・通信オブジェクトに対する待ちであるか（言い換えると，
!  *  同期通信オブジェクトの待ちキューにつながれているか）どうかを判別す
!  *  る．また，TSTAT_WAIT_WOBJCBはタスクが同期・通信オブジェクトの管理
!  *  ブロックの共通部分（WOBJCB）の待ちキューにつながれているかどうかを
!  *  判別する．
!  *
!  *  TSTAT_WAIT_SLPは，任意のタスク状態の中から，タスクが起床待ちである
!  *  ことを判別できる．すなわち，TSTAT_WAITINGにより待ち状態であることを
!  *  判別せずに，TSTAT_SLPだけを用いて起床待ち状態であることを判別できる．
!  *  これを効率的に実現するために，TS_WAIT_SLPの値を，(0x00U << 3)ではな
!  *  く(0x01U << 3)としている．そのため，タスクが時間経過待ち状態である
!  *  ことを判別するためのTSTAT_WAIT_DLYを，TSTAT_WAIT_SLPと同様の方法で
!  *  実現することはできない．
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* 待ち要因の取出しマスク */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
***************
*** 127,489 ****
  #define TSTAT_WAIT_MTX(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_MTX)
  
  /*
!  *  Ԥ֥åWINFOˤ
   *
!  *  Ԥ֤δ֤ϡTCBӤp_winfoǻؤWINFO򼡤
!  *  褦ꤷʤФʤʤ
   *
!  *  (a) TCBΥ֤Ԥ֡TS_WAITINGˤˤ롥κݤˡԤ
!  *  װTS_WAIT_???ˤꤹ롥
   *
!  *  (b) ॢȤƻ뤹뤿ˡ।٥ȥ֥åϿ롥
!  *  Ͽ륿।٥ȥ֥åϡԤ륵ӥؿ
!  *  ΥѿȤƳݤؤΥݥ󥿤WINFOp_tmevtb˵
!  *  롥ॢȤδƻ뤬ɬפʤʱʵԤξˤˤϡ
!  *  p_tmevtbNULLˤ롥
!  *
!  *  Ʊ֥̿ȤФԤ֤ξˤϡɸWINFO
!  *  p_wobjcbեɤɲä¤ΡWINFO_WOBJwait.hˤ
!  *  ޤʲ(c)(e)Ԥɬפ롥Ʊ֥̿
!  *  Ȥ˴طʤԤʵԤַвԤˤξˤϡ(c)(e)
!  *  ɬפʤ
!  *
!  *  (c) TCBԤоݤƱ֥̿ȤԤ塼ˤĤʤ
!  *  塼ˤĤʤˡtask_queueȤ
!  *
!  *  (d) ԤоݤƱ֥̿Ȥδ֥åؤΥݥ󥿤
!  *  WINFO_WOBJp_wobjcb˵롥
!  *
!  *  (e) ԤоݤƱ֥̿Ȥ˰¸Ƶ뤳Ȥɬפ
!  *  󤬤ˤϡWINFO_WOBJɬפʾΤΥեɤɲ
!  *  ¤ΤWINFO_WOBJѤ롥
!  *
!  *  Ԥ֤ݤˤϡԤФͤWINFO
!  *  wercdꤹ롥wercdɬפʤΤԤʹߤǤΤФơ
!  *  p_tmevtbԤɬפʤᡤΤ˶ΤȤ
!  *  Ƥ롥Τᡤwercdإ顼ɤꤹΤϡ।٥
!  *  ֥åϿˤʤФʤʤ
   */
  typedef union waiting_information {
! 	ER		wercd;			/* ԤΥ顼 */
! 	TMEVTB	*p_tmevtb;		/* ԤѤΥ।٥ȥ֥å */
  } WINFO;
  
  /*
!  *  ֥å
   *
!  *  ˴ؤͤѤʤROM֤ʬʥ
!  *  ֥åˤȡͤѲ뤿RAM֤ʤФʤʤ
!  *  ʬʥ֥åTCBˤʬΥTCBб륿
!  *  ֥åؤݥ󥿤롥֥åб
!  *  TCBؤݥ󥿤ˡRAMδ˾ޤ
!  *  ¹ԸΨʤ뤿˺ѤƤʤ¾Υ֥ȤˤĤ
!  *  ƤƱͤ˰
   *
!  *  ֥åˤϡDEF_TEX륿㳰롼
!  *  ˴ؤޤࡥ
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* ° */
! 	intptr_t	exinf;			/* γĥ */
! 	TASK		task;			/* εư */
! 	uint_t		ipriority;		/* εưͥ١ɽ */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* ƥȥ֥å */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* åΰΥʴݤ᤿͡ */
! 	void		*stk;			/* åΰƬ */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* 㳰롼° */
! 	TEXRTN		texrtn;			/* 㳰롼εư */
  } TINIB;
  
  /*
!  *  TCBΥեɤΥӥå
   *
!  *  ץåˤäƤϡTCBΥեɤΥӥåǥ̤
!  *  ǽȥ졼ɥդˤʤ뤿ᡤåȰ¸˥եɤΥӥå
!  *  ѹ뤳ȤƤ롥
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityեɤΥӥå */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  ֥åTCB
   *
!  *  ASPͥǤϡεư׵ᥭ塼󥰿κ͡TMAX_ACTCNT
!  *  ȵ׵ᥭ塼󥰿κ͡TMAX_WUPCNTˤ1˸ꤵƤ
!  *  ᡤ塼󥰤Ƥ뤫ɤοͤɽ뤳ȤǤ롥
!  *  ޤԤ׵ͥȿκ͡TMAX_SUSCNTˤ1˸ꤵƤ
!  *  ΤǡԤ׵ͥȿsuscntˤɬפʤ
!  *
!  *  TCBΤĤΥեɤϡΥ֤ǤΤͭͤݻ
!  *  ʳξͤݾڤʤʤäơȤƤϤʤʤˡ
!  *  եɤͭͤݻϼ̤ꡥ
!  *
!  *  Ͼͭ
!  *  		p_tinibtstatactque
!  *  ٻ߾ְʳͭʵٻ߾֤ǤϽͤˤʤäƤˡ
!  *  		bpriorityprioritywupqueenatextexptnmutex_queue
!  *  Ԥ֡Ԥ֤ޤˤͭ
   *  		p_winfo
!  *  ¹ԤǤ֤Ʊ֥̿ȤФԤ֤ͭ
   *  		task_queue
!  *  ¹Բǽ֡Ԥ֡Ԥ֡Ԥ֤ͭ
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* 塼 */
! 	const TINIB		*p_tinib;		/* ֥åؤΥݥ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* ֡ɽ*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* ֡ɽ*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			bpriority;		/* ١ͥ١ɽ*/
! 	uint8_t			priority;		/* ߤͥ١ɽ*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	bpriority : TBIT_TCB_PRIORITY;
! 									/* ١ͥ١ɽ*/
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* ߤͥ١ɽ*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* ư׵ᥭ塼 */
! 	BIT_FIELD_BOOL	wupque : 1;		/* ׵ᥭ塼 */
! 	BIT_FIELD_BOOL	enatex : 1;		/* 㳰ľ */
! 
! 	TEXPTN			texptn;			/* α㳰װ */
! 	WINFO			*p_winfo;		/* Ԥ֥åؤΥݥ */
! 	QUEUE			mutex_queue;	/* åƤߥ塼ƥåΥ塼 */
! 	TSKCTXB			tskctxb;		/* ƥȥ֥å */
  } TCB;
  
  /*
!  *  ¹Ծ֤Υ
   *
!  *  ¹Ծ֤ΥʡץåƥȤäƤ륿ˤ
!  *  TCBؤݥ󥿡¹Ծ֤ΥʤNULLˤ롥
   *
!  *  ӥνǡʥӥƤӽФ
!  *  ˤ˴ؤ򻲾Ȥp_runtskȤp_runtsk񤭴
!  *  ΤϡǥѥåʤȽˤΤߤǤ롥
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   *
!  *  ¹ԤǤ륿Ǻǹ̤ͥΥTCBؤݥ󥿡
!  *  ԤǤ륿ʤNULLˤ롥
   *
!  *  ǥѥåػ߾֤ʤɡǥѥåαƤ֤p_runtsk
!  *  ȰפƤȤϸ¤ʤ
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   *
!  *  ߥϥɥ顿CPU㳰ϥɥνиˡǥѥåޤ
!  *  㳰롼εư׵᤹뤳Ȥ򼨤ե饰
   */
  extern bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   *
!  *  ͥ٥ޥ֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   *
!  *  ǥѥåػ߾֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   *
!  *  ͥ٥ޥ֤Ǥꡤǥѥåľ֤Ǥʥǥ
!  *  ѥåػ߾֤ǤʤˤȤ򼨤ե饰
   */
  extern bool_t	dspflg;
  
  /*
!  *  ǥ塼
   *
!  *  ǥ塼ϡ¹ԤǤ֤Υ뤿Υ塼Ǥ롥
!  *  ¹Ծ֤ΥƤ뤿ᡤǥʼ¹Բǽ˥塼Ȥ
!  *  ̾ΤΤǤϤʤǥ塼Ȥ̾Τ夷Ƥ뤿ᡤ
!  *  ̾ΤǸƤ֤Ȥˤ롥
   *
!  *  ǥ塼ϡͥ٤ȤΥ塼ǹƤ롥
!  *  TCBϡͥ٤Υ塼Ͽ롥
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   *
!  *  ǥ塼ΥΨ褯Ԥˡͥ٤ȤΥ塼
!  *  ˥äƤ뤫ɤ򼨤ӥåȥޥåפѰդƤ롥ӥ
!  *  ȥޥåפȤȤǡꥢβ򸺤餹ȤǤ뤬
!  *  ӥå̿᤬¤Ƥʤץåǡͥ٤ʳʤ
!  *  ˤϡӥåȥޥåΥСإåɤΤˡդ˸Ψ
!  *  ǽ⤢롥
   *
!  *  ͥ٤16ʳǤ뤳ȤꤷƤ뤿ᡤuint16_tȤƤ롥
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  ֥åΥꥢkernel_cfg.c
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  ơ֥kernel_cfg.c
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBΥꥢkernel_cfg.c
   */
  extern TCB	tcb_table[];
  
  /*
!  *  ο
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  IDTCBФΥޥ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCB饿IDФΥޥ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  ⥸塼ν
   */
  extern void	initialize_task(void);
  
  /*
!  *  ǹ̥ͥΥ
   *
!  *  ǥ塼κǹ̤ͥΥ򥵡TCBؤΥݥ
!  *  ֤ǥ塼ξˤϡδؿƤӽФƤϤʤʤ
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥ǥ塼
!  *  ͥ٤ǹ̤ͥΥͥ٤⤤ϡ
!  *  ǹ̤ͥΥ򹹿ǥѥåľ֤Ǥtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥p_tcbǻꤷ
!  *  ǹ̤ͥΥǤäˤϡǹ̤ͥΥ
!  *  ꤷʤǥѥåľ֤Ǥtrue֤Ǥʤ
!  *  false֤ξ֤Ϲʤ
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤Ȥ롥ޤεư
!  *  ˽٤ѿνȡưΤΥƥȤ
!  *  ꤹ롥
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤¹ԤǤ֤Ȥ롥
!  *  ¹ԤǤ֤ܤؤΥǥѥåɬפʾtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  ͥ٤ѹ
   *
!  *  p_tcbǻꤵ륿ͥ٤newpriɽˤѹ롥ޤ
!  *  ɬפʾˤϺǹ̤ͥΥ򹹿ǥѥåľ֤
!  *  true֤Ǥʤfalse֤
!  *
!  *  p_tcbǻꤵ륿̤ͥϡmtxmodefalseλƱͥ
!  *  ΥǺ㡤mtxmodetrueλƱͥ٤ΥǺǹ
!  *  Ȥ롥
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri, bool_t mtxmode);
  
  /*
!  *  ǥ塼βž
   *
!  *  ǥ塼Ρpriǻꤵͥ٤Υ塼ž롥
!  *  ޤɬפʾˤϺǹ̤ͥΥѹǥѥå
!  *  αƤʤtrue֤Ǥʤfalse֤
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  㳰롼θƽФ
   *
!  *  㳰롼ƤӽФƤӽФˡ¹Ծ֤Υ
!  *  α㳰װ򥯥ꥢ㳰ػ߾֤ˤCPUå
!  *  롥
!  *
!  *  㳰롼󤫤ȡޤCPUå֤ᤷδ
!  *  α㳰װ0ǤʤʤäƤСƤӥ㳰롼
!  *  ƤӽФα㳰װ0ξˤϡ㳰ľ֤ˤƴؿ
!  *  ꥿󤹤롥
!  *
!  *  δؿϡ¹Ծ֤Υ㳰ľ֡enatex
!  *  trueˤǡα㳰װ0Ǥʤtexptn0Ǥʤ˾˸ƤӽФ
!  *  ȤꤷƤ롥δؿϡCPUå֤ǸƤӽФʤФʤ
!  *  ʤ
   */
  extern void	call_texrtn(void);
  
  /*
!  *  㳰롼εư
   *
!  *  ¹Ծ֤Υ㳰롼εưƤС
!  *  㳰롼ƤӽФCPU㳰롼ƤӽФ
!  *  ϡŪCPUå롥
!  *
!  *  δؿϡǥѥåߥϥɥ顿CPU㳰ϥɥνи
!  *  ƤӽФ뤳ȤꤷƤ롥δؿϡCPUå
!  *  ǸƤӽФʤФʤʤ
   *
!  *  ¹ԸΨ夲뤿ˡδؿ򥿡åȰ¸ǵҤƤ褤
!  *  ξˤϡOMIT_CALLTEXޥ롥
   */
  extern void	calltex(void);
  
--- 127,489 ----
  #define TSTAT_WAIT_MTX(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_MTX)
  
  /*
!  *  待ち情報ブロック（WINFO）の定義
   *
!  *  タスクが待ち状態の間は，TCBおよびそのp_winfoで指されるWINFOを次の
!  *  ように設定しなければならない．
   *
!  *  (a) TCBのタスク状態を待ち状態（TS_WAITING）にする．その際に，待ち
!  *  要因（TS_WAIT_???）も設定する．
   *
!  *  (b) タイムアウトを監視するために，タイムイベントブロックを登録する．
!  *  登録するタイムイベントブロックは，待ちに入るサービスコール処理関数
!  *  のローカル変数として確保し，それへのポインタをWINFOのp_tmevtbに記
!  *  憶する．タイムアウトの監視が必要ない場合（永久待ちの場合）には，
!  *  p_tmevtbをNULLにする．
!  *
!  *  同期・通信オブジェクトに対する待ち状態の場合には，標準のWINFOに
!  *  p_wobjcbフィールドを追加した構造体（WINFO_WOBJ，wait.hで定義）を使
!  *  う．また，以下の(c)〜(e)の設定を行う必要がある．同期・通信オブジェ
!  *  クトに関係しない待ち（起床待ち，時間経過待ち）の場合には，(c)〜(e)
!  *  は必要ない．
!  *
!  *  (c) TCBを待ち対象の同期・通信オブジェクトの待ちキューにつなぐ．待
!  *  ちキューにつなぐために，task_queueを使う．
!  *
!  *  (d) 待ち対象の同期・通信オブジェクトの管理ブロックへのポインタを，
!  *  WINFO_WOBJのp_wobjcbに記憶する．
!  *
!  *  (e) 待ち対象の同期・通信オブジェクトに依存して記憶することが必要な
!  *  情報がある場合には，WINFO_WOBJに必要な情報のためのフィールドを追加
!  *  した構造体を定義し，WINFO_WOBJの代わりに用いる．
!  *
!  *  待ち状態を解除する際には，待ち解除したタスクに対する返値をWINFOの
!  *  wercdに設定する．wercdが必要なのは待ち解除以降であるのに対して，
!  *  p_tmevtbは待ち解除後は必要ないため，メモリ節約のために共用体を使っ
!  *  ている．そのため，wercdへエラーコードを設定するのは，タイムイベント
!  *  ブロックを登録解除した後にしなければならない．
   */
  typedef union waiting_information {
! 	ER		wercd;			/* 待ち解除時のエラーコード */
! 	TMEVTB	*p_tmevtb;		/* 待ち状態用のタイムイベントブロック */
  } WINFO;
  
  /*
!  *  タスク初期化ブロック
   *
!  *  タスクに関する情報を，値が変わらないためにROMに置ける部分（タスク
!  *  初期化ブロック）と，値が変化するためにRAMに置かなければならない部
!  *  分（タスク管理ブロック，TCB）に分離し，TCB内に対応するタスク初期化
!  *  ブロックを指すポインタを入れる．タスク初期化ブロック内に対応する
!  *  TCBを指すポインタを入れる方法の方が，RAMの節約の観点からは望ましい
!  *  が，実行効率が悪くなるために採用していない．他のオブジェクトについ
!  *  ても同様に扱う．
   *
!  *  タスク初期化ブロックには，DEF_TEXで定義されるタスク例外処理ルーチ
!  *  ンに関する情報も含む．
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* タスク属性 */
! 	intptr_t	exinf;			/* タスクの拡張情報 */
! 	TASK		task;			/* タスクの起動番地 */
! 	uint_t		ipriority;		/* タスクの起動時優先度（内部表現） */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* タスク初期化コンテキストブロック */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* スタック領域のサイズ（丸めた値） */
! 	void		*stk;			/* スタック領域の先頭番地 */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* タスク例外処理ルーチン属性 */
! 	TEXRTN		texrtn;			/* タスク例外処理ルーチンの起動番地 */
  } TINIB;
  
  /*
!  *  TCB中のフィールドのビット幅の定義
   *
!  *  プロセッサによっては，TCB中のフィールドのビット幅でメモリ使用量と
!  *  性能がトレードオフになるため，ターゲット依存にフィールドのビット幅
!  *  を変更することを許している．
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityフィールドのビット幅 */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  タスク管理ブロック（TCB）
   *
!  *  ASPカーネルでは，タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）
!  *  と起床要求キューイング数の最大値（TMAX_WUPCNT）は1に固定されている
!  *  ため，キューイングされているかどうかの真偽値で表現することができる．
!  *  また，強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が1に固定されてい
!  *  るので，強制待ち要求ネスト数（suscnt）は必要ない．
!  *
!  *  TCBのいくつかのフィールドは，特定のタスク状態でのみ有効な値を保持し，
!  *  それ以外の場合は値が保証されない（よって，参照してはならない）．各
!  *  フィールドが有効な値を保持する条件は次の通り．
!  *
!  *  ・初期化後は常に有効：
!  *  		p_tinib，tstat，actque
!  *  ・休止状態以外で有効（休止状態では初期値になっている）：
!  *  		bpriority，priority，wupque，enatex，texptn，mutex_queue
!  *  ・待ち状態（二重待ち状態を含む）で有効：
   *  		p_winfo
!  *  ・実行できる状態と同期・通信オブジェクトに対する待ち状態で有効：
   *  		task_queue
!  *  ・実行可能状態，待ち状態，強制待ち状態，二重待ち状態で有効：
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* タスクキュー */
! 	const TINIB		*p_tinib;		/* 初期化ブロックへのポインタ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* タスク状態（内部表現）*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* タスク状態（内部表現）*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			bpriority;		/* ベース優先度（内部表現）*/
! 	uint8_t			priority;		/* 現在の優先度（内部表現）*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	bpriority : TBIT_TCB_PRIORITY;
! 									/* ベース優先度（内部表現）*/
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* 現在の優先度（内部表現）*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* 起動要求キューイング */
! 	BIT_FIELD_BOOL	wupque : 1;		/* 起床要求キューイング */
! 	BIT_FIELD_BOOL	enatex : 1;		/* タスク例外処理許可状態 */
! 
! 	TEXPTN			texptn;			/* 保留例外要因 */
! 	WINFO			*p_winfo;		/* 待ち情報ブロックへのポインタ */
! 	QUEUE			mutex_queue;	/* ロックしているミューテックスのキュー */
! 	TSKCTXB			tskctxb;		/* タスクコンテキストブロック */
  } TCB;
  
  /*
!  *  実行状態のタスク
   *
!  *  実行状態のタスク（＝プロセッサがコンテキストを持っているタスク）の
!  *  TCBを指すポインタ．実行状態のタスクがない場合はNULLにする．
   *
!  *  サービスコールの処理中で，自タスク（サービスコールを呼び出したタス
!  *  ク）に関する情報を参照する場合はp_runtskを使う．p_runtskを書き換え
!  *  るのは，ディスパッチャ（と初期化処理）のみである．
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   *
!  *  実行できるタスクの中で最高優先順位のタスクのTCBを指すポインタ．実
!  *  行できるタスクがない場合はNULLにする．
   *
!  *  ディスパッチ禁止状態など，ディスパッチが保留されている間はp_runtsk
!  *  と一致しているとは限らない．
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ディスパッチ／タスク例外処理ルーチン起動要求フラグ
   *
!  *  割込みハンドラ／CPU例外ハンドラの出口処理に，ディスパッチまたは
!  *  タスク例外処理ルーチンの起動を要求することを示すフラグ．
   */
  extern bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   *
!  *  割込み優先度マスク全解除状態であることを示すフラグ．
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   *
!  *  ディスパッチ禁止状態であることを示すフラグ．
   */
  extern bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   *
!  *  割込み優先度マスク全解除状態であり，ディスパッチ許可状態である（ディ
!  *  スパッチ禁止状態でない）ことを示すフラグ．
   */
  extern bool_t	dspflg;
  
  /*
!  *  レディキュー
   *
!  *  レディキューは，実行できる状態のタスクを管理するためのキューである．
!  *  実行状態のタスクも管理しているため，レディ（実行可能）キューという
!  *  名称は正確ではないが，レディキューという名称が定着しているため，こ
!  *  の名称で呼ぶことにする．
   *
!  *  レディキューは，優先度ごとのタスクキューで構成されている．タスクの
!  *  TCBは，該当する優先度のキューに登録される．
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   *
!  *  レディキューのサーチを効率よく行うために，優先度ごとのタスクキュー
!  *  にタスクが入っているかどうかを示すビットマップを用意している．ビッ
!  *  トマップを使うことで，メモリアクセスの回数を減らすことができるが，
!  *  ビット操作命令が充実していないプロセッサで，優先度の段階数が少ない
!  *  場合には，ビットマップ操作のオーバーヘッドのために，逆に効率が落ち
!  *  る可能性もある．
   *
!  *  優先度が16段階であることを仮定しているため，uint16_t型としている．
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  タスクIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  タスク初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  タスク生成順序テーブル（kernel_cfg.c）
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBのエリア（kernel_cfg.c）
   */
  extern TCB	tcb_table[];
  
  /*
!  *  タスクの数
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  タスクIDからTCBを取り出すためのマクロ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCBからタスクIDを取り出すためのマクロ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  タスク管理モジュールの初期化
   */
  extern void	initialize_task(void);
  
  /*
!  *  最高優先順位タスクのサーチ
   *
!  *  レディキュー中の最高優先順位のタスクをサーチし，そのTCBへのポインタ
!  *  を返す．レディキューが空の場合には，この関数を呼び出してはならない．
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューに挿入する．レディキューに挿入
!  *  したタスクの優先度が，最高優先順位のタスクの優先度よりも高い場合は，
!  *  最高優先順位のタスクを更新し，ディスパッチ許可状態であればtrueを返
!  *  す．そうでない場合はfalseを返す．
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューから削除する．p_tcbで指定した
!  *  タスクが最高優先順位のタスクであった場合には，最高優先順位のタスク
!  *  を設定しなおし，ディスパッチ許可状態であればtrueを返す．そうでない
!  *  場合はfalseを返す．タスクの状態は更新しない．
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  休止状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態とする．また，タスクの起動
!  *  時に初期化すべき変数の初期化と，タスク起動のためのコンテキストを設
!  *  定する．
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  休止状態から実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態から実行できる状態とする．
!  *  実行できる状態に遷移したタスクへのディスパッチが必要な場合はtrue，
!  *  そうでない場合はfalseを返す．
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  タスクの優先度の変更
   *
!  *  p_tcbで指定されるタスクの優先度をnewpri（内部表現）に変更する．また，
!  *  必要な場合には最高優先順位のタスクを更新し，ディスパッチ許可状態で
!  *  あればtrueを返す．そうでない場合はfalseを返す．
!  *
!  *  p_tcbで指定されるタスクの優先順位は，mtxmodeがfalseの時は同じ優先度
!  *  のタスクの中で最低，mtxmodeがtrueの時は同じ優先度のタスクの中で最高
!  *  とする．
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri, bool_t mtxmode);
  
  /*
!  *  レディキューの回転
   *
!  *  レディキュー中の，priで指定される優先度のタスクキューを回転させる．
!  *  また，必要な場合には最高優先順位のタスクを変更し，ディスパッチが保
!  *  留されていなければtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  タスク例外処理ルーチンを呼び出す．呼び出す前に，実行状態のタスクの
!  *  保留例外要因をクリアし，タスク例外処理禁止状態にし，CPUロックを解
!  *  除する．
!  *
!  *  タスク例外処理ルーチンから戻ると，まずCPUロック状態に戻し，その間
!  *  に保留例外要因が0でなくなっていれば，再びタスク例外処理ルーチンを
!  *  呼び出す．保留例外要因が0の場合には，例外処理許可状態にして関数か
!  *  らリターンする．
!  *
!  *  この関数は，実行状態のタスクが，タスク例外処理許可状態（enatexが
!  *  true）で，保留例外要因が0でない（texptnが0でない）場合に呼び出すこ
!  *  とを想定している．この関数は，CPUロック状態で呼び出さなければなら
!  *  ない．
   */
  extern void	call_texrtn(void);
  
  /*
!  *  タスク例外処理ルーチンの起動
   *
!  *  実行状態のタスクがタスク例外処理ルーチンの起動条件を満たしていれば，
!  *  タスク例外処理ルーチンを呼び出す．CPU例外処理ルーチンを呼び出す時
!  *  は，一時的にCPUロックを解除する．
!  *
!  *  この関数は，ディスパッチャや割込みハンドラ／CPU例外ハンドラの出口
!  *  処理から呼び出されることを想定している．この関数は，CPUロック状態
!  *  で呼び出さなければならない．
   *
!  *  実行効率を上げるために，この関数をターゲット依存部で記述してもよい．
!  *  その場合には，OMIT_CALLTEXをマクロ定義する．
   */
  extern void	calltex(void);
  
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/task_manage.c ASPs/asp/extension/mutex/kernel/task_manage.c
*** 1.9.1/asp/extension/mutex/kernel/task_manage.c	Fri Dec 31 22:43:07 2010
--- ASPs/asp/extension/mutex/kernel/task_manage.c	Fri Dec  9 13:54:02 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: task_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: task_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		タスク管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "mutex.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
--- 51,57 ----
  #include "mutex.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
***************
*** 118,124 ****
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  εư
   */
  #ifdef TOPPERS_act_tsk
  
--- 118,124 ----
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  タスクの起動
   */
  #ifdef TOPPERS_act_tsk
  
***************
*** 157,163 ****
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  εư󥿥ƥѡ
   */
  #ifdef TOPPERS_iact_tsk
  
--- 157,163 ----
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  タスクの起動（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iact_tsk
  
***************
*** 196,202 ****
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  ư׵Υ󥻥
   */
  #ifdef TOPPERS_can_act
  
--- 196,202 ----
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  タスク起動要求のキャンセル
   */
  #ifdef TOPPERS_can_act
  
***************
*** 224,230 ****
  #endif /* TOPPERS_can_act */
  
  /*
!  *  νλ
   */
  #ifdef TOPPERS_ext_tsk
  
--- 224,230 ----
  #endif /* TOPPERS_can_act */
  
  /*
!  *  自タスクの終了
   */
  #ifdef TOPPERS_ext_tsk
  
***************
*** 238,246 ****
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUå֤ext_tskƤФ줿ϡCPUå
! 		 *  Ƥ饿λ롥ϡӥǤCPU
! 		 *  åάФ褤
  		 */
  	}
  	else {
--- 238,246 ----
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUロック状態でext_tskが呼ばれた場合は，CPUロックを解除し
! 		 *  てからタスクを終了する．実装上は，サービスコール内でのCPU
! 		 *  ロックを省略すればよいだけ．
  		 */
  	}
  	else {
***************
*** 248,263 ****
  	}
  	if (disdsp) {
  		/*
! 		 *  ǥѥåػ߾֤ext_tskƤФ줿ϡǥѥ
! 		 *  ľ֤ˤƤ饿λ롥
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  ͥ٥ޥIPMˤTIPM_ENAALLʳξ֤ext_tsk
! 		 *  ƤФ줿ϡIPMTIPM_ENAALLˤƤ饿λ
! 		 *  롥
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
--- 248,263 ----
  	}
  	if (disdsp) {
  		/*
! 		 *  ディスパッチ禁止状態でext_tskが呼ばれた場合は，ディスパッ
! 		 *  チ許可状態にしてからタスクを終了する．
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  割込み優先度マスク（IPM）がTIPM_ENAALL以外の状態でext_tsk
! 		 *  が呼ばれた場合は，IPMをTIPM_ENAALLにしてからタスクを終了す
! 		 *  る．
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
***************
*** 284,290 ****
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  ζλ
   */
  #ifdef TOPPERS_ter_tsk
  
--- 284,290 ----
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  タスクの強制終了
   */
  #ifdef TOPPERS_ter_tsk
  
***************
*** 308,316 ****
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbϼǤʤᡤʥ󥰥ץåǤϡ˼
! 			 *  Ծ֤Ǥʤmake_non_runnable(p_tcb)ǥǥѥ
! 			 *  ɬפˤʤ뤳ȤϤʤ
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
--- 308,316 ----
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbは自タスクでないため，（シングルプロセッサでは）実
! 			 *  行状態でなく，make_non_runnable(p_tcb)でタスクディスパッ
! 			 *  チが必要になることはない．
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
***************
*** 345,351 ****
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  Υ١ͥ٤ѹ
   */
  #ifdef TOPPERS_chg_pri
  
--- 345,351 ----
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  タスクのベース優先度の変更
   */
  #ifdef TOPPERS_chg_pri
  
***************
*** 393,399 ****
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  ͥ٤λ
   */
  #ifdef TOPPERS_get_pri
  
--- 393,399 ----
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  タスク優先度の参照
   */
  #ifdef TOPPERS_get_pri
  
***************
*** 426,432 ****
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  γĥλ
   */
  #ifdef TOPPERS_get_inf
  
--- 426,432 ----
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  自タスクの拡張情報の参照
   */
  #ifdef TOPPERS_get_inf
  
diff -cr --new-file 1.9.1/asp/extension/mutex/kernel/task_refer.c ASPs/asp/extension/mutex/kernel/task_refer.c
*** 1.9.1/asp/extension/mutex/kernel/task_refer.c	Sun May  6 19:40:32 2012
--- ASPs/asp/extension/mutex/kernel/task_refer.c	Fri Dec  9 13:54:02 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task_refer.c 2371 2012-05-06 10:40:31Z ertl-hiro $
   */
  
  /*
!  *		ξֻȵǽ
   */
  
  #include "kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task_refer.c 2371 2012-05-06 10:40:31Z ertl-hiro $
   */
  
  /*
!  *		タスクの状態参照機能
   */
  
  #include "kernel_impl.h"
***************
*** 56,62 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_REF_TSK_ENTER
  #define LOG_REF_TSK_ENTER(tskid, pk_rtsk)
--- 56,62 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_REF_TSK_ENTER
  #define LOG_REF_TSK_ENTER(tskid, pk_rtsk)
***************
*** 67,73 ****
  #endif /* LOG_REF_TSK_LEAVE */
  
  /*
!  *  ξֻ
   */
  #ifdef TOPPERS_ref_tsk
  
--- 67,73 ----
  #endif /* LOG_REF_TSK_LEAVE */
  
  /*
!  *  タスクの状態参照
   */
  #ifdef TOPPERS_ref_tsk
  
***************
*** 87,99 ****
  	tstat = p_tcb->tstat;
  	if (TSTAT_DORMANT(tstat)) {
  		/*
!  		 *  оݥٻ߾֤ξ
  		 */
  		pk_rtsk->tskstat = TTS_DMT;
  	}
  	else {
  		/*
!  		 *  ֤μФ
  		 */
  		if (TSTAT_SUSPENDED(tstat)) {
  			if (TSTAT_WAITING(tstat)) {
--- 87,99 ----
  	tstat = p_tcb->tstat;
  	if (TSTAT_DORMANT(tstat)) {
  		/*
!  		 *  対象タスクが休止状態の場合
  		 */
  		pk_rtsk->tskstat = TTS_DMT;
  	}
  	else {
  		/*
!  		 *  タスク状態の取出し
  		 */
  		if (TSTAT_SUSPENDED(tstat)) {
  			if (TSTAT_WAITING(tstat)) {
***************
*** 114,127 ****
  		}
  
  		/*
!  		 *  ͥ٤ȥ١ͥ٤μФ
  		 */
  		pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
  		pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->bpriority);
  
  		if (TSTAT_WAITING(tstat)) {
  			/*
! 	 		 *  ԤװԤоݤΥ֥ȤIDμФ
  			 */
  			switch (tstat & TS_WAIT_MASK) {
  			case TS_WAIT_SLP:
--- 114,127 ----
  		}
  
  		/*
!  		 *  現在優先度とベース優先度の取出し
  		 */
  		pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
  		pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->bpriority);
  
  		if (TSTAT_WAITING(tstat)) {
  			/*
! 	 		 *  待ち要因と待ち対象のオブジェクトのIDの取出し
  			 */
  			switch (tstat & TS_WAIT_MASK) {
  			case TS_WAIT_SLP:
***************
*** 178,184 ****
  			}
  
  			/*
! 	 		 *  ॢȤޤǤλ֤μФ
  			 */
  			if (p_tcb->p_winfo->p_tmevtb != NULL) {
  				pk_rtsk->lefttmo
--- 178,184 ----
  			}
  
  			/*
! 	 		 *  タイムアウトするまでの時間の取出し
  			 */
  			if (p_tcb->p_winfo->p_tmevtb != NULL) {
  				pk_rtsk->lefttmo
***************
*** 190,202 ****
  		}
  
  		/*
!  		 *  ׵ᥭ塼󥰿μФ
  		 */
  		pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
  	}
  
  	/*
! 	 *  ư׵ᥭ塼󥰿μФ
  	 */
  	pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
  	ercd = E_OK;
--- 190,202 ----
  		}
  
  		/*
!  		 *  起床要求キューイング数の取出し
  		 */
  		pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
  	}
  
  	/*
! 	 *  起動要求キューイング数の取出し
  	 */
  	pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
  	ercd = E_OK;
diff -cr --new-file 1.9.1/asp/extension/mutex/test/bit_kernel.c ASPs/asp/extension/mutex/test/bit_kernel.c
*** 1.9.1/asp/extension/mutex/test/bit_kernel.c	Sun Jun 26 12:35:55 2011
--- ASPs/asp/extension/mutex/test/bit_kernel.c	Fri Dec  9 13:54:02 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: bit_kernel.c 2136 2011-06-26 03:35:48Z ertl-hiro $
   */
  
  /*
!  *		ͥ
   */
  
  #include "kernel/kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: bit_kernel.c 2136 2011-06-26 03:35:48Z ertl-hiro $
   */
  
  /*
!  *		カーネルの整合性検査
   */
  
  #include "kernel/kernel_impl.h"
***************
*** 55,66 ****
  #include "kernel/time_event.h"
  
  /*
!  *   顼ɤ
   */
  #define E_SYS_LINENO	ERCD(E_SYS, -(__LINE__))
  
  /*
!  *  ֥åΥɥ쥹Υå
   */
  #define VALID_TCB(p_tcb) \
  		((((char *) p_tcb) - ((char *) tcb_table)) % sizeof(TCB) == 0 \
--- 55,66 ----
  #include "kernel/time_event.h"
  
  /*
!  *   エラーコードの定義
   */
  #define E_SYS_LINENO	ERCD(E_SYS, -(__LINE__))
  
  /*
!  *  管理ブロックのアドレスの正当性のチェック
   */
  #define VALID_TCB(p_tcb) \
  		((((char *) p_tcb) - ((char *) tcb_table)) % sizeof(TCB) == 0 \
***************
*** 95,105 ****
  			&& TMIN_MPFID <= MPFID(p_mpfcb) && MPFID(p_mpfcb) <= tmax_mpfid)
  
  /*
!  *  塼ΥåΤδؿ
   *
!  *  p_queuep_entryޤޤƤ뤫Ĵ٤롥ޤޤƤtrueޤ
!  *  Ƥʤˤfalse֤֥󥯤ξˤ⡤
!  *  false֤
   */
  static bool_t
  in_queue(QUEUE *p_queue, QUEUE *p_entry)
--- 95,105 ----
  			&& TMIN_MPFID <= MPFID(p_mpfcb) && MPFID(p_mpfcb) <= tmax_mpfid)
  
  /*
!  *  キューのチェックのための関数
   *
!  *  p_queueにp_entryが含まれているかを調べる．含まれていればtrue，含ま
!  *  れていない場合にはfalseを返す．ダブルリンクの不整合の場合にも，
!  *  falseを返す．
   */
  static bool_t
  in_queue(QUEUE *p_queue, QUEUE *p_entry)
***************
*** 108,126 ****
  
  	p_current = p_queue->p_next;
  	if (p_current->p_prev != p_queue) {
! 		return(false);					/* ֥󥯤 */
  	}
  	while (p_current != p_queue) {
  		if (p_current == p_entry) {
! 			return(true);				/* p_entryޤޤƤ */
  		}
  
  		/*
! 		 *  塼μǤ˿ʤ
  		 */
  		p_next = p_current->p_next;
  		if (p_next->p_prev != p_current) {
! 			return(false);				 /* ֥󥯤 */
  		}
  		p_current = p_next;
  	}
--- 108,126 ----
  
  	p_current = p_queue->p_next;
  	if (p_current->p_prev != p_queue) {
! 		return(false);					/* ダブルリンクの不整合 */
  	}
  	while (p_current != p_queue) {
  		if (p_current == p_entry) {
! 			return(true);				/* p_entryが含まれていた */
  		}
  
  		/*
! 		 *  キューの次の要素に進む
  		 */
  		p_next = p_current->p_next;
  		if (p_next->p_prev != p_current) {
! 			return(false);				 /* ダブルリンクの不整合 */
  		}
  		p_current = p_next;
  	}
***************
*** 128,134 ****
  }
  
  /*
!  *  åؤƤ뤫θ
   */
  static bool_t
  on_stack(void *addr, const TINIB *p_tinib)
--- 128,134 ----
  }
  
  /*
!  *  スタック上を指しているかの検査
   */
  static bool_t
  on_stack(void *addr, const TINIB *p_tinib)
***************
*** 141,147 ****
  }
  
  /*
!  *  
   */
  static ER
  bit_task(ID tskid)
--- 141,147 ----
  }
  
  /*
!  *  タスク毎の整合性検査
   */
  static ER
  bit_task(ID tskid)
***************
*** 168,181 ****
  	pri = p_tcb->priority;
  
  	/*
! 	 *  ֥åؤΥݥ󥿤θ
  	 */
  	if (p_tinib != &(tinib_table[INDEX_TSK(tskid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  tstatθ
  	 */
  	switch (tstat & (TS_RUNNABLE | TS_WAITING | TS_SUSPENDED)) {
  	case TS_DORMANT:
--- 168,181 ----
  	pri = p_tcb->priority;
  
  	/*
! 	 *  初期化ブロックへのポインタの検査
  	 */
  	if (p_tinib != &(tinib_table[INDEX_TSK(tskid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  tstatの検査
  	 */
  	switch (tstat & (TS_RUNNABLE | TS_WAITING | TS_SUSPENDED)) {
  	case TS_DORMANT:
***************
*** 208,235 ****
  	}
  
  	/*
! 	 *  actqueθ
  	 */
  	if (TSTAT_DORMANT(tstat) && p_tcb->actque) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  ͥ٤θ
  	 */
  	if (pri >= TNUM_TPRI) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  texptnθ
  	 */
  	if (p_tcb->p_tinib->texrtn == NULL && p_tcb->texptn != 0U) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  ٻ߾֤ˤå
  	 */
  	if (TSTAT_DORMANT(tstat)) {
  		if (!(pri == p_tinib->ipriority)
--- 208,235 ----
  	}
  
  	/*
! 	 *  actqueの検査
  	 */
  	if (TSTAT_DORMANT(tstat) && p_tcb->actque) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  タスク優先度の検査
  	 */
  	if (pri >= TNUM_TPRI) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  texptnの検査
  	 */
  	if (p_tcb->p_tinib->texrtn == NULL && p_tcb->texptn != 0U) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  休止状態におけるチェック
  	 */
  	if (TSTAT_DORMANT(tstat)) {
  		if (!(pri == p_tinib->ipriority)
***************
*** 241,247 ****
  	}
  
  	/*
! 	 *  ¹ԤǤ֤ˤå
  	 */
  	if (TSTAT_RUNNABLE(tstat)) {
  		if (!in_queue(&ready_queue[pri], &(p_tcb->task_queue))) {
--- 241,247 ----
  	}
  
  	/*
! 	 *  実行できる状態におけるチェック
  	 */
  	if (TSTAT_RUNNABLE(tstat)) {
  		if (!in_queue(&ready_queue[pri], &(p_tcb->task_queue))) {
***************
*** 250,256 ****
  	}
  
  	/*
! 	 *  Ԥ֤ˤå
  	 */
  	if (TSTAT_WAITING(tstat)) {
  		if (!on_stack(p_tcb->p_winfo, p_tinib)) {
--- 250,256 ----
  	}
  
  	/*
! 	 *  待ち状態におけるチェック
  	 */
  	if (TSTAT_WAITING(tstat)) {
  		if (!on_stack(p_tcb->p_winfo, p_tinib)) {
***************
*** 262,268 ****
  				return(E_SYS_LINENO);
  			}
  			/*
! 			 *  (*p_tmevtb)θ̤
  			 */
  		}
  
--- 262,268 ----
  				return(E_SYS_LINENO);
  			}
  			/*
! 			 *  (*p_tmevtb)の検査（未完成）
  			 */
  		}
  
***************
*** 372,382 ****
  	}
  
  	/*
! 	 *  tskctxbθ
  	 */
  	if (!TSTAT_DORMANT(tstat) && p_tcb != p_runtsk) {
  		/*
! 		 *  åȰ¸θ
  		 */
  #if 0
  		if (bit_tskctxb(&(p_tcb->tskctxb))) {
--- 372,382 ----
  	}
  
  	/*
! 	 *  tskctxbの検査
  	 */
  	if (!TSTAT_DORMANT(tstat) && p_tcb != p_runtsk) {
  		/*
! 		 *  ターゲット依存の検査
  		 */
  #if 0
  		if (bit_tskctxb(&(p_tcb->tskctxb))) {
***************
*** 388,394 ****
  }
  
  /*
!  *  ޥե
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
--- 388,394 ----
  }
  
  /*
!  *  セマフォ毎の整合性検査
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
***************
*** 410,430 ****
  	semcnt = p_semcb->semcnt;
  
  	/*
! 	 *  ֥åؤΥݥ󥿤θ
  	 */
  	if (p_seminib != &(seminib_table[INDEX_SEM(semid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  semcntθ
  	 */
  	if (semcnt > p_seminib->maxsem) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  wait_queueθ
  	 */
  	if (semcnt == 0) {
  		p_queue = p_semcb->wait_queue.p_next;
--- 410,430 ----
  	semcnt = p_semcb->semcnt;
  
  	/*
! 	 *  初期化ブロックへのポインタの検査
  	 */
  	if (p_seminib != &(seminib_table[INDEX_SEM(semid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  semcntの検査
  	 */
  	if (semcnt > p_seminib->maxsem) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  wait_queueの検査
  	 */
  	if (semcnt == 0) {
  		p_queue = p_semcb->wait_queue.p_next;
***************
*** 451,457 ****
  }
  
  /*
!  *  롼
   */
  ER
  bit_kernel(void)
--- 451,457 ----
  }
  
  /*
!  *  整合性検査ルーチン本体
   */
  ER
  bit_kernel(void)
***************
*** 461,467 ****
  	ER		ercd;
  
  	/*
! 	 *  θ
  	 */
  	for (tskid = TMIN_TSKID; tskid <= tmax_tskid; tskid++) {
  		ercd = bit_task(tskid);
--- 461,467 ----
  	ER		ercd;
  
  	/*
! 	 *  タスク毎の検査
  	 */
  	for (tskid = TMIN_TSKID; tskid <= tmax_tskid; tskid++) {
  		ercd = bit_task(tskid);
***************
*** 471,477 ****
  	}
  
  	/*
! 	 *  ޥեθ
  	 */
  	for (semid = TMIN_SEMID; semid <= tmax_semid; semid++) {
  		ercd = bit_semaphore(semid);
--- 471,477 ----
  	}
  
  	/*
! 	 *  セマフォ毎の検査
  	 */
  	for (semid = TMIN_SEMID; semid <= tmax_semid; semid++) {
  		ercd = bit_semaphore(semid);
diff -cr --new-file 1.9.1/asp/extension/mutex/test/bit_mutex.c ASPs/asp/extension/mutex/test/bit_mutex.c
*** 1.9.1/asp/extension/mutex/test/bit_mutex.c	Sun Jun 26 12:35:55 2011
--- ASPs/asp/extension/mutex/test/bit_mutex.c	Fri Dec  9 13:54:02 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: bit_mutex.c 2136 2011-06-26 03:35:48Z ertl-hiro $
   */
  
  /*
!  *		ߥ塼ƥåǽ
   */
  
  #include "kernel/kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: bit_mutex.c 2136 2011-06-26 03:35:48Z ertl-hiro $
   */
  
  /*
!  *		ミューテックス機能の整合性検査
   */
  
  #include "kernel/kernel_impl.h"
***************
*** 47,79 ****
  #include "kernel/mutex.h"
  
  /*
!  *  ߥ塼ƥåIDߥ塼ƥå֥åФΥޥ
!  *  mutex.c
   */
  #define INDEX_MTX(mtxid)	((uint_t)((mtxid) - TMIN_MTXID))
  #define get_mtxcb(mtxid)	(&(mtxcb_table[INDEX_MTX(mtxid)]))
  
  /*
!  *  ߥ塼ƥå֥åmutex_queueؤΥݥ󥿤顤ߥ塼ƥ
!  *  ֥åؤΥݥ󥿤ФΥޥmutex.c
   */
  #define MTXCB_QUEUE(p_queue) \
  			((MTXCB *)(((char *) p_queue) - offsetof(MTXCB, mutex_queue)))
  
  /*
!  *  ߥ塼ƥåΥץȥȽǤޥmutex.c
   */
  #define MTXPROTO_MASK			0x03U
  #define MTXPROTO(p_mtxcb)		((p_mtxcb)->p_mtxinib->mtxatr & MTXPROTO_MASK)
  #define MTX_CEILING(p_mtxcb)	(MTXPROTO(p_mtxcb) == TA_CEILING)
  
  /*
!  *   顼ɤ
   */
  #define E_SYS_LINENO	ERCD(E_SYS, -(__LINE__))
  
  /*
!  *  ֥åΥɥ쥹Υå
   */
  #define VALID_TCB(p_tcb) \
  		((((char *) p_tcb) - ((char *) tcb_table)) % sizeof(TCB) == 0 \
--- 47,79 ----
  #include "kernel/mutex.h"
  
  /*
!  *  ミューテックスIDからミューテックス管理ブロックを取り出すためのマク
!  *  ロ（mutex.cより）
   */
  #define INDEX_MTX(mtxid)	((uint_t)((mtxid) - TMIN_MTXID))
  #define get_mtxcb(mtxid)	(&(mtxcb_table[INDEX_MTX(mtxid)]))
  
  /*
!  *  ミューテックス管理ブロック中のmutex_queueへのポインタから，ミューテッ
!  *  クス管理ブロックへのポインタを取り出すためのマクロ（mutex.cより）
   */
  #define MTXCB_QUEUE(p_queue) \
  			((MTXCB *)(((char *) p_queue) - offsetof(MTXCB, mutex_queue)))
  
  /*
!  *  ミューテックスのプロトコルを判断するマクロ（mutex.cより）
   */
  #define MTXPROTO_MASK			0x03U
  #define MTXPROTO(p_mtxcb)		((p_mtxcb)->p_mtxinib->mtxatr & MTXPROTO_MASK)
  #define MTX_CEILING(p_mtxcb)	(MTXPROTO(p_mtxcb) == TA_CEILING)
  
  /*
!  *   エラーコードの定義
   */
  #define E_SYS_LINENO	ERCD(E_SYS, -(__LINE__))
  
  /*
!  *  管理ブロックのアドレスの正当性のチェック
   */
  #define VALID_TCB(p_tcb) \
  		((((char *) p_tcb) - ((char *) tcb_table)) % sizeof(TCB) == 0 \
***************
*** 84,94 ****
  			&& TMIN_MTXID <= MTXID(p_mtxcb) && MTXID(p_mtxcb) <= tmax_mtxid)
  				
  /*
!  *  塼ΥåΤδؿ
   *
!  *  p_queuep_entryޤޤƤ뤫Ĵ٤롥ޤޤƤtrueޤ
!  *  Ƥʤˤfalse֤֥󥯤ξˤ⡤
!  *  false֤
   */
  static bool_t
  in_queue(QUEUE *p_queue, QUEUE *p_entry)
--- 84,94 ----
  			&& TMIN_MTXID <= MTXID(p_mtxcb) && MTXID(p_mtxcb) <= tmax_mtxid)
  				
  /*
!  *  キューのチェックのための関数
   *
!  *  p_queueにp_entryが含まれているかを調べる．含まれていればtrue，含ま
!  *  れていない場合にはfalseを返す．ダブルリンクの不整合の場合にも，
!  *  falseを返す．
   */
  static bool_t
  in_queue(QUEUE *p_queue, QUEUE *p_entry)
***************
*** 97,115 ****
  
  	p_current = p_queue->p_next;
  	if (p_current->p_prev != p_queue) {
! 		return(false);					/* ֥󥯤 */
  	}
  	while (p_current != p_queue) {
  		if (p_current == p_entry) {
! 			return(true);				/* p_entryޤޤƤ */
  		}
  
  		/*
! 		 *  塼μǤ˿ʤ
  		 */
  		p_next = p_current->p_next;
  		if (p_next->p_prev != p_current) {
! 			return(false);				 /* ֥󥯤 */
  		}
  		p_current = p_next;
  	}
--- 97,115 ----
  
  	p_current = p_queue->p_next;
  	if (p_current->p_prev != p_queue) {
! 		return(false);					/* ダブルリンクの不整合 */
  	}
  	while (p_current != p_queue) {
  		if (p_current == p_entry) {
! 			return(true);				/* p_entryが含まれていた */
  		}
  
  		/*
! 		 *  キューの次の要素に進む
  		 */
  		p_next = p_current->p_next;
  		if (p_next->p_prev != p_current) {
! 			return(false);				 /* ダブルリンクの不整合 */
  		}
  		p_current = p_next;
  	}
***************
*** 117,123 ****
  }
  
  /*
!  *  θ
   */
  static ER
  bit_mutex_task(ID tskid)
--- 117,123 ----
  }
  
  /*
!  *  タスク毎の検査
   */
  static ER
  bit_mutex_task(ID tskid)
***************
*** 134,140 ****
  	pri = p_tcb->bpriority;
  
  	/*
! 	 *  åƤߥ塼ƥåΥ塼θ
  	 */
  	p_queue = p_tcb->mutex_queue.p_next;
  	if (p_queue->p_prev != &(p_tcb->mutex_queue)) {
--- 134,140 ----
  	pri = p_tcb->bpriority;
  
  	/*
! 	 *  タスクがロックしているミューテックスのキューの検査
  	 */
  	p_queue = p_tcb->mutex_queue.p_next;
  	if (p_queue->p_prev != &(p_tcb->mutex_queue)) {
***************
*** 147,160 ****
  		}
  
  		/*
! 		 *  ߥ塼ƥååƤ륿Υå
  		 */
  		if (p_mtxcb->p_loctsk != p_tcb) {
  			return(E_SYS_LINENO);
  		}
  
  		/*
! 		 *  ͥ٤η׻
  		 */
  		if (MTXPROTO(p_mtxcb)) {
  			if (p_mtxcb->p_mtxinib->ceilpri < pri) {
--- 147,160 ----
  		}
  
  		/*
! 		 *  ミューテックスをロックしているタスクのチェック
  		 */
  		if (p_mtxcb->p_loctsk != p_tcb) {
  			return(E_SYS_LINENO);
  		}
  
  		/*
! 		 *  現在優先度の計算
  		 */
  		if (MTXPROTO(p_mtxcb)) {
  			if (p_mtxcb->p_mtxinib->ceilpri < pri) {
***************
*** 163,169 ****
  		}
  
  		/*
! 		 *  塼μǤ˿ʤ
  		 */
  		p_next = p_queue->p_next;
  		if (p_next->p_prev != p_queue) {
--- 163,169 ----
  		}
  
  		/*
! 		 *  キューの次の要素に進む
  		 */
  		p_next = p_queue->p_next;
  		if (p_next->p_prev != p_queue) {
***************
*** 173,186 ****
  	}
  
  	/*
! 	 *  ͥ٤θ
  	 */
  	if (p_tcb->priority != pri) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  ԤäƤߥ塼ƥå˴ؤ븡
  	 */
  	if (TSTAT_WAIT_MTX(p_tcb->tstat)) {
  		p_mtxcb = ((WINFO_MTX *)(p_tcb->p_winfo))->p_mtxcb;
--- 173,186 ----
  	}
  
  	/*
! 	 *  現在優先度の検査
  	 */
  	if (p_tcb->priority != pri) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  タスクが待っているミューテックスに関する検査
  	 */
  	if (TSTAT_WAIT_MTX(p_tcb->tstat)) {
  		p_mtxcb = ((WINFO_MTX *)(p_tcb->p_winfo))->p_mtxcb;
***************
*** 195,201 ****
  }
  
  /*
!  *  ߥ塼ƥåθ
   */
  static ER
  bit_mutex_mutex(ID mtxid)
--- 195,201 ----
  }
  
  /*
!  *  ミューテックス毎の検査
   */
  static ER
  bit_mutex_mutex(ID mtxid)
***************
*** 211,224 ****
  	p_mtxcb = get_mtxcb(mtxid);
  
  	/*
! 	 *  ֥åؤΥݥ󥿤θ
  	 */
  	if (p_mtxcb->p_mtxinib != &(mtxinib_table[INDEX_MTX(mtxid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  ߥ塼ƥåԤ塼θ
  	 */
  	p_queue = p_mtxcb->wait_queue.p_next;
  	if (p_queue->p_prev != &(p_mtxcb->wait_queue)) {
--- 211,224 ----
  	p_mtxcb = get_mtxcb(mtxid);
  
  	/*
! 	 *  初期化ブロックへのポインタの検査
  	 */
  	if (p_mtxcb->p_mtxinib != &(mtxinib_table[INDEX_MTX(mtxid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  ミューテックス待ちキューの検査
  	 */
  	p_queue = p_mtxcb->wait_queue.p_next;
  	if (p_queue->p_prev != &(p_mtxcb->wait_queue)) {
***************
*** 232,238 ****
  		}
  
  		/*
! 		 *  塼ͥٽˤʤäƤ뤫θ
  		 */
  		if (MTXPROTO(p_mtxcb) != TA_NULL) {
  			if (p_tcb->priority < pri) {
--- 232,238 ----
  		}
  
  		/*
! 		 *  キューがタスク優先度順になっているかの検査
  		 */
  		if (MTXPROTO(p_mtxcb) != TA_NULL) {
  			if (p_tcb->priority < pri) {
***************
*** 242,258 ****
  		pri = p_tcb->priority;
  
  		/*
! 		 *  ֤θ
  		 *
! 		 *  ߥ塼ƥåԤ֤ΥθϡθǹԤ
! 		 *  Ƥ뤿ᡤǤϹԤʤ
  		 */
  		if (!TSTAT_WAIT_MTX(p_tcb->tstat)) {
  			return(E_SYS_LINENO);
  		}
  
  		/*
! 		 *  ͥپ¤θ
  		 */
  		if (MTXPROTO(p_mtxcb) == TA_CEILING) {
  			if (p_tcb->bpriority < p_mtxcb->p_mtxinib->ceilpri) {
--- 242,258 ----
  		pri = p_tcb->priority;
  
  		/*
! 		 *  タスク状態の検査
  		 *
! 		 *  ミューテックス待ち状態のタスクの検査は，タスク毎の検査で行っ
! 		 *  ているため，ここでは行わない．
  		 */
  		if (!TSTAT_WAIT_MTX(p_tcb->tstat)) {
  			return(E_SYS_LINENO);
  		}
  
  		/*
! 		 *  優先度上限の検査
  		 */
  		if (MTXPROTO(p_mtxcb) == TA_CEILING) {
  			if (p_tcb->bpriority < p_mtxcb->p_mtxinib->ceilpri) {
***************
*** 261,267 ****
  		}
  
  		/*
! 		 *  塼μǤ˿ʤ
  		 */
  		p_next = p_queue->p_next;
  		if (p_next->p_prev != p_queue) {
--- 261,267 ----
  		}
  
  		/*
! 		 *  キューの次の要素に進む
  		 */
  		p_next = p_queue->p_next;
  		if (p_next->p_prev != p_queue) {
***************
*** 271,282 ****
  	}
  
  	/*
! 	 *  ߥ塼ƥååƤ륿θ
  	 */
  	p_tcb = p_mtxcb->p_loctsk;
  	if (p_tcb == NULL) {
  		/*
! 		 *  ߥ塼ƥååƤʤ
  		 */
  		if (!queue_empty(&(p_mtxcb->wait_queue))) {
  			return(E_SYS_LINENO);
--- 271,282 ----
  	}
  
  	/*
! 	 *  ミューテックスをロックしているタスクの検査
  	 */
  	p_tcb = p_mtxcb->p_loctsk;
  	if (p_tcb == NULL) {
  		/*
! 		 *  ミューテックスがロックされていない時
  		 */
  		if (!queue_empty(&(p_mtxcb->wait_queue))) {
  			return(E_SYS_LINENO);
***************
*** 284,293 ****
  	}
  	else {
  		/*
! 		 *  ߥ塼ƥååƤ
  		 *
! 		 *  ߥ塼ƥååƤ륿θϡθ
! 		 *  ǹԤäƤ뤿ᡤǤϹԤʤ
  		 */
  		if (!VALID_TCB(p_tcb)) {
  			return(E_SYS_LINENO);
--- 284,293 ----
  	}
  	else {
  		/*
! 		 *  ミューテックスがロックされている時
  		 *
! 		 *  ミューテックスをロックしているタスクの検査は，タスク毎の検
! 		 *  査で行っているため，ここでは行わない．
  		 */
  		if (!VALID_TCB(p_tcb)) {
  			return(E_SYS_LINENO);
***************
*** 297,303 ****
  		}
  
  		/*
! 		 *  ͥپ¤θ
  		 */
  		if (MTXPROTO(p_mtxcb) == TA_CEILING) {
  			if (p_tcb->bpriority < p_mtxcb->p_mtxinib->ceilpri) {
--- 297,303 ----
  		}
  
  		/*
! 		 *  優先度上限の検査
  		 */
  		if (MTXPROTO(p_mtxcb) == TA_CEILING) {
  			if (p_tcb->bpriority < p_mtxcb->p_mtxinib->ceilpri) {
***************
*** 309,315 ****
  }
  
  /*
!  *  롼
   */
  ER
  bit_mutex(void)
--- 309,315 ----
  }
  
  /*
!  *  整合性検査ルーチン本体
   */
  ER
  bit_mutex(void)
***************
*** 318,324 ****
  	ER		ercd;
  
  	/*
! 	 *  θ
  	 */
  	for (tskid = TMIN_TSKID; tskid <= tmax_tskid; tskid++) {
  		ercd = bit_mutex_task(tskid);
--- 318,324 ----
  	ER		ercd;
  
  	/*
! 	 *  タスク毎の検査
  	 */
  	for (tskid = TMIN_TSKID; tskid <= tmax_tskid; tskid++) {
  		ercd = bit_mutex_task(tskid);
***************
*** 328,334 ****
  	}
  
  	/*
! 	 *  ߥ塼ƥåθ
  	 */
  	for (mtxid = TMIN_MTXID; mtxid <= tmax_mtxid; mtxid++) {
  		ercd = bit_mutex_mutex(mtxid);
--- 328,334 ----
  	}
  
  	/*
! 	 *  ミューテックス毎の検査
  	 */
  	for (mtxid = TMIN_MTXID; mtxid <= tmax_mtxid; mtxid++) {
  		ercd = bit_mutex_mutex(mtxid);
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex.h ASPs/asp/extension/mutex/test/test_mutex.h
*** 1.9.1/asp/extension/mutex/test/test_mutex.h	Sat Apr 12 10:31:23 2008
--- ASPs/asp/extension/mutex/test/test_mutex.h	Fri Dec  9 13:54:02 2022
***************
*** 5,67 ****
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_mutex.h 495 2007-08-20 02:39:10Z hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(1)(3)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_mutex.h 495 2007-08-20 02:39:10Z hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(1)〜(3)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex1.c ASPs/asp/extension/mutex/test/test_mutex1.c
*** 1.9.1/asp/extension/mutex/test/test_mutex1.c	Sun Aug 17 22:09:31 2014
--- ASPs/asp/extension/mutex/test/test_mutex1.c	Fri Dec  9 13:54:02 2022
***************
*** 5,80 ****
   *  Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_mutex1.c 2656 2014-08-17 13:09:30Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(1)
   *
!  * ڥƥȤŪ
   *
!  *  FIFOߥ塼ƥå򡤥åȥå̤
!  *  ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) ߥ塼ƥåΥåloc_mtx
!  *		(A-1) åƤʤˤϡ˥åǤ뤳
!  *		(A-2) ¿Ť˥å褦ȤȡE_OBJ顼ˤʤ뤳
!  *		(A-3) åƤˤϡFIFOԤ֤ˤʤ뤳
!  *	(B) ߥ塼ƥåΥåunl_mtx
!  *		(B-1) ¾åƤߥ塼ƥå褦Ȥ
!  *		E_OBJ顼ˤʤ뤳
!  *		(B-2) Ԥʤȡñ˥å뤳
!  *		(B-3) Ԥ˥åϤ
!  *		(B-4) Ԥ˥åϤơǥѥå뤳
!  *	(C) ߥ塼ƥåΥåploc_mtx
!  *		(C-1) åƤˤϡE_TMOUT顼ˤʤ뤳
!  *	(D) ߥ塼ƥåΥåtloc_mtx
!  *		(D-1) åƤˤϡॢդԤ֤ˤ
!  *		뤳
!  *	(E) ޤ
!  *		(E-1) λȡߥ塼ƥåå뤳
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	MTX1: ߥ塼ƥåTA_NULL°
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_mutex))
   *	1:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
--- 5,80 ----
   *  Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_mutex1.c 2656 2014-08-17 13:09:30Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(1)
   *
!  * 【テストの目的】
   *
!  *  FIFO順ミューテックスを，ロックする処理とロック解除する処理を一通り
!  *  テストする．
   *
!  * 【テスト項目】
   *
!  *	(A) ミューテックスのロック処理（loc_mtx）
!  *		(A-1) ロックされていない場合には，すぐにロックできること
!  *		(A-2) 多重にロックしようとすると，E_OBJエラーになること
!  *		(A-3) ロックされている場合には，FIFO順で待ち状態になること
!  *	(B) ミューテックスのロック解除処理（unl_mtx）
!  *		(B-1) 他タスクがロックしているミューテックスを解放しようとすると
!  *		　　　E_OBJエラーになること
!  *		(B-2) 待ちタスクがないと，単にロック解除すること
!  *		(B-3) 待ちタスクにロックを渡すこと
!  *		(B-4) 待ちタスクにロックを渡して，ディスパッチが起こること
!  *	(C) ミューテックスのロック処理（ploc_mtx）
!  *		(C-1) ロックされている場合には，すぐにE_TMOUTエラーになること
!  *	(D) ミューテックスのロック処理（tloc_mtx）
!  *		(D-1) ロックされている場合には，タイムアウト付きの待ち状態にな
!  *		　　　ること
!  *	(E) おまけ
!  *		(E-1) タスクを終了すると，ミューテックスをロック解除すること
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 低優先度タスク，メインタスク，最初から起動
!  *	TASK2: 中優先度タスク
!  *	TASK3: 高優先度タスク
!  *	MTX1: ミューテックス（TA_NULL属性）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：低）==
   *		call(set_bit_func(bit_mutex))
   *	1:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
***************
*** 85,102 ****
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		act_tsk(TASK2)
!  *	== TASK2ͥ١==
   *	4:	ploc_mtx(MTX1) -> E_TMOUT		... (C-1)
   *		loc_mtx(MTX1)					... (A-3)
!  *	== TASK1³==
   *	5:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK2)
   *		act_tsk(TASK3)
!  *	== TASK3ͥ١==
   *	6:	unl_mtx(MTX1) -> E_OBJ			... (B-1)
   *	7:	loc_mtx(MTX1)					... (A-3)
!  *	== TASK1³==
   *	8:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK2)
--- 85,102 ----
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		act_tsk(TASK2)
!  *	== TASK2（優先度：中）==
   *	4:	ploc_mtx(MTX1) -> E_TMOUT		... (C-1)
   *		loc_mtx(MTX1)					... (A-3)
!  *	== TASK1（続き）==
   *	5:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK2)
   *		act_tsk(TASK3)
!  *	== TASK3（優先度：高）==
   *	6:	unl_mtx(MTX1) -> E_OBJ			... (B-1)
   *	7:	loc_mtx(MTX1)					... (A-3)
!  *	== TASK1（続き）==
   *	8:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK2)
***************
*** 106,128 ****
   *		assert(rmtx.htskid == TASK2)
   *		assert(rmtx.wtskid == TASK3)
   *		ena_dsp()
!  *	== TASK2³==
   *	10:	unl_mtx(MTX1)					... (B-4)
!  *	== TASK3³==
   *	11:	ext_tsk() -> noreturn			... (E-1)
!  *	== TASK2³==
   *	12:	loc_mtx(MTX1)
   *	13:	slp_tsk()
!  *	== TASK1³==
   *	14:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK2)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		tloc_mtx(MTX1, 10) -> E_TMOUT	... (D-1)
   *	15:	wup_tsk(TASK2)
!  *	== TASK2³==
   *	16:	unl_mtx(MTX1)					... (B-2)
   *	17:	ext_tsk() -> noreturn
!  *	== TASK1³==
   *	18:	END
   */
  
--- 106,128 ----
   *		assert(rmtx.htskid == TASK2)
   *		assert(rmtx.wtskid == TASK3)
   *		ena_dsp()
!  *	== TASK2（続き）==
   *	10:	unl_mtx(MTX1)					... (B-4)
!  *	== TASK3（続き）==
   *	11:	ext_tsk() -> noreturn			... (E-1)
!  *	== TASK2（続き）==
   *	12:	loc_mtx(MTX1)
   *	13:	slp_tsk()
!  *	== TASK1（続き）==
   *	14:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK2)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		tloc_mtx(MTX1, 10) -> E_TMOUT	... (D-1)
   *	15:	wup_tsk(TASK2)
!  *	== TASK2（続き）==
   *	16:	unl_mtx(MTX1)					... (B-2)
   *	17:	ext_tsk() -> noreturn
!  *	== TASK1（続き）==
   *	18:	END
   */
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex1.cfg ASPs/asp/extension/mutex/test/test_mutex1.cfg
*** 1.9.1/asp/extension/mutex/test/test_mutex1.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex1.cfg	Fri Dec  9 13:54:02 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ߥ塼ƥåΥƥ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  ミューテックスのテスト(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex2.c ASPs/asp/extension/mutex/test/test_mutex2.c
*** 1.9.1/asp/extension/mutex/test/test_mutex2.c	Sun Aug 17 22:09:31 2014
--- ASPs/asp/extension/mutex/test/test_mutex2.c	Fri Dec  9 13:54:02 2022
***************
*** 5,80 ****
   *  Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_mutex2.c 2656 2014-08-17 13:09:30Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(2)
   *
!  * ڥƥȤŪ
   *
!  *  ͥٽߥ塼ƥå򡤥åȥå
!  *  ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) ߥ塼ƥåΥåloc_mtx
!  *		(A-1) åƤʤˤϡ˥åǤ뤳
!  *		(A-2) ¿Ť˥å褦ȤȡE_OBJ顼ˤʤ뤳
!  *		(A-3) åƤˤϡͥٽԤ֤ˤʤ뤳
!  *	(B) ߥ塼ƥåΥåunl_mtx
!  *		(B-1) ¾åƤߥ塼ƥå褦Ȥ
!  *		E_OBJ顼ˤʤ뤳
!  *		(B-2) Ԥʤȡñ˥å뤳
!  *		(B-3) Ԥ˥åϤ
!  *		(B-4) Ԥ˥åϤơǥѥå뤳
!  *	(C) ߥ塼ƥåΥåploc_mtx
!  *		(C-1) åƤˤϡE_TMOUT顼ˤʤ뤳
!  *	(D) ߥ塼ƥåΥåtloc_mtx
!  *		(D-1) åƤˤϡॢդԤ֤ˤ
!  *		뤳
!  *	(E) ޤ
!  *		(E-1) λȡߥ塼ƥåå뤳
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	MTX1: ߥ塼ƥåTA_TPRI°
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_mutex))
   *	1:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
--- 5,80 ----
   *  Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_mutex2.c 2656 2014-08-17 13:09:30Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(2)
   *
!  * 【テストの目的】
   *
!  *  優先度順ミューテックスを，ロックする処理とロック解除する処理を一通
!  *  りテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) ミューテックスのロック処理（loc_mtx）
!  *		(A-1) ロックされていない場合には，すぐにロックできること
!  *		(A-2) 多重にロックしようとすると，E_OBJエラーになること
!  *		(A-3) ロックされている場合には，優先度順で待ち状態になること
!  *	(B) ミューテックスのロック解除処理（unl_mtx）
!  *		(B-1) 他タスクがロックしているミューテックスを解放しようとすると
!  *		　　　E_OBJエラーになること
!  *		(B-2) 待ちタスクがないと，単にロック解除すること
!  *		(B-3) 待ちタスクにロックを渡すこと
!  *		(B-4) 待ちタスクにロックを渡して，ディスパッチが起こること
!  *	(C) ミューテックスのロック処理（ploc_mtx）
!  *		(C-1) ロックされている場合には，すぐにE_TMOUTエラーになること
!  *	(D) ミューテックスのロック処理（tloc_mtx）
!  *		(D-1) ロックされている場合には，タイムアウト付きの待ち状態にな
!  *		　　　ること
!  *	(E) おまけ
!  *		(E-1) タスクを終了すると，ミューテックスをロック解除すること
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 低優先度タスク，メインタスク，最初から起動
!  *	TASK2: 中優先度タスク
!  *	TASK3: 高優先度タスク
!  *	MTX1: ミューテックス（TA_TPRI属性）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：低）==
   *		call(set_bit_func(bit_mutex))
   *	1:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
***************
*** 85,102 ****
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		act_tsk(TASK2)
!  *	== TASK2ͥ١==
   *	4:	ploc_mtx(MTX1) -> E_TMOUT		... (C-1)
   *		loc_mtx(MTX1)					... (A-3)
!  *	== TASK1³==
   *	5:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK2)
   *		act_tsk(TASK3)
!  *	== TASK3ͥ١==
   *	6:	unl_mtx(MTX1) -> E_OBJ			... (B-1)
   *	7:	loc_mtx(MTX1)					... (A-3)
!  *	== TASK1³==
   *	8:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK3)
--- 85,102 ----
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		act_tsk(TASK2)
!  *	== TASK2（優先度：中）==
   *	4:	ploc_mtx(MTX1) -> E_TMOUT		... (C-1)
   *		loc_mtx(MTX1)					... (A-3)
!  *	== TASK1（続き）==
   *	5:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK2)
   *		act_tsk(TASK3)
!  *	== TASK3（優先度：高）==
   *	6:	unl_mtx(MTX1) -> E_OBJ			... (B-1)
   *	7:	loc_mtx(MTX1)					... (A-3)
!  *	== TASK1（続き）==
   *	8:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK3)
***************
*** 106,127 ****
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TASK2)
   *		ena_dsp()
!  *	== TASK3³==
   *	10:	ext_tsk() -> noreturn			... (E-1)
!  *	== TASK2³==
   *	11:	unl_mtx(MTX1)					... (B-4)
   *	12:	loc_mtx(MTX1)
   *	13:	slp_tsk()
!  *	== TASK1³==
   *	14:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK2)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		tloc_mtx(MTX1, 10) -> E_TMOUT	... (D-1)
   *	15:	wup_tsk(TASK2)
!  *	== TASK2³==
   *	16:	unl_mtx(MTX1)					... (B-2)
   *	17:	ext_tsk() -> noreturn
!  *	== TASK1³==
   *	18:	END
   */
  
--- 106,127 ----
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TASK2)
   *		ena_dsp()
!  *	== TASK3（続き）==
   *	10:	ext_tsk() -> noreturn			... (E-1)
!  *	== TASK2（続き）==
   *	11:	unl_mtx(MTX1)					... (B-4)
   *	12:	loc_mtx(MTX1)
   *	13:	slp_tsk()
!  *	== TASK1（続き）==
   *	14:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK2)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		tloc_mtx(MTX1, 10) -> E_TMOUT	... (D-1)
   *	15:	wup_tsk(TASK2)
!  *	== TASK2（続き）==
   *	16:	unl_mtx(MTX1)					... (B-2)
   *	17:	ext_tsk() -> noreturn
!  *	== TASK1（続き）==
   *	18:	END
   */
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex2.cfg ASPs/asp/extension/mutex/test/test_mutex2.cfg
*** 1.9.1/asp/extension/mutex/test/test_mutex2.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex2.cfg	Fri Dec  9 13:54:02 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ߥ塼ƥåΥƥ(2)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  ミューテックスのテスト(2)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex3.c ASPs/asp/extension/mutex/test/test_mutex3.c
*** 1.9.1/asp/extension/mutex/test/test_mutex3.c	Sun Aug 17 22:09:31 2014
--- ASPs/asp/extension/mutex/test/test_mutex3.c	Fri Dec  9 13:54:02 2022
***************
*** 5,81 ****
   *  Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_mutex3.c 2656 2014-08-17 13:09:30Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(3)
   *
!  * ڥƥȤŪ
   *
!  *  ͥپ¥ߥ塼ƥå򡤥åȥå
!  *  ̤ƥȤ롥ref_tskˤ١ͥ٤ȸͥ٤λȽΥ
!  *  ȤͤƤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *	(A) ߥ塼ƥåΥåloc_mtx
!  *		(A-1) åƤʤˤϡ˥åǤ뤳
!  *		(A-2) ¿Ť˥å褦ȤȡE_OBJ顼ˤʤ뤳
!  *		(A-3) åƤˤϡͥٽԤ֤ˤʤ뤳
!  *	(B) ߥ塼ƥåΥåunl_mtx
!  *		(B-1) ¾åƤߥ塼ƥå褦Ȥ
!  *		E_OBJ顼ˤʤ뤳
!  *		(B-2) Ԥʤȡñ˥å뤳
!  *		(B-3) Ԥ˥åϤ
!  *		(B-4) Ԥ˥åϤơǥѥå뤳
!  *	(C) ߥ塼ƥåΥåploc_mtx
!  *		(C-1) åƤˤϡE_TMOUT顼ˤʤ뤳
!  *	(D) ߥ塼ƥåΥåtloc_mtx
!  *		(D-1) åƤˤϡॢդԤ֤ˤ
!  *		뤳
!  *	(E) ޤ
!  *		(E-1) λȡߥ塼ƥåå뤳
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	MTX1: ߥ塼ƥåTA_CEILING°¤Ϲͥ١
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_mutex))
   *	1:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
--- 5,81 ----
   *  Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_mutex3.c 2656 2014-08-17 13:09:30Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(3)
   *
!  * 【テストの目的】
   *
!  *  優先度上限ミューテックスを，ロックする処理とロック解除する処理を一
!  *  通りテストする．ref_tskによるベース優先度と現在優先度の参照処理のテ
!  *  ストも兼ねている．
!  *
!  * 【テスト項目】
!  *
!  *	(A) ミューテックスのロック処理（loc_mtx）
!  *		(A-1) ロックされていない場合には，すぐにロックできること
!  *		(A-2) 多重にロックしようとすると，E_OBJエラーになること
!  *		(A-3) ロックされている場合には，優先度順で待ち状態になること
!  *	(B) ミューテックスのロック解除処理（unl_mtx）
!  *		(B-1) 他タスクがロックしているミューテックスを解放しようとすると
!  *		　　　E_OBJエラーになること
!  *		(B-2) 待ちタスクがないと，単にロック解除すること
!  *		(B-3) 待ちタスクにロックを渡すこと
!  *		(B-4) 待ちタスクにロックを渡して，ディスパッチが起こること
!  *	(C) ミューテックスのロック処理（ploc_mtx）
!  *		(C-1) ロックされている場合には，すぐにE_TMOUTエラーになること
!  *	(D) ミューテックスのロック処理（tloc_mtx）
!  *		(D-1) ロックされている場合には，タイムアウト付きの待ち状態にな
!  *		　　　ること
!  *	(E) おまけ
!  *		(E-1) タスクを終了すると，ミューテックスをロック解除すること
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 低優先度タスク，メインタスク，最初から起動
!  *	TASK2: 中優先度タスク
!  *	TASK3: 高優先度タスク
!  *	MTX1: ミューテックス（TA_CEILING属性，上限は高優先度）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：低）==
   *		call(set_bit_func(bit_mutex))
   *	1:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
***************
*** 90,108 ****
   *		assert(rmtx.wtskid == TSK_NONE)
   *		act_tsk(TASK2)
   *	4:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK2ͥ١==
   *	5:	ploc_mtx(MTX1) -> E_TMOUT		... (C-1)
   *		loc_mtx(MTX1)					... (A-3)
!  *	== TASK1³==
   *	6:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK2)
   *		act_tsk(TASK3)
   *	7:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK3ͥ١==
   *	8:	unl_mtx(MTX1) -> E_OBJ			... (B-1)
   *	9:	loc_mtx(MTX1)					... (A-3)
!  *	== TASK1³==
   *	10:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK3)
--- 90,108 ----
   *		assert(rmtx.wtskid == TSK_NONE)
   *		act_tsk(TASK2)
   *	4:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK2（優先度：中）==
   *	5:	ploc_mtx(MTX1) -> E_TMOUT		... (C-1)
   *		loc_mtx(MTX1)					... (A-3)
!  *	== TASK1（続き）==
   *	6:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK2)
   *		act_tsk(TASK3)
   *	7:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK3（優先度：高）==
   *	8:	unl_mtx(MTX1) -> E_OBJ			... (B-1)
   *	9:	loc_mtx(MTX1)					... (A-3)
!  *	== TASK1（続き）==
   *	10:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK1)
   *		assert(rmtx.wtskid == TASK3)
***************
*** 115,139 ****
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TASK2)
   *		ena_dsp()
!  *	== TASK3³==
   *	12:	ext_tsk() -> noreturn			... (E-1)
!  *	== TASK2³==
   *	13:	ref_tsk(TASK2, &rtsk)
   *		assert(rtsk.tskpri == HIGH_PRIORITY)
   *		assert(rtsk.tskbpri == MID_PRIORITY)
   *		unl_mtx(MTX1)					... (B-4)
   *	14:	loc_mtx(MTX1)
   *	15:	slp_tsk()
!  *	== TASK1³==
   *	16:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK2)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		tloc_mtx(MTX1, 10) -> E_TMOUT	... (D-1)
   *	17:	wup_tsk(TASK2)
!  *	== TASK2³==
   *	18:	unl_mtx(MTX1)					... (B-2)
   *	19:	ext_tsk() -> noreturn
!  *	== TASK1³==
   *	20:	END
   */
  
--- 115,139 ----
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TASK2)
   *		ena_dsp()
!  *	== TASK3（続き）==
   *	12:	ext_tsk() -> noreturn			... (E-1)
!  *	== TASK2（続き）==
   *	13:	ref_tsk(TASK2, &rtsk)
   *		assert(rtsk.tskpri == HIGH_PRIORITY)
   *		assert(rtsk.tskbpri == MID_PRIORITY)
   *		unl_mtx(MTX1)					... (B-4)
   *	14:	loc_mtx(MTX1)
   *	15:	slp_tsk()
!  *	== TASK1（続き）==
   *	16:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK2)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		tloc_mtx(MTX1, 10) -> E_TMOUT	... (D-1)
   *	17:	wup_tsk(TASK2)
!  *	== TASK2（続き）==
   *	18:	unl_mtx(MTX1)					... (B-2)
   *	19:	ext_tsk() -> noreturn
!  *	== TASK1（続き）==
   *	20:	END
   */
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex3.cfg ASPs/asp/extension/mutex/test/test_mutex3.cfg
*** 1.9.1/asp/extension/mutex/test/test_mutex3.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex3.cfg	Fri Dec  9 13:54:02 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ߥ塼ƥåΥƥ(3)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  ミューテックスのテスト(3)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex4.c ASPs/asp/extension/mutex/test/test_mutex4.c
*** 1.9.1/asp/extension/mutex/test/test_mutex4.c	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex4.c	Fri Dec  9 13:54:02 2022
***************
*** 5,355 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_mutex4.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(4)
   *
!  * ڥƥȤŪ
   *
!  *  ͥپ¥ߥ塼ƥåФơloc_mtxunl_mtxȼͥ٤
!  *  Ū˥ƥȤ롥change_priority
!  *  mutex_calc_priorityƤˤƧ߹ޤʤ
!  *
!  * ڥƥȹܡ
!  *
!  *	(A) ߥ塼ƥåΥåloc_mtxˤȼͥѹ
!  *		(A-1) åߥ塼ƥåͥپ¤θͥ
!  *			  ٤⤤ˡͥ٤ͥپ¤ޤ
!  *			  夬뤳ȡޤƱͥǤ̤ͥǹˤʤ뤳
!  *			  
!  *		(A-2) åߥ塼ƥåͥپ¤θͥ
!  *			  ٤Ʊˡͥ٤Ѥʤȡޤ
!  *			  ƱͥǤ̤ͥѤʤ
!  *		(A-3) åߥ塼ƥåͥپ¤θͥ
!  *			  ٤㤤ˡͥ٤Ѥʤȡ
!  *			  ƱͥǤ̤ͥѤʤ
!  *	(B) ߥ塼ƥåΥåunl_mtxˤȼå
!  * 		ͥѹ
!  *		(B-1) åߥ塼ƥåξͥ٤θ
!  *			  ͥ٤Ʊǡߥ塼ƥåΥåͥ٤
!  *			  ٤ˡͥ٤Ŭڤ˲뤳ȡ
!  *			  ƱͥǤ̤ͥǹˤʤ뤳
!  *		(B-2) åߥ塼ƥåξͥ٤θ
!  *			  ͥ٤Ʊǡߥ塼ƥåΥåͥ٤Ѥ
!  *			  ٤Ǥʤˡͥ٤Ѥʤȡ
!  *			  ƱͥǤ̤ͥѤʤ
!  *		(B-3) åߥ塼ƥåξͥ٤θ
!  *			  ͥ٤㤤ˡͥ٤Ѥʤȡ
!  *			  ޤƱͥǤ̤ͥѤʤ
!  *	(C) ߥ塼ƥåΥåunl_mtxˤȼߥ塼ƥå
!  *		åͥѹ
!  *		(C-1) ߥ塼ƥåͥپ¤˥ߥ塼ƥåå
!  *			  θͥ٤⤤ˡͥ
!  *			  ٤ͥپ¤ޤǾ夬뤳ȡޤƱͥǤ
!  *			  ̤ͥˤʤ뤳
!  *		(C-2) ߥ塼ƥåͥپ¤˥ߥ塼ƥåå
!  *			  θͥ٤Ʊˡͥ٤
!  *			  ѤʤȡޤƱͥǤ̤ͥˤ
!  *			  뤳
!  *		(C-3) ߥ塼ƥåͥپ¤˥ߥ塼ƥåå
!  *			  θͥ٤㤤ˡͥ
!  *			  ٤ѤʤȡޤƱͥǤ̤ͥ
!  *			  ˤʤ뤳
!  *	(D) ߥ塼ƥåΥåloc_mtxˤE_ILUSE顼
!  *		(D-1) Υ١ͥ٤å褦Ȥߥ塼ƥå
!  *			  ξͥ٤⤤E_ILUSE顼ˤʤ뤳
!  *		(D-2) Υ١ͥ٤å褦Ȥߥ塼ƥå
!  *			  ξͥ٤Ʊ㤱Сθͥ
!  *			  ٤⤯Ƥ⡤E_ILUSE顼ˤʤʤ
   *
!  * ڥƥȹܤμ¸ˡ
   *
   *	(A-1)
!  *		ͥ٥TASK1ˤˡͥپ¥ߥ塼ƥåMTX2ˤ
!  *		åͥ٤ˤʤ뤳Ȥǧ롥ޤ¹Բǽ֤
!  *		ͥ٥TASK4ˤ⡤̤ͥ⤯ʤ뤳Ȥǧ롥
!  *		ǥѥåػ߾֤Ǽ»ܤ롥
   *	(A-2)
!  *		ͥ٥TASK1ˤˡͥپ¥ߥ塼ƥåMTX1ˤ
!  *		åͥ٤ѤʤȤǧ롥ޤ¹Բǽ
!  *		֤ͥ٥2ġTASK2TASK3ˤѰդƤͥ
!  *		ѤʤȤǧ롥ǥѥåػ߾֤Ǽ»ܤ롥
   *	(A-3)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX2ˤ
!  *		ƹͥ٤ˤʤäƤ֤ǡͥپ¥ߥ塼ƥå
!  *		MTX1ˤåͥ٤ѤʤȤǧ롥ޤ
!  *		¹Բǽ֤ιͥ٥2ġTASK4TASK5ˤѰդƤ
!  *		̤ͥѤʤȤǧ롥ǥѥåػ߾֤Ǽ»
!  *		롥
   *	(B-1)
!  *		ͥ٥TASK1ˤ˹ͥپ¥ߥ塼ƥåMTX2ˤΤ
!  *		åƤ֤ǡåͥ٤ˤʤ
!  *		Ȥǧ롥ޤ¹Բǽ֤ͥ٥TASK2ˤ
!  *		⡤̤ͥ⤯ʤ뤳Ȥǧ롥
   *	(B-2)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX1ˤΤ
!  *		åƤ֤ǡåͥ٤Ѥ
!  *		ʤȤǧ롥ޤ¹Բǽ֤ͥ٥2
!  *		TASK2TASK3ˤѰդƤ̤ͥѤʤȤǧ
!  *		롥ǥѥåػ߾֤Ǽ»ܤ롥
   *	(B-3)
!  *		ͥ٥TASK1ˤ˹ͥپ¥ߥ塼ƥåMTX2ˤ
!  *		ͥپ¥ߥ塼ƥåMTX1ˤåƤ֤ǡͥ
!  *		پ¥ߥ塼ƥåMTX1ˤåͥ٤Ѥ
!  *		ʤȤǧ롥ޤ¹Բǽ֤ιͥ٥2
!  *		TASK4TASK5ˤѰդƤ̤ͥѤʤȤǧ
!  *		롥ǥѥåػ߾֤Ǽ»ܤ롥
   *	(C-1)
!  *		ͥ٥TASK1ˤ˹ͥپ¥ߥ塼ƥå2ġMTX2
!  *		MTX3˥å̤ͥ٥TASK2ˤMTX2ԤäƤ
!  *		֤ǡTASK1MTX2åTASK2ͥ٤ͥ٤
!  *		ʤ뤳Ȥǧ롥ޤTASK2̤ͥTASK1㤯
!  *		뤳Ȥǧ롥
   *	(C-2)
!  *		ͥ٥TASK2ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		̤ͥ٥TASK1ˤMTX1ԤäƤ֤ǡ
!  *		TASK2MTX1åTASK1ͥ٤ͥ٤ΤޤѲ
!  *		ʤȤǧ롥ޤ¹Բǽ֤ͥ٥⤦
!  *		1ġTASK3ѰդƤTASK1̤ͥTASK3㤯ʤ
!  *		Ȥǧ롥
   *	(C-3)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX1ˤȹ
!  *		ͥپ¥ߥ塼ƥåMTX3ˤå̤ͥ٥
!  *		TASK2ˤ̤ιͥپ¥ߥ塼ƥåMTX2ˤå
!  *		MTX1ԤäƤ֤ǡTASK1MTX1åTASK2ͥ
!  *		٤ͥ٤ΤޤѲʤȤǧ롥ޤTASK2ͥ
!  *		̤TASK1㤯ʤ뤳Ȥǧ롥
   *	(D-1)
!  *		ͥ٥TASK4ˤˡͥپ¥ߥ塼ƥåMTX1ˤ
!  *		åE_ILUSE顼ˤʤ뤳Ȥǧ롥
   *	(D-2)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX2ˤ
!  *		ƹͥ٤ˤʤäƤ֤ǡͥپ¥ߥ塼ƥå
!  *		MTX1ˤåE_ILUSE顼ˤʤʤȤǧ롥
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	TASK4: ͥ٥
!  *	TASK5: ͥ٥
!  *	MTX1: ߥ塼ƥåTA_CEILING°¤ͥ١
!  *	MTX2: ߥ塼ƥåTA_CEILING°¤Ϲͥ١
!  *	MTX3: ߥ塼ƥåTA_CEILING°¤Ϲͥ١
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_mutex))
   *	1:	dis_dsp()
   *	2:	act_tsk(TASK2)
   *		act_tsk(TASK4)
!  *	//		⡧TASK4桧TASK1TASK2
   *	3:	ploc_mtx(MTX2)								... (A-1)
!  *	//		⡧TASK1TASK4桧TASK2MTX2TASK1
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	4:	ena_dsp()
   *	5:	unl_mtx(MTX2)								... (B-1)
!  *	//		⡧TASK4桧TASK1TASK2
!  *	== TASK4ͥ١==
   *	6:	loc_mtx(MTX1) -> E_ILUSE					... (D-1)
   *	7:	slp_tsk()
!  *	//		桧TASK1TASK2
!  *	== TASK1³==
   *	8:	get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *
   *	9:	dis_dsp()
   *	10:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK2TASK1
   *	11:	act_tsk(TASK3)
!  *	//		桧TASK2TASK1TASK3
   *	12:	ploc_mtx(MTX1)								... (A-2)
!  *	//		桧TASK2TASK1TASK3MTX1TASK1
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	13:	ena_dsp()
!  *	== TASK2ͥ١==
   *	14:	slp_tsk()
!  *	//		桧TASK1TASK3MTX1TASK1
!  *	== TASK1³==
   *	15:	slp_tsk()
!  *	//		桧TASK3MTX1TASK1
!  *	== TASK3ͥ١==
   *	16:	wup_tsk(TASK1)
!  *	//		桧TASK3TASK1MTX1TASK1
   *	17:	slp_tsk()
!  *	//		桧TASK1MTX1TASK1
   *
!  *	== TASK1³==
   *	18:	wup_tsk(TASK2)
!  *	//		桧TASK1TASK2MTX1TASK1
   *	19:	dis_dsp()
   *	20:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK2TASK1MTX1TASK1
   *	21:	wup_tsk(TASK3)
!  *	//		桧TASK2TASK1TASK3MTX1TASK1
   *	22:	unl_mtx(MTX1)								... (B-2)
!  *	//		桧TASK2TASK1TASK3
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	23:	ena_dsp()
!  *	== TASK2ͥ١==
   *	24:	slp_tsk()
!  *	//		桧TASK1TASK3
!  *	== TASK1³==
   *	25:	slp_tsk()
!  *	//		桧TASK3
!  *	== TASK3ͥ١==
   *	26:	wup_tsk(TASK1)
!  *	//		桧TASK3TASK1
   *	27:	slp_tsk()
!  *	//		桧TASK1
   *
!  *	== TASK1³==
   *	28:	dis_dsp()
   *	29:	wup_tsk(TASK4)
!  *	//		⡧TASK4桧TASK1
   *	30:	ploc_mtx(MTX2)
!  *	//		⡧TASK1TASK4MTX2TASK1
   *	31:	rot_rdq(HIGH_PRIORITY)
!  *	//		⡧TASK4TASK1MTX2TASK1
   *	32:	act_tsk(TASK5)
!  *	//		⡧TASK4TASK1TASK5MTX2TASK1
   *	33:	ploc_mtx(MTX1)								... (A-3)(D-2)
!  *	//		⡧TASK4TASK1TASK5MTX2TASK1MTX1TASK1
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	34:	ena_dsp()
!  *	== TASK4³==
   *	35:	slp_tsk()
!  *	//		⡧TASK1TASK5MTX2TASK1MTX1TASK1
!  *	== TASK1³==
   *	36:	slp_tsk()
!  *	//		⡧TASK5MTX2TASK1MTX1TASK1
!  *	== TASK5ͥ١==
   *	37:	wup_tsk(TASK1)
!  *	//		⡧TASK5TASK1MTX2TASK1MTX1TASK1
   *	38:	slp_tsk()
!  *	//		⡧TASK1MTX2TASK1MTX1TASK1
   *
!  *	== TASK1³==
   *	39:	dis_dsp()
   *	40:	wup_tsk(TASK4)
!  *	//		⡧TASK1TASK4MTX2TASK1MTX1TASK1
   *	41:	rot_rdq(HIGH_PRIORITY)
!  *	//		⡧TASK4TASK1MTX2TASK1MTX1TASK1
   *	42:	wup_tsk(TASK5)
!  *	//		⡧TASK4TASK1TASK5MTX2TASK1MTX1TASK1
   *	43:	unl_mtx(MTX1)								... (B-3)
!  *	//		⡧TASK4TASK1TASK5MTX2TASK1
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	44:	ena_dsp()
!  *	== TASK4³==
   *	45:	slp_tsk()
!  *	//		⡧TASK1TASK5MTX2TASK1
!  *	== TASK1³==
   *	46:	slp_tsk()
!  *	//		⡧TASK5MTX2TASK1
!  *	== TASK5³==
   *	47:	wup_tsk(TASK1)
!  *	//		⡧TASK5TASK1MTX2TASK1
   *	48:	slp_tsk()
!  *	//		⡧TASK1MTX2TASK1
   *
!  *	== TASK1³==
   *	49:	wup_tsk(TASK2)
   *		wup_tsk(TASK3)
   *		slp_tsk()
!  *	//		桧TASK2TASK3MTX2TASK1
!  *	== TASK2³==
   *	50:	loc_mtx(MTX2)
!  *	//		桧TASK3MTX2TASK1TASK2
!  *	== TASK3³==
   *	51:	wup_tsk(TASK1)
!  *	//		⡧TASK1桧TASK3MTX2TASK1TASK2
!  *	== TASK1³==
   *	52:	loc_mtx(MTX3)
!  *	//		⡧TASK1桧TASK3MTX2TASK1TASK2MTX3TASK1
   *	53:	unl_mtx(MTX2)								... (C-1)
!  *	//		⡧TASK1TASK2桧TASK3MTX2TASK2MTX3TASK1
   *		get_pri(TASK2, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	54:	loc_mtx(MTX1)
!  *	//		⡧TASK1TASK2桧TASK3MTX1TASK1MTX2TASK2MTX3TASK1
   *	55:	slp_tsk()
!  *	//		⡧TASK2桧TASK3MTX1TASK1MTX2TASK2MTX3TASK1
   *
!  *	== TASK2³==
   *	56:	wup_tsk(TASK1)
!  *	//		⡧TASK2TASK1桧TASK3MTX1TASK1MTX2TASK2MTX3TASK1
   *	57:	loc_mtx(MTX1)
!  *	//		⡧TASK1桧TASK3MTX1TASK1TASK2MTX2TASK2MTX3TASK1
!  *	== TASK1³==
   *	58:	unl_mtx(MTX1)								... (C-3)
!  *	//		⡧TASK1TASK2桧TASK3MTX1TASK2MTX2TASK2MTX3TASK1
   *		get_pri(TASK2, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	59:	unl_mtx(MTX3)
!  *	//		⡧TASK2桧TASK1TASK3MTX1TASK2MTX2TASK2
!  *	== TASK2³==
   *	60:	unl_mtx(MTX2)
!  *	//		桧TASK2TASK1TASK3MTX1TASK2
   *
   *	61:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK1TASK3TASK2MTX1TASK2
!  *	== TASK1³==
   *	62:	loc_mtx(MTX1)
!  *	//		桧TASK3TASK2MTX1TASK2TASK1
!  *	== TASK3³==
   *	63:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK2TASK3MTX1TASK2TASK1
!  *	== TASK2³==
   *	64:	unl_mtx(MTX1)								... (C-2)
!  *	//		桧TASK2TASK3TASK1MTX1TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
!  *	== TASK2³==
   *	65:	ext_tsk() -> noreturn
!  *	//		桧TASK3TASK1MTX1TASK1
!  *	== TASK3³==
   *	66:	ext_tsk() -> noreturn
!  *	//		桧TASK1MTX1TASK1
!  *	== TASK1³==
   *	67:	END
   */
  
--- 5,355 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_mutex4.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(4)
   *
!  * 【テストの目的】
   *
!  *  優先度上限ミューテックスに対して，loc_mtxとunl_mtxに伴う優先度の変
!  *  更処理を網羅的にテストする．ただし，change_priorityと
!  *  mutex_calc_priorityの内容には踏み込まない．
!  *
!  * 【テスト項目】
!  *
!  *	(A) ミューテックスのロック処理（loc_mtx）に伴う優先度変更
!  *		(A-1) ロックしたミューテックスの優先度上限が自タスクの現在優先
!  *			  度よりも高い場合に，自タスクの優先度がその優先度上限まで
!  *			  上がること．また，同じ優先度内での優先順位が最高になるこ
!  *			  と
!  *		(A-2) ロックしたミューテックスの優先度上限が自タスクの現在優先
!  *			  度と同じ場合に，自タスクの優先度が変わらないこと．また，
!  *			  同じ優先度内での優先順位が変わらないこと
!  *		(A-3) ロックしたミューテックスの優先度上限が自タスクの現在優先
!  *			  度よりも低い場合に，自タスクの優先度が変わらないこと．ま
!  *			  た，同じ優先度内での優先順位が変わらないこと
!  *	(B) ミューテックスのロック解除処理（unl_mtx）に伴うロック解除した
!  * 		タスクの優先度変更
!  *		(B-1) ロック解除したミューテックスの上限優先度が自タスクの現在
!  *			  優先度と同じで，ミューテックスのロック解除で優先度が下が
!  *			  るべき場合に，自タスクの優先度が適切に下げられること．ま
!  *			  た，同じ優先度内での優先順位が最高になること
!  *		(B-2) ロック解除したミューテックスの上限優先度が自タスクの現在
!  *			  優先度と同じで，ミューテックスのロック解除で優先度が変わ
!  *			  るべきでない場合に，自タスクの優先度が変わらないこと．ま
!  *			  た，同じ優先度内での優先順位が変わらないこと
!  *		(B-3) ロック解除したミューテックスの上限優先度が自タスクの現在
!  *			  優先度よりも低い場合に，自タスクの優先度が変わらないこと．
!  *			  また，同じ優先度内での優先順位が変わらないこと
!  *	(C) ミューテックスのロック解除処理（unl_mtx）に伴いミューテックスを
!  *		ロックしたタスクの優先度変更
!  *		(C-1) ミューテックスの優先度上限が新たにミューテックスをロック
!  *			  したタスクの現在優先度よりも高い場合に，当該タスクの優先
!  *			  度がその優先度上限まで上がること．また，同じ優先度内での
!  *			  優先順位が最低になること
!  *		(C-2) ミューテックスの優先度上限が新たにミューテックスをロック
!  *			  したタスクの現在優先度と同じ場合に，当該タスクの優先度が
!  *			  変わらないこと．また，同じ優先度内での優先順位が最低にな
!  *			  ること
!  *		(C-3) ミューテックスの優先度上限が新たにミューテックスをロック
!  *			  したタスクの現在優先度よりも低い場合に，当該タスクの優先
!  *			  度が変わらないこと．また，同じ優先度内での優先順位が最低
!  *			  になること
!  *	(D) ミューテックスのロック処理（loc_mtx）のE_ILUSEエラー
!  *		(D-1) 自タスクのベース優先度が，ロックしようとしたミューテック
!  *			  スの上限優先度よりも高い時，E_ILUSEエラーになること
!  *		(D-2) 自タスクのベース優先度が，ロックしようとしたミューテック
!  *			  スの上限優先度と同じかそれより低ければ，自タスクの現在優
!  *			  先度がそれより高くても，E_ILUSEエラーにならないこと
   *
!  * 【テスト項目の実現方法】
   *
   *	(A-1)
!  *		中優先度タスク（TASK1）に，高優先度上限ミューテックス（MTX2）を
!  *		ロックさせ，高優先度になることを確認する．また，実行可能状態の
!  *		高優先度タスク（TASK4）よりも，優先順位が高くなることを確認する．
!  *		ディスパッチ禁止状態で実施する．
   *	(A-2)
!  *		中優先度タスク（TASK1）に，中優先度上限ミューテックス（MTX1）を
!  *		ロックさせ，優先度が変わらないことを確認する．また，実行可能状
!  *		態の中優先度タスクを2つ（TASK2，TASK3）を用意しておき，優先順位
!  *		が変わらないことを確認する．ディスパッチ禁止状態で実施する．
   *	(A-3)
!  *		中優先度タスク（TASK1）が高優先度上限ミューテックス（MTX2）をロッ
!  *		クして高優先度になっている状態で，中優先度上限ミューテックス
!  *		（MTX1）をロックさせ，優先度が変わらないことを確認する．また，
!  *		実行可能状態の高優先度タスクを2つ（TASK4，TASK5）を用意しておき，
!  *		優先順位が変わらないことを確認する．ディスパッチ禁止状態で実施
!  *		する．
   *	(B-1)
!  *		中優先度タスク（TASK1）に高優先度上限ミューテックス（MTX2）のみ
!  *		をロックさせている状態で，それをロック解除させ，中優先度になる
!  *		ことを確認する．また，実行可能状態の中優先度タスク（TASK2）より
!  *		も，優先順位が高くなることを確認する．
   *	(B-2)
!  *		中優先度タスク（TASK1）に中優先度上限ミューテックス（MTX1）のみ
!  *		をロックさせている状態で，それをロック解除させ，優先度が変わら
!  *		ないことを確認する．また，実行可能状態の中優先度タスクを2つ
!  *		（TASK2，TASK3）を用意しておき，優先順位が変わらないことを確認
!  *		する．ディスパッチ禁止状態で実施する．
   *	(B-3)
!  *		中優先度タスク（TASK1）に高優先度上限ミューテックス（MTX2）と中
!  *		優先度上限ミューテックス（MTX1）をロックさせている状態で，中優
!  *		先度上限ミューテックス（MTX1）をロック解除させ，優先度が変わら
!  *		ないことを確認する．また，実行可能状態の高優先度タスクを2つ
!  *		（TASK4，TASK5）を用意しておき，優先順位が変わらないことを確認
!  *		する．ディスパッチ禁止状態で実施する．
   *	(C-1)
!  *		中優先度タスク（TASK1）に高優先度上限ミューテックスを2つ（MTX2，
!  *		MTX3）ロックさせ，別の中優先度タスク（TASK2）がMTX2を待っている
!  *		状態で，TASK1にMTX2をロック解除させ，TASK2の優先度が高優先度に
!  *		なることを確認する．また，TASK2の優先順位が，TASK1よりも低くな
!  *		ることを確認する．
   *	(C-2)
!  *		中優先度タスク（TASK2）に中優先度上限ミューテックス（MTX1）をロッ
!  *		クさせ，別の中優先度タスク（TASK1）がMTX1を待っている状態で，
!  *		TASK2にMTX1をロック解除させ，TASK1の優先度が中優先度のまま変化
!  *		しないことを確認する．また，実行可能状態の中優先度タスクをもう
!  *		1つ（TASK3）用意しておき，TASK1の優先順位がTASK3よりも低くなる
!  *		ことを確認する．
   *	(C-3)
!  *		中優先度タスク（TASK1）に中優先度上限ミューテックス（MTX1）と高
!  *		優先度上限ミューテックス（MTX3）をロックさせ，別の中優先度タス
!  *		ク（TASK2）が別の高優先度上限ミューテックス（MTX2）をロックして
!  *		MTX1を待っている状態で，TASK1にMTX1をロック解除させ，TASK2の優
!  *		先度が高優先度のまま変化しないことを確認する．また，TASK2の優先
!  *		順位が，TASK1よりも低くなることを確認する．
   *	(D-1)
!  *		高優先度タスク（TASK4）に，中優先度上限ミューテックス（MTX1）を
!  *		ロックさせ，E_ILUSEエラーになることを確認する．
   *	(D-2)
!  *		中優先度タスク（TASK1）が高優先度上限ミューテックス（MTX2）をロッ
!  *		クして高優先度になっている状態で，中優先度上限ミューテックス
!  *		（MTX1）をロックさせ，E_ILUSEエラーになるないことを確認する．
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 中優先度タスク，メインタスク，最初から起動
!  *	TASK2: 中優先度タスク
!  *	TASK3: 中優先度タスク
!  *	TASK4: 高優先度タスク
!  *	TASK5: 高優先度タスク
!  *	MTX1: ミューテックス（TA_CEILING属性，上限は中優先度）
!  *	MTX2: ミューテックス（TA_CEILING属性，上限は高優先度）
!  *	MTX3: ミューテックス（TA_CEILING属性，上限は高優先度）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：中）==
   *		call(set_bit_func(bit_mutex))
   *	1:	dis_dsp()
   *	2:	act_tsk(TASK2)
   *		act_tsk(TASK4)
!  *	//		高：TASK4，中：TASK1→TASK2
   *	3:	ploc_mtx(MTX2)								... (A-1)
!  *	//		高：TASK1→TASK4，中：TASK2，MTX2：TASK1
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	4:	ena_dsp()
   *	5:	unl_mtx(MTX2)								... (B-1)
!  *	//		高：TASK4，中：TASK1→TASK2
!  *	== TASK4（優先度：高）==
   *	6:	loc_mtx(MTX1) -> E_ILUSE					... (D-1)
   *	7:	slp_tsk()
!  *	//		中：TASK1→TASK2
!  *	== TASK1（続き）==
   *	8:	get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *
   *	9:	dis_dsp()
   *	10:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK2→TASK1
   *	11:	act_tsk(TASK3)
!  *	//		中：TASK2→TASK1→TASK3
   *	12:	ploc_mtx(MTX1)								... (A-2)
!  *	//		中：TASK2→TASK1→TASK3，MTX1：TASK1
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	13:	ena_dsp()
!  *	== TASK2（優先度：中）==
   *	14:	slp_tsk()
!  *	//		中：TASK1→TASK3，MTX1：TASK1
!  *	== TASK1（続き）==
   *	15:	slp_tsk()
!  *	//		中：TASK3，MTX1：TASK1
!  *	== TASK3（優先度：中）==
   *	16:	wup_tsk(TASK1)
!  *	//		中：TASK3→TASK1，MTX1：TASK1
   *	17:	slp_tsk()
!  *	//		中：TASK1，MTX1：TASK1
   *
!  *	== TASK1（続き）==
   *	18:	wup_tsk(TASK2)
!  *	//		中：TASK1→TASK2，MTX1：TASK1
   *	19:	dis_dsp()
   *	20:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK2→TASK1，MTX1：TASK1
   *	21:	wup_tsk(TASK3)
!  *	//		中：TASK2→TASK1→TASK3，MTX1：TASK1
   *	22:	unl_mtx(MTX1)								... (B-2)
!  *	//		中：TASK2→TASK1→TASK3
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	23:	ena_dsp()
!  *	== TASK2（優先度：中）==
   *	24:	slp_tsk()
!  *	//		中：TASK1→TASK3
!  *	== TASK1（続き）==
   *	25:	slp_tsk()
!  *	//		中：TASK3
!  *	== TASK3（優先度：中）==
   *	26:	wup_tsk(TASK1)
!  *	//		中：TASK3→TASK1
   *	27:	slp_tsk()
!  *	//		中：TASK1
   *
!  *	== TASK1（続き）==
   *	28:	dis_dsp()
   *	29:	wup_tsk(TASK4)
!  *	//		高：TASK4，中：TASK1
   *	30:	ploc_mtx(MTX2)
!  *	//		高：TASK1→TASK4，MTX2：TASK1
   *	31:	rot_rdq(HIGH_PRIORITY)
!  *	//		高：TASK4→TASK1，MTX2：TASK1
   *	32:	act_tsk(TASK5)
!  *	//		高：TASK4→TASK1→TASK5，MTX2：TASK1
   *	33:	ploc_mtx(MTX1)								... (A-3)(D-2)
!  *	//		高：TASK4→TASK1→TASK5，MTX2：TASK1，MTX1：TASK1
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	34:	ena_dsp()
!  *	== TASK4（続き）==
   *	35:	slp_tsk()
!  *	//		高：TASK1→TASK5，MTX2：TASK1，MTX1：TASK1
!  *	== TASK1（続き）==
   *	36:	slp_tsk()
!  *	//		高：TASK5，MTX2：TASK1，MTX1：TASK1
!  *	== TASK5（優先度：高）==
   *	37:	wup_tsk(TASK1)
!  *	//		高：TASK5→TASK1，MTX2：TASK1，MTX1：TASK1
   *	38:	slp_tsk()
!  *	//		高：TASK1，MTX2：TASK1，MTX1：TASK1
   *
!  *	== TASK1（続き）==
   *	39:	dis_dsp()
   *	40:	wup_tsk(TASK4)
!  *	//		高：TASK1→TASK4，MTX2：TASK1，MTX1：TASK1
   *	41:	rot_rdq(HIGH_PRIORITY)
!  *	//		高：TASK4→TASK1，MTX2：TASK1，MTX1：TASK1
   *	42:	wup_tsk(TASK5)
!  *	//		高：TASK4→TASK1→TASK5，MTX2：TASK1，MTX1：TASK1
   *	43:	unl_mtx(MTX1)								... (B-3)
!  *	//		高：TASK4→TASK1→TASK5，MTX2：TASK1
   *		get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	44:	ena_dsp()
!  *	== TASK4（続き）==
   *	45:	slp_tsk()
!  *	//		高：TASK1→TASK5，MTX2：TASK1
!  *	== TASK1（続き）==
   *	46:	slp_tsk()
!  *	//		高：TASK5，MTX2：TASK1
!  *	== TASK5（続き）==
   *	47:	wup_tsk(TASK1)
!  *	//		高：TASK5→TASK1，MTX2：TASK1
   *	48:	slp_tsk()
!  *	//		高：TASK1，MTX2：TASK1
   *
!  *	== TASK1（続き）==
   *	49:	wup_tsk(TASK2)
   *		wup_tsk(TASK3)
   *		slp_tsk()
!  *	//		中：TASK2→TASK3，MTX2：TASK1
!  *	== TASK2（続き）==
   *	50:	loc_mtx(MTX2)
!  *	//		中：TASK3，MTX2：TASK1→TASK2
!  *	== TASK3（続き）==
   *	51:	wup_tsk(TASK1)
!  *	//		高：TASK1，中：TASK3，MTX2：TASK1→TASK2
!  *	== TASK1（続き）==
   *	52:	loc_mtx(MTX3)
!  *	//		高：TASK1，中：TASK3，MTX2：TASK1→TASK2，MTX3：TASK1
   *	53:	unl_mtx(MTX2)								... (C-1)
!  *	//		高：TASK1→TASK2，中：TASK3，MTX2：TASK2，MTX3：TASK1
   *		get_pri(TASK2, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	54:	loc_mtx(MTX1)
!  *	//		高：TASK1→TASK2，中：TASK3，MTX1：TASK1，MTX2：TASK2，MTX3：TASK1
   *	55:	slp_tsk()
!  *	//		高：TASK2，中：TASK3，MTX1：TASK1，MTX2：TASK2，MTX3：TASK1
   *
!  *	== TASK2（続き）==
   *	56:	wup_tsk(TASK1)
!  *	//		高：TASK2→TASK1，中：TASK3，MTX1：TASK1，MTX2：TASK2，MTX3：TASK1
   *	57:	loc_mtx(MTX1)
!  *	//		高：TASK1，中：TASK3，MTX1：TASK1→TASK2，MTX2：TASK2，MTX3：TASK1
!  *	== TASK1（続き）==
   *	58:	unl_mtx(MTX1)								... (C-3)
!  *	//		高：TASK1→TASK2，中：TASK3，MTX1：TASK2，MTX2：TASK2，MTX3：TASK1
   *		get_pri(TASK2, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *	59:	unl_mtx(MTX3)
!  *	//		高：TASK2，中：TASK1→TASK3，MTX1：TASK2，MTX2：TASK2
!  *	== TASK2（続き）==
   *	60:	unl_mtx(MTX2)
!  *	//		中：TASK2→TASK1→TASK3，MTX1：TASK2
   *
   *	61:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK1→TASK3→TASK2，MTX1：TASK2
!  *	== TASK1（続き）==
   *	62:	loc_mtx(MTX1)
!  *	//		中：TASK3→TASK2，MTX1：TASK2→TASK1
!  *	== TASK3（続き）==
   *	63:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK2→TASK3，MTX1：TASK2→TASK1
!  *	== TASK2（続き）==
   *	64:	unl_mtx(MTX1)								... (C-2)
!  *	//		中：TASK2→TASK3→TASK1，MTX1：TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
!  *	== TASK2（続き）==
   *	65:	ext_tsk() -> noreturn
!  *	//		中：TASK3→TASK1，MTX1：TASK1
!  *	== TASK3（続き）==
   *	66:	ext_tsk() -> noreturn
!  *	//		中：TASK1，MTX1：TASK1
!  *	== TASK1（続き）==
   *	67:	END
   */
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex4.cfg ASPs/asp/extension/mutex/test/test_mutex4.cfg
*** 1.9.1/asp/extension/mutex/test/test_mutex4.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex4.cfg	Fri Dec  9 13:54:02 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ߥ塼ƥåΥƥ(4)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  ミューテックスのテスト(4)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex4.h ASPs/asp/extension/mutex/test/test_mutex4.h
*** 1.9.1/asp/extension/mutex/test/test_mutex4.h	Sat Jan  2 01:01:35 2010
--- ASPs/asp/extension/mutex/test/test_mutex4.h	Fri Dec  9 13:54:02 2022
***************
*** 5,67 ****
   *  Copyright (C) 2007-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_mutex4.h 1696 2010-01-01 16:01:25Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(4)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2007-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_mutex4.h 1696 2010-01-01 16:01:25Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(4)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex5.c ASPs/asp/extension/mutex/test/test_mutex5.c
*** 1.9.1/asp/extension/mutex/test/test_mutex5.c	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex5.c	Fri Dec  9 13:54:02 2022
***************
*** 5,446 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_mutex5.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(5)
   *
!  * ڥƥȤŪ
   *
!  *  ͥپ¥ߥ塼ƥåФơߥ塼ƥåκƽ
!  *  Ū˥ƥȤ롥change_prioritymutex_calc_priority
!  *  ƤˤƧ߹ޤʤ
!  *
!  * ڥƥȹܡ
!  *
!  *	(A) ߥ塼ƥåνini_mtxˤȼߥ塼ƥåå
!  *		Ƥʼ¹ԤǤ֡ˤͥѹ
!  *		(A-1) ߥ塼ƥåξͥ٤ߥ塼ƥå
!  *			  åƤʼ¹ԤǤ֡ˤθͥ٤Ʊ
!  *			  ǡߥ塼ƥåΥåͥ٤٤ˡ
!  *			  ͥ٤Ŭڤ˲뤳ȡޤƱͥ
!  *			  Ǥ̤ͥǹˤʤ뤳
!  *		(A-2) ߥ塼ƥåξͥ٤ߥ塼ƥå
!  *			  åƤʼ¹ԤǤ֡ˤθͥ٤Ʊ
!  *			  ǡߥ塼ƥåΥåͥ٤Ѥ٤Ǥʤ
!  *			  ˡͥ٤ѤʤȡޤƱͥ
!  *			  Ǥ̤ͥѤʤ
!  *		(A-3) ߥ塼ƥåξͥ٤ߥ塼ƥå
!  *			  åƤʼ¹ԤǤ֡ˤθͥ٤
!  *			  㤤ˡͥ٤ѤʤȡޤƱ
!  *			  ͥǤ̤ͥѤʤ
!  *		(A-4) (A-1)η̡ǥѥå뤳ȡ
!  *	(B) ߥ塼ƥåνini_mtxˤȼߥ塼ƥåå
!  *		ƤԤ֡ˤͥѹ
!  *		(B-1) ߥ塼ƥåξͥ٤ߥ塼ƥå
!  *			  åƤԤ֡ˤθͥ٤Ʊǡ
!  *			  ߥ塼ƥåΥåͥ٤٤ˡ
!  *			  ͥ٤Ŭڤ˲뤳ȡޤƱͥ
!  *			  ǤνǸˤʤ뤳
!  *		(B-2) ߥ塼ƥåξͥ٤ߥ塼ƥå
!  *			  åƤԤ֡ˤθͥ٤Ʊǡ
!  *			  ߥ塼ƥåΥåͥ٤Ѥ٤Ǥʤ
!  *			  ˡͥ٤ѤʤȡޤƱͥ
!  *			  ǤνѤʤ
!  *		(B-3) ߥ塼ƥåξͥ٤ߥ塼ƥå
!  *			  åƤԤ֡ˤθͥ٤㤤
!  *			  ˡͥ٤ѤʤȡޤƱͥ
!  *			  ǤνѤʤ
!  *	(C) ߥ塼ƥåνini_mtxˤȼߥ塼ƥåԤäƤ
!  *		ξѲ
!  *		(C-1) ߥ塼ƥåԤäƤԤ뤳ȡ
!  *		(C-2) (C-1)η̡ǥѥå뤳ȡ
   *
!  * ڥƥȹܤμ¸ˡ
   *
   *	(A-1)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		å֤ǡͥ٥TASK5ˤMTX1ƽ
!  *		TASK1ͥ٤ͥ٤˲뤳Ȥǧ롥ޤ¹Բǽ
!  *		֤ͥ٥TASK2ˤ⡤̤ͥ⤯ʤ뤳Ȥǧ
!  *		롥
   *	(A-2)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥå2
!  *		MTX1MTX2ˤå֤ǡͥ٥TASK5ˤ
!  *		MTX1ƽTASK1ͥ٤ѲʤȤǧ롥ޤ
!  *		¹Բǽ֤ͥ٥2ġTASK3TASK4ˤѰդƤ
!  *		̤ͥѤʤȤǧ롥
   *	(A-3)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX2ˤ
!  *		ͥپ¥ߥ塼ƥåMTX3ˤå֤ǡͥ
!  *		TASK5ˤMTX3ƽTASK1ͥ٤Ѳʤ
!  *		Ȥǧ롥ޤ¹Բǽ֤ͥ٥2ġTASK3
!  *		TASK4ˤѰդƤ̤ͥѤʤȤǧ롥
   *	(A-4)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX2ˤ
!  *		å֤ǡTASK1MTX2ƽTASK1ͥ٤
!  *		ͥ٤˲ꡤ¹Բǽ֤ͥ٥TASK4ˤڤ괹
!  *		뤳Ȥǧ롥ޤ¹Բǽ֤ͥ٥TASK2ˤ
!  *		⡤̤ͥ⤯ʤ뤳Ȥǧ롥
   *	(B-1)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		å֤ǡ̤Υߥ塼ƥåMTX4Ԥ֤Ȥͥ
!  *		٥TASK5ˤMTX1ƽTASK1ͥ٤ͥ
!  *		٤˲뤳Ȥǧ롥ޤMTX4Ԥ֤ͥ٥
!  *		TASK2ˤ⡤ԤǤνˤʤ뤳Ȥǧ롥
   *	(B-2)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥå2
!  *		MTX1MTX2ˤå֤ǡ̤Υߥ塼ƥåMTX4
!  *		֤Ȥͥ٥TASK5ˤMTX1ƽTASK1
!  *		ͥ٤ѲʤȤǧ롥ޤMTX4Ԥ֤ͥ
!  *		٥2ġTASK3TASK4ˤѰդƤԤǤν
!  *		ѤʤȤǧ롥
   *	(B-3)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX2ˤ
!  *		ͥپ¥ߥ塼ƥåMTX3ˤå֤ǡ̤Υߥ塼
!  *		ƥåMTX4Ԥ֤Ȥͥ٥TASK5ˤMTX3
!  *		ƽTASK1ͥ٤ѲʤȤǧ롥ޤ
!  *		MTX4Ԥ֤ͥ٥2ġTASK3TASK4ˤѰդƤ
!  *		ԤǤνѤʤȤǧ롥
   *	(C-1)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		ͥ٥TASK3ˤMTX1ԤäƤ֤ǡͥ
!  *		TASK5ˤMTX1ƽTASK3Ԥ뤳
!  *		ǧ롥ޤ¹Բǽ֤ͥ٥TASK4ˤ⡤
!  *		TASK3̤ͥ㤯ʤ뤳Ȥǧ롥
   *	(C-2)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		ͥ٥TASK3ˤMTX1ԤTASK1򵯾Ԥ
!  *		Ȥ֤ǡ̤ͥ٥TASK2ˤMTX1ƽ
!  *		TASK3Ԥ졤TASK3ڤ괹뤳Ȥǧ롥
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	TASK4: ͥ٥
!  *	TASK5: ͥ٥
!  *	MTX1: ߥ塼ƥåTA_CEILING°¤ͥ١
!  *	MTX2: ߥ塼ƥåTA_CEILING°¤ͥ١
!  *	MTX3: ߥ塼ƥåTA_CEILING°¤ͥ١
!  *	MTX4: ߥ塼ƥåTA_CEILING°¤Ϲͥ١
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_mutex))
   *	1:	loc_mtx(MTX1)
   *	2:	act_tsk(TASK2)
   *	3:	act_tsk(TASK5)
!  *	//		⡧TASK5桧TASK1㡧TASK2MTX1TASK1
!  *	== TASK5ͥ١==
   *	4:	ini_mtx(MTX1)			... (A-1)
!  *	//		⡧TASK5㡧TASK1TASK2
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == LOW_PRIORITY)
   *	5:	slp_tsk()
!  *	//		㡧TASK1TASK2
   *
!  *	== TASK1³==
   *	6:	sus_tsk(TASK2)
   *	7:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
   *	8:	act_tsk(TASK3)
!  *	//		桧TASK1TASK3MTX1TASK1MTX2TASK1
   *	9:	dis_dsp()
   *	10:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK3TASK1MTX1TASK1MTX2TASK1
   *	11:	act_tsk(TASK4)
!  *	//		桧TASK3TASK1TASK4MTX1TASK1MTX2TASK1
   *	12:	wup_tsk(TASK5)
!  *	//		⡧TASK5桧TASK3TASK1TASK4MTX1TASK1MTX2TASK1
   *	13:	ena_dsp()
!  *	== TASK5³==
   *	14:	ini_mtx(MTX1)			... (A-2)
!  *	//		⡧TASK5桧TASK3TASK1TASK4MTX2TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	15:	slp_tsk()
!  *	//		桧TASK3TASK1TASK4MTX2TASK1
!  *	== TASK3ͥ١==
   *	16:	slp_tsk()
!  *	//		桧TASK1TASK4MTX2TASK1
!  *	== TASK1³==
   *	17:	slp_tsk()
!  *	//		桧TASK4MTX2TASK1
!  *	== TASK4ͥ١==
   *	18:	wup_tsk(TASK1)
!  *	//		桧TASK4TASK1MTX2TASK1
   *	19:	slp_tsk()
!  *	//		桧TASK1MTX2TASK1
   *
!  *	== TASK1³==
   *	20:	loc_mtx(MTX3)
!  *	//		桧TASK1MTX2TASK1MTX3TASK1
   *	21:	wup_tsk(TASK3)
!  *	//		桧TASK1TASK3MTX2TASK1MTX3TASK1
   *	22:	dis_dsp()
   *	23:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK3TASK1MTX2TASK1MTX3TASK1
   *	24:	wup_tsk(TASK4)
!  *	//		桧TASK3TASK1TASK4MTX2TASK1MTX3TASK1
   *	25:	wup_tsk(TASK5)
!  *	//		⡧TASK5桧TASK3TASK1TASK4MTX2TASK1MTX3TASK1
   *	26:	ena_dsp()
!  *	== TASK5³==
   *	27:	ini_mtx(MTX3)			... (A-3)
!  *	//		⡧TASK5桧TASK3TASK1TASK4MTX2TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	28:	slp_tsk()
!  *	//		桧TASK3TASK1TASK4MTX2TASK1
!  *	== TASK3³==
   *	29:	slp_tsk()
!  *	//		桧TASK1TASK4MTX2TASK1
   *
!  *	== TASK1³==
   *	30:	slp_tsk()
!  *	//		桧TASK4MTX2TASK1
!  *	== TASK4³==
   *	31:	wup_tsk(TASK1)
!  *	//		桧TASK4TASK1MTX2TASK1
   *	32:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK1TASK4MTX2TASK1
!  *	== TASK1³==
   *	33:	rsm_tsk(TASK2)
!  *	//		桧TASK1TASK4㡧TASK2MTX2TASK1
   *	34:	ini_mtx(MTX2)			... (A-4)
!  *	//		桧TASK4㡧TASK1TASK2
!  *	== TASK4³==
   *	35:	get_pri(TASK1, &tskpri)
   *		assert(tskpri == LOW_PRIORITY)
   *	36:	slp_tsk()
!  *	//		㡧TASK1TASK2
   *
!  *	== TASK1³==
   *	37:	wup_tsk(TASK5)
!  *	== TASK5³==
   *	38:	loc_mtx(MTX4)
   *	39:	tslp_tsk(10) -> E_TMOUT
!  *	//		㡧TASK1TASK2MTX4TASK5
!  *	== TASK1³==
   *	40:	loc_mtx(MTX1)
!  *	//		桧TASK1㡧TASK2MTX1TASK1MTX4TASK5
   *	41:	loc_mtx(MTX4)
!  *	//		㡧TASK2MTX1TASK1MTX4TASK5TASK1
!  *	== TASK2ͥ١==
   *	42:	loc_mtx(MTX4)
!  *	//		MTX1TASK1MTX4TASK5TASK1TASK2
!  *	//		ॢԤ
!  *	//		⡧TASK5MTX1TASK1MTX4TASK5TASK1TASK2
!  *	== TASK5³==
   *	43:	ini_mtx(MTX1)			... (B-1)
!  *	//		⡧TASK5MTX4TASK5TASK2TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == LOW_PRIORITY)
   *	44:	unl_mtx(MTX4)
!  *	//		⡧TASK5TASK2MTX4TASK2TASK1
   *	45:	slp_tsk()
!  *	//		⡧TASK2MTX4TASK2TASK1
!  *	== TASK2³==
   *	46:	unl_mtx(MTX4)
!  *	//		⡧TASK1㡧TASK2MTX4TASK1
!  *	== TASK1³==
   *	47:	unl_mtx(MTX4)
!  *	//		㡧TASK1TASK2
   *
   *	48:	wup_tsk(TASK5)
!  *	== TASK5³==
   *	49:	loc_mtx(MTX4)
   *	50:	slp_tsk()
!  *	//		㡧TASK1TASK2MTX4TASK5
!  *	== TASK1³==
   *	51:	wup_tsk(TASK3)
!  *	//		桧TASK3㡧TASK1TASK2MTX4TASK5
!  *	== TASK3³==
   *	52:	loc_mtx(MTX4)
!  *	//		㡧TASK1TASK2MTX4TASK5TASK3
!  *	== TASK1³==
   *	53:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		桧TASK1㡧TASK2MTX1TASK1MTX2TASK1MTX4TASK5TASK3
   *	54:	loc_mtx(MTX4)
!  *	//		㡧TASK2MTX1TASK1MTX2TASK1MTX4TASK5TASK3TASK1
!  *	== TASK2³==
   *	55:	wup_tsk(TASK4)
!  *	== TASK4³==
   *	56:	loc_mtx(MTX4)
!  *	//		㡧TASK2MTX1TASK1MTX2TASK1
!  *	//								MTX4TASK5TASK3TASK1TASK4
!  *	== TASK2³==
   *	57:	wup_tsk(TASK5)
!  *	//		⡧TASK5㡧TASK2MTX1TASK1MTX2TASK1
!  *	//								MTX4TASK5TASK3TASK1TASK4
!  *	== TASK5³==
   *	58:	ini_mtx(MTX1)			... (B-2)
!  *	//		⡧TASK5㡧TASK2MTX2TASK1MTX4TASK5TASK3TASK1TASK4
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	59:	unl_mtx(MTX4)
!  *	//		⡧TASK5TASK3㡧TASK2MTX2TASK1MTX4TASK3TASK1TASK4
   *	60:	slp_tsk()
!  *	//		⡧TASK3㡧TASK2MTX2TASK1MTX4TASK3TASK1TASK4
!  *	== TASK3³==
   *	61:	unl_mtx(MTX4)
!  *	//		⡧TASK1桧TASK3㡧TASK2MTX2TASK1MTX4TASK1TASK4
!  *	== TASK1³==
   *	62:	unl_mtx(MTX4)
!  *	//		⡧TASK4桧TASK1TASK3㡧TASK2MTX2TASK1MTX4TASK4
!  *	== TASK4³==
   *	63:	unl_mtx(MTX4)
!  *	//		桧TASK4TASK1TASK3㡧TASK2MTX2TASK1
   *	64:	slp_tsk()
!  *	//		桧TASK1TASK3㡧TASK2MTX2TASK1
!  *	== TASK1³==
   *	65:	slp_tsk()
!  *	//		桧TASK3㡧TASK2MTX2TASK1
!  *	== TASK3³==
   *	66:	slp_tsk()
!  *	//		㡧TASK2MTX2TASK1
   *
!  *	== TASK2³==
   *	67: wup_tsk(TASK5)
!  *	== TASK5³==
   *	68:	loc_mtx(MTX4)
   *	69:	slp_tsk()
!  *	//		㡧TASK2MTX4TASK5
!  *	== TASK2³==
   *	70:	wup_tsk(TASK3)
!  *	== TASK3³==
   *	71:	loc_mtx(MTX4)
!  *	//		㡧TASK2MTX4TASK5TASK3
!  *	== TASK2³==
   *	72:	wup_tsk(TASK1)
!  *	//		桧TASK1㡧TASK2MTX4TASK5
!  *	== TASK1³==
   *	73:	loc_mtx(MTX3)
!  *	//		桧TASK1㡧TASK2MTX2TASK1MTX3TASK1MTX4TASK5TASK3
   *	74:	loc_mtx(MTX4)
!  *	//		㡧TASK2MTX2TASK1MTX3TASK1MTX4TASK5TASK3TASK1
!  *	== TASK2³==
   *	75:	wup_tsk(TASK4)
!  *	== TASK4³==
   *	76:	loc_mtx(MTX4)
!  *	//		㡧TASK2MTX2TASK1MTX3TASK1
!  *	//								MTX4TASK5TASK3TASK1TASK4
!  *	== TASK2³==
   *	77:	wup_tsk(TASK5)
!  *	//		⡧TASK5㡧TASK2MTX2TASK1MTX3TASK1
!  *	//								MTX4TASK5TASK3TASK1TASK4
!  *	== TASK5³==
   *	78:	ini_mtx(MTX3)			... (B-3)
!  *	//		⡧TASK5㡧TASK2MTX2TASK1MTX4TASK5TASK3TASK1TASK4
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	79:	unl_mtx(MTX4)
!  *	//		⡧TASK5TASK3㡧TASK2MTX2TASK1MTX4TASK3TASK1TASK4
   *	80:	slp_tsk()
!  *	//		⡧TASK3㡧TASK2MTX2TASK1MTX4TASK3TASK1TASK4
!  *	== TASK3³==
   *	81:	unl_mtx(MTX4)
!  *	//		⡧TASK1桧TASK3㡧TASK2MTX2TASK1MTX4TASK1TASK4
!  *	== TASK1³==
   *	82:	unl_mtx(MTX4)
!  *	//		⡧TASK4桧TASK1TASK3㡧TASK2MTX2TASK1MTX4TASK4
!  *	== TASK4³==
   *	83:	unl_mtx(MTX4)
!  *	//		桧TASK4TASK1TASK3㡧TASK2MTX2TASK1
   *	84:	slp_tsk()
!  *	//		桧TASK1TASK3㡧TASK2MTX2TASK1
!  *	== TASK1³==
   *	85:	unl_mtx(MTX2)
!  *	//		桧TASK3㡧TASK1TASK2
!  *	== TASK3³==
   *	86:	slp_tsk()
!  *	//		㡧TASK1TASK2
   *
!  *	== TASK1³==
   *	87:	sus_tsk(TASK2)
!  *	//		㡧TASK1
   *	88:	loc_mtx(MTX1)
!  *	//		桧TASK1MTX1TASK1
   *	89:	wup_tsk(TASK3)
!  *	//		桧TASK1TASK3MTX1TASK1
   *	90:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK3TASK1MTX1TASK1
!  *	== TASK3³==
   *	91:	loc_mtx(MTX1) -> E_DLT
!  *	//		桧TASK1MTX1TASK1TASK3
!  *	== TASK1³==
   *	92:	wup_tsk(TASK5)
!  *	//		⡧TASK5桧TASK1MTX1TASK1TASK3
!  *	== TASK5³==
   *	93:	wup_tsk(TASK4)
!  *	//		⡧TASK5桧TASK1TASK4MTX1TASK1TASK3
   *	94:	ini_mtx(MTX1)			... (C-1)
!  *	//		⡧TASK5桧TASK4TASK3㡧TASK1
   *	95:	ext_tsk() -> noreturn
!  *	//		桧TASK4TASK3㡧TASK1
!  *	== TASK4³==
   *	96:	ext_tsk() -> noreturn
!  *	//		桧TASK3㡧TASK1
!  *	== TASK3³==
   *	97:	slp_tsk()
!  *	//		㡧TASK1
   *
!  *	== TASK1³==
   *	98:	loc_mtx(MTX1)
!  *	//		桧TASK1MTX1TASK1
   *	99:	wup_tsk(TASK3)
!  *	//		桧TASK1TASK3MTX1TASK1
   * 100:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK3TASK1MTX1TASK1
!  *	== TASK3³==
   * 101:	loc_mtx(MTX1) -> E_DLT
!  *	//		桧TASK1MTX1TASK1TASK3
!  *	== TASK1³==
   * 102:	rsm_tsk(TASK2)
!  *	//		桧TASK1㡧TASK2MTX1TASK1TASK3
   * 103:	slp_tsk()
!  *	//		㡧TASK2MTX1TASK1TASK3
!  *	== TASK2³==
   * 104:	ini_mtx(MTX1)			... (C-2)
!  *	//		桧TASK3㡧TASK2
!  *	== TASK3³==
   * 105:	ext_tsk() -> noreturn
!  *	//		㡧TASK2
!  *	== TASK2³==
   * 106:	ter_tsk(TASK1)
   * 107:	END
   */
--- 5,446 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_mutex5.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(5)
   *
!  * 【テストの目的】
   *
!  *  優先度上限ミューテックスに対して，ミューテックスの再初期化処理を網
!  *  羅的にテストする．ただし，change_priorityとmutex_calc_priorityの内
!  *  容には踏み込まない．
!  *
!  * 【テスト項目】
!  *
!  *	(A) ミューテックスの初期化（ini_mtx）に伴うミューテックスをロックし
!  *		ていたタスク（実行できる状態）の優先度変更
!  *		(A-1) 初期化したミューテックスの上限優先度が，ミューテックスを
!  *			  ロックしていたタスク（実行できる状態）の現在優先度と同じ
!  *			  で，ミューテックスのロック解除で優先度が下がるべき場合に，
!  *			  当該タスクの優先度が適切に下げられること．また，同じ優先
!  *			  度内での優先順位が最高になること
!  *		(A-2) 初期化したミューテックスの上限優先度が，ミューテックスを
!  *			  ロックしていたタスク（実行できる状態）の現在優先度と同じ
!  *			  で，ミューテックスのロック解除で優先度が変わるべきでない
!  *			  場合に，当該タスクの優先度が変わらないこと．また，同じ優
!  *			  先度内での優先順位が変わらないこと
!  *		(A-3) 初期化したミューテックスの上限優先度が，ミューテックスを
!  *			  ロックしていたタスク（実行できる状態）の現在優先度よりも
!  *			  低い場合に，当該タスクの優先度が変わらないこと．また，同
!  *			  じ優先度内での優先順位が変わらないこと
!  *		(A-4) (A-1)の結果，タスクディスパッチが起こること．
!  *	(B) ミューテックスの初期化（ini_mtx）に伴うミューテックスをロックし
!  *		ていたタスク（待ち状態）の優先度変更
!  *		(B-1) 初期化したミューテックスの上限優先度が，ミューテックスを
!  *			  ロックしていたタスク（待ち状態）の現在優先度と同じで，
!  *			  ミューテックスのロック解除で優先度が下がるべき場合に，当
!  *			  該タスクの優先度が適切に下げられること．また，同じ優先度
!  *			  内での順序が最後になること
!  *		(B-2) 初期化したミューテックスの上限優先度が，ミューテックスを
!  *			  ロックしていたタスク（待ち状態）の現在優先度と同じで，
!  *			  ミューテックスのロック解除で優先度が変わるべきでない場合
!  *			  に，当該タスクの優先度が変わらないこと．また，同じ優先度
!  *			  内での順序が変わらないこと
!  *		(B-3) 初期化したミューテックスの上限優先度が，ミューテックスを
!  *			  ロックしていたタスク（待ち状態）の現在優先度よりも低い場
!  *			  合に，当該タスクの優先度が変わらないこと．また，同じ優先
!  *			  度内での順序が変わらないこと
!  *	(C) ミューテックスの初期化（ini_mtx）に伴うミューテックスを待ってい
!  *		たタスクの状態変化
!  *		(C-1) ミューテックスを待っていたタスクが待ち解除されること．
!  *		(C-2) (C-1)の結果，タスクディスパッチが起こること．
   *
!  * 【テスト項目の実現方法】
   *
   *	(A-1)
!  *		低優先度タスク（TASK1）が，中優先度上限ミューテックス（MTX1）を
!  *		ロックした状態で，高優先度タスク（TASK5）からMTX1を再初期化し，
!  *		TASK1の優先度が低優先度に下がることを確認する．また，実行可能状
!  *		態の低優先度タスク（TASK2）よりも，優先順位が高くなることを確認
!  *		する．　
   *	(A-2)
!  *		低優先度タスク（TASK1）が，中優先度上限ミューテックスを2つ
!  *		（MTX1，MTX2）をロックした状態で，高優先度タスク（TASK5）から
!  *		MTX1を再初期化し，TASK1の優先度が変化しないことを確認する．また，
!  *		実行可能状態の中優先度タスクを2つ（TASK3，TASK4）を用意しておき，
!  *		優先順位が変わらないことを確認する．
   *	(A-3)
!  *		低優先度タスク（TASK1）が，中優先度上限ミューテックス（MTX2）と
!  *		低優先度上限ミューテックス（MTX3）をロックした状態で，高優先度
!  *		タスク（TASK5）からMTX3を再初期化し，TASK1の優先度が変化しない
!  *		ことを確認する．また，実行可能状態の中優先度タスクを2つ（TASK3，
!  *		TASK4）を用意しておき，優先順位が変わらないことを確認する．
   *	(A-4)
!  *		低優先度タスク（TASK1）が，中優先度上限ミューテックス（MTX2）を
!  *		ロックした状態で，TASK1からMTX2を再初期化し，TASK1の優先度が低
!  *		優先度に下がり，実行可能状態の中優先度タスク（TASK4）に切り換わ
!  *		ることを確認する．また，実行可能状態の低優先度タスク（TASK2）よ
!  *		りも，優先順位が高くなることを確認する．　
   *	(B-1)
!  *		低優先度タスク（TASK1）が，中優先度上限ミューテックス（MTX1）を
!  *		ロックした状態で，別のミューテックス（MTX4）待ち状態とし，高優
!  *		先度タスク（TASK5）からMTX1を再初期化し，TASK1の優先度が低優先
!  *		度に下がることを確認する．また，MTX4待ち状態の低優先度タスク
!  *		（TASK2）よりも，待ち行列中での順序が後になることを確認する．
   *	(B-2)
!  *		低優先度タスク（TASK1）が，中優先度上限ミューテックスを2つ
!  *		（MTX1，MTX2）をロックした状態で，別のミューテックス（MTX4）待
!  *		ち状態とし，高優先度タスク（TASK5）からMTX1を再初期化し，TASK1
!  *		の優先度が変化しないことを確認する．また，MTX4待ち状態の中優先
!  *		度タスクを2つ（TASK3，TASK4）を用意しておき，待ち行列中での順序
!  *		が変わらないことを確認する．
   *	(B-3)
!  *		低優先度タスク（TASK1）が，中優先度上限ミューテックス（MTX2）と
!  *		低優先度上限ミューテックス（MTX3）をロックした状態で，別のミュー
!  *		テックス（MTX4）待ち状態とし，高優先度タスク（TASK5）からMTX3を
!  *		再初期化し，TASK1の優先度が変化しないことを確認する．また，
!  *		MTX4待ち状態の中優先度タスクを2つ（TASK3，TASK4）を用意しておき，
!  *		待ち行列中での順序が変わらないことを確認する．
   *	(C-1)
!  *		低優先度タスク（TASK1）が中優先度上限ミューテックス（MTX1）をロッ
!  *		クし，中優先度タスク（TASK3）がMTX1を待っている状態で，高優先度
!  *		タスク（TASK5）からMTX1を再初期化し，TASK3が待ち解除されること
!  *		を確認する．また，実行可能状態の中優先度タスク（TASK4）よりも，
!  *		TASK3の方が優先順位が低くなることを確認する．　
   *	(C-2)
!  *		低優先度タスク（TASK1）が中優先度上限ミューテックス（MTX1）をロッ
!  *		クし，中優先度タスク（TASK3）がMTX1を待ち，TASK1を起床待ち状態
!  *		とした状態で，別の低優先度タスク（TASK2）からMTX1を再初期化し，
!  *		TASK3が待ち解除され，TASK3に切り換わることを確認する．
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 低優先度タスク，メインタスク，最初から起動
!  *	TASK2: 低優先度タスク
!  *	TASK3: 中優先度タスク
!  *	TASK4: 中優先度タスク
!  *	TASK5: 高優先度タスク
!  *	MTX1: ミューテックス（TA_CEILING属性，上限は中優先度）
!  *	MTX2: ミューテックス（TA_CEILING属性，上限は中優先度）
!  *	MTX3: ミューテックス（TA_CEILING属性，上限は低優先度）
!  *	MTX4: ミューテックス（TA_CEILING属性，上限は高優先度）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：低）==
   *		call(set_bit_func(bit_mutex))
   *	1:	loc_mtx(MTX1)
   *	2:	act_tsk(TASK2)
   *	3:	act_tsk(TASK5)
!  *	//		高：TASK5，中：TASK1，低：TASK2，MTX1：TASK1
!  *	== TASK5（優先度：高）==
   *	4:	ini_mtx(MTX1)			... (A-1)
!  *	//		高：TASK5，低：TASK1→TASK2
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == LOW_PRIORITY)
   *	5:	slp_tsk()
!  *	//		低：TASK1→TASK2
   *
!  *	== TASK1（続き）==
   *	6:	sus_tsk(TASK2)
   *	7:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
   *	8:	act_tsk(TASK3)
!  *	//		中：TASK1→TASK3，MTX1：TASK1，MTX2：TASK1
   *	9:	dis_dsp()
   *	10:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK3→TASK1，MTX1：TASK1，MTX2：TASK1
   *	11:	act_tsk(TASK4)
!  *	//		中：TASK3→TASK1→TASK4，MTX1：TASK1，MTX2：TASK1
   *	12:	wup_tsk(TASK5)
!  *	//		高：TASK5，中：TASK3→TASK1→TASK4，MTX1：TASK1，MTX2：TASK1
   *	13:	ena_dsp()
!  *	== TASK5（続き）==
   *	14:	ini_mtx(MTX1)			... (A-2)
!  *	//		高：TASK5，中：TASK3→TASK1→TASK4，MTX2：TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	15:	slp_tsk()
!  *	//		中：TASK3→TASK1→TASK4，MTX2：TASK1
!  *	== TASK3（優先度：中）==
   *	16:	slp_tsk()
!  *	//		中：TASK1→TASK4，MTX2：TASK1
!  *	== TASK1（続き）==
   *	17:	slp_tsk()
!  *	//		中：TASK4，MTX2：TASK1
!  *	== TASK4（優先度：中）==
   *	18:	wup_tsk(TASK1)
!  *	//		中：TASK4→TASK1，MTX2：TASK1
   *	19:	slp_tsk()
!  *	//		中：TASK1，MTX2：TASK1
   *
!  *	== TASK1（続き）==
   *	20:	loc_mtx(MTX3)
!  *	//		中：TASK1，MTX2：TASK1，MTX3：TASK1
   *	21:	wup_tsk(TASK3)
!  *	//		中：TASK1→TASK3，MTX2：TASK1，MTX3：TASK1
   *	22:	dis_dsp()
   *	23:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK3→TASK1，MTX2：TASK1，MTX3：TASK1
   *	24:	wup_tsk(TASK4)
!  *	//		中：TASK3→TASK1→TASK4，MTX2：TASK1，MTX3：TASK1
   *	25:	wup_tsk(TASK5)
!  *	//		高：TASK5，中：TASK3→TASK1→TASK4，MTX2：TASK1，MTX3：TASK1
   *	26:	ena_dsp()
!  *	== TASK5（続き）==
   *	27:	ini_mtx(MTX3)			... (A-3)
!  *	//		高：TASK5，中：TASK3→TASK1→TASK4，MTX2：TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	28:	slp_tsk()
!  *	//		中：TASK3→TASK1→TASK4，MTX2：TASK1
!  *	== TASK3（続き）==
   *	29:	slp_tsk()
!  *	//		中：TASK1→TASK4，MTX2：TASK1
   *
!  *	== TASK1（続き）==
   *	30:	slp_tsk()
!  *	//		中：TASK4，MTX2：TASK1
!  *	== TASK4（続き）==
   *	31:	wup_tsk(TASK1)
!  *	//		中：TASK4→TASK1，MTX2：TASK1
   *	32:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK1→TASK4，MTX2：TASK1
!  *	== TASK1（続き）==
   *	33:	rsm_tsk(TASK2)
!  *	//		中：TASK1→TASK4，低：TASK2，MTX2：TASK1
   *	34:	ini_mtx(MTX2)			... (A-4)
!  *	//		中：TASK4，低：TASK1→TASK2
!  *	== TASK4（続き）==
   *	35:	get_pri(TASK1, &tskpri)
   *		assert(tskpri == LOW_PRIORITY)
   *	36:	slp_tsk()
!  *	//		低：TASK1→TASK2
   *
!  *	== TASK1（続き）==
   *	37:	wup_tsk(TASK5)
!  *	== TASK5（続き）==
   *	38:	loc_mtx(MTX4)
   *	39:	tslp_tsk(10) -> E_TMOUT
!  *	//		低：TASK1→TASK2，MTX4：TASK5
!  *	== TASK1（続き）==
   *	40:	loc_mtx(MTX1)
!  *	//		中：TASK1，低：TASK2，MTX1：TASK1，MTX4：TASK5
   *	41:	loc_mtx(MTX4)
!  *	//		低：TASK2，MTX1：TASK1，MTX4：TASK5→TASK1
!  *	== TASK2（優先度：低）==
   *	42:	loc_mtx(MTX4)
!  *	//		MTX1：TASK1，MTX4：TASK5→TASK1→TASK2
!  *	//		タイムアウト待ち
!  *	//		高：TASK5，MTX1：TASK1，MTX4：TASK5→TASK1→TASK2
!  *	== TASK5（続き）==
   *	43:	ini_mtx(MTX1)			... (B-1)
!  *	//		高：TASK5，MTX4：TASK5→TASK2→TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == LOW_PRIORITY)
   *	44:	unl_mtx(MTX4)
!  *	//		高：TASK5→TASK2，MTX4：TASK2→TASK1
   *	45:	slp_tsk()
!  *	//		高：TASK2，MTX4：TASK2→TASK1
!  *	== TASK2（続き）==
   *	46:	unl_mtx(MTX4)
!  *	//		高：TASK1，低：TASK2，MTX4：TASK1
!  *	== TASK1（続き）==
   *	47:	unl_mtx(MTX4)
!  *	//		低：TASK1→TASK2
   *
   *	48:	wup_tsk(TASK5)
!  *	== TASK5（続き）==
   *	49:	loc_mtx(MTX4)
   *	50:	slp_tsk()
!  *	//		低：TASK1→TASK2，MTX4：TASK5
!  *	== TASK1（続き）==
   *	51:	wup_tsk(TASK3)
!  *	//		中：TASK3，低：TASK1→TASK2，MTX4：TASK5
!  *	== TASK3（続き）==
   *	52:	loc_mtx(MTX4)
!  *	//		低：TASK1→TASK2，MTX4：TASK5→TASK3
!  *	== TASK1（続き）==
   *	53:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		中：TASK1，低：TASK2，MTX1：TASK1，MTX2：TASK1，MTX4：TASK5→TASK3
   *	54:	loc_mtx(MTX4)
!  *	//		低：TASK2，MTX1：TASK1，MTX2：TASK1，MTX4：TASK5→TASK3→TASK1
!  *	== TASK2（続き）==
   *	55:	wup_tsk(TASK4)
!  *	== TASK4（続き）==
   *	56:	loc_mtx(MTX4)
!  *	//		低：TASK2，MTX1：TASK1，MTX2：TASK1，
!  *	//								MTX4：TASK5→TASK3→TASK1→TASK4
!  *	== TASK2（続き）==
   *	57:	wup_tsk(TASK5)
!  *	//		高：TASK5，低：TASK2，MTX1：TASK1，MTX2：TASK1，
!  *	//								MTX4：TASK5→TASK3→TASK1→TASK4
!  *	== TASK5（続き）==
   *	58:	ini_mtx(MTX1)			... (B-2)
!  *	//		高：TASK5，低：TASK2，MTX2：TASK1，MTX4：TASK5→TASK3→TASK1→TASK4
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	59:	unl_mtx(MTX4)
!  *	//		高：TASK5→TASK3，低：TASK2，MTX2：TASK1，MTX4：TASK3→TASK1→TASK4
   *	60:	slp_tsk()
!  *	//		高：TASK3，低：TASK2，MTX2：TASK1，MTX4：TASK3→TASK1→TASK4
!  *	== TASK3（続き）==
   *	61:	unl_mtx(MTX4)
!  *	//		高：TASK1，中：TASK3，低：TASK2，MTX2：TASK1，MTX4：TASK1→TASK4
!  *	== TASK1（続き）==
   *	62:	unl_mtx(MTX4)
!  *	//		高：TASK4，中：TASK1→TASK3，低：TASK2，MTX2：TASK1，MTX4：TASK4
!  *	== TASK4（続き）==
   *	63:	unl_mtx(MTX4)
!  *	//		中：TASK4→TASK1→TASK3，低：TASK2，MTX2：TASK1
   *	64:	slp_tsk()
!  *	//		中：TASK1→TASK3，低：TASK2，MTX2：TASK1
!  *	== TASK1（続き）==
   *	65:	slp_tsk()
!  *	//		中：TASK3，低：TASK2，MTX2：TASK1
!  *	== TASK3（続き）==
   *	66:	slp_tsk()
!  *	//		低：TASK2，MTX2：TASK1
   *
!  *	== TASK2（続き）==
   *	67: wup_tsk(TASK5)
!  *	== TASK5（続き）==
   *	68:	loc_mtx(MTX4)
   *	69:	slp_tsk()
!  *	//		低：TASK2，MTX4：TASK5
!  *	== TASK2（続き）==
   *	70:	wup_tsk(TASK3)
!  *	== TASK3（続き）==
   *	71:	loc_mtx(MTX4)
!  *	//		低：TASK2，MTX4：TASK5→TASK3
!  *	== TASK2（続き）==
   *	72:	wup_tsk(TASK1)
!  *	//		中：TASK1，低：TASK2，MTX4：TASK5
!  *	== TASK1（続き）==
   *	73:	loc_mtx(MTX3)
!  *	//		中：TASK1，低：TASK2，MTX2：TASK1，MTX3：TASK1，MTX4：TASK5→TASK3
   *	74:	loc_mtx(MTX4)
!  *	//		低：TASK2，MTX2：TASK1，MTX3：TASK1，MTX4：TASK5→TASK3→TASK1
!  *	== TASK2（続き）==
   *	75:	wup_tsk(TASK4)
!  *	== TASK4（続き）==
   *	76:	loc_mtx(MTX4)
!  *	//		低：TASK2，MTX2：TASK1，MTX3：TASK1，
!  *	//								MTX4：TASK5→TASK3→TASK1→TASK4
!  *	== TASK2（続き）==
   *	77:	wup_tsk(TASK5)
!  *	//		高：TASK5，低：TASK2，MTX2：TASK1，MTX3：TASK1，
!  *	//								MTX4：TASK5→TASK3→TASK1→TASK4
!  *	== TASK5（続き）==
   *	78:	ini_mtx(MTX3)			... (B-3)
!  *	//		高：TASK5，低：TASK2，MTX2：TASK1，MTX4：TASK5→TASK3→TASK1→TASK4
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	79:	unl_mtx(MTX4)
!  *	//		高：TASK5→TASK3，低：TASK2，MTX2：TASK1，MTX4：TASK3→TASK1→TASK4
   *	80:	slp_tsk()
!  *	//		高：TASK3，低：TASK2，MTX2：TASK1，MTX4：TASK3→TASK1→TASK4
!  *	== TASK3（続き）==
   *	81:	unl_mtx(MTX4)
!  *	//		高：TASK1，中：TASK3，低：TASK2，MTX2：TASK1，MTX4：TASK1→TASK4
!  *	== TASK1（続き）==
   *	82:	unl_mtx(MTX4)
!  *	//		高：TASK4，中：TASK1→TASK3，低：TASK2，MTX2：TASK1，MTX4：TASK4
!  *	== TASK4（続き）==
   *	83:	unl_mtx(MTX4)
!  *	//		中：TASK4→TASK1→TASK3，低：TASK2，MTX2：TASK1
   *	84:	slp_tsk()
!  *	//		中：TASK1→TASK3，低：TASK2，MTX2：TASK1
!  *	== TASK1（続き）==
   *	85:	unl_mtx(MTX2)
!  *	//		中：TASK3，低：TASK1→TASK2
!  *	== TASK3（続き）==
   *	86:	slp_tsk()
!  *	//		低：TASK1→TASK2
   *
!  *	== TASK1（続き）==
   *	87:	sus_tsk(TASK2)
!  *	//		低：TASK1
   *	88:	loc_mtx(MTX1)
!  *	//		中：TASK1，MTX1：TASK1
   *	89:	wup_tsk(TASK3)
!  *	//		中：TASK1→TASK3，MTX1：TASK1
   *	90:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK3→TASK1，MTX1：TASK1
!  *	== TASK3（続き）==
   *	91:	loc_mtx(MTX1) -> E_DLT
!  *	//		中：TASK1，MTX1：TASK1→TASK3
!  *	== TASK1（続き）==
   *	92:	wup_tsk(TASK5)
!  *	//		高：TASK5，中：TASK1，MTX1：TASK1→TASK3
!  *	== TASK5（続き）==
   *	93:	wup_tsk(TASK4)
!  *	//		高：TASK5，中：TASK1→TASK4，MTX1：TASK1→TASK3
   *	94:	ini_mtx(MTX1)			... (C-1)
!  *	//		高：TASK5，中：TASK4→TASK3，低：TASK1
   *	95:	ext_tsk() -> noreturn
!  *	//		中：TASK4→TASK3，低：TASK1
!  *	== TASK4（続き）==
   *	96:	ext_tsk() -> noreturn
!  *	//		中：TASK3，低：TASK1
!  *	== TASK3（続き）==
   *	97:	slp_tsk()
!  *	//		低：TASK1
   *
!  *	== TASK1（続き）==
   *	98:	loc_mtx(MTX1)
!  *	//		中：TASK1，MTX1：TASK1
   *	99:	wup_tsk(TASK3)
!  *	//		中：TASK1→TASK3，MTX1：TASK1
   * 100:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK3→TASK1，MTX1：TASK1
!  *	== TASK3（続き）==
   * 101:	loc_mtx(MTX1) -> E_DLT
!  *	//		中：TASK1，MTX1：TASK1→TASK3
!  *	== TASK1（続き）==
   * 102:	rsm_tsk(TASK2)
!  *	//		中：TASK1，低：TASK2，MTX1：TASK1→TASK3
   * 103:	slp_tsk()
!  *	//		低：TASK2，MTX1：TASK1→TASK3
!  *	== TASK2（続き）==
   * 104:	ini_mtx(MTX1)			... (C-2)
!  *	//		中：TASK3，低：TASK2
!  *	== TASK3（続き）==
   * 105:	ext_tsk() -> noreturn
!  *	//		低：TASK2
!  *	== TASK2（続き）==
   * 106:	ter_tsk(TASK1)
   * 107:	END
   */
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex5.cfg ASPs/asp/extension/mutex/test/test_mutex5.cfg
*** 1.9.1/asp/extension/mutex/test/test_mutex5.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex5.cfg	Fri Dec  9 13:54:02 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ߥ塼ƥåΥƥ(5)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  ミューテックスのテスト(5)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex5.h ASPs/asp/extension/mutex/test/test_mutex5.h
*** 1.9.1/asp/extension/mutex/test/test_mutex5.h	Sat Jan  2 01:01:35 2010
--- ASPs/asp/extension/mutex/test/test_mutex5.h	Fri Dec  9 13:54:02 2022
***************
*** 5,67 ****
   *  Copyright (C) 2007-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_mutex5.h 1696 2010-01-01 16:01:25Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(5)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2007-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_mutex5.h 1696 2010-01-01 16:01:25Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(5)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex6.c ASPs/asp/extension/mutex/test/test_mutex6.c
*** 1.9.1/asp/extension/mutex/test/test_mutex6.c	Sat Jan 11 23:15:56 2014
--- ASPs/asp/extension/mutex/test/test_mutex6.c	Fri Dec  9 13:54:02 2022
***************
*** 5,121 ****
   *  Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_mutex6.c 2606 2014-01-11 14:15:55Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(6)
   *
!  * ڥƥȤŪ
   *
!  *  ͥپ¥ߥ塼ƥåФơνλͥ
!  *  βžΥߥ塼ƥåϢνŪ˥ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) νλext_tsk
!  *		(A-1) åƤߥ塼ƥå1ġˤå뤳ȡ
!  *		(A-2) åƤߥ塼ƥå1ġˤå졤
!  *			  ԤäƤåͥ٤Ѳ
!  *			  뤳ȡ
!  *		(A-3) åƤߥ塼ƥåʣˤ٤ƥå
!  *			  뤳ȡ
!  *		(A-4) åƤߥ塼ƥåʣˤå졤
!  *			  ԤäƤʣˤåͥ٤
!  *			  Ԥ뤳ȡλˡǥߥ塼ƥå
!  *			  å˥åƤߥ塼ƥåԤ
!  *			  Ƥˤ̤ͥ⤯ʤ뤳ȡ
!  *	(B) ̤ͥβžrot_rdq
!  *		(B-1) TPRI_SELFꤷˡΥ١ͥ٤̤ͥ
!  *		ž뤳ȡ
!  *		(B-2) TPRI_SELFꤷˡθͥ٤̤ͥ
!  *		žʤȡ
   *
!  * ڥƥȹܤμ¸ˡ
   *
   *	(A-1)
!  *		ͥ٥TASK2ˤ˥ߥ塼ƥåMTX1ˤå
!  *		ext_tskȡå뤳Ȥǧ롥
   *	(A-2)
!  *		ͥ٥TASK2ˤ˹ͥپ¥ߥ塼ƥåMTX1ˤ
!  *		̤ͥ٥TASK3ˤMTX1Ԥ֤ǡ
!  *		TASK2 ext_tskȡTASK3ͥ٤ˤʤäԤ뤳
!  *		Ȥǧ롥
   *	(A-3)
!  *		ͥ٥TASK2ˤ˥ߥ塼ƥå2ġMTX1MTX2˥
!  *		ext_tskȡξΥå뤳Ȥǧ롥
   *	(A-4)
!  *		ͥ٥TASK2ˤ˹ͥپ¥ߥ塼ƥå2ġMTX1
!  *		MTX2ˤ򤳤νǥå̤ͥ٥2ġTASK3
!  *		TASK4ˤˤ줾ΥåԤ֤ǡTASK2ext_tskȡ
!  *		TASK3TASK4ͥ٤ˤʤäԤ뤳Ȥǧ롥
!  *		˥åƤߥ塼ƥåMTX1ˤԤäƤ
!  *		TASK3ˤTASK4̤ͥ⤯ʤ뤳Ȥǧ롥
   *	(B-1)
!  *		ͥ٥3ġTASK2TASK3TASK4ˤ¹ԤǤ֤λ
!  *		ˡ1Ĥͥ٥TASK2ˤ˹ͥپ¥ߥ塼ƥå
!  *		årot_rdq(TPRI_SELF)ȡĤ2Ĥͥ٥
!  *		̤ͥž뤳Ȥǧ롥
   *	(B-2)
!  *		Ʊǡͥ٥̤ͥžʤȤǧ
!  *		롥
   *
!  * ڻѥ꥽
   *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	TASK4: ͥ٥
!  *	MTX1: ߥ塼ƥåTA_CEILING°¤Ϲͥ١
!  *	MTX2: ߥ塼ƥåTA_CEILING°¤Ϲͥ١
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_mutex))
   *	1:	act_tsk(TASK2)
   *	2:	rot_rdq(TPRI_SELF)
!  *	//		㡧TASK2TASK1
!  *	== TASK2-1ͥ١1 ==
   *	3:	loc_mtx(MTX1)
!  *	//		⡧TASK2㡧TASK1MTX1TASK2
   *	4:	ext_tsk() -> noreturn			... (A-1)
!  *	//		㡧TASK1
!  *	== TASK1³==
   *	5:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
   *		assert(rmtx.wtskid == TSK_NONE)
--- 5,121 ----
   *  Copyright (C) 2007-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_mutex6.c 2606 2014-01-11 14:15:55Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(6)
   *
!  * 【テストの目的】
   *
!  *  優先度上限ミューテックスに対して，タスクの終了時，タスクの優先順位
!  *  の回転時のミューテックス関連の処理を網羅的にテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) タスクの終了時（ext_tsk）
!  *		(A-1) ロックしていたミューテックス（1つ）がロック解除されること．
!  *		(A-2) ロックしていたミューテックス（1つ）がロック解除され，ロッ
!  *			  クを待っていたタスクがそれをロックし，優先度が変化し，待
!  *			  ち解除されること．
!  *		(A-3) ロックしていたミューテックス（複数）がすべてロック解除さ
!  *			  れること．
!  *		(A-4) ロックしていたミューテックス（複数）がロック解除され，ロッ
!  *			  クを待っていたタスク（複数）がそれをロックし，優先度が変
!  *			  化し，待ち解除されること．その時に，後でミューテックスを
!  *			  ロックしたタスク（先にロックしていたミューテックスを待っ
!  *			  ていたタスク）の方が，優先順位が高くなること．
!  *	(B) タスクの優先順位の回転（rot_rdq）
!  *		(B-1) TPRI_SELFを指定した時に，タスクのベース優先度の優先順位が
!  *		　　　回転すること．
!  *		(B-2) TPRI_SELFを指定した時に，タスクの現在優先度の優先順位が回
!  *		　　　転しないこと．
   *
!  * 【テスト項目の実現方法】
   *
   *	(A-1)
!  *		低優先度タスク（TASK2）にミューテックス（MTX1）をロックさせ，
!  *		ext_tskすると，ロックが解除されることを確認する．
   *	(A-2)
!  *		低優先度タスク（TASK2）に高優先度上限ミューテックス（MTX1）をロッ
!  *		クさせ，別の低優先度タスク（TASK3）にMTX1を待たせた状態で，
!  *		TASK2 がext_tskすると，TASK3が高優先度になって待ち解除されるこ
!  *		とを確認する．
   *	(A-3)
!  *		低優先度タスク（TASK2）にミューテックスを2つ（MTX1，MTX2）ロッ
!  *		クさせ，ext_tskすると，両方のロックが解除されることを確認する．
   *	(A-4)
!  *		低優先度タスク（TASK2）に高優先度上限ミューテックス2つ（MTX1，
!  *		MTX2）をこの順でロックさせ，別の低優先度タスク2つ（TASK3，
!  *		TASK4）にそれぞれのロックを待たせた状態で，TASK2をext_tskすると，
!  *		TASK3とTASK4が高優先度になって待ち解除されることを確認する．ま
!  *		た，先にロックしていたミューテックス（MTX1）を待っていたタスク
!  *		（TASK3）が，TASK4よりも優先順位が高くなることを確認する．
   *	(B-1)
!  *		低優先度タスクが3つ（TASK2，TASK3，TASK4）が実行できる状態の時
!  *		に，1つの低優先度タスク（TASK2）に高優先度上限ミューテックスを
!  *		ロックさせ，rot_rdq(TPRI_SELF)すると，残りの2つの低優先度タスク
!  *		の優先順位が回転することを確認する．
   *	(B-2)
!  *		上と同じ状況で，高優先度タスクの優先順位が回転しないことを確認
!  *		する．
   *
!  * 【使用リソース】
   *
!  *	TASK1: 低優先度タスク，メインタスク，最初から起動
!  *	TASK2: 低優先度タスク
!  *	TASK3: 低優先度タスク
!  *	TASK4: 低優先度タスク
!  *	MTX1: ミューテックス（TA_CEILING属性，上限は高優先度）
!  *	MTX2: ミューテックス（TA_CEILING属性，上限は高優先度）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：低）==
   *		call(set_bit_func(bit_mutex))
   *	1:	act_tsk(TASK2)
   *	2:	rot_rdq(TPRI_SELF)
!  *	//		低：TASK2→TASK1
!  *	== TASK2-1（優先度：低）1回め ==
   *	3:	loc_mtx(MTX1)
!  *	//		高：TASK2，低：TASK1，MTX1：TASK2
   *	4:	ext_tsk() -> noreturn			... (A-1)
!  *	//		低：TASK1
!  *	== TASK1（続き）==
   *	5:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
   *		assert(rmtx.wtskid == TSK_NONE)
***************
*** 123,144 ****
   *	6:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *	7:	rot_rdq(TPRI_SELF)
!  *	//		㡧TASK2TASK3TASK1
!  *	== TASK2-2ͥ١2 ==
   *	8:	loc_mtx(MTX1)
!  *	//		⡧TASK2㡧TASK3TASK1MTX1TASK2
   *	9:	slp_tsk()
!  *	//		㡧TASK3TASK1MTX1TASK2
!  *	== TASK3ͥ١==
   *	10:	loc_mtx(MTX1)
!  *	//		㡧TASK1MTX1TASK2TASK3
!  *	== TASK1³==
   *	11:	wup_tsk(TASK2)
!  *	//		⡧TASK2㡧TASK1MTX1TASK2TASK3
!  *	== TASK2-2³==
   *	12:	ext_tsk() -> noreturn			... (A-2)
!  *	//		⡧TASK3㡧TASK1MTX1TASK3
!  *	== TASK3³==
   *	13:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
--- 123,144 ----
   *	6:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *	7:	rot_rdq(TPRI_SELF)
!  *	//		低：TASK2→TASK3→TASK1
!  *	== TASK2-2（優先度：低）2回め ==
   *	8:	loc_mtx(MTX1)
!  *	//		高：TASK2，低：TASK3→TASK1，MTX1：TASK2
   *	9:	slp_tsk()
!  *	//		低：TASK3→TASK1，MTX1：TASK2
!  *	== TASK3（優先度：低）==
   *	10:	loc_mtx(MTX1)
!  *	//		低：TASK1，MTX1：TASK2→TASK3
!  *	== TASK1（続き）==
   *	11:	wup_tsk(TASK2)
!  *	//		高：TASK2，低：TASK1，MTX1：TASK2→TASK3
!  *	== TASK2-2（続き）==
   *	12:	ext_tsk() -> noreturn			... (A-2)
!  *	//		高：TASK3，低：TASK1，MTX1：TASK3
!  *	== TASK3（続き）==
   *	13:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
***************
*** 146,164 ****
   *		assert(tskpri == HIGH_PRIORITY)
   *		unl_mtx(MTX1)
   *		slp_tsk()
!  *	//		㡧TASK1
   *
!  *	== TASK1³==
   *	14:	act_tsk(TASK2)
   *	15:	rot_rdq(TPRI_SELF)
!  *	//		㡧TASK2TASK1
!  *	== TASK2-3ͥ١3 ==
   *	16:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		⡧TASK2㡧TASK1MTX1TASK2MTX2TASK2
   *	17:	ext_tsk() -> noreturn			... (A-3)
!  *	//		㡧TASK1
!  *	== TASK1³==
   *	18:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
   *		assert(rmtx.wtskid == TSK_NONE)
--- 146,164 ----
   *		assert(tskpri == HIGH_PRIORITY)
   *		unl_mtx(MTX1)
   *		slp_tsk()
!  *	//		低：TASK1
   *
!  *	== TASK1（続き）==
   *	14:	act_tsk(TASK2)
   *	15:	rot_rdq(TPRI_SELF)
!  *	//		低：TASK2→TASK1
!  *	== TASK2-3（優先度：低）3回め ==
   *	16:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		高：TASK2，低：TASK1，MTX1：TASK2，MTX2：TASK2
   *	17:	ext_tsk() -> noreturn			... (A-3)
!  *	//		低：TASK1
!  *	== TASK1（続き）==
   *	18:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
   *		assert(rmtx.wtskid == TSK_NONE)
***************
*** 170,202 ****
   *		wup_tsk(TASK3)
   *		act_tsk(TASK4)
   *	20:	rot_rdq(TPRI_SELF)
!  *	//		㡧TASK2TASK3TASK4TASK1
!  *	== TASK2-4ͥ١4 ==
   *	21:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		⡧TASK2㡧TASK3TASK4TASK1MTX1TASK2MTX2TASK2
   *	22:	chg_pri(TASK1, HIGH_PRIORITY)
!  *	//		⡧TASK2TASK1㡧TASK3TASK4MTX1TASK2MTX2TASK2
   *	23:	rot_rdq(TPRI_SELF)				... (B-1)(B-2)
!  *	//		⡧TASK2TASK1㡧TASK4TASK3MTX1TASK2MTX2TASK2
   *	24:	slp_tsk()
!  *	//		⡧TASK1㡧TASK4TASK3MTX1TASK2MTX2TASK2
!  *	== TASK1³==
   *	25:	chg_pri(TSK_SELF, TPRI_INI)
!  *	//		㡧TASK4TASK3TASK1MTX1TASK2MTX2TASK2
!  *	== TASK4ͥ١==
   *	26:	loc_mtx(MTX2)
!  *	//		㡧TASK3TASK1MTX1TASK2MTX2TASK2TASK4
!  *	== TASK3³==
   *	27:	loc_mtx(MTX1)
!  *	//		㡧TASK1MTX1TASK2TASK3MTX2TASK2TASK4
!  *	== TASK1³==
   *	28:	wup_tsk(TASK2)
!  *	//		⡧TASK2㡧TASK1MTX1TASK2TASK3MTX2TASK2TASK4
!  *	== TASK2-4³==
   *	29:	ext_tsk() -> noreturn			... (A-4)
!  *	//		⡧TASK4TASK3㡧TASK1MTX1TASK3MTX2TASK4
!  *	== TASK4³==
   *	30:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
--- 170,202 ----
   *		wup_tsk(TASK3)
   *		act_tsk(TASK4)
   *	20:	rot_rdq(TPRI_SELF)
!  *	//		低：TASK2→TASK3→TASK4→TASK1
!  *	== TASK2-4（優先度：低）4回め ==
   *	21:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		高：TASK2，低：TASK3→TASK4→TASK1，MTX1：TASK2，MTX2：TASK2
   *	22:	chg_pri(TASK1, HIGH_PRIORITY)
!  *	//		高：TASK2→TASK1，低：TASK3→TASK4，MTX1：TASK2，MTX2：TASK2
   *	23:	rot_rdq(TPRI_SELF)				... (B-1)(B-2)
!  *	//		高：TASK2→TASK1，低：TASK4→TASK3，MTX1：TASK2，MTX2：TASK2
   *	24:	slp_tsk()
!  *	//		高：TASK1，低：TASK4→TASK3，MTX1：TASK2，MTX2：TASK2
!  *	== TASK1（続き）==
   *	25:	chg_pri(TSK_SELF, TPRI_INI)
!  *	//		低：TASK4→TASK3→TASK1，MTX1：TASK2，MTX2：TASK2
!  *	== TASK4（優先度：低）==
   *	26:	loc_mtx(MTX2)
!  *	//		低：TASK3→TASK1，MTX1：TASK2，MTX2：TASK2→TASK4
!  *	== TASK3（続き）==
   *	27:	loc_mtx(MTX1)
!  *	//		低：TASK1，MTX1：TASK2→TASK3，MTX2：TASK2→TASK4
!  *	== TASK1（続き）==
   *	28:	wup_tsk(TASK2)
!  *	//		高：TASK2，低：TASK1，MTX1：TASK2→TASK3，MTX2：TASK2→TASK4
!  *	== TASK2-4（続き）==
   *	29:	ext_tsk() -> noreturn			... (A-4)
!  *	//		高：TASK4→TASK3，低：TASK1，MTX1：TASK3，MTX2：TASK4
!  *	== TASK4（続き）==
   *	30:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
***************
*** 206,218 ****
   *		get_pri(TPRI_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *		ext_tsk() -> noreturn
!  *	//		⡧TASK3㡧TASK1MTX2TASK4
!  *	== TASK3³==
   *	31:	get_pri(TPRI_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *		ext_tsk() -> noreturn
!  *	//		㡧TASK1
!  *	== TASK1³==
   *	32:	END
   */
  
--- 206,218 ----
   *		get_pri(TPRI_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *		ext_tsk() -> noreturn
!  *	//		高：TASK3，低：TASK1，MTX2：TASK4
!  *	== TASK3（続き）==
   *	31:	get_pri(TPRI_SELF, &tskpri)
   *		assert(tskpri == HIGH_PRIORITY)
   *		ext_tsk() -> noreturn
!  *	//		低：TASK1
!  *	== TASK1（続き）==
   *	32:	END
   */
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex6.cfg ASPs/asp/extension/mutex/test/test_mutex6.cfg
*** 1.9.1/asp/extension/mutex/test/test_mutex6.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex6.cfg	Fri Dec  9 13:54:02 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ߥ塼ƥåΥƥ(6)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  ミューテックスのテスト(6)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex6.h ASPs/asp/extension/mutex/test/test_mutex6.h
*** 1.9.1/asp/extension/mutex/test/test_mutex6.h	Sat Apr 12 10:31:23 2008
--- ASPs/asp/extension/mutex/test/test_mutex6.h	Fri Dec  9 13:54:02 2022
***************
*** 5,67 ****
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_mutex6.h 519 2007-08-28 02:08:04Z hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(6)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_mutex6.h 519 2007-08-28 02:08:04Z hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(6)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex7.c ASPs/asp/extension/mutex/test/test_mutex7.c
*** 1.9.1/asp/extension/mutex/test/test_mutex7.c	Sat Jan 11 23:15:56 2014
--- ASPs/asp/extension/mutex/test/test_mutex7.c	Fri Dec  9 13:54:02 2022
***************
*** 5,126 ****
   *  Copyright (C) 2008-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_mutex7.c 2606 2014-01-11 14:15:55Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(7)
   *
!  * ڥƥȤŪ
   *
!  *  ͥپ¥ߥ塼ƥåФơζλΥߥ塼ƥå
!  *  ϢνŪ˥ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) ζλter_tsk
!  *		(A-1) åƤߥ塼ƥå1ġˤå뤳ȡ
!  *		(A-2) åƤߥ塼ƥå1ġˤå졤
!  *			  ԤäƤåͥ٤Ѳ
!  *			  뤳ȡ
!  *		(A-3) (A-2)η̡ǥѥå뤳ȡ
!  *		(A-4) åƤߥ塼ƥåʣˤ٤ƥå
!  *			  뤳ȡ
!  *		(A-5) åƤߥ塼ƥåʣˤå졤
!  *			  ԤäƤʣˤåͥ٤
!  *			  Ԥ뤳ȡλˡǥߥ塼ƥå
!  *			  å˥åƤߥ塼ƥåԤ
!  *			  Ƥˤ̤ͥ⤯ʤ뤳ȡ
!  *		(A-6) (A-5)η̡ǥѥå뤳ȡ
   *
!  * ڥƥȹܤμ¸ˡ
   *
   *	(A-1)
!  *		ͥ٥TASK2ˤ˥ߥ塼ƥåMTX1ˤå
!  *		ΥTASK1ˤTASK2ter_tskȡå뤳
!  *		Ȥǧ롥
   *	(A-2)
!  *		ͥ٥TASK2ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		̤ͥ٥TASK3ˤMTX1Ԥ֤ǡͥ
!  *		٥TASK1ˤTASK2ter_tskȡTASK3ͥ٤
!  *		ʤäԤ뤳Ȥǧ롥
   *	(A-3)
!  *		ͥ٥TASK2ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		̤ͥ٥TASK3ˤMTX1Ԥ֤ǡ̤
!  *		ͥ٥TASK1ˤTASK2ter_tskȡTASK3ͥ
!  *		٤ˤʤäԤ졤TASK3ڤ괹뤳Ȥǧ롥
   *	(A-4)
!  *		ͥ٥TASK2ˤ˥ߥ塼ƥå2ġMTX1MTX2˥
!  *		̤ΥTASK1ˤTASK2ter_tskȡξΥ
!  *		뤳Ȥǧ롥
   *	(A-5)
!  *		ͥ٥TASK2ˤ˹ͥپ¥ߥ塼ƥå2ġMTX1
!  *		MTX2ˤ򤳤νǥå̤ͥ٥2ġTASK3
!  *		TASK4ˤˤ줾ΥåԤ֤ǡͥ٥
!  *		TASK1ˤTASK2ter_tskȡTASK3TASK4ͥ٤ˤʤ
!  *		Ԥ뤳Ȥǧ롥ޤ˥åƤߥ塼
!  *		ƥåMTX1ˤԤäƤTASK3ˤTASK4ͥ
!  *		̤⤯ʤ뤳Ȥǧ롥
   *	(A-6)
!  *		ͥ٥TASK2ˤ˹ͥپ¥ߥ塼ƥå2ġMTX1
!  *		MTX2ˤ򤳤νǥå̤ͥ٥2ġTASK3
!  *		TASK4ˤˤ줾ΥåԤ֤ǡ̤ͥ٥
!  *		TASK1ˤTASK2 ter_tskȡTASK3TASK4ͥ٤ˤʤ
!  *		Ԥ졤TASK3ڤ괹뤳Ȥǧ롥
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	TASK4: ͥ٥
!  *	MTX1: ߥ塼ƥåTA_CEILING°¤ͥ١
!  *	MTX2: ߥ塼ƥåTA_CEILING°¤ͥ١
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_mutex))
   *	1:	act_tsk(TASK2)
   *	2:	slp_tsk()
!  *	//		㡧TASK2
!  *	== TASK2-1ͥ١==
   *	3:	loc_mtx(MTX1)
!  *	//		桧TASK2MTX1TASK2
   *	4:	wup_tsk(TASK1)
!  *	//		⡧TASK1桧TASK2MTX1TASK2
!  *	== TASK1³==
   *	5:	ter_tsk(TASK2)			... (A-1)
!  *	//		⡧TASK1
   *	6:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
   *		assert(rmtx.wtskid == TSK_NONE)
--- 5,126 ----
   *  Copyright (C) 2008-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_mutex7.c 2606 2014-01-11 14:15:55Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(7)
   *
!  * 【テストの目的】
   *
!  *  優先度上限ミューテックスに対して，タスクの強制終了時のミューテック
!  *  ス関連の処理を網羅的にテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) タスクの強制終了時（ter_tsk）
!  *		(A-1) ロックしていたミューテックス（1つ）がロック解除されること．
!  *		(A-2) ロックしていたミューテックス（1つ）がロック解除され，ロッ
!  *			  クを待っていたタスクがそれをロックし，優先度が変化し，待
!  *			  ち解除されること．
!  *		(A-3) (A-2)の結果，タスクディスパッチが起こること．
!  *		(A-4) ロックしていたミューテックス（複数）がすべてロック解除さ
!  *			  れること．
!  *		(A-5) ロックしていたミューテックス（複数）がロック解除され，ロッ
!  *			  クを待っていたタスク（複数）がそれをロックし，優先度が変
!  *			  化し，待ち解除されること．その時に，後でミューテックスを
!  *			  ロックしたタスク（先にロックしていたミューテックスを待っ
!  *			  ていたタスク）の方が，優先順位が高くなること．
!  *		(A-6) (A-5)の結果，タスクディスパッチが起こること．
   *
!  * 【テスト項目の実現方法】
   *
   *	(A-1)
!  *		低優先度タスク（TASK2）にミューテックス（MTX1）をロックさせ，別
!  *		のタスク（TASK1）からTASK2をter_tskすると，ロックが解除されるこ
!  *		とを確認する．
   *	(A-2)
!  *		低優先度タスク（TASK2）に中優先度上限ミューテックス（MTX1）をロッ
!  *		クさせ，別の低優先度タスク（TASK3）にMTX1を待たせた状態で，高優
!  *		先度タスク（TASK1）からTASK2をter_tskすると，TASK3が中優先度に
!  *		なって待ち解除されることを確認する．
   *	(A-3)
!  *		低優先度タスク（TASK2）に中優先度上限ミューテックス（MTX1）をロッ
!  *		クさせ，別の低優先度タスク（TASK3）にMTX1を待たせた状態で，別の
!  *		低優先度タスク（TASK1）からTASK2をter_tskすると，TASK3が中優先
!  *		度になって待ち解除され，TASK3に切り換わることを確認する．
   *	(A-4)
!  *		低優先度タスク（TASK2）にミューテックスを2つ（MTX1，MTX2）ロッ
!  *		クさせ，別のタスク（TASK1）からTASK2をter_tskすると，両方のロッ
!  *		クが解除されることを確認する．
   *	(A-5)
!  *		低優先度タスク（TASK2）に高優先度上限ミューテックス2つ（MTX1，
!  *		MTX2）をこの順でロックさせ，別の低優先度タスク2つ（TASK3，
!  *		TASK4）にそれぞれのロックを待たせた状態で，高優先度タスク
!  *		（TASK1）からTASK2をter_tskすると，TASK3とTASK4が中優先度になっ
!  *		て待ち解除されることを確認する．また，先にロックしていたミュー
!  *		テックス（MTX1）を待っていたタスク（TASK3）が，TASK4よりも優先
!  *		順位が高くなることを確認する．
   *	(A-6)
!  *		低優先度タスク（TASK2）に高優先度上限ミューテックス2つ（MTX1，
!  *		MTX2）をこの順でロックさせ，別の低優先度タスク2つ（TASK3，
!  *		TASK4）にそれぞれのロックを待たせた状態で，別の低優先度タスク
!  *		（TASK1）からTASK2 をter_tskすると，TASK3とTASK4が中優先度になっ
!  *		て待ち解除され，TASK3に切り換わることを確認する．
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 高優先度タスク，メインタスク，最初から起動
!  *	TASK2: 低優先度タスク
!  *	TASK3: 低優先度タスク
!  *	TASK4: 低優先度タスク
!  *	MTX1: ミューテックス（TA_CEILING属性，上限は中優先度）
!  *	MTX2: ミューテックス（TA_CEILING属性，上限は中優先度）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：高）==
   *		call(set_bit_func(bit_mutex))
   *	1:	act_tsk(TASK2)
   *	2:	slp_tsk()
!  *	//		低：TASK2
!  *	== TASK2-1（優先度：低）==
   *	3:	loc_mtx(MTX1)
!  *	//		中：TASK2，MTX1：TASK2
   *	4:	wup_tsk(TASK1)
!  *	//		高：TASK1，中：TASK2，MTX1：TASK2
!  *	== TASK1（続き）==
   *	5:	ter_tsk(TASK2)			... (A-1)
!  *	//		高：TASK1
   *	6:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
   *		assert(rmtx.wtskid == TSK_NONE)
***************
*** 128,197 ****
   *	7:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *	8:	slp_tsk()
!  *	//		㡧TASK2TASK3
!  *	== TASK2-2ͥ١==
   *	9:	loc_mtx(MTX1)
!  *	//		桧TASK2㡧TASK3MTX1TASK2
   *	10:	tslp_tsk(10) -> E_TMOUT
!  *	//		㡧TASK3MTX1TASK2
!  *	== TASK3-1ͥ١==
   *	11:	loc_mtx(MTX1)
!  *	//		MTX1TASK2TASK3
!  *	//		ॢȸ
!  *	//		桧TASK2MTX1TASK2TASK3
!  *	== TASK2-2³==
   *	12:	wup_tsk(TASK1)
!  *	//		⡧TASK1桧TASK2MTX1TASK2TASK3
!  *	== TASK1³==
   *	13:	ter_tsk(TASK2)			... (A-2)
!  *	//		⡧TASK1桧TASK3MTX1TASK3
   *	14:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		get_pri(TASK3, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	15:	ter_tsk(TASK3)
!  *	//		⡧TASK1
   *
   *	16:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *	17:	chg_pri(TSK_SELF, LOW_PRIORITY)
!  *	//		㡧TASK2TASK3TASK1
!  *	== TASK2-3ͥ١==
   *	18:	loc_mtx(MTX1)
!  *	//		桧TASK2㡧TASK3TASK1MTX1TASK2
   *	19:	slp_tsk()
!  *	//		㡧TASK3TASK1MTX1TASK2
!  *	== TASK3-2ͥ١==
   *	20:	loc_mtx(MTX1)
!  *	//		㡧TASK1MTX1TASK2TASK3
!  *	== TASK1³==
   *	21:	ter_tsk(TASK2)			... (A-3)
!  *	//		桧TASK3㡧TASK1MTX1TASK3
!  *	== TASK3-2³==
   *	22:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		get_pri(TASK3, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	23:	ext_tsk() -> noreturn
!  *	//		㡧TASK1
!  *	== TASK1³==
   *	24:	chg_pri(TSK_SELF, HIGH_PRIORITY)
!  *	//		⡧TASK1
   *
   *	25:	act_tsk(TASK2)
   *	26:	slp_tsk()
!  *	//		㡧TASK2
!  *	== TASK2-4ͥ١==
   *	27:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		桧TASK2MTX1TASK2MTX2TASK2
   *	28:	wup_tsk(TASK1)
!  *	//		⡧TASK1桧TASK2MTX1TASK2MTX2TASK2
!  *	== TASK1³==
   *	29:	ter_tsk(TASK2)			... (A-4)
!  *	//		⡧TASK1
   *	30:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
   *		assert(rmtx.wtskid == TSK_NONE)
--- 128,197 ----
   *	7:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *	8:	slp_tsk()
!  *	//		低：TASK2→TASK3
!  *	== TASK2-2（優先度：低）==
   *	9:	loc_mtx(MTX1)
!  *	//		中：TASK2，低：TASK3，MTX1：TASK2
   *	10:	tslp_tsk(10) -> E_TMOUT
!  *	//		低：TASK3，MTX1：TASK2
!  *	== TASK3-1（優先度：低）==
   *	11:	loc_mtx(MTX1)
!  *	//		MTX1：TASK2→TASK3
!  *	//		タイムアウト後
!  *	//		中：TASK2，MTX1：TASK2→TASK3
!  *	== TASK2-2（続き）==
   *	12:	wup_tsk(TASK1)
!  *	//		高：TASK1，中：TASK2，MTX1：TASK2→TASK3
!  *	== TASK1（続き）==
   *	13:	ter_tsk(TASK2)			... (A-2)
!  *	//		高：TASK1，中：TASK3，MTX1：TASK3
   *	14:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		get_pri(TASK3, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	15:	ter_tsk(TASK3)
!  *	//		高：TASK1
   *
   *	16:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *	17:	chg_pri(TSK_SELF, LOW_PRIORITY)
!  *	//		低：TASK2→TASK3→TASK1
!  *	== TASK2-3（優先度：低）==
   *	18:	loc_mtx(MTX1)
!  *	//		中：TASK2，低：TASK3→TASK1，MTX1：TASK2
   *	19:	slp_tsk()
!  *	//		低：TASK3→TASK1，MTX1：TASK2
!  *	== TASK3-2（優先度：低）==
   *	20:	loc_mtx(MTX1)
!  *	//		低：TASK1，MTX1：TASK2→TASK3
!  *	== TASK1（続き）==
   *	21:	ter_tsk(TASK2)			... (A-3)
!  *	//		中：TASK3，低：TASK1，MTX1：TASK3
!  *	== TASK3-2（続き）==
   *	22:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
   *		get_pri(TASK3, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	23:	ext_tsk() -> noreturn
!  *	//		低：TASK1
!  *	== TASK1（続き）==
   *	24:	chg_pri(TSK_SELF, HIGH_PRIORITY)
!  *	//		高：TASK1
   *
   *	25:	act_tsk(TASK2)
   *	26:	slp_tsk()
!  *	//		低：TASK2
!  *	== TASK2-4（優先度：低）==
   *	27:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		中：TASK2，MTX1：TASK2，MTX2：TASK2
   *	28:	wup_tsk(TASK1)
!  *	//		高：TASK1，中：TASK2，MTX1：TASK2，MTX2：TASK2
!  *	== TASK1（続き）==
   *	29:	ter_tsk(TASK2)			... (A-4)
!  *	//		高：TASK1
   *	30:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TSK_NONE)
   *		assert(rmtx.wtskid == TSK_NONE)
***************
*** 203,229 ****
   *		act_tsk(TASK3)
   *		act_tsk(TASK4)
   *	32:	slp_tsk()
!  *	//		㡧TASK2TASK3TASK4
!  *	== TASK2-5ͥ١==
   *	33:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		桧TASK2㡧TASK3TASK4MTX1TASK2MTX2TASK2
   *	34:	tslp_tsk(10) -> E_TMOUT
!  *	//		㡧TASK3TASK4MTX1TASK2MTX2TASK2
!  *	== TASK3-3ͥ١==
   *	35:	loc_mtx(MTX1)
!  *	//		㡧TASK4MTX1TASK2TASK3MTX2TASK2
!  *	== TASK4-1ͥ١==
   *	36:	loc_mtx(MTX2)
!  *	//		MTX1TASK2TASK3MTX2TASK2TASK4
!  *	//		ॢȸ
!  *	//		桧TASK2MTX1TASK2TASK3MTX2TASK2TASK4
!  *	== TASK2-5³==
   *	37:	wup_tsk(TASK1)
!  *	//		⡧TASK1桧TASK2MTX1TASK2TASK3MTX2TASK2TASK4
!  *	== TASK1³==
   *	38:	ter_tsk(TASK2)			... (A-5)
!  *	//		⡧TASK1桧TASK4TASK3MTX1TASK3MTX2TASK4
   *	39:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
--- 203,229 ----
   *		act_tsk(TASK3)
   *		act_tsk(TASK4)
   *	32:	slp_tsk()
!  *	//		低：TASK2→TASK3→TASK4
!  *	== TASK2-5（優先度：低）==
   *	33:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		中：TASK2，低：TASK3→TASK4，MTX1：TASK2，MTX2：TASK2
   *	34:	tslp_tsk(10) -> E_TMOUT
!  *	//		低：TASK3→TASK4，MTX1：TASK2，MTX2：TASK2
!  *	== TASK3-3（優先度：低）==
   *	35:	loc_mtx(MTX1)
!  *	//		低：TASK4，MTX1：TASK2→TASK3，MTX2：TASK2
!  *	== TASK4-1（優先度：低）==
   *	36:	loc_mtx(MTX2)
!  *	//		MTX1：TASK2→TASK3，MTX2：TASK2→TASK4
!  *	//		タイムアウト後
!  *	//		中：TASK2，MTX1：TASK2→TASK3，MTX2：TASK2→TASK4
!  *	== TASK2-5（続き）==
   *	37:	wup_tsk(TASK1)
!  *	//		高：TASK1，中：TASK2，MTX1：TASK2→TASK3，MTX2：TASK2→TASK4
!  *	== TASK1（続き）==
   *	38:	ter_tsk(TASK2)			... (A-5)
!  *	//		高：TASK1，中：TASK4→TASK3，MTX1：TASK3，MTX2：TASK4
   *	39:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
***************
*** 235,270 ****
   *		get_pri(TASK4, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	40:	chg_pri(TSK_SELF, LOW_PRIORITY)
!  *	//		桧TASK4TASK3㡧TASK1MTX1TASK3MTX2TASK4
!  *	== TASK4-1³==
   *	41:	ext_tsk() -> noreturn
!  *	//		桧TASK3㡧TASK1MTX1TASK3
!  *	== TASK3-3³==
   *	42:	ext_tsk() -> noreturn
!  *	//		㡧TASK1
!  *	== TASK1³==
   *	43:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *		act_tsk(TASK4)
!  *	//		㡧TASK1TASK2TASK3TASK4
   *	44:	chg_pri(TSK_SELF, LOW_PRIORITY)
!  *	//		㡧TASK2TASK3TASK4TASK1
!  *	== TASK2-6ͥ١==
   *	45:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		桧TASK2㡧TASK3TASK4TASK1MTX1TASK2MTX2TASK2
   *	46:	slp_tsk()
!  *	//		㡧TASK3TASK4TASK1MTX1TASK2MTX2TASK2
!  *	== TASK3-4ͥ١==
   *	47:	loc_mtx(MTX1)
!  *	//		㡧TASK4TASK1MTX1TASK2TASK3MTX2TASK2
!  *	== TASK4-2ͥ١==
   *	48:	loc_mtx(MTX2)
!  *	//		㡧TASK1MTX1TASK2TASK3MTX2TASK2TASK4
!  *	== TASK1³==
   *	49:	ter_tsk(TASK2)			... (A-6)
!  *	//		桧TASK4TASK3㡧TASK1MTX1TASK3MTX2TASK4
!  *	== TASK4-2³==
   *	50:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
--- 235,270 ----
   *		get_pri(TASK4, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	40:	chg_pri(TSK_SELF, LOW_PRIORITY)
!  *	//		中：TASK4→TASK3，低：TASK1，MTX1：TASK3，MTX2：TASK4
!  *	== TASK4-1（続き）==
   *	41:	ext_tsk() -> noreturn
!  *	//		中：TASK3，低：TASK1，MTX1：TASK3
!  *	== TASK3-3（続き）==
   *	42:	ext_tsk() -> noreturn
!  *	//		低：TASK1
!  *	== TASK1（続き）==
   *	43:	act_tsk(TASK2)
   *		act_tsk(TASK3)
   *		act_tsk(TASK4)
!  *	//		低：TASK1→TASK2→TASK3→TASK4
   *	44:	chg_pri(TSK_SELF, LOW_PRIORITY)
!  *	//		低：TASK2→TASK3→TASK4→TASK1
!  *	== TASK2-6（優先度：低）==
   *	45:	loc_mtx(MTX1)
   *		loc_mtx(MTX2)
!  *	//		中：TASK2，低：TASK3→TASK4→TASK1，MTX1：TASK2，MTX2：TASK2
   *	46:	slp_tsk()
!  *	//		低：TASK3→TASK4→TASK1，MTX1：TASK2，MTX2：TASK2
!  *	== TASK3-4（優先度：低）==
   *	47:	loc_mtx(MTX1)
!  *	//		低：TASK4→TASK1，MTX1：TASK2→TASK3，MTX2：TASK2
!  *	== TASK4-2（優先度：低）==
   *	48:	loc_mtx(MTX2)
!  *	//		低：TASK1，MTX1：TASK2→TASK3，MTX2：TASK2→TASK4
!  *	== TASK1（続き）==
   *	49:	ter_tsk(TASK2)			... (A-6)
!  *	//		中：TASK4→TASK3，低：TASK1，MTX1：TASK3，MTX2：TASK4
!  *	== TASK4-2（続き）==
   *	50:	ref_mtx(MTX1, &rmtx)
   *		assert(rmtx.htskid == TASK3)
   *		assert(rmtx.wtskid == TSK_NONE)
***************
*** 276,286 ****
   *		get_pri(TASK4, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	51:	ext_tsk() -> noreturn
!  *	//		桧TASK3㡧TASK1MTX1TASK3
!  *	== TASK3-4³==
   *	52:	ext_tsk() -> noreturn
!  *	//		㡧TASK1
!  *	== TASK1³==
   *	53:	END
   */
  
--- 276,286 ----
   *		get_pri(TASK4, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	51:	ext_tsk() -> noreturn
!  *	//		中：TASK3，低：TASK1，MTX1：TASK3
!  *	== TASK3-4（続き）==
   *	52:	ext_tsk() -> noreturn
!  *	//		低：TASK1
!  *	== TASK1（続き）==
   *	53:	END
   */
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex7.cfg ASPs/asp/extension/mutex/test/test_mutex7.cfg
*** 1.9.1/asp/extension/mutex/test/test_mutex7.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex7.cfg	Fri Dec  9 13:54:02 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ߥ塼ƥåΥƥ(7)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  ミューテックスのテスト(7)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex7.h ASPs/asp/extension/mutex/test/test_mutex7.h
*** 1.9.1/asp/extension/mutex/test/test_mutex7.h	Sun May 24 23:35:37 2009
--- ASPs/asp/extension/mutex/test/test_mutex7.h	Fri Dec  9 13:54:02 2022
***************
*** 5,67 ****
   *  Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_mutex7.h 1566 2009-05-24 14:35:24Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(7)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_mutex7.h 1566 2009-05-24 14:35:24Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(7)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex8.c ASPs/asp/extension/mutex/test/test_mutex8.c
*** 1.9.1/asp/extension/mutex/test/test_mutex8.c	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex8.c	Fri Dec  9 13:54:02 2022
***************
*** 5,176 ****
   *  Copyright (C) 2009-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_mutex8.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(8)
   *
!  * ڥƥȤŪ
   *
!  *  ͥپ¥ߥ塼ƥåФơchg_priȼߥ塼ƥåϢ
!  *  ͥѹŪ˥ƥȤ롥change_priority
!  *  mutex_calc_priorityƤˤƧ߹ޤʤ
!  *
!  * ڥƥȹܡ
!  *
!  *	(A) Υ١ͥ٤ѹchg_pri
!  *		(A-1) оݥ¹ԤǤ֤ǡߥ塼ƥåå
!  *			  ʤˡƱͥǤ̤ͥˤʤ뤳
!  *		(A-2) оݥ¹ԤǤ֤ǡͥپ¥ߥ塼ƥå
!  *			  Υߥ塼ƥåΤߤåƤˡƱͥ
!  *			  Ǥ̤ͥˤʤ뤳
!  *		(A-3) оݥ¹ԤǤ֤ǡͥپ¥ߥ塼ƥå
!  *			  åƤˡƱͥǤ̤ͥѤ
!  *			  
!  *		(A-4) оݥԤ֤ǡͥٽԤˤĤʤƤ
!  *			  ꡤߥ塼ƥååƤʤˡͥ٤
!  *			  ѹ졤ƱͥǤνǸˤʤ뤳
!  *		(A-5) оݥԤ֤ǡͥٽԤˤĤʤƤ
!  *			  ꡤͥپ¥ߥ塼ƥåʳΥߥ塼ƥåΤߤ
!  *			  Ƥˡͥ٤ѹ졤Ʊͥ
!  *			  νǸˤʤ뤳
!  *		(A-6) оݥԤ֤ǡͥٽԤˤĤʤƤ
!  *			  ꡤͥپ¥ߥ塼ƥååƤˡƱ
!  *			  ͥǤνѤʤ
!  *	(B) Υ١ͥ٤ѹchg_priˤE_ILUSE顼
!  *		(B-1) оݥåƤߥ塼ƥåξͥ٤
!  *			  ⡤١ͥ٤⤯褦ȤE_ILUSE顼ˤʤ
!  *			  
!  *		(B-2) оݥͥپ¥ߥ塼ƥååƤƤ⡤
!  *			  åƤߥ塼ƥåξͥ٤⡤١ͥ
!  *			  ٤⤯褦ȤʤˤϡE_ILUSE顼ˤʤʤ
!  *			  
!  *		(B-3) оݥåԤäƤߥ塼ƥåξͥ
!  *			  ⡤١ͥ٤⤯褦ȤE_ILUSE顼
!  *			  ʤ뤳
!  *		(B-4) оݥͥپ¥ߥ塼ƥåԤǤäƤ⡤
!  *			  ԤäƤߥ塼ƥåξͥ٤⡤١ͥ
!  *			  ٤⤯褦ȤʤˤϡE_ILUSE顼ˤʤʤ
!  *			  
   *
!  * ڥƥȹܤμ¸ˡ
   *
   *	(A-1)
!  *		ͥ٥TASK1ˤ¹Բǽ֤λˡͥ٥
!  *		TASK5ˤTASK1ͥ٤chg_priȡ¹Բǽ֤¾
!  *		ͥ٥TASK4ˤ⡤̤ͥ㤯ʤ뤳Ȥǧ롥
   *	(A-2)
!  *		ͥ٥TASK1ˤͥٽߥ塼ƥåMTX3ˤå
!  *		¹Բǽ֤λˡͥ٥TASK5ˤTASK1ͥ
!  *		٤chg_priȡ¹Բǽ֤¾ͥ٥TASK4
!  *		⡤̤ͥ㤯ʤ뤳Ȥǧ롥
   *	(A-3)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		¹Բǽ֤λˡͥ٥TASK5ˤTASK1
!  *		ͥ٤chg_priȡTASK1ͥ٤ѲʤȤǧ롥
!  *		ޤ¹Բǽ֤ͥ٥2ġTASK2TASK3ˤѰդ
!  *		Ƥ̤ͥѤʤȤǧ롥
   *	(A-4)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX2ˤԤ
!  *		Ƥˡͥ٥TASK5ˤTASK1ͥ٤
!  *		chg_priȡMTX2ԤäƤ¾ͥ٥TASK4ˤ
!  *		⡤ԤǤνˤʤ뤳Ȥǧ롥
   *	(A-5)
!  *		ͥ٥TASK1ˤͥٽߥ塼ƥåMTX3ˤå
!  *		ͥپ¥ߥ塼ƥåMTX2ˤԤäƤˡͥ٥
!  *		TASK5ˤTASK1ͥ٤chg_priȡMTX2ԤäƤ
!  *		¾ͥ٥TASK4ˤ⡤ԤǤνѤ
!  *		ʤȤǧ롥
   *	(A-6)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		ͥپ¥ߥ塼ƥåMTX2ˤԤäƤˡͥ
!  *		٥TASK5ˤTASK1ͥ٤chg_priȡTASK1
!  *		ͥ٤ѲʤȤǧ롥ޤMTX2ԤäƤͥ
!  *		٥2ġTASK2TASK3ˤѰդƤԤǤν
!  *		ѤʤȤǧ롥
   *	(B-1)
!  *		ͥ٥TASK1ˤͥپ¥ߥ塼ƥåMTX1ˤ
!  *		¹Բǽ֤λˡͥ٥TASK5ˤTASK1
!  *		ͥ٤chg_priȡE_ILUSE顼ˤʤ뤳Ȥǧ롥
   *	(B-2)
!  *		(A-3)Υƥȹܤǡchg_priE_ILUSE顼ˤʤʤȤǳǧ
!  *		ǤƤ롥
   *	(B-3)
!  *		ͥ٥TASK2ˤͥپ¥ߥ塼ƥåMTX1ˤΥ
!  *		ԤäƤˡͥ٥TASK5ˤTASK2ͥ
!  *		chg_priȡE_ILUSE顼ˤʤ뤳Ȥǧ롥
   *	(B-4)
!  *		(A-6)Υƥȹܤǡchg_priE_ILUSE顼ˤʤʤȤǳǧ
!  *		ǤƤ롥
   *
!  * ڻѥ꥽
   *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	TASK4: ͥ٥
!  *	TASK5: ͥ٥
!  *	MTX1: ߥ塼ƥåTA_CEILING°¤ͥ١
!  *	MTX2: ߥ塼ƥåTA_CEILING°¤Ϲͥ١
!  *	MTX3: ߥ塼ƥåTA_TPRI°
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *		call(set_bit_func(bit_mutex))
   *	1:	act_tsk(TASK4)
   *	2:	act_tsk(TASK5)
!  *	//		⡧TASK5桧TASK1㡧TASK4
!  *	== TASK5ͥ١==
   *	3:	chg_pri(TASK1, LOW_PRIORITY)		... (A-1)
!  *	//		⡧TASK5㡧TASK4TASK1
   *	4:	slp_tsk()
!  *	== TASK4ͥ١==
   *	5:	slp_tsk()
!  *	== TASK1³==
   *	6:	chg_pri(TSK_SELF, TPRI_INI)
   *
   *	7:	loc_mtx(MTX3)
   *	8:	wup_tsk(TASK4)
   *	9:	wup_tsk(TASK5)
!  *	//		⡧TASK5桧TASK1㡧TASK4MTX3TASK1
!  *	== TASK5³==
   *	10:	chg_pri(TASK1, LOW_PRIORITY)		... (A-2)
!  *	//		⡧TASK5㡧TASK4TASK1MTX3TASK1
   *	11:	slp_tsk()
!  *	== TASK4³==
   *	12:	slp_tsk()
!  *	== TASK1³==
   *	13:	unl_mtx(MTX3)
   *		chg_pri(TSK_SELF, TPRI_INI)
   *
--- 5,176 ----
   *  Copyright (C) 2009-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_mutex8.c 2593 2014-01-02 06:29:10Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(8)
   *
!  * 【テストの目的】
   *
!  *  優先度上限ミューテックスに対して，chg_priに伴うミューテックス関連の
!  *  優先度変更処理を網羅的にテストする．ただし，change_priorityと
!  *  mutex_calc_priorityの内容には踏み込まない．
!  *
!  * 【テスト項目】
!  *
!  *	(A) タスクのベース優先度の変更処理（chg_pri）
!  *		(A-1) 対象タスクが実行できる状態で，ミューテックスをロックして
!  *			  いない場合に，同じ優先度内での優先順位が最低になること
!  *		(A-2) 対象タスクが実行できる状態で，優先度上限ミューテックス以
!  *			  外のミューテックスのみをロックしている場合に，同じ優先度
!  *			  内での優先順位が最低になること
!  *		(A-3) 対象タスクが実行できる状態で，優先度上限ミューテックスを
!  *			  ロックしている場合に，同じ優先度内での優先順位が変わらな
!  *			  いこと
!  *		(A-4) 対象タスクが待ち状態で，優先度順の待ち行列につながれてお
!  *			  り，ミューテックスをロックしていない場合に，優先度が正し
!  *			  く変更され，同じ優先度内での順序が最後になること
!  *		(A-5) 対象タスクが待ち状態で，優先度順の待ち行列につながれてお
!  *			  り，優先度上限ミューテックス以外のミューテックスのみをロッ
!  *			  クしている場合に，優先度が正しく変更され，同じ優先度内で
!  *			  の順序が最後になること
!  *		(A-6) 対象タスクが待ち状態で，優先度順の待ち行列につながれてお
!  *			  り，優先度上限ミューテックスをロックしている場合に，同じ
!  *			  優先度内での順序が変わらないこと
!  *	(B) タスクのベース優先度の変更処理（chg_pri）のE_ILUSEエラー
!  *		(B-1) 対象タスクがロックしているミューテックスの上限優先度より
!  *			  も，ベース優先度を高くしようとした時，E_ILUSEエラーになる
!  *			  こと
!  *		(B-2) 対象タスクが優先度上限ミューテックスをロックしていても，
!  *			  ロックしているミューテックスの上限優先度よりも，ベース優
!  *			  先度を高くしようとしない場合には，E_ILUSEエラーにならない
!  *			  こと
!  *		(B-3) 対象タスクがロックを待っているミューテックスの上限優先度
!  *			  よりも，ベース優先度を高くしようとした時，E_ILUSEエラーに
!  *			  なること
!  *		(B-4) 対象タスクが優先度上限ミューテックス待ちであっても，ロッ
!  *			  クを待っているミューテックスの上限優先度よりも，ベース優
!  *			  先度を高くしようとしない場合には，E_ILUSEエラーにならない
!  *			  こと
   *
!  * 【テスト項目の実現方法】
   *
   *	(A-1)
!  *		中優先度タスク（TASK1）が実行可能状態の時に，高優先度タスク
!  *		（TASK5）からTASK1を低優先度にchg_priすると，実行可能状態の他の
!  *		低優先度タスク（TASK4）よりも，優先順位が低くなることを確認する．
   *	(A-2)
!  *		中優先度タスク（TASK1）が優先度順ミューテックス（MTX3）をロック
!  *		し，実行可能状態の時に，高優先度タスク（TASK5）からTASK1を低優
!  *		先度にchg_priすると，実行可能状態の他の低優先度タスク（TASK4）
!  *		よりも，優先順位が低くなることを確認する．
   *	(A-3)
!  *		中優先度タスク（TASK1）が中優先度上限ミューテックス（MTX1）をロッ
!  *		クし，実行可能状態の時に，高優先度タスク（TASK5）からTASK1を低
!  *		優先度にchg_priすると，TASK1の優先度が変化しないことを確認する．
!  *		また，実行可能状態の中優先度タスクを2つ（TASK2，TASK3）を用意し
!  *		ておき，優先順位が変わらないことを確認する．
   *	(A-4)
!  *		中優先度タスク（TASK1）が高優先度上限ミューテックス（MTX2）を待っ
!  *		ている時に，高優先度タスク（TASK5）からTASK1を低優先度に
!  *		chg_priすると，MTX2を待っている他の低優先度タスク（TASK4）より
!  *		も，待ち行列中での順序が後になることを確認する．
   *	(A-5)
!  *		中優先度タスク（TASK1）が優先度順ミューテックス（MTX3）をロック
!  *		し，高優先度上限ミューテックス（MTX2）を待っている時に，高優先度タ
!  *		スク（TASK5）からTASK1を低優先度にchg_priすると，MTX2を待ってい
!  *		る他の低優先度タスク（TASK4）よりも，待ち行列中での順序が変わら
!  *		ないことを確認する．
   *	(A-6)
!  *		中優先度タスク（TASK1）が中優先度上限ミューテックス（MTX1）をロッ
!  *		クし，高優先度上限ミューテックス（MTX2）を待っている時に，高優
!  *		先度タスク（TASK5）からTASK1を低優先度にchg_priすると，TASK1の
!  *		優先度が変化しないことを確認する．また，MTX2を待っている中優先
!  *		度タスクを2つ（TASK2，TASK3）を用意しておき，待ち行列中での順序
!  *		が変わらないことを確認する．
   *	(B-1)
!  *		中優先度タスク（TASK1）が中優先度上限ミューテックス（MTX1）をロッ
!  *		クし，実行可能状態の時に，高優先度タスク（TASK5）からTASK1を高
!  *		優先度にchg_priすると，E_ILUSEエラーになることを確認する．
   *	(B-2)
!  *		(A-3)のテスト項目で，chg_priがE_ILUSEエラーにならないことで確認
!  *		できている．
   *	(B-3)
!  *		中優先度タスク（TASK2）が中優先度上限ミューテックス（MTX1）のロッ
!  *		クを待っている時に，高優先度タスク（TASK5）からTASK2を高優先度
!  *		にchg_priすると，E_ILUSEエラーになることを確認する．
   *	(B-4)
!  *		(A-6)のテスト項目で，chg_priがE_ILUSEエラーにならないことで確認
!  *		できている．
   *
!  * 【使用リソース】
   *
!  *	TASK1: 中優先度タスク，メインタスク，最初から起動
!  *	TASK2: 中優先度タスク
!  *	TASK3: 中優先度タスク
!  *	TASK4: 低優先度タスク
!  *	TASK5: 高優先度タスク
!  *	MTX1: ミューテックス（TA_CEILING属性，上限は中優先度）
!  *	MTX2: ミューテックス（TA_CEILING属性，上限は高優先度）
!  *	MTX3: ミューテックス（TA_TPRI属性）
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：中）==
   *		call(set_bit_func(bit_mutex))
   *	1:	act_tsk(TASK4)
   *	2:	act_tsk(TASK5)
!  *	//		高：TASK5，中：TASK1，低：TASK4
!  *	== TASK5（優先度：高）==
   *	3:	chg_pri(TASK1, LOW_PRIORITY)		... (A-1)
!  *	//		高：TASK5，低：TASK4→TASK1
   *	4:	slp_tsk()
!  *	== TASK4（優先度：低）==
   *	5:	slp_tsk()
!  *	== TASK1（続き）==
   *	6:	chg_pri(TSK_SELF, TPRI_INI)
   *
   *	7:	loc_mtx(MTX3)
   *	8:	wup_tsk(TASK4)
   *	9:	wup_tsk(TASK5)
!  *	//		高：TASK5，中：TASK1，低：TASK4，MTX3：TASK1
!  *	== TASK5（続き）==
   *	10:	chg_pri(TASK1, LOW_PRIORITY)		... (A-2)
!  *	//		高：TASK5，低：TASK4→TASK1，MTX3：TASK1
   *	11:	slp_tsk()
!  *	== TASK4（続き）==
   *	12:	slp_tsk()
!  *	== TASK1（続き）==
   *	13:	unl_mtx(MTX3)
   *		chg_pri(TSK_SELF, TPRI_INI)
   *
***************
*** 179,328 ****
   *	16:	dis_dsp()
   *	17:	rot_rdq(MID_PRIORITY)
   *	18:	act_tsk(TASK3)
!  *	//		桧TASK2TASK1TASK3MTX1TASK1
   *	19:	wup_tsk(TASK5)
!  *	//		⡧TASK5桧TASK2TASK1TASK3MTX1TASK1
   *	20:	ena_dsp()
!  *	== TASK5³==
   *	21:	chg_pri(TASK1, LOW_PRIORITY)		... (A-3)(B-2)
!  *	//		⡧TASK5桧TASK2TASK1TASK3MTX1TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	22:	slp_tsk()
!  *	//		桧TASK2TASK1TASK3MTX1TASK1
!  *	== TASK2³==
   *	23:	slp_tsk()
!  *	//		桧TASK1TASK3MTX1TASK1
!  *	== TASK1³==
   *	24:	unl_mtx(MTX1)
!  *	//		桧TASK3㡧TASK1
!  *	== TASK3³==
   *	25:	slp_tsk()
!  *	== TASK1³==
   *	26:	chg_pri(TSK_SELF, TPRI_INI)
   *
   *	27:	wup_tsk(TASK5)
!  *	== TASK5³==
   *	28:	loc_mtx(MTX2)
   *	29:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK1³==
   *	30:	wup_tsk(TASK4)
   *	31:	loc_mtx(MTX2)
!  *	== TASK4³==
   *	32:	loc_mtx(MTX2)
!  *	//		MTX2TASK5TASK1TASK4
!  *	//		ॢԤ
!  *	//		⡧TASK5MTX2TASK5TASK1TASK4
!  *	== TASK5³==
   *	33:	chg_pri(TASK1, LOW_PRIORITY)		... (A-4)
!  *	//		⡧TASK5MTX2TASK5TASK4TASK1
   *	34:	unl_mtx(MTX2)
!  *	//		⡧TASK5TASK4MTX2TASK4TASK1
   *	35:	slp_tsk()
!  *	//		⡧TASK4MTX2TASK4TASK1
!  *	== TASK4³==
   *	36:	unl_mtx(MTX2)
!  *	//		⡧TASK1㡧TASK4MTX2TASK1
!  *	== TASK1³==
   *	37:	unl_mtx(MTX2)
!  *	//		㡧TASK1TASK4
   *	38:	chg_pri(TSK_SELF, TPRI_INI)
   *
   *	39:	loc_mtx(MTX3)
   *	40:	wup_tsk(TASK5)
!  *	//		⡧TASK5桧TASK1㡧TASK4MTX3TASK1
!  *	== TASK5³==
   *	41:	loc_mtx(MTX2)
   *	42:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK1³==
   *	43:	loc_mtx(MTX2)
!  *	== TASK4³==
   *	44:	loc_mtx(MTX2)
!  *	//		MTX2TASK5TASK1TASK4MTX3TASK1
!  *	//		ॢԤ
!  *	//		⡧TASK5MTX2TASK5TASK1TASK4MTX3TASK1
!  *	== TASK5³==
   *	45:	chg_pri(TASK1, LOW_PRIORITY)		... (A-5)
!  *	//		⡧TASK5MTX2TASK5TASK4TASK1MTX3TASK1
   *	46:	unl_mtx(MTX2)
!  *	//		⡧TASK5TASK4MTX2TASK4TASK1MTX3TASK1
   *	47:	slp_tsk()
!  *	//		⡧TASK4MTX2TASK4TASK1MTX3TASK1
!  *	== TASK4³==
   *	48:	unl_mtx(MTX2)
!  *	//		⡧TASK1㡧TASK4MTX2TASK1MTX3TASK1
!  *	== TASK1³==
   *	49:	unl_mtx(MTX2)
!  *	//		㡧TASK1TASK4MTX3TASK1
   *	50:	unl_mtx(MTX3)
!  *	//		㡧TASK1TASK4
   *	51:	ter_tsk(TASK4)
   *	52:	chg_pri(TSK_SELF, TPRI_INI)
   *
   *	53:	loc_mtx(MTX1)
   *	54:	wup_tsk(TASK5)
!  *	//		⡧TASK5桧TASK1MTX1TASK1
!  *	== TASK5³==
   *	55:	loc_mtx(MTX2)
   *	56:	tslp_tsk(10) -> E_TMOUT
!  *	//		桧TASK1MTX1TASK1MTX2TASK5
!  *	== TASK1³==
   *	57:	wup_tsk(TASK2)
   *	58:	rot_rdq(MID_PRIORITY)
!  *	== TASK2³==
   *	59:	loc_mtx(MTX2)
!  *	//		桧TASK1MTX1TASK1MTX2TASK5TASK2
!  *	== TASK1³==
   *	60:	wup_tsk(TASK3)
   *	61:	loc_mtx(MTX2)
!  *	//		桧TASK3MTX1TASK1MTX2TASK5TASK2TASK1
!  *	== TASK3³==
   *	62:	loc_mtx(MTX2)
!  *	//		MTX1TASK1MTX2TASK5TASK2TASK1TASK3
!  *	//		ॢԤ
!  *	//		⡧TASK5MTX1TASK1MTX2TASK5TASK2TASK1TASK3
!  *	== TASK5³==
   *	63:	chg_pri(TASK1, LOW_PRIORITY)		... (A-6)(B-4)
!  *	//		⡧TASK5MTX1TASK1MTX2TASK5TASK2TASK1TASK3
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	64:	unl_mtx(MTX2)
!  *	//		⡧TASK5TASK2MTX1TASK1MTX2TASK2TASK1TASK3
   *	65:	slp_tsk()
!  *	//		⡧TASK2MTX1TASK1MTX2TASK2TASK1TASK3
!  *	== TASK2³==
   *	66:	unl_mtx(MTX2)
!  *	//		⡧TASK1桧TASK2MTX1TASK1MTX2TASK1TASK3
!  *	== TASK1³==
   *	67:	unl_mtx(MTX2)
!  *	//		⡧TASK3桧TASK1TASK2MTX1TASK1MTX2TASK3
!  *	== TASK3³==
   *	68:	unl_mtx(MTX2)
!  *	//		桧TASK3TASK1TASK2MTX1TASK1
   *	69:	ext_tsk() -> noreturn
!  *	//		桧TASK1TASK2MTX1TASK1
!  *	== TASK1³==
   *	70:	chg_pri(TSK_SELF, TPRI_INI)
!  *	//		桧TASK1TASK2MTX1TASK1
   *
   *	71:	rot_rdq(MID_PRIORITY)
!  *	//		桧TASK2TASK1MTX1TASK1
!  *	== TASK2³==
   *	72:	loc_mtx(MTX1)
!  *	//		桧TASK1MTX1TASK1TASK2
!  *	== TASK1³==
   *	73:	wup_tsk(TASK5)
!  *	//		⡧TASK5桧TASK1MTX1TASK1TASK2
!  *	== TASK5³==
   *	74:	chg_pri(TASK1, HIGH_PRIORITY) -> E_ILUSE	... (B-1)
   *	75:	chg_pri(TASK2, HIGH_PRIORITY) -> E_ILUSE	... (B-3)
   *	76:	ext_tsk() -> noreturn
!  *	//		桧TASK1MTX1TASK1TASK2
!  *	== TASK1³==
   *	77:	unl_mtx(MTX1)
!  *	//		桧TASK1TASK2MTX1TASK2
   *	78:	ext_tsk() -> noreturn
!  *	== TASK2³==
   *	79:	unl_mtx(MTX1)
   *	80:	END
   */
--- 179,328 ----
   *	16:	dis_dsp()
   *	17:	rot_rdq(MID_PRIORITY)
   *	18:	act_tsk(TASK3)
!  *	//		中：TASK2→TASK1→TASK3，MTX1：TASK1
   *	19:	wup_tsk(TASK5)
!  *	//		高：TASK5，中：TASK2→TASK1→TASK3，MTX1：TASK1
   *	20:	ena_dsp()
!  *	== TASK5（続き）==
   *	21:	chg_pri(TASK1, LOW_PRIORITY)		... (A-3)(B-2)
!  *	//		高：TASK5，中：TASK2→TASK1→TASK3，MTX1：TASK1
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	22:	slp_tsk()
!  *	//		中：TASK2→TASK1→TASK3，MTX1：TASK1
!  *	== TASK2（続き）==
   *	23:	slp_tsk()
!  *	//		中：TASK1→TASK3，MTX1：TASK1
!  *	== TASK1（続き）==
   *	24:	unl_mtx(MTX1)
!  *	//		中：TASK3，低：TASK1
!  *	== TASK3（続き）==
   *	25:	slp_tsk()
!  *	== TASK1（続き）==
   *	26:	chg_pri(TSK_SELF, TPRI_INI)
   *
   *	27:	wup_tsk(TASK5)
!  *	== TASK5（続き）==
   *	28:	loc_mtx(MTX2)
   *	29:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK1（続き）==
   *	30:	wup_tsk(TASK4)
   *	31:	loc_mtx(MTX2)
!  *	== TASK4（続き）==
   *	32:	loc_mtx(MTX2)
!  *	//		MTX2：TASK5→TASK1→TASK4
!  *	//		タイムアウト待ち
!  *	//		高：TASK5，MTX2：TASK5→TASK1→TASK4
!  *	== TASK5（続き）==
   *	33:	chg_pri(TASK1, LOW_PRIORITY)		... (A-4)
!  *	//		高：TASK5，MTX2：TASK5→TASK4→TASK1
   *	34:	unl_mtx(MTX2)
!  *	//		高：TASK5→TASK4，MTX2：TASK4→TASK1
   *	35:	slp_tsk()
!  *	//		高：TASK4，MTX2：TASK4→TASK1
!  *	== TASK4（続き）==
   *	36:	unl_mtx(MTX2)
!  *	//		高：TASK1，低：TASK4，MTX2：TASK1
!  *	== TASK1（続き）==
   *	37:	unl_mtx(MTX2)
!  *	//		低：TASK1→TASK4
   *	38:	chg_pri(TSK_SELF, TPRI_INI)
   *
   *	39:	loc_mtx(MTX3)
   *	40:	wup_tsk(TASK5)
!  *	//		高：TASK5，中：TASK1，低：TASK4，MTX3：TASK1
!  *	== TASK5（続き）==
   *	41:	loc_mtx(MTX2)
   *	42:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK1（続き）==
   *	43:	loc_mtx(MTX2)
!  *	== TASK4（続き）==
   *	44:	loc_mtx(MTX2)
!  *	//		MTX2：TASK5→TASK1→TASK4，MTX3：TASK1
!  *	//		タイムアウト待ち
!  *	//		高：TASK5，MTX2：TASK5→TASK1→TASK4，MTX3：TASK1
!  *	== TASK5（続き）==
   *	45:	chg_pri(TASK1, LOW_PRIORITY)		... (A-5)
!  *	//		高：TASK5，MTX2：TASK5→TASK4→TASK1，MTX3：TASK1
   *	46:	unl_mtx(MTX2)
!  *	//		高：TASK5→TASK4，MTX2：TASK4→TASK1，MTX3：TASK1
   *	47:	slp_tsk()
!  *	//		高：TASK4，MTX2：TASK4→TASK1，MTX3：TASK1
!  *	== TASK4（続き）==
   *	48:	unl_mtx(MTX2)
!  *	//		高：TASK1，低：TASK4，MTX2：TASK1，MTX3：TASK1
!  *	== TASK1（続き）==
   *	49:	unl_mtx(MTX2)
!  *	//		低：TASK1→TASK4，MTX3：TASK1
   *	50:	unl_mtx(MTX3)
!  *	//		低：TASK1→TASK4
   *	51:	ter_tsk(TASK4)
   *	52:	chg_pri(TSK_SELF, TPRI_INI)
   *
   *	53:	loc_mtx(MTX1)
   *	54:	wup_tsk(TASK5)
!  *	//		高：TASK5，中：TASK1，MTX1：TASK1
!  *	== TASK5（続き）==
   *	55:	loc_mtx(MTX2)
   *	56:	tslp_tsk(10) -> E_TMOUT
!  *	//		中：TASK1，MTX1：TASK1，MTX2：TASK5
!  *	== TASK1（続き）==
   *	57:	wup_tsk(TASK2)
   *	58:	rot_rdq(MID_PRIORITY)
!  *	== TASK2（続き）==
   *	59:	loc_mtx(MTX2)
!  *	//		中：TASK1，MTX1：TASK1，MTX2：TASK5→TASK2
!  *	== TASK1（続き）==
   *	60:	wup_tsk(TASK3)
   *	61:	loc_mtx(MTX2)
!  *	//		中：TASK3，MTX1：TASK1，MTX2：TASK5→TASK2→TASK1
!  *	== TASK3（続き）==
   *	62:	loc_mtx(MTX2)
!  *	//		MTX1：TASK1，MTX2：TASK5→TASK2→TASK1→TASK3
!  *	//		タイムアウト待ち
!  *	//		高：TASK5，MTX1：TASK1，MTX2：TASK5→TASK2→TASK1→TASK3
!  *	== TASK5（続き）==
   *	63:	chg_pri(TASK1, LOW_PRIORITY)		... (A-6)(B-4)
!  *	//		高：TASK5，MTX1：TASK1，MTX2：TASK5→TASK2→TASK1→TASK3
   *		get_pri(TASK1, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	64:	unl_mtx(MTX2)
!  *	//		高：TASK5→TASK2，MTX1：TASK1，MTX2：TASK2→TASK1→TASK3
   *	65:	slp_tsk()
!  *	//		高：TASK2，MTX1：TASK1，MTX2：TASK2→TASK1→TASK3
!  *	== TASK2（続き）==
   *	66:	unl_mtx(MTX2)
!  *	//		高：TASK1，中：TASK2，MTX1：TASK1，MTX2：TASK1→TASK3
!  *	== TASK1（続き）==
   *	67:	unl_mtx(MTX2)
!  *	//		高：TASK3，中：TASK1→TASK2，MTX1：TASK1，MTX2：TASK3
!  *	== TASK3（続き）==
   *	68:	unl_mtx(MTX2)
!  *	//		中：TASK3→TASK1→TASK2，MTX1：TASK1
   *	69:	ext_tsk() -> noreturn
!  *	//		中：TASK1→TASK2，MTX1：TASK1
!  *	== TASK1（続き）==
   *	70:	chg_pri(TSK_SELF, TPRI_INI)
!  *	//		中：TASK1→TASK2，MTX1：TASK1
   *
   *	71:	rot_rdq(MID_PRIORITY)
!  *	//		中：TASK2→TASK1，MTX1：TASK1
!  *	== TASK2（続き）==
   *	72:	loc_mtx(MTX1)
!  *	//		中：TASK1，MTX1：TASK1→TASK2
!  *	== TASK1（続き）==
   *	73:	wup_tsk(TASK5)
!  *	//		高：TASK5，中：TASK1，MTX1：TASK1→TASK2
!  *	== TASK5（続き）==
   *	74:	chg_pri(TASK1, HIGH_PRIORITY) -> E_ILUSE	... (B-1)
   *	75:	chg_pri(TASK2, HIGH_PRIORITY) -> E_ILUSE	... (B-3)
   *	76:	ext_tsk() -> noreturn
!  *	//		中：TASK1，MTX1：TASK1→TASK2
!  *	== TASK1（続き）==
   *	77:	unl_mtx(MTX1)
!  *	//		中：TASK1→TASK2，MTX1：TASK2
   *	78:	ext_tsk() -> noreturn
!  *	== TASK2（続き）==
   *	79:	unl_mtx(MTX1)
   *	80:	END
   */
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex8.cfg ASPs/asp/extension/mutex/test/test_mutex8.cfg
*** 1.9.1/asp/extension/mutex/test/test_mutex8.cfg	Thu Jan  2 15:29:11 2014
--- ASPs/asp/extension/mutex/test/test_mutex8.cfg	Fri Dec  9 13:54:02 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ߥ塼ƥåΥƥ(8)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  ミューテックスのテスト(8)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/mutex/test/test_mutex8.h ASPs/asp/extension/mutex/test/test_mutex8.h
*** 1.9.1/asp/extension/mutex/test/test_mutex8.h	Sat Jan  2 01:01:35 2010
--- ASPs/asp/extension/mutex/test/test_mutex8.h	Fri Dec  9 13:54:02 2022
***************
*** 5,67 ****
   *  Copyright (C) 2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_mutex8.h 1696 2010-01-01 16:01:25Z ertl-hiro $
   */
  
  /* 
!  *		ߥ塼ƥåΥƥ(8)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_mutex8.h 1696 2010-01-01 16:01:25Z ertl-hiro $
   */
  
  /* 
!  *		ミューテックスのテスト(8)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/include/kernel.h ASPs/asp/extension/ovrhdr/include/kernel.h
*** 1.9.1/asp/extension/ovrhdr/include/kernel.h	Sun Aug 17 21:42:45 2014
--- ASPs/asp/extension/ovrhdr/include/kernel.h	Fri Dec  9 13:54:02 2022
***************
*** 8,57 ****
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥ ɸإåե
   *
!  *  TOPPERS/ASPͥ뤬ݡȤ륵ӥȡɬפʥǡ
!  *  ޥޤإåե롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   *
!  *  Υե򥤥󥯥롼ɤ˥󥯥롼ɤƤ٤ե
!  *  Ϥʤ
   */
  
  #ifndef TOPPERS_KERNEL_H
--- 8,57 ----
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル 標準ヘッダファイル
   *
!  *  TOPPERS/ASPカーネルがサポートするサービスコールの宣言と，必要なデー
!  *  タ型，定数，マクロの定義を含むヘッダファイル．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   *
!  *  このファイルをインクルードする前にインクルードしておくべきファイル
!  *  はない．
   */
  
  #ifndef TOPPERS_KERNEL_H
***************
*** 62,94 ****
  #endif
  
  /*
!  *	TOPPERS̤Υǡޥ
   */
  #include <t_stddef.h>
  
  /*
!  *  åȰ¸
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ǡ
   */
  
  /*
!  *  ӥåȥѥ䥪ֹ֥η
   */
! typedef	uint_t		TEXPTN;		/* 㳰װΥӥåȥѥ */
! typedef	uint_t		FLGPTN;		/* ٥ȥե饰Υӥåȥѥ */
! typedef	ulong_t		OVRTIM;		/* ץå */
! typedef	uint_t		INTNO;		/* ֹ */
! typedef	uint_t		INHNO;		/* ߥϥɥֹ */
! typedef	uint_t		EXCNO;		/* CPU㳰ϥɥֹ */
  
  /*
!  *  ñ̤η
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
--- 62,94 ----
  #endif
  
  /*
!  *	TOPPERS共通のデータ型・定数・マクロ
   */
  #include <t_stddef.h>
  
  /*
!  *  ターゲット依存部
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  データ型の定義
   */
  
  /*
!  *  ビットパターンやオブジェクト番号の型定義
   */
! typedef	uint_t		TEXPTN;		/* タスク例外要因のビットパターン */
! typedef	uint_t		FLGPTN;		/* イベントフラグのビットパターン */
! typedef	ulong_t		OVRTIM;		/* プロセッサ時間 */
! typedef	uint_t		INTNO;		/* 割込み番号 */
! typedef	uint_t		INHNO;		/* 割込みハンドラ番号 */
! typedef	uint_t		EXCNO;		/* CPU例外ハンドラ番号 */
  
  /*
!  *  処理単位の型定義
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
***************
*** 102,209 ****
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  ΰݤΤη
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* åΰݤ뤿η */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* Ĺסΰݤ뤿η */
  
  /*
!  *  åإåη
   */
! typedef	struct t_msg {			/* ᡼ܥåΥåإå */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* ͥդåإå */
! 	T_MSG	msgque;				/* åإå */
! 	PRI		msgpri;				/* åͥ */
  } T_MSG_PRI;
  
  /*
!  *  ѥåȷ
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/*  */
! 	PRI		tskpri;		/* θͥ */
! 	PRI		tskbpri;	/* Υ١ͥ */
! 	STAT	tskwait;	/* Ԥװ */
! 	ID		wobjid;		/* ԤоݤΥ֥ȤID */
! 	TMO		lefttmo;	/* ॢȤޤǤλ */
! 	uint_t	actcnt;		/* ư׵ᥭ塼󥰿 */
! 	uint_t	wupcnt;		/* ׵ᥭ塼󥰿 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* 㳰ξ */
! 	TEXPTN	pndptn;		/* α㳰װ */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* ޥեԤƬΥIDֹ */
! 	uint_t	semcnt;		/* ޥեθߤλ񸻿 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* ٥ȥե饰ԤƬΥIDֹ */
! 	FLGPTN	flgptn;		/* ٥ȥե饰θߤΥӥåȥѥ */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* ǡ塼ԤƬΥIDֹ */
! 	ID		rtskid;		/* ǡ塼μԤƬΥIDֹ */
! 	uint_t	sdtqcnt;	/* ǡ塼ΰ˳ǼƤǡο */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* ͥ٥ǡ塼ԤƬΥ
! 						   IDֹ */
! 	ID		rtskid;		/* ͥ٥ǡ塼μԤƬΥ
! 						   IDֹ */
! 	uint_t	spdqcnt;	/* ͥ٥ǡ塼ΰ˳ǼƤǡ
! 						   ο */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* ᡼ܥåԤƬΥIDֹ */
! 	T_MSG	*pk_msg;	/* å塼ƬˤĤʤ줿å
! 						   Ƭ */
  } T_RMBX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* ĹסԤƬΥ
! 						   IDֹ */
! 	uint_t	fblkcnt;	/* Ĺסΰζΰ˳
! 						   դ뤳ȤǤĹ֥åο */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* ϥɥư */
! 	RELTIM	lefttim;	/* ˼ϥɥưޤǤл */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* 顼ϥɥư */
! 	RELTIM	lefttim;	/* 顼ϥɥưޤǤл */
  } T_RALM;
  
  typedef struct t_rovr {
! 	STAT	ovrstat;	/* Хϥɥư */
! 	OVRTIM	leftotm;	/* Ĥץå */
  } T_ROVR;
  
  /*
!  *  ӥ
   */
  
  /*
!  *  ǽ
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
--- 102,209 ----
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  メモリ領域確保のための型定義
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* スタック領域を確保するための型 */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* 固定長メモリプール領域を確保するための型 */
  
  /*
!  *  メッセージヘッダの型定義
   */
! typedef	struct t_msg {			/* メールボックスのメッセージヘッダ */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* 優先度付きメッセージヘッダ */
! 	T_MSG	msgque;				/* メッセージヘッダ */
! 	PRI		msgpri;				/* メッセージ優先度 */
  } T_MSG_PRI;
  
  /*
!  *  パケット形式の定義
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/* タスク状態 */
! 	PRI		tskpri;		/* タスクの現在優先度 */
! 	PRI		tskbpri;	/* タスクのベース優先度 */
! 	STAT	tskwait;	/* 待ち要因 */
! 	ID		wobjid;		/* 待ち対象のオブジェクトのID */
! 	TMO		lefttmo;	/* タイムアウトするまでの時間 */
! 	uint_t	actcnt;		/* 起動要求キューイング数 */
! 	uint_t	wupcnt;		/* 起床要求キューイング数 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* タスク例外処理の状態 */
! 	TEXPTN	pndptn;		/* 保留例外要因 */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* セマフォの待ち行列の先頭のタスクのID番号 */
! 	uint_t	semcnt;		/* セマフォの現在の資源数 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* イベントフラグの待ち行列の先頭のタスクのID番号 */
! 	FLGPTN	flgptn;		/* イベントフラグの現在のビットパターン */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* データキューの送信待ち行列の先頭のタスクのID番号 */
! 	ID		rtskid;		/* データキューの受信待ち行列の先頭のタスクのID番号 */
! 	uint_t	sdtqcnt;	/* データキュー管理領域に格納されているデータの数 */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* 優先度データキューの送信待ち行列の先頭のタスク
! 						   のID番号 */
! 	ID		rtskid;		/* 優先度データキューの受信待ち行列の先頭のタスク
! 						   のID番号 */
! 	uint_t	spdqcnt;	/* 優先度データキュー管理領域に格納されているデー
! 						   タの数 */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* メールボックスの待ち行列の先頭のタスクのID番号 */
! 	T_MSG	*pk_msg;	/* メッセージキューの先頭につながれたメッセージ
! 						   の先頭番地 */
  } T_RMBX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* 固定長メモリプールの待ち行列の先頭のタスクの
! 						   ID番号 */
! 	uint_t	fblkcnt;	/* 固定長メモリプール領域の空きメモリ領域に割り
! 						   付けることができる固定長メモリブロックの数 */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* 周期ハンドラの動作状態 */
! 	RELTIM	lefttim;	/* 次に周期ハンドラを起動する時刻までの相対時間 */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* アラームハンドラの動作状態 */
! 	RELTIM	lefttim;	/* アラームハンドラを起動する時刻までの相対時間 */
  } T_RALM;
  
  typedef struct t_rovr {
! 	STAT	ovrstat;	/* オーバランハンドラの動作状態 */
! 	OVRTIM	leftotm;	/* 残りプロセッサ時間 */
  } T_ROVR;
  
  /*
!  *  サービスコールの宣言
   */
  
  /*
!  *  タスク管理機能
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
***************
*** 216,222 ****
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  °Ʊǽ
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
--- 216,222 ----
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  タスク付属同期機能
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
***************
*** 230,236 ****
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  㳰ǽ
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
--- 230,236 ----
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  タスク例外処理機能
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
***************
*** 240,246 ****
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  Ʊ̿ǽ
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
--- 240,246 ----
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  同期・通信機能
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
***************
*** 294,300 ****
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  סǽ
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
--- 294,300 ----
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  メモリプール管理機能
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
***************
*** 304,310 ****
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  ִǽ
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
--- 304,310 ----
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  時間管理機能
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
***************
*** 326,332 ****
  extern ER		ref_ovr(ID tskid, T_ROVR *pk_rovr) throw();
  
  /*
!  *  ƥִǽ
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
--- 326,332 ----
  extern ER		ref_ovr(ID tskid, T_ROVR *pk_rovr) throw();
  
  /*
!  *  システム状態管理機能
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
***************
*** 346,352 ****
  extern ER		ext_ker(void) throw();
  
  /*
!  *  ߴǽ
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
--- 346,352 ----
  extern ER		ext_ker(void) throw();
  
  /*
!  *  割込み管理機能
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
***************
*** 354,360 ****
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU㳰ǽ
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
--- 354,360 ----
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU例外管理機能
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
***************
*** 362,506 ****
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ֥°
   */
! #define TA_ACT			UINT_C(0x02)	/* ư줿֤ */
  
! #define TA_TPRI			UINT_C(0x01)	/* Ԥͥٽ */
! #define TA_MPRI			UINT_C(0x02)	/* å塼ͥٽ */
  
! #define TA_WMUL			UINT_C(0x02)	/* ʣԤ */
! #define TA_CLR			UINT_C(0x04)	/* ٥ȥե饰Υꥢ */
  
! #define TA_STA			UINT_C(0x02)	/* ϥɥư֤ */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* ͥγ */
  
! #define TA_ENAINT		UINT_C(0x01)	/* ׵ػߥե饰򥯥ꥢ */
! #define TA_EDGE			UINT_C(0x02)	/* åȥꥬ */
  
  /*
!  *  ӥư⡼ɤ
   */
! #define TWF_ORW			UINT_C(0x01)	/* ٥ȥե饰ORԤ */
! #define TWF_ANDW		UINT_C(0x02)	/* ٥ȥե饰ANDԤ */
  
  /*
!  *  ֥Ȥξ֤
   */
! #define TTS_RUN			UINT_C(0x01)	/* ¹Ծ */
! #define TTS_RDY			UINT_C(0x02)	/* ¹Բǽ */
! #define TTS_WAI			UINT_C(0x04)	/* Ԥ */
! #define TTS_SUS			UINT_C(0x08)	/* Ԥ */
! #define TTS_WAS			UINT_C(0x0c)	/* Ԥ */
! #define TTS_DMT			UINT_C(0x10)	/* ٻ߾ */
  
! #define TTW_SLP			UINT_C(0x0001)	/* Ԥ */
! #define TTW_DLY			UINT_C(0x0002)	/* ַвԤ */
! #define TTW_SEM			UINT_C(0x0004)	/* ޥեλ񸻳Ԥ */
! #define TTW_FLG			UINT_C(0x0008)	/* ٥ȥե饰Ԥ */
! #define TTW_SDTQ		UINT_C(0x0010)	/* ǡ塼ؤԤ */
! #define TTW_RDTQ		UINT_C(0x0020)	/* ǡ塼μԤ */
! #define TTW_SPDQ		UINT_C(0x0100)	/* ͥ٥ǡ塼ؤԤ */
! #define TTW_RPDQ		UINT_C(0x0200)	/* ͥ٥ǡ塼μԤ */
! #define TTW_MBX			UINT_C(0x0040)	/* ᡼ܥåμԤ */
! #define TTW_MPF			UINT_C(0x2000)	/* Ĺ֥åγԤ */
  
! #define TTEX_ENA		UINT_C(0x01)	/* 㳰ľ */
! #define TTEX_DIS		UINT_C(0x02)	/* 㳰ػ߾ */
  
! #define TCYC_STP		UINT_C(0x01)	/* ϥɥ餬ưƤʤ */
! #define TCYC_STA		UINT_C(0x02)	/* ϥɥ餬ưƤ */
  
! #define TALM_STP		UINT_C(0x01)	/* 顼ϥɥ餬ưƤʤ */
! #define TALM_STA		UINT_C(0x02)	/* 顼ϥɥ餬ưƤ */
  
! #define TOVR_STP		UINT_C(0x01)	/* Хϥɥ餬ưƤʤ*/
! #define TOVR_STA		UINT_C(0x02)	/* Хϥɥ餬ưƤ */
  
  /*
!  *  ¾
   */
! #define TSK_SELF		0			/*  */
! #define TSK_NONE		0			/* 륿ʤ */
  
! #define TPRI_SELF		0			/* Υ١ͥ */
! #define TPRI_INI		0			/* εưͥ */
  
! #define TIPM_ENAALL		0			/* ͥ٥ޥ */
  
  /*
!  *  ȥޥ
   */
  
  /*
!  *  ݡȤ뵡ǽ
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
  #ifdef TOPPERS_TARGET_SUPPORT_OVRHDR
! #define TOPPERS_SUPPORT_OVRHDR			/* Хϥɥ鵡ǽĥ */
  #endif /* TOPPERS_TARGET_SUPPORT_OVRHDR */
  
  /*
!  *  ͥ٤ϰ
   */
! #define TMIN_TPRI		1			/* ͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_TPRI		16			/* ͥ٤κ͡ʺ͡*/
! #define TMIN_DPRI		1			/* ǡͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_DPRI		16			/* ǡͥ٤κ͡ʺ͡*/
! #define TMIN_MPRI		1			/* åͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_MPRI		16			/* åͥ٤κ͡ʺ͡*/
! #define TMIN_ISRPRI		1			/* ߥӥ롼ͥ٤κǾ */
! #define TMAX_ISRPRI		16			/* ߥӥ롼ͥ٤κ */
  
  /*
!  *  С
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* ͥΥ᡼ */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* ͥμֹ */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* ͥͤΥСֹ */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* ͥΥСֹ */
  
  /*
!  *  塼󥰲κ
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* ư׵ᥭ塼󥰿κ */
! #define TMAX_WUPCNT		UINT_C(1)		/* ׵ᥭ塼󥰿κ */
  
  /*
!  *  ӥåȥѥΥӥåȿ
   */
! #ifndef TBIT_TEXPTN					/* 㳰װΥӥåȿ */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* ٥ȥե饰Υӥåȿ */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  ץå֡OVRTIMˤκ
   */
  #ifndef TMAX_OVRTIM
  #define TMAX_OVRTIM		ULONG_MAX
  #endif /* TMAX_OVRTIM */
  
  /*
!  *  ΰݤΤΥޥ
   *
!  *  ʲTOPPERS_COUNT_SZTOPPERS_ROUND_SZϡunit2ζҾǤ
!  *  뤳ȤꤷƤ롥
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
--- 362,506 ----
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  オブジェクト属性の定義
   */
! #define TA_ACT			UINT_C(0x02)	/* タスクを起動された状態で生成 */
  
! #define TA_TPRI			UINT_C(0x01)	/* タスクの待ち行列を優先度順に */
! #define TA_MPRI			UINT_C(0x02)	/* メッセージキューを優先度順に */
  
! #define TA_WMUL			UINT_C(0x02)	/* 複数の待ちタスク */
! #define TA_CLR			UINT_C(0x04)	/* イベントフラグのクリア指定 */
  
! #define TA_STA			UINT_C(0x02)	/* 周期ハンドラを動作状態で生成 */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* カーネル管理外の割込み */
  
! #define TA_ENAINT		UINT_C(0x01)	/* 割込み要求禁止フラグをクリア */
! #define TA_EDGE			UINT_C(0x02)	/* エッジトリガ */
  
  /*
!  *  サービスコールの動作モードの定義
   */
! #define TWF_ORW			UINT_C(0x01)	/* イベントフラグのOR待ち */
! #define TWF_ANDW		UINT_C(0x02)	/* イベントフラグのAND待ち */
  
  /*
!  *  オブジェクトの状態の定義
   */
! #define TTS_RUN			UINT_C(0x01)	/* 実行状態 */
! #define TTS_RDY			UINT_C(0x02)	/* 実行可能状態 */
! #define TTS_WAI			UINT_C(0x04)	/* 待ち状態 */
! #define TTS_SUS			UINT_C(0x08)	/* 強制待ち状態 */
! #define TTS_WAS			UINT_C(0x0c)	/* 二重待ち状態 */
! #define TTS_DMT			UINT_C(0x10)	/* 休止状態 */
  
! #define TTW_SLP			UINT_C(0x0001)	/* 起床待ち */
! #define TTW_DLY			UINT_C(0x0002)	/* 時間経過待ち */
! #define TTW_SEM			UINT_C(0x0004)	/* セマフォの資源獲得待ち */
! #define TTW_FLG			UINT_C(0x0008)	/* イベントフラグ待ち */
! #define TTW_SDTQ		UINT_C(0x0010)	/* データキューへの送信待ち */
! #define TTW_RDTQ		UINT_C(0x0020)	/* データキューからの受信待ち */
! #define TTW_SPDQ		UINT_C(0x0100)	/* 優先度データキューへの送信待ち */
! #define TTW_RPDQ		UINT_C(0x0200)	/* 優先度データキューからの受信待ち */
! #define TTW_MBX			UINT_C(0x0040)	/* メールボックスからの受信待ち */
! #define TTW_MPF			UINT_C(0x2000)	/* 固定長メモリブロックの獲得待ち */
  
! #define TTEX_ENA		UINT_C(0x01)	/* タスク例外処理許可状態 */
! #define TTEX_DIS		UINT_C(0x02)	/* タスク例外処理禁止状態 */
  
! #define TCYC_STP		UINT_C(0x01)	/* 周期ハンドラが動作していない */
! #define TCYC_STA		UINT_C(0x02)	/* 周期ハンドラが動作している */
  
! #define TALM_STP		UINT_C(0x01)	/* アラームハンドラが動作していない */
! #define TALM_STA		UINT_C(0x02)	/* アラームハンドラが動作している */
  
! #define TOVR_STP		UINT_C(0x01)	/* オーバランハンドラが動作していない*/
! #define TOVR_STA		UINT_C(0x02)	/* オーバランハンドラが動作している */
  
  /*
!  *  その他の定数の定義
   */
! #define TSK_SELF		0			/* 自タスク指定 */
! #define TSK_NONE		0			/* 該当するタスクがない */
  
! #define TPRI_SELF		0			/* 自タスクのベース優先度 */
! #define TPRI_INI		0			/* タスクの起動時優先度 */
  
! #define TIPM_ENAALL		0			/* 割込み優先度マスク全解除 */
  
  /*
!  *  構成定数とマクロ
   */
  
  /*
!  *  サポートする機能
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
  #ifdef TOPPERS_TARGET_SUPPORT_OVRHDR
! #define TOPPERS_SUPPORT_OVRHDR			/* オーバランハンドラ機能拡張 */
  #endif /* TOPPERS_TARGET_SUPPORT_OVRHDR */
  
  /*
!  *  優先度の範囲
   */
! #define TMIN_TPRI		1			/* タスク優先度の最小値（最高値）*/
! #define TMAX_TPRI		16			/* タスク優先度の最大値（最低値）*/
! #define TMIN_DPRI		1			/* データ優先度の最小値（最高値）*/
! #define TMAX_DPRI		16			/* データ優先度の最大値（最低値）*/
! #define TMIN_MPRI		1			/* メッセージ優先度の最小値（最高値）*/
! #define TMAX_MPRI		16			/* メッセージ優先度の最大値（最低値）*/
! #define TMIN_ISRPRI		1			/* 割込みサービスルーチン優先度の最小値 */
! #define TMAX_ISRPRI		16			/* 割込みサービスルーチン優先度の最大値 */
  
  /*
!  *  バージョン情報
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* カーネルのメーカーコード */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* カーネルの識別番号 */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* カーネル仕様のバージョン番号 */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* カーネルのバージョン番号 */
  
  /*
!  *  キューイング回数の最大値
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* 起動要求キューイング数の最大値 */
! #define TMAX_WUPCNT		UINT_C(1)		/* 起床要求キューイング数の最大値 */
  
  /*
!  *  ビットパターンのビット数
   */
! #ifndef TBIT_TEXPTN					/* タスク例外要因のビット数 */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* イベントフラグのビット数 */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  プロセッサ時間（OVRTIM）の最大値
   */
  #ifndef TMAX_OVRTIM
  #define TMAX_OVRTIM		ULONG_MAX
  #endif /* TMAX_OVRTIM */
  
  /*
!  *  メモリ領域確保のためのマクロ
   *
!  *  以下のTOPPERS_COUNT_SZとTOPPERS_ROUND_SZの定義は，unitが2の巾乗であ
!  *  ることを仮定している．
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
***************
*** 516,524 ****
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  ¾ι
   */
! #define TMAX_MAXSEM		UINT_MAX	/* ޥեκ񸻿κ */
  
  #ifdef __cplusplus
  }
--- 516,524 ----
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  その他の構成定数
   */
! #define TMAX_MAXSEM		UINT_MAX	/* セマフォの最大資源数の最大値 */
  
  #ifdef __cplusplus
  }
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/Makefile.kernel ASPs/asp/extension/ovrhdr/kernel/Makefile.kernel
*** 1.9.1/asp/extension/ovrhdr/kernel/Makefile.kernel	Sun Jan 31 20:41:39 2010
--- ASPs/asp/extension/ovrhdr/kernel/Makefile.kernel	Fri Dec  9 13:54:02 2022
***************
*** 8,52 ****
  #  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! #  ܥեȥѤΤޤࡥʲƱˤѡʣ
! #  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! #  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! #      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! #      ˴ޤޤƤ뤳ȡ
! #  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! #      ѤǤǺۤˤϡۤȼɥȡ
! #      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! #      ̵ݾڵǺܤ뤳ȡ
! #  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! #      ѤǤʤǺۤˤϡΤ줫ξ
! #      ȡ
! #    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! #        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! #    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! #        𤹤뤳ȡ
! #  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! #      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! #      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! #      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! #      դ뤳ȡ
  # 
! #  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! #  TOPPERSץȤϡܥեȥ˴ؤơλŪ
! #  ФŬޤơʤݾڤԤʤޤܥեȥ
! #  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! #  Ǥʤ
  # 
  #  @(#) $Id: Makefile.kernel 1717 2010-01-31 11:41:03Z ertl-hiro $
  # 
  
  #
! #		ͥΥե빽
  #
  
  #
! #  1ĤΥե뤫ʣΥ֥ȥե褦˺
! #  줿եΥꥹ
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
--- 8,52 ----
  #  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! #  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! #  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! #  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! #      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! #      スコード中に含まれていること．
! #  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! #      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! #      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! #      の無保証規定を掲載すること．
! #  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! #      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! #      と．
! #    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! #        作権表示，この利用条件および下記の無保証規定を掲載すること．
! #    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! #        報告すること．
! #  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! #      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! #      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! #      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! #      免責すること．
  # 
! #  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! #  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! #  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! #  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! #  の責任を負わない．
  # 
  #  @(#) $Id: Makefile.kernel 1717 2010-01-31 11:41:03Z ertl-hiro $
  # 
  
  #
! #		カーネルのファイル構成の定義
  #
  
  #
! #  1つのソースファイルから複数のオブジェクトファイルを生成するように作
! #  成されたソースファイルのリスト
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
***************
*** 55,61 ****
  				sys_manage.c interrupt.c exception.c
  
  #
! #  ƥե뤫륪֥ȥեΥꥹ
  #
  startup = sta_ker.o ext_ker.o
  
--- 55,61 ----
  				sys_manage.c interrupt.c exception.c
  
  #
! #  各ソースファイルから生成されるオブジェクトファイルのリスト
  #
  startup = sta_ker.o ext_ker.o
  
***************
*** 115,121 ****
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  륪֥ȥեΰ¸ط
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
--- 115,121 ----
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  生成されるオブジェクトファイルの依存関係の定義
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/allfunc.h ASPs/asp/extension/ovrhdr/kernel/allfunc.h
*** 1.9.1/asp/extension/ovrhdr/kernel/allfunc.h	Sun Jan 31 20:41:39 2010
--- ASPs/asp/extension/ovrhdr/kernel/allfunc.h	Fri Dec  9 13:54:02 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: allfunc.h 1717 2010-01-31 11:41:03Z ertl-hiro $
   */
  
  /*
!  *		٤Ƥδؿ򥳥ѥ뤹뤿
   */
  
  #ifndef TOPPERS_ALLFUNC_H
--- 6,45 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: allfunc.h 1717 2010-01-31 11:41:03Z ertl-hiro $
   */
  
  /*
!  *		すべての関数をコンパイルするための定義
   */
  
  #ifndef TOPPERS_ALLFUNC_H
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/check.h ASPs/asp/extension/ovrhdr/kernel/check.h
*** 1.9.1/asp/extension/ovrhdr/kernel/check.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/ovrhdr/kernel/check.h	Fri Dec  9 13:54:02 2022
***************
*** 8,54 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: check.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		顼åѥޥ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  ͥ٤ϰϤȽ
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
--- 8,54 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: check.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		エラーチェック用マクロ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  優先度の範囲の判定
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
***************
*** 58,64 ****
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
--- 58,64 ----
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  タスク優先度のチェック（E_PAR）
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
***************
*** 82,88 ****
  } while (false)
  
  /*
!  *  ॢȻͤΥåE_PAR
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
--- 82,88 ----
  } while (false)
  
  /*
!  *  タイムアウト指定値のチェック（E_PAR）
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
***************
*** 92,98 ****
  } while (false)
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
--- 92,98 ----
  } while (false)
  
  /*
!  *  割込み優先度のチェック（E_PAR）
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
***************
*** 102,108 ****
  } while (false)
  
  /*
!  *  ֹΥåE_PAR
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
--- 102,108 ----
  } while (false)
  
  /*
!  *  割込み番号のチェック（E_PAR）
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
***************
*** 112,118 ****
  } while (false)
  
  /*
!  *  ¾Υѥ᡼顼ΥåE_PAR
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
--- 112,118 ----
  } while (false)
  
  /*
!  *  その他のパラメータエラーのチェック（E_PAR）
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
***************
*** 122,128 ****
  } while (false)
  
  /*
!  *  ֥IDϰϤȽ
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
--- 122,128 ----
  } while (false)
  
  /*
!  *  オブジェクトIDの範囲の判定
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
***************
*** 135,141 ****
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  ֥IDΥåE_ID
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
--- 135,141 ----
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  オブジェクトIDのチェック（E_ID）
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
***************
*** 208,214 ****
  } while (false)
  
  /*
!  *  ƽФƥȤΥåE_CTX
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
--- 208,214 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストのチェック（E_CTX）
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
***************
*** 225,231 ****
  } while (false)
  
  /*
!  *  ƽФƥȤCPUå֤ΥåE_CTX
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
--- 225,231 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストとCPUロック状態のチェック（E_CTX）
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
***************
*** 242,248 ****
  } while (false)
  
  /*
!  *  ǥѥåα֤ǤʤΥåE_CTX
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
--- 242,248 ----
  } while (false)
  
  /*
!  *  ディスパッチ保留状態でないかのチェック（E_CTX）
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
***************
*** 252,258 ****
  } while (false)
  
  /*
!  *  ¾Υƥȥ顼ΥåE_CTX
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
--- 252,258 ----
  } while (false)
  
  /*
!  *  その他のコンテキストエラーのチェック（E_CTX）
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
***************
*** 262,268 ****
  } while (false)
  
  /*
!  *  ꤷƤʤΥåE_ILUSE
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
--- 262,268 ----
  } while (false)
  
  /*
!  *  自タスクを指定していないかのチェック（E_ILUSE）
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
***************
*** 272,278 ****
  } while (false)
  
  /*
!  *  ¾ѥ顼ΥåE_ILUSE
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
--- 272,278 ----
  } while (false)
  
  /*
!  *  その他の不正使用エラーのチェック（E_ILUSE）
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
***************
*** 282,288 ****
  } while (false)
  
  /*
!  *  Ūʥ֥Ⱦ֥顼ΥåE_OBJ
   */
  #define CHECK_OBJ(exp) do {									\
  	if (!(exp)) {											\
--- 282,288 ----
  } while (false)
  
  /*
!  *  静的なオブジェクト状態エラーのチェック（E_OBJ）
   */
  #define CHECK_OBJ(exp) do {									\
  	if (!(exp)) {											\
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/kernel.tf ASPs/asp/extension/ovrhdr/kernel/kernel.tf
*** 1.9.1/asp/extension/ovrhdr/kernel/kernel.tf	Sun Sep 28 18:32:50 2014
--- ASPs/asp/extension/ovrhdr/kernel/kernel.tf	Fri Dec  9 13:54:02 2022
***************
*** 8,48 ****
  $   Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   $Id: kernel.tf 2661 2014-09-28 09:32:49Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.h
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
--- 8,48 ----
  $   Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   $Id: kernel.tf 2661 2014-09-28 09:32:49Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.hの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
***************
*** 91,97 ****
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.c
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
--- 91,97 ----
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.cの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
***************
*** 105,111 ****
  $NL$
  
  $ 
! $  󥯥롼ɥǥ쥯ƥ֡#include
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
--- 105,111 ----
  $NL$
  
  $ 
! $  インクルードディレクティブ（#include）
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
***************
*** 115,121 ****
  $NL$
  
  $ 
! $  ֥ȤIDֹݻѿ
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
--- 115,121 ----
  $NL$
  
  $ 
! $  オブジェクトのID番号を保持する変数
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
***************
*** 152,158 ****
  $END$
  
  $ 
! $  ȥ졼ޥΥǥե
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
--- 152,158 ----
  $END$
  
  $ 
! $  トレースログマクロのデフォルト定義
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
***************
*** 168,217 ****
  $NL$
  
  $ 
! $  
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 1İʾ¸ߤ뤳ȤΥå
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ IDֹκ
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ 顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrʡTA_ACTϡˤǤʤE_RSATR
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)ǤʤE_PAR
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrTA_NULLˤǤʤE_RSATR
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ åΰȤ˴ؤ륨顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// stksz0ʲåκǾ͡TARGET_MIN_STKSZˤ
! $	// E_PAR
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszåΰΥȤʤE_PAR
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
--- 168,217 ----
  $NL$
  
  $ 
! $  タスク
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ タスクが1個以上存在することのチェック
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ タスクID番号の最大値
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ エラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrが（［TA_ACT］）でない場合（E_RSATR）
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)でない場合（E_PAR）
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrが（TA_NULL）でない場合（E_RSATR）
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ スタック領域の生成とそれに関するエラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// stkszが0以下か，ターゲット定義の最小値（TARGET_MIN_STKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
***************
*** 228,302 ****
  $END$
  $NL$
  
! $ ֥åʥ1İʾ¸ߤ
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// °ĥ󡤵ưϡưͥ
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// ƥȥ֥ååΰ
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// 㳰롼°ȵư
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ ֥å
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ ơ֥
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  ޥե
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ޥեIDֹκ
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ ޥե֥å
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)ǤʤE_PAR
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)ǤʤE_PAR
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// ޥե֥å
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ޥե֥å
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
--- 228,302 ----
  $END$
  $NL$
  
! $ タスク初期化ブロックの生成（タスクは1個以上存在する）
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// タスク属性，拡張情報，起動番地，起動時優先度
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// タスク初期化コンテキストブロック，スタック領域
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// タスク例外処理ルーチンの属性と起動番地
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ タスク管理ブロックの生成
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ タスク生成順序テーブルの生成
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  セマフォ
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ セマフォID番号の最大値
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ セマフォ初期化ブロックの生成
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)でない場合（E_PAR）
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)でない場合（E_PAR）
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// セマフォ初期化ブロック
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// セマフォ管理ブロック
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
***************
*** 304,341 ****
  $END$$NL$
  
  $ 
! $  ٥ȥե饰
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ٥ȥե饰IDֹκ
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ ٥ȥե饰֥å
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrʡTA_TPRIϡáTA_WMULϡáTA_CLRϡˤǤʤE_RSATR
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnFLGPTN˳ǼǤʤE_PAR
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// ٥ȥե饰֥å
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ٥ȥե饰֥å
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
--- 304,341 ----
  $END$$NL$
  
  $ 
! $  イベントフラグ
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ イベントフラグID番号の最大値
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ イベントフラグ初期化ブロックの生成
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrが（［TA_TPRI］｜［TA_WMUL］｜［TA_CLR］）でない場合（E_RSATR）
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnがFLGPTNに格納できない場合（E_PAR）
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// イベントフラグ初期化ブロック
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// イベントフラグ管理ブロック
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
***************
*** 343,383 ****
  $END$$NL$
  
  $ 
! $  ǡ塼
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ǡ塼IDֹκ
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntξE_PAR
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbNULLǤʤE_NOSPT
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// ǡ塼ΰ
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// ǡ塼֥å
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
--- 343,383 ----
  $END$$NL$
  
  $ 
! $  データキュー
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ データキューID番号の最大値
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntが負の場合（E_PAR）
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// データキュー管理領域
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// データキュー初期化ブロックの生成
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
***************
*** 385,391 ****
  	};$NL$
  	$NL$
  
! $	// ǡ塼֥å
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
--- 385,391 ----
  	};$NL$
  	$NL$
  
! $	// データキュー管理ブロック
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
***************
*** 393,438 ****
  $END$$NL$
  
  $ 
! $  ͥ٥ǡ塼
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ͥ٥ǡ塼IDֹκ
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntξE_PAR
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)ǤʤE_PAR
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbNULLǤʤE_NOSPT
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// ͥ٥ǡ塼ΰ
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// ͥ٥ǡ塼֥å
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
--- 393,438 ----
  $END$$NL$
  
  $ 
! $  優先度データキュー
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 優先度データキューID番号の最大値
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntが負の場合（E_PAR）
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)でない場合（E_PAR）
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// 優先度データキュー管理領域
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// 優先度データキュー初期化ブロックの生成
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
***************
*** 440,446 ****
  	};$NL$
  	$NL$
  
! $	// ͥ٥ǡ塼֥å
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
--- 440,446 ----
  	};$NL$
  	$NL$
  
! $	// 優先度データキュー管理ブロック
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
***************
*** 448,490 ****
  $END$$NL$
  
  $ 
! $  ᡼ܥå
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ᡼ܥåIDֹκ
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ ᡼ܥå֥å
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrʡTA_TPRIϡáTA_MPRIϡˤǤʤE_RSATR
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)ǤʤE_PAR
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdNULLǤʤE_NOSPT
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// ᡼ܥå֥å
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ᡼ܥå֥å
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
--- 448,490 ----
  $END$$NL$
  
  $ 
! $  メールボックス
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ メールボックスID番号の最大値
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ メールボックス初期化ブロックの生成
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrが（［TA_TPRI］｜［TA_MPRI］）でない場合（E_RSATR）
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)でない場合（E_PAR）
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdがNULLでない場合（E_NOSPT）
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// メールボックス初期化ブロック
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// メールボックス管理ブロック
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
***************
*** 492,540 ****
  $END$$NL$
  
  $ 
! $  Ĺס
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ĹסIDֹκ
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcnt0ʲξE_PAR
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blksz0ʲξE_PAR
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbNULLǤʤE_NOSPT
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// Ĺס֥å
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
--- 492,540 ----
  $END$$NL$
  
  $ 
! $  固定長メモリプール
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 固定長メモリプールID番号の最大値
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcntが0以下の場合（E_PAR）
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkszが0以下の場合（E_PAR）
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール領域
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール管理領域
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// 固定長メモリプール初期化ブロックの生成
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
***************
*** 542,548 ****
  	};$NL$
  	$NL$
  
! $	// Ĺס֥å
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
--- 542,548 ----
  	};$NL$
  	$NL$
  
! $	// 固定長メモリプール管理ブロック
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
***************
*** 550,597 ****
  $END$$NL$
  
  $ 
! $  ϥɥ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ϥɥIDֹκ
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ ϥɥơ֥
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrʡTA_STAϡˤǤʤE_RSATR
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// ٹcycatrTA_STAꤵƤơ(cycphs == 0)ξ
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// ϥɥ֥å
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ϥɥ֥å
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
--- 550,597 ----
  $END$$NL$
  
  $ 
! $  周期ハンドラ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 周期ハンドラID番号の最大値
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ 周期ハンドラ初期化テーブルの生成
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrが（［TA_STA］）でない場合（E_RSATR）
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// 警告：cycatrにTA_STAが設定されていて，(cycphs == 0)の場合
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// 周期ハンドラ初期化ブロック
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 周期ハンドラ管理ブロック
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
***************
*** 599,631 ****
  $END$$NL$
  
  $ 
! $  顼ϥɥ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 顼ϥɥIDֹκ
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ 顼ϥɥ֥å
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrTA_NULLˤǤʤE_RSATR
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// 顼ϥɥ֥å
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 顼ϥɥ֥å
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
--- 599,631 ----
  $END$$NL$
  
  $ 
! $  アラームハンドラ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ アラームハンドラID番号の最大値
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ アラームハンドラ初期化ブロックの生成
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrが（TA_NULL）でない場合（E_RSATR）
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// アラームハンドラ初期化ブロック
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// アラームハンドラ管理ブロック
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
***************
*** 633,642 ****
  $END$$NL$
  
  $ 
! $  Хϥɥ
  $ 
  $IF !TOPPERS_SUPPORT_OVRHDR$
! $	// Хϥɥ餬ݡȤƤʤ
  	$IF LENGTH(OVR.ORDER_LIST)$
  		$ERROR$E_NOSPT: $FORMAT(_("%1% is not supported on this target"), "DEF_OVR")$$END$
  	$END$
--- 633,642 ----
  $END$$NL$
  
  $ 
! $  オーバランハンドラ
  $ 
  $IF !TOPPERS_SUPPORT_OVRHDR$
! $	// オーバランハンドラがサポートされていない場合
  	$IF LENGTH(OVR.ORDER_LIST)$
  		$ERROR$E_NOSPT: $FORMAT(_("%1% is not supported on this target"), "DEF_OVR")$$END$
  	$END$
***************
*** 646,663 ****
  	$SPC$*/$NL$
  	$NL$
  
! $	// ŪAPIDEF_OVRפʣE_OBJ
  	$IF LENGTH(OVR.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_OVR")$$END$
  	$END$
  
! $	// ovratrTA_NULLˤǤʤE_RSATR
  	$IF OVR.OVRATR[1] != 0$
  		$ERROR OVR.TEXT_LINE[1]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "ovratr", OVR.OVRATR[1], "DEF_OVR")$
  		$END$
  	$END$
  
! $	// Хϥɥ֥å
  	const OVRINIB _kernel_ovrinib = {$NL$
  	$IF LENGTH(OVR.ORDER_LIST)$
  		$TAB$($OVR.OVRATR[1]$), ($OVR.OVRHDR[1]$)$NL$
--- 646,663 ----
  	$SPC$*/$NL$
  	$NL$
  
! $	// 静的API「DEF_OVR」が複数ある（E_OBJ）
  	$IF LENGTH(OVR.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_OVR")$$END$
  	$END$
  
! $	// ovratrが（TA_NULL）でない場合（E_RSATR）
  	$IF OVR.OVRATR[1] != 0$
  		$ERROR OVR.TEXT_LINE[1]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "ovratr", OVR.OVRATR[1], "DEF_OVR")$
  		$END$
  	$END$
  
! $	// オーバランハンドラ初期化ブロックの生成
  	const OVRINIB _kernel_ovrinib = {$NL$
  	$IF LENGTH(OVR.ORDER_LIST)$
  		$TAB$($OVR.OVRATR[1]$), ($OVR.OVRHDR[1]$)$NL$
***************
*** 668,681 ****
  $END$
  
  $ 
! $  ߴǽ
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ֹȳߥϥɥֹѴơ֥κ
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
--- 668,681 ----
  $END$
  
  $ 
! $  割込み管理機能
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 割込み番号と割込みハンドラ番号の変換テーブルの作成
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
***************
*** 687,701 ****
  	$i = i + 1$
  $END$
  
! $ ׵饤˴ؤ륨顼å
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoCFG_INTФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoCFG_INTˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
--- 687,701 ----
  	$i = i + 1$
  $END$
  
! $ 割込み要求ラインに関するエラーチェック
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoがCFG_INTに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoがCFG_INTによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
***************
*** 704,729 ****
  		$j = j + 1$
  	$END$
  
! $	// intatrʡTA_ENAINTϡáTA_EDGEϡˤǤʤE_RSATR
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriCFG_INTФͥ٤ȤʤE_PAR
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵ줿E_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵʤäE_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
--- 704,729 ----
  		$j = j + 1$
  	$END$
  
! $	// intatrが（［TA_ENAINT］｜［TA_EDGE］）でない場合（E_RSATR）
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriがCFG_INTに対する割込み優先度として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// カーネル管理に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定された場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定されなかった場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
***************
*** 732,746 ****
  	$i = i + 1$
  $END$
  
! $ ߥϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoDEF_INHФߥϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoDEF_INHˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
--- 732,746 ----
  	$i = i + 1$
  $END$
  
! $ 割込みハンドラに関するエラーチェック
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoがDEF_INHに対する割込みハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoがDEF_INHによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
***************
*** 749,769 ****
  		$j = j + 1$
  	$END$
  
! $	// inhatrTA_NULLˤǤʤE_RSATR
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	//ꤵƤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	// ꤵƤʤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
--- 749,769 ----
  		$j = j + 1$
  	$END$
  
! $	// inhatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// カーネル管理に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	//　が指定されている場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	// が指定されていない場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
***************
*** 772,792 ****
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoбintnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrTA_NONKERNELꤵƤ餺inhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRI⾮E_OBJ
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrTA_NONKERNELꤵƤꡤinhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRIʾǤE_OBJ
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
--- 772,792 ----
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoに対応するintnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrにTA_NONKERNELが指定されておらず，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRIよりも小さい場合（E_OBJ）
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrにTA_NONKERNELが指定されており，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRI以上である場合（E_OBJ）
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
***************
*** 796,814 ****
  	$i = i + 1$
  $END$
  
! $ ߥӥ롼ISRˤ˴ؤ륨顼åȳߥϥɥ
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrTA_NULLˤǤʤE_RSATR
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoATT_ISRФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)ǤʤE_PAR
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
--- 796,814 ----
  	$i = i + 1$
  $END$
  
! $ 割込みサービスルーチン（ISR）に関するエラーチェックと割込みハンドラの生成
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrが（TA_NULL）でない場合（E_RSATR）
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoがATT_ISRに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)でない場合（E_PAR）
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
***************
*** 817,823 ****
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// ֹintnoФϿ줿ISRΥꥹȤκ
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
--- 817,823 ----
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// 割込み番号intnoに対して登録されたISRのリストの作成
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
***************
*** 826,844 ****
  		$END$
  	$END$
  
! $	// ֹintnoФϿ줿ISR¸ߤ
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoбinhnoФDEF_INHE_OBJ
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoФCFG_INTꤵ줿ͥ٤TMIN_INTPRI
! $			// ⾮E_OBJ
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
--- 826,844 ----
  		$END$
  	$END$
  
! $	// 割込み番号intnoに対して登録されたISRが存在する場合
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoに対応するinhnoに対してDEF_INHがある場合（E_OBJ）
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoに対してCFG_INTで設定された割込み優先度がTMIN_INTPRI
! $			// よりも小さい場合（E_OBJ）
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
***************
*** 850,856 ****
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISRѤγߥϥɥ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
--- 850,856 ----
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISR用の割込みハンドラ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
***************
*** 862,868 ****
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRͥٽ˸ƤӽФ
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
--- 862,868 ----
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRを優先度順に呼び出す
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
***************
*** 875,886 ****
  $NL$
  
  $ 
! $  ߴǽΤɸŪʽ
  $ 
! $ ߥϥɥνɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ ߥϥɥ
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
--- 875,886 ----
  $NL$
  
  $ 
! $  割込み管理機能のための標準的な初期化情報の生成
  $ 
! $ 割込みハンドラの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ 割込みハンドラ数
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
***************
*** 891,897 ****
  $END$
  $NL$
  
! $ ߥϥɥơ֥
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
--- 891,897 ----
  $END$
  $NL$
  
! $ 割込みハンドラ初期化テーブル
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
***************
*** 907,921 ****
  $END$$NL$
  $END$
  
! $ ׵饤νɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ ׵饤
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ ׵饤ơ֥
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
--- 907,921 ----
  $END$$NL$
  $END$
  
! $ 割込み要求ラインの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ 割込み要求ライン数
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ 割込み要求ライン初期化テーブル
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
***************
*** 928,949 ****
  $END$
  
  $ 
! $  CPU㳰ǽ
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU㳰ϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoDEF_EXCФCPU㳰ϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoDEF_EXCˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
--- 928,949 ----
  $END$
  
  $ 
! $  CPU例外管理機能
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU例外ハンドラに関するエラーチェック
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoがDEF_EXCに対するCPU例外ハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoがDEF_EXCによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
***************
*** 952,968 ****
  		$j = j + 1$
  	$END$
  
! $	// excatrTA_NULLˤǤʤE_RSATR
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU㳰ϥɥΤɸŪʽ
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU㳰ϥɥ
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
--- 952,968 ----
  		$j = j + 1$
  	$END$
  
! $	// excatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU例外ハンドラのための標準的な初期化情報の生成
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU例外ハンドラ数
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
***************
*** 971,977 ****
  $END$
  $NL$
  
! $ CPU㳰ϥɥơ֥
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
--- 971,977 ----
  $END$
  $NL$
  
! $ CPU例外ハンドラ初期化テーブル
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
***************
*** 984,990 ****
  $END$
  
  $ 
! $  󥿥ƥѤΥåΰ
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
--- 984,990 ----
  $END$
  
  $ 
! $  非タスクコンテキスト用のスタック領域
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
***************
*** 992,998 ****
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSʤΥǥեͤ
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
--- 992,998 ----
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSがない場合のデフォルト値の設定
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
***************
*** 1007,1032 ****
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// ŪAPIDEF_ICSפʣE_OBJ
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istksz0ʲåκǾ͡TARGET_MIN_ISTKSZˤ
! $	// E_PAR
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszåΰΥȤʤE_PAR
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// åΰμưդ
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
--- 1007,1032 ----
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// 静的API「DEF_ICS」が複数ある（E_OBJ）
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istkszが0以下か，ターゲット定義の最小値（TARGET_MIN_ISTKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// スタック領域の自動割付け
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
***************
*** 1037,1043 ****
  $END$
  $NL$
  
! $ 󥿥ƥѤΥåΰ
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
--- 1037,1043 ----
  $END$
  $NL$
  
! $ 非タスクコンテキスト用のスタック領域
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
***************
*** 1047,1053 ****
  $NL$
  
  $ 
! $  ।٥ȴ
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
--- 1047,1053 ----
  $NL$
  
  $ 
! $  タイムイベント管理
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
***************
*** 1057,1063 ****
  $NL$
  
  $ 
! $  ƥ⥸塼νؿ
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
--- 1057,1063 ----
  $NL$
  
  $ 
! $  各モジュールの初期化関数
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
***************
*** 1082,1088 ****
  $NL$
  
  $ 
! $  롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
--- 1082,1088 ----
  $NL$
  
  $ 
! $  初期化ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
***************
*** 1092,1098 ****
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrTA_NULLˤǤʤE_RSATR
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
--- 1092,1098 ----
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrが（TA_NULL）でない場合（E_RSATR）
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
***************
*** 1102,1108 ****
  $NL$
  
  $ 
! $  λ롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
--- 1102,1108 ----
  $NL$
  
  $ 
! $  終了処理ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
***************
*** 1112,1118 ****
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrTA_NULLˤǤʤE_RSATR
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
--- 1112,1118 ----
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrが（TA_NULL）でない場合（E_RSATR）
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/kernel_check.tf ASPs/asp/extension/ovrhdr/kernel/kernel_check.tf
*** 1.9.1/asp/extension/ovrhdr/kernel/kernel_check.tf	Mon Sep 16 10:32:44 2013
--- ASPs/asp/extension/ovrhdr/kernel/kernel_check.tf	Fri Dec  9 13:54:02 2022
***************
*** 7,47 ****
  $   Copyright (C) 2008-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   @(#) $Id: kernel_check.tf 2526 2013-09-16 01:32:30Z ertl-hiro $
  $  
  $ =====================================================================
  
  $
! $  ǡLMAVMAؤΥԡ
  $
  $FOREACH lma LMA.ORDER_LIST$
  	$start_data = SYMBOL(LMA.START_DATA[lma])$
--- 7,47 ----
  $   Copyright (C) 2008-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   @(#) $Id: kernel_check.tf 2526 2013-09-16 01:32:30Z ertl-hiro $
  $  
  $ =====================================================================
  
  $
! $  データセクションのLMAからVMAへのコピー
  $
  $FOREACH lma LMA.ORDER_LIST$
  	$start_data = SYMBOL(LMA.START_DATA[lma])$
***************
*** 59,68 ****
  $END$
  
  $ 
! $  ؿƬϤΥå
  $ 
  $IF CHECK_FUNC_ALIGN || CHECK_FUNC_NONNULL$
! $	// ȥ㳰롼ƬϤΥå
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$task = PEEK(tinib + offsetof_TINIB_task, sizeof_FP)$
--- 59,68 ----
  $END$
  
  $ 
! $  関数の先頭番地のチェック
  $ 
  $IF CHECK_FUNC_ALIGN || CHECK_FUNC_NONNULL$
! $	// タスクとタスク例外処理ルーチンの先頭番地のチェック
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$task = PEEK(tinib + offsetof_TINIB_task, sizeof_FP)$
***************
*** 85,91 ****
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// ϥɥƬϤΥå
  	$cycinib = SYMBOL("_kernel_cycinib_table")$
  	$FOREACH cycid CYC.ID_LIST$
  		$cychdr = PEEK(cycinib + offsetof_CYCINIB_cychdr, sizeof_FP)$
--- 85,91 ----
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// 周期ハンドラの先頭番地のチェック
  	$cycinib = SYMBOL("_kernel_cycinib_table")$
  	$FOREACH cycid CYC.ID_LIST$
  		$cychdr = PEEK(cycinib + offsetof_CYCINIB_cychdr, sizeof_FP)$
***************
*** 102,108 ****
  		$cycinib = cycinib + sizeof_CYCINIB$
  	$END$
  
! $	// 顼ϥɥƬϤΥå
  	$alminib = SYMBOL("_kernel_alminib_table")$
  	$FOREACH almid ALM.ID_LIST$
  		$almhdr = PEEK(alminib + offsetof_ALMINIB_almhdr, sizeof_FP)$
--- 102,108 ----
  		$cycinib = cycinib + sizeof_CYCINIB$
  	$END$
  
! $	// アラームハンドラの先頭番地のチェック
  	$alminib = SYMBOL("_kernel_alminib_table")$
  	$FOREACH almid ALM.ID_LIST$
  		$almhdr = PEEK(alminib + offsetof_ALMINIB_almhdr, sizeof_FP)$
***************
*** 119,125 ****
  		$alminib = alminib + sizeof_ALMINIB$
  	$END$
  
! $	// ХϥɥƬϤΥå
  	$ovrinib = SYMBOL("_kernel_ovrinib")$
  	$IF LENGTH(OVR.ORDER_LIST)$
  		$ovrhdr = PEEK(ovrinib + offsetof_OVRINIB_ovrhdr, sizeof_FP)$
--- 119,125 ----
  		$alminib = alminib + sizeof_ALMINIB$
  	$END$
  
! $	// オーバランハンドラの先頭番地のチェック
  	$ovrinib = SYMBOL("_kernel_ovrinib")$
  	$IF LENGTH(OVR.ORDER_LIST)$
  		$ovrhdr = PEEK(ovrinib + offsetof_OVRINIB_ovrhdr, sizeof_FP)$
***************
*** 137,146 ****
  $END$
  
  $ 
! $  åΰƬϤΥå
  $ 
  $IF CHECK_STACK_ALIGN || CHECK_STACK_NONNULL$
! $	// ΥåΰƬϤΥå
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$IF USE_TSKINICTXB$
--- 137,146 ----
  $END$
  
  $ 
! $  スタック領域の先頭番地のチェック
  $ 
  $IF CHECK_STACK_ALIGN || CHECK_STACK_NONNULL$
! $	// タスクのスタック領域の先頭番地のチェック
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$IF USE_TSKINICTXB$
***************
*** 161,167 ****
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// 󥿥ƥѤΥåΰƬϤΥå
  	$istk = PEEK(SYMBOL("_kernel_istk"), sizeof_void_ptr)$
  	$IF CHECK_STACK_ALIGN && (istk & (CHECK_STACK_ALIGN - 1)) != 0$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: 
--- 161,167 ----
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// 非タスクコンテキスト用のスタック領域の先頭番地のチェック
  	$istk = PEEK(SYMBOL("_kernel_istk"), sizeof_void_ptr)$
  	$IF CHECK_STACK_ALIGN && (istk & (CHECK_STACK_ALIGN - 1)) != 0$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: 
***************
*** 176,185 ****
  $END$
  
  $ 
! $  ĹסΰƬϤΥå
  $ 
  $IF CHECK_MPF_ALIGN || CHECK_MPF_NONNULL$
! $	// ĹסΰƬϤΥå
  	$mpfinib = SYMBOL("_kernel_mpfinib_table")$
  	$FOREACH mpfid MPF.ID_LIST$
  		$mpf = PEEK(mpfinib + offsetof_MPFINIB_mpf, sizeof_void_ptr)$
--- 176,185 ----
  $END$
  
  $ 
! $  固定長メモリプール領域の先頭番地のチェック
  $ 
  $IF CHECK_MPF_ALIGN || CHECK_MPF_NONNULL$
! $	// 固定長メモリプール領域の先頭番地のチェック
  	$mpfinib = SYMBOL("_kernel_mpfinib_table")$
  	$FOREACH mpfid MPF.ID_LIST$
  		$mpf = PEEK(mpfinib + offsetof_MPFINIB_mpf, sizeof_void_ptr)$
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/kernel_int.h ASPs/asp/extension/ovrhdr/kernel/kernel_int.h
*** 1.9.1/asp/extension/ovrhdr/kernel/kernel_int.h	Wed Aug 15 11:26:24 2012
--- ASPs/asp/extension/ovrhdr/kernel/kernel_int.h	Fri Dec  9 13:54:02 2022
***************
*** 8,59 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: kernel_int.h 2396 2012-08-15 02:26:22Z ertl-hiro $
   */
  
  /*
!  *		kernel_cfg.cʤcfg1_out.cѥإåե
   */
  
  #ifndef TOPPERS_KERNEL_INT_H
  #define TOPPERS_KERNEL_INT_H
  
  /*
!  *  ͥɸإåե
   */
  #include "kernel_impl.h"
  
  /*
!  *  ͥγƥإåե
   */
  #include "task.h"
  #include "semaphore.h"
--- 8,59 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: kernel_int.h 2396 2012-08-15 02:26:22Z ertl-hiro $
   */
  
  /*
!  *		kernel_cfg.c（およびcfg1_out.c）用ヘッダファイル
   */
  
  #ifndef TOPPERS_KERNEL_INT_H
  #define TOPPERS_KERNEL_INT_H
  
  /*
!  *  カーネル標準ヘッダファイル
   */
  #include "kernel_impl.h"
  
  /*
!  *  カーネルの各ヘッダファイル
   */
  #include "task.h"
  #include "semaphore.h"
***************
*** 70,81 ****
  #include "time_event.h"
  
  /*
!  *  ͡षܥ򸵤᤹Υإåե
   */
  #include "kernel_unrename.h"
  
  /*
!  *  Ƥ뤿Υޥ
   */
  #ifndef TOPPERS_EMPTY_LABEL
  #define TOPPERS_EMPTY_LABEL(type, var)		type var[0]
--- 70,81 ----
  #include "time_event.h"
  
  /*
!  *  リネームしたシンボルを元に戻すためのヘッダファイル
   */
  #include "kernel_unrename.h"
  
  /*
!  *  内容が空の配列を生成するためのマクロ
   */
  #ifndef TOPPERS_EMPTY_LABEL
  #define TOPPERS_EMPTY_LABEL(type, var)		type var[0]
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/overrun.c ASPs/asp/extension/ovrhdr/kernel/overrun.c
*** 1.9.1/asp/extension/ovrhdr/kernel/overrun.c	Sun Sep 28 15:43:25 2014
--- ASPs/asp/extension/ovrhdr/kernel/overrun.c	Fri Dec  9 13:54:02 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: overrun.c 2657 2014-09-28 06:43:24Z ertl-hiro $
   */
  
  /*
!  *		Хϥɥ鵡ǽ
   */
  
  #include "kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: overrun.c 2657 2014-09-28 06:43:24Z ertl-hiro $
   */
  
  /*
!  *		オーバランハンドラ機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "target_timer.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_OVR_ENTER
  #define LOG_OVR_ENTER(p_runtsk)
--- 51,57 ----
  #include "target_timer.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_OVR_ENTER
  #define LOG_OVR_ENTER(p_runtsk)
***************
*** 104,115 ****
  #ifdef TOPPERS_ovrini
  
  /*
!  *  Х󥿥ޤư椫򼨤ե饰
   */
  bool_t	ovrtimer_flag;
  
  /*
!  *  Хϥɥ鵡ǽν
   */
  void
  initialize_overrun(void)
--- 104,115 ----
  #ifdef TOPPERS_ovrini
  
  /*
!  *  オーバランタイマが動作中かを示すフラグ
   */
  bool_t	ovrtimer_flag;
  
  /*
!  *  オーバランハンドラ機能の初期化
   */
  void
  initialize_overrun(void)
***************
*** 120,126 ****
  #endif /* TOPPERS_ovrini */
  
  /*
!  *  Хϥɥѥޤư
   */
  #ifdef TOPPERS_ovrsta
  #ifndef OMIT_OVRTIMER_START
--- 120,126 ----
  #endif /* TOPPERS_ovrini */
  
  /*
!  *  オーバランハンドラ用タイマの動作開始
   */
  #ifdef TOPPERS_ovrsta
  #ifndef OMIT_OVRTIMER_START
***************
*** 138,144 ****
  #endif /* TOPPERS_ovrsta */
  
  /*
!  *  Хϥɥѥޤ
   */
  #ifdef TOPPERS_ovrstp
  #ifndef OMIT_OVRTIMER_STOP
--- 138,144 ----
  #endif /* TOPPERS_ovrsta */
  
  /*
!  *  オーバランハンドラ用タイマの停止
   */
  #ifdef TOPPERS_ovrstp
  #ifndef OMIT_OVRTIMER_STOP
***************
*** 157,163 ****
  #endif /* TOPPERS_ovrstp */
  
  /*
!  *  Хϥɥư
   */
  #ifdef TOPPERS_sta_ovr
  
--- 157,163 ----
  #endif /* TOPPERS_ovrstp */
  
  /*
!  *  オーバランハンドラの動作開始
   */
  #ifdef TOPPERS_sta_ovr
  
***************
*** 194,200 ****
  #endif /* TOPPERS_sta_ovr */
  
  /*
!  *  Хϥɥưϡ󥿥ƥѡ
   */
  #ifdef TOPPERS_ista_ovr
  
--- 194,200 ----
  #endif /* TOPPERS_sta_ovr */
  
  /*
!  *  オーバランハンドラの動作開始（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_ista_ovr
  
***************
*** 224,230 ****
  #endif /* TOPPERS_ista_ovr */
  
  /*
!  *  Хϥɥư
   */
  #ifdef TOPPERS_stp_ovr
  
--- 224,230 ----
  #endif /* TOPPERS_ista_ovr */
  
  /*
!  *  オーバランハンドラの動作停止
   */
  #ifdef TOPPERS_stp_ovr
  
***************
*** 259,265 ****
  #endif /* TOPPERS_stp_ovr */
  
  /*
!  *  Хϥɥưߡ󥿥ƥѡ
   */
  #ifdef TOPPERS_istp_ovr
  
--- 259,265 ----
  #endif /* TOPPERS_stp_ovr */
  
  /*
!  *  オーバランハンドラの動作停止（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_istp_ovr
  
***************
*** 288,294 ****
  #endif /* TOPPERS_istp_ovr */
  
  /*
!  *  Хϥɥξֻ
   */
  #ifdef TOPPERS_ref_ovr
  
--- 288,294 ----
  #endif /* TOPPERS_istp_ovr */
  
  /*
!  *  オーバランハンドラの状態参照
   */
  #ifdef TOPPERS_ref_ovr
  
***************
*** 328,338 ****
  #endif /* TOPPERS_ref_ovr */
  
  /*
!  *  Хϥɥ鵯ư롼
   *
!  *  ХϥɥθƽФˡƽФξ֡CPUåե饰
!  *  ͥ٥ޥˤᤵʤΤϡΥ롼󤫤Υ꥿ˡ
!  *  ߽иǸξ֤᤹Ǥ롥
   */
  #ifdef TOPPERS_ovrcal
  
--- 328,338 ----
  #endif /* TOPPERS_ref_ovr */
  
  /*
!  *  オーバランハンドラ起動ルーチン
   *
!  *  オーバランハンドラの呼出し後に，呼出し前の状態（CPUロックフラグ，割
!  *  込み優先度マスク）に戻さないのは，このルーチンからのリターン後に，
!  *  割込み出口処理で元の状態に戻すためである．
   */
  #ifdef TOPPERS_ovrcal
  
***************
*** 354,361 ****
  	}
  	else {
  		/*
! 		 *  Υ롼󤬸ƤӽФˡХϥɥεư
! 		 *  󥻥뤵줿
  		 */
  		i_unlock_cpu();
  	}
--- 354,361 ----
  	}
  	else {
  		/*
! 		 *  このルーチンが呼び出される前に，オーバランハンドラの起動が
! 		 *  キャンセルされた場合
  		 */
  		i_unlock_cpu();
  	}
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/overrun.h ASPs/asp/extension/ovrhdr/kernel/overrun.h
*** 1.9.1/asp/extension/ovrhdr/kernel/overrun.h	Sun Jan 31 20:41:40 2010
--- ASPs/asp/extension/ovrhdr/kernel/overrun.h	Fri Dec  9 13:54:02 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: overrun.h 1717 2010-01-31 11:41:03Z ertl-hiro $
   */
  
  /*
!  *		Хϥɥ鵡ǽ
   */
  
  #ifndef TOPPERS_OVERRUN_H
--- 6,45 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: overrun.h 1717 2010-01-31 11:41:03Z ertl-hiro $
   */
  
  /*
!  *		オーバランハンドラ機能
   */
  
  #ifndef TOPPERS_OVERRUN_H
***************
*** 49,83 ****
  #include "target_timer.h"
  
  /*
!  *  Хϥɥ֥å
   */
  typedef struct overrun_handler_initialization_block {
! 	ATR			ovratr;			/* Хϥɥ° */
! 	OVRHDR		ovrhdr;			/* Хϥɥεư */
  } OVRINIB;
  
  /*
!  *  Хϥɥ֥åΥꥢkernel_cfg.c
   */
  extern const OVRINIB	ovrinib;
  
  /*
!  *  Х󥿥ޤư椫򼨤ե饰
   */
  extern bool_t	ovrtimer_flag;
  
  /*
!  *  Хϥɥ鵡ǽν
   */
  extern void	initialize_overrun(void);
  
  /*
!  *  Хϥɥѥޤư
   */
  extern void	ovrtimer_start(void);
  
  /*
!  *  Хϥɥѥޤ
   */
  #ifndef OMIT_OVRTIMER_STOP
  
--- 49,83 ----
  #include "target_timer.h"
  
  /*
!  *  オーバランハンドラ初期化ブロック
   */
  typedef struct overrun_handler_initialization_block {
! 	ATR			ovratr;			/* オーバランハンドラ属性 */
! 	OVRHDR		ovrhdr;			/* オーバランハンドラの起動番地 */
  } OVRINIB;
  
  /*
!  *  オーバランハンドラ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const OVRINIB	ovrinib;
  
  /*
!  *  オーバランタイマが動作中かを示すフラグ
   */
  extern bool_t	ovrtimer_flag;
  
  /*
!  *  オーバランハンドラ機能の初期化
   */
  extern void	initialize_overrun(void);
  
  /*
!  *  オーバランハンドラ用タイマの動作開始
   */
  extern void	ovrtimer_start(void);
  
  /*
!  *  オーバランハンドラ用タイマの停止
   */
  #ifndef OMIT_OVRTIMER_STOP
  
***************
*** 97,103 ****
  #endif /* OMIT_OVRTIMER_STOP */
  
  /*
!  *  Хϥɥ鵯ư롼
   */
  extern void	call_ovrhdr(void);
  
--- 97,103 ----
  #endif /* OMIT_OVRTIMER_STOP */
  
  /*
!  *  オーバランハンドラ起動ルーチン
   */
  extern void	call_ovrhdr(void);
  
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/task.c ASPs/asp/extension/ovrhdr/kernel/task.c
*** 1.9.1/asp/extension/ovrhdr/kernel/task.c	Mon Aug  6 11:45:37 2012
--- ASPs/asp/extension/ovrhdr/kernel/task.c	Fri Dec  9 13:54:02 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.c 2395 2012-08-06 02:45:37Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.c 2395 2012-08-06 02:45:37Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
***************
*** 62,108 ****
  #ifdef TOPPERS_tskini
  
  /*
!  *  ¹Ծ֤Υ
   */
  TCB		*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   */
  TCB		*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   */
  bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   */
  bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   */
  bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   */
  bool_t	dspflg;
  
  /*
!  *  ǥ塼
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   */
  uint16_t	ready_primap;
  
  /*
!  *  ⥸塼ν
   */
  void
  initialize_task(void)
--- 62,108 ----
  #ifdef TOPPERS_tskini
  
  /*
!  *  実行状態のタスク
   */
  TCB		*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   */
  TCB		*p_schedtsk;
  
  /*
!  *  タスクディスパッチ／タスク例外処理ルーチン起動要求フラグ
   */
  bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   */
  bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   */
  bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   */
  bool_t	dspflg;
  
  /*
!  *  レディキュー
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   */
  uint16_t	ready_primap;
  
  /*
!  *  タスク管理モジュールの初期化
   */
  void
  initialize_task(void)
***************
*** 137,158 ****
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ӥåȥޥåץؿ
   *
!  *  bitmap1ΥӥåȤ⡤ǤⲼ̡ʱˤΤΤ򥵡Υӥ
!  *  ֹ֤ӥåֹϡǲ̥ӥåȤ0Ȥ롥bitmap0
!  *  ƤϤʤʤδؿǤϡbitmap16ӥåȤǤ뤳Ȥꤷ
!  *  uint16_tȤƤ롥
   *
!  *  ӥåȥ̿ĥץåǤϡӥåȥ̿Ȥ褦
!  *  ľΨɤ礬롥Τ褦ʾˤϡå
!  *  ¸ǥӥåȥ̿Ȥäbitmap_search
!  *  OMIT_BITMAP_SEARCHޥФ褤ޤӥåȥ̿
!  *  դʤɤͳͥ٤ȥӥåȤȤбѹ
!  *  ϡPRIMAP_BITޥФ褤
   *
!  *  ޤ饤֥ffsʤ顤Τ褦ƥ饤֥ؿ
!  *  ȤäΨɤǽ⤢롥
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
--- 137,158 ----
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ビットマップサーチ関数
   *
!  *  bitmap内の1のビットの内，最も下位（右）のものをサーチし，そのビッ
!  *  ト番号を返す．ビット番号は，最下位ビットを0とする．bitmapに0を指定
!  *  してはならない．この関数では，bitmapが16ビットであることを仮定し，
!  *  uint16_t型としている．
   *
!  *  ビットサーチ命令を持つプロセッサでは，ビットサーチ命令を使うように
!  *  書き直した方が効率が良い場合がある．このような場合には，ターゲット
!  *  依存部でビットサーチ命令を使ったbitmap_searchを定義し，
!  *  OMIT_BITMAP_SEARCHをマクロ定義すればよい．また，ビットサーチ命令の
!  *  サーチ方向が逆などの理由で優先度とビットとの対応を変更したい場合に
!  *  は，PRIMAP_BITをマクロ定義すればよい．
   *
!  *  また，ライブラリにffsがあるなら，次のように定義してライブラリ関数を
!  *  使った方が効率が良い可能性もある．
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
***************
*** 184,190 ****
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline bool_t
  primap_empty(void)
--- 184,190 ----
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  優先度ビットマップが空かのチェック
   */
  Inline bool_t
  primap_empty(void)
***************
*** 193,199 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥ
   */
  Inline uint_t
  primap_search(void)
--- 193,199 ----
  }
  
  /*
!  *  優先度ビットマップのサーチ
   */
  Inline uint_t
  primap_search(void)
***************
*** 202,208 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline void
  primap_set(uint_t pri)
--- 202,208 ----
  }
  
  /*
!  *  優先度ビットマップのセット
   */
  Inline void
  primap_set(uint_t pri)
***************
*** 211,217 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥꥢ
   */
  Inline void
  primap_clear(uint_t pri)
--- 211,217 ----
  }
  
  /*
!  *  優先度ビットマップのクリア
   */
  Inline void
  primap_clear(uint_t pri)
***************
*** 220,226 ****
  }
  
  /*
!  *  ǹ̥ͥΥ
   */
  #ifdef TOPPERS_tsksched
  
--- 220,226 ----
  }
  
  /*
!  *  最高優先順位タスクのサーチ
   */
  #ifdef TOPPERS_tsksched
  
***************
*** 236,246 ****
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡ¹ԤǤ륿ʤä
!  *  ȡp_tcbͥ٤ǹ̤ͥΥͥ٤⤤Ǥ
!  *  롥
   */
  #ifdef TOPPERS_tskrun
  
--- 236,246 ----
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  実行できる状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，実行できるタスクがなかった場合
!  *  と，p_tcbの優先度が最高優先順位のタスクの優先度よりも高い場合であ
!  *  る．
   */
  #ifdef TOPPERS_tskrun
  
***************
*** 262,273 ****
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡp_tcbǹ̤ͥΥ
!  *  äǤ롥p_tcbƱͥ٤Υ¾ˤϡp_tcb
!  *  μΥǹ̤ͥˤʤ롥Ǥʤϡǥ塼
!  *  ɬפ롥
   */
  #ifdef TOPPERS_tsknrun
  
--- 262,273 ----
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，p_tcbが最高優先順位のタスクで
!  *  あった場合である．p_tcbと同じ優先度のタスクが他にある場合は，p_tcb
!  *  の次のタスクが最高優先順位になる．そうでない場合は，レディキューを
!  *  サーチする必要がある．
   */
  #ifdef TOPPERS_tsknrun
  
***************
*** 297,303 ****
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  ٻ߾֤ؤ
   */
  #ifdef TOPPERS_tskdmt
  
--- 297,303 ----
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  休止状態への遷移
   */
  #ifdef TOPPERS_tskdmt
  
***************
*** 318,324 ****
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   */
  #ifdef TOPPERS_tskact
  
--- 318,324 ----
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  休止状態から実行できる状態への遷移
   */
  #ifdef TOPPERS_tskact
  
***************
*** 334,349 ****
  #endif /* TOPPERS_tskact */
  
  /*
!  *  ͥ٤ѹ
   *
!  *  ¹ԤǤ֤ξˤϡǥ塼Ǥΰ֤ѹ
!  *  롥֥ȤԤ塼Ԥ֤ˤʤäƤˤϡ
!  *  塼Ǥΰ֤ѹ롥
   *
!  *  ǹ̤ͥΥ򹹿Τϡ(1) p_tcbǹ̤ͥΥ
!  *  Ǥäơͥ٤򲼤硤(2) p_tcbǹ̤ͥΥ
!  *  ǤϤʤѹͥ٤ǹ̤ͥΥͥ٤⤤
!  *  Ǥ롥(1)ξˤϡǥ塼򥵡ɬפ롥
   */
  #ifdef TOPPERS_tskpri
  
--- 334,349 ----
  #endif /* TOPPERS_tskact */
  
  /*
!  *  タスクの優先度の変更
   *
!  *  タスクが実行できる状態の場合には，レディキューの中での位置を変更す
!  *  る．オブジェクトの待ちキューの中で待ち状態になっている場合には，待
!  *  ちキューの中での位置を変更する．
   *
!  *  最高優先順位のタスクを更新するのは，(1) p_tcbが最高優先順位のタス
!  *  クであって，その優先度を下げた場合，(2) p_tcbが最高優先順位のタス
!  *  クではなく，変更後の優先度が最高優先順位のタスクの優先度よりも高い
!  *  場合である．(1)の場合には，レディキューをサーチする必要がある．
   */
  #ifdef TOPPERS_tskpri
  
***************
*** 357,363 ****
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤ξ
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
--- 357,363 ----
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  タスクが実行できる状態の場合
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
***************
*** 382,389 ****
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  Ʊ֥̿Ȥδ֥åζ
! 			 *  ʬWOBJCBˤԤ塼ˤĤʤƤ
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
--- 382,389 ----
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  タスクが，同期・通信オブジェクトの管理ブロックの共通部
! 			 *  分（WOBJCB）の待ちキューにつながれている場合
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
***************
*** 395,404 ****
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  ǥ塼βž
   *
!  *  ǹ̤ͥΥ򹹿Τϡǹ̤ͥΥ
!  *  塼˰ưǤ롥
   */
  #ifdef TOPPERS_tskrot
  
--- 395,404 ----
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  レディキューの回転
   *
!  *  最高優先順位のタスクを更新するのは，最高優先順位のタスクがタスクキ
!  *  ューの末尾に移動した場合である．
   */
  #ifdef TOPPERS_tskrot
  
***************
*** 422,431 ****
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  㳰롼θƽФ
   *
!  *  ASPͥǤϡ㳰롼CPUå֤ܤ
!  *  ξ֤ᤵ˥꥿󤷤硤ͥ뤬ξ֤᤹
   */
  #ifdef TOPPERS_tsktex
  
--- 422,431 ----
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  ASPカーネルでは，タスク例外処理ルーチン内でCPUロック状態に遷移し，
!  *  元の状態に戻さずにリターンした場合，カーネルが元の状態に戻す．
   */
  #ifdef TOPPERS_tsktex
  
***************
*** 458,467 ****
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  dispatchƤӽФϡߺƵƽФˤʤä
! 			 *  뤬dispatchƤp_runtsk->enatexfalseˤ
! 			 *  лپ㤬ʤͳˤĤƤϡTOPPERS/ASP 
! 			 *  ͥ ߷ץפ򻲾ȤΤȡ
  			 */
  			dispatch();
  		}
--- 458,467 ----
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  ここでdispatchを呼び出す処理は，相互再帰呼出しになって
! 			 *  いるが，dispatchを呼ぶ前にp_runtsk->enatexをfalseにして
! 			 *  おけば支障がない．その理由については，「TOPPERS/ASP カー
! 			 *  ネル 設計メモ」を参照のこと．
  			 */
  			dispatch();
  		}
***************
*** 470,476 ****
  }
  
  /*
!  *  㳰롼εư
   */
  #ifndef OMIT_CALLTEX
  
--- 470,476 ----
  }
  
  /*
!  *  タスク例外処理ルーチンの起動
   */
  #ifndef OMIT_CALLTEX
  
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/task.h ASPs/asp/extension/ovrhdr/kernel/task.h
*** 1.9.1/asp/extension/ovrhdr/kernel/task.h	Mon Aug  6 11:45:37 2012
--- ASPs/asp/extension/ovrhdr/kernel/task.h	Fri Dec  9 13:54:02 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.h 2395 2012-08-06 02:45:37Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #ifndef TOPPERS_TASK_H
--- 8,47 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.h 2395 2012-08-06 02:45:37Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #ifndef TOPPERS_TASK_H
***************
*** 51,99 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  ͥ٤ɽɽѴޥ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  ֤ɽ
   *
!  *  TCBΥ֤Ǥϡ¹Ծ֡RUNNINGˤȼ¹Բǽ֡READY
!  *  ϶̤ʤξ֤Τơ¹ԤǤ֡RUNNABLEˤȸƤ֡
!  *  Ԥ֤ϡ(TS_WAITING | TS_SUSPENDED)ɽTS_WAIT_???
!  *  װɽԤ֡Ԥ֤ޤˤξˤΤꤹ롥
!  */
! #define TS_DORMANT		0x00U			/* ٻ߾ */
! #define TS_RUNNABLE		0x01U			/* ¹ԤǤ */
! #define TS_WAITING		0x02U			/* Ԥ */
! #define TS_SUSPENDED	0x04U			/* Ԥ */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* ַвԤ */
! #define TS_WAIT_SLP		(0x01U << 3)	/* Ԥ */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* ǡ塼μԤ */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* ͥ٥ǡ塼μԤ */
! #define TS_WAIT_SEM		(0x04U << 3)	/* ޥե񸻤γԤ */
! #define TS_WAIT_FLG		(0x05U << 3)	/* ٥ȥե饰Ԥ */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* ǡ塼ؤԤ */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* ͥ٥ǡ塼ؤԤ */
! #define TS_WAIT_MBX		(0x08U << 3)	/* ᡼ܥåμԤ */
! #define TS_WAIT_MPF		(0x09U << 3)	/* Ĺ֥åγԤ */
! 
! /*
!  *  Ƚ̥ޥ
!  *
!  *  TSTAT_DORMANTϥٻ߾֤Ǥ뤫ɤTSTAT_RUNNABLE
!  *  ¹ԤǤ֤Ǥ뤫ɤȽ̤롥TSTAT_WAITING
!  *  ֤Ԥ֤Τ줫Ǥ뤫ɤTSTAT_SUSPENDED
!  *  Ԥ֤Ԥ֤Τ줫Ǥ뤫ɤȽ̤롥
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
--- 51,99 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  タスク優先度の内部表現・外部表現変換マクロ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  タスク状態の内部表現
   *
!  *  TCB中のタスク状態では，実行状態（RUNNING）と実行可能状態（READY）
!  *  は区別しない．両状態を総称して，実行できる状態（RUNNABLE）と呼ぶ．
!  *  二重待ち状態は，(TS_WAITING | TS_SUSPENDED)で表す．TS_WAIT_???は待
!  *  ち要因を表し，待ち状態（二重待ち状態を含む）の場合にのみ設定する．
!  */
! #define TS_DORMANT		0x00U			/* 休止状態 */
! #define TS_RUNNABLE		0x01U			/* 実行できる状態 */
! #define TS_WAITING		0x02U			/* 待ち状態 */
! #define TS_SUSPENDED	0x04U			/* 強制待ち状態 */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* 時間経過待ち */
! #define TS_WAIT_SLP		(0x01U << 3)	/* 起床待ち */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* データキューからの受信待ち */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* 優先度データキューからの受信待ち */
! #define TS_WAIT_SEM		(0x04U << 3)	/* セマフォ資源の獲得待ち */
! #define TS_WAIT_FLG		(0x05U << 3)	/* イベントフラグ待ち */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* データキューへの送信待ち */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* 優先度データキューへの送信待ち */
! #define TS_WAIT_MBX		(0x08U << 3)	/* メールボックスからの受信待ち */
! #define TS_WAIT_MPF		(0x09U << 3)	/* 固定長メモリブロックの獲得待ち */
! 
! /*
!  *  タスク状態判別マクロ
!  *
!  *  TSTAT_DORMANTはタスクが休止状態であるかどうかを，TSTAT_RUNNABLEは
!  *  タスクが実行できる状態であるかどうかを判別する．TSTAT_WAITINGは待
!  *  ち状態と二重待ち状態のいずれかであるかどうかを，TSTAT_SUSPENDEDは
!  *  強制待ち状態と二重待ち状態のいずれかであるかどうかを判別する．
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
***************
*** 101,482 ****
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  ԤװȽ̥ޥ
   *
!  *  TSTAT_WAIT_SLPϥԤǤ뤫ɤTSTAT_WAIT_WOBJ
!  *  ϥƱ֥̿ȤФԤǤ뤫ʸȡ
!  *  Ʊ֥̿ȤԤ塼ˤĤʤƤ뤫ˤɤȽ̤
!  *  롥ޤTSTAT_WAIT_WOBJCBϥƱ֥̿Ȥδ
!  *  ֥åζʬWOBJCBˤԤ塼ˤĤʤƤ뤫ɤ
!  *  Ƚ̤롥
!  *
!  *  TSTAT_WAIT_SLPϡǤդΥ֤椫顤ԤǤ
!  *  ȤȽ̤Ǥ롥ʤTSTAT_WAITINGˤԤ֤Ǥ뤳Ȥ
!  *  Ƚ̤ˡTSTAT_SLPѤƵԤ֤Ǥ뤳ȤȽ̤Ǥ롥
!  *  ΨŪ˼¸뤿ˡTS_WAIT_SLPͤ(0x00U << 3)ǤϤ
!  *  (0x01U << 3)ȤƤ롥ΤᡤַвԤ֤Ǥ
!  *  ȤȽ̤뤿TSTAT_WAIT_DLYTSTAT_WAIT_SLPƱͤˡ
!  *  ¸뤳ȤϤǤʤ
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* ԤװμФޥ */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  Ԥ֥åWINFOˤ
   *
!  *  Ԥ֤δ֤ϡTCBӤp_winfoǻؤWINFO򼡤
!  *  褦ꤷʤФʤʤ
   *
!  *  (a) TCBΥ֤Ԥ֡TS_WAITINGˤˤ롥κݤˡԤ
!  *  װTS_WAIT_???ˤꤹ롥
   *
!  *  (b) ॢȤƻ뤹뤿ˡ।٥ȥ֥åϿ롥
!  *  Ͽ륿।٥ȥ֥åϡԤ륵ӥؿ
!  *  ΥѿȤƳݤؤΥݥ󥿤WINFOp_tmevtb˵
!  *  롥ॢȤδƻ뤬ɬפʤʱʵԤξˤˤϡ
!  *  p_tmevtbNULLˤ롥
!  *
!  *  Ʊ֥̿ȤФԤ֤ξˤϡɸWINFO
!  *  p_wobjcbեɤɲä¤ΡWINFO_WOBJwait.hˤ
!  *  ޤʲ(c)(e)Ԥɬפ롥Ʊ֥̿
!  *  Ȥ˴طʤԤʵԤַвԤˤξˤϡ(c)(e)
!  *  ɬפʤ
!  *
!  *  (c) TCBԤоݤƱ֥̿ȤԤ塼ˤĤʤ
!  *  塼ˤĤʤˡtask_queueȤ
!  *
!  *  (d) ԤоݤƱ֥̿Ȥδ֥åؤΥݥ󥿤
!  *  WINFO_WOBJp_wobjcb˵롥
!  *
!  *  (e) ԤоݤƱ֥̿Ȥ˰¸Ƶ뤳Ȥɬפ
!  *  󤬤ˤϡWINFO_WOBJɬפʾΤΥեɤɲ
!  *  ¤ΤWINFO_WOBJѤ롥
!  *
!  *  Ԥ֤ݤˤϡԤФͤWINFO
!  *  wercdꤹ롥wercdɬפʤΤԤʹߤǤΤФơ
!  *  p_tmevtbԤɬפʤᡤΤ˶ΤȤ
!  *  Ƥ롥Τᡤwercdإ顼ɤꤹΤϡ।٥
!  *  ֥åϿˤʤФʤʤ
   */
  typedef union waiting_information {
! 	ER		wercd;			/* ԤΥ顼 */
! 	TMEVTB	*p_tmevtb;		/* ԤѤΥ।٥ȥ֥å */
  } WINFO;
  
  /*
!  *  ֥å
   *
!  *  ˴ؤͤѤʤROM֤ʬʥ
!  *  ֥åˤȡͤѲ뤿RAM֤ʤФʤʤ
!  *  ʬʥ֥åTCBˤʬΥTCBб륿
!  *  ֥åؤݥ󥿤롥֥åб
!  *  TCBؤݥ󥿤ˡRAMδ˾ޤ
!  *  ¹ԸΨʤ뤿˺ѤƤʤ¾Υ֥ȤˤĤ
!  *  ƤƱͤ˰
   *
!  *  ֥åˤϡDEF_TEX륿㳰롼
!  *  ˴ؤޤࡥ
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* ° */
! 	intptr_t	exinf;			/* γĥ */
! 	TASK		task;			/* εư */
! 	uint_t		ipriority;		/* εưͥ١ɽ */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* ƥȥ֥å */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* åΰΥʴݤ᤿͡ */
! 	void		*stk;			/* åΰƬ */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* 㳰롼° */
! 	TEXRTN		texrtn;			/* 㳰롼εư */
  } TINIB;
  
  /*
!  *  TCBΥեɤΥӥå
   *
!  *  ץåˤäƤϡTCBΥեɤΥӥåǥ̤
!  *  ǽȥ졼ɥդˤʤ뤿ᡤåȰ¸˥եɤΥӥå
!  *  ѹ뤳ȤƤ롥
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityեɤΥӥå */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  ֥åTCB
   *
!  *  ASPͥǤϡεư׵ᥭ塼󥰿κ͡TMAX_ACTCNT
!  *  ȵ׵ᥭ塼󥰿κ͡TMAX_WUPCNTˤ1˸ꤵƤ
!  *  ᡤ塼󥰤Ƥ뤫ɤοͤɽ뤳ȤǤ롥
!  *  ޤԤ׵ͥȿκ͡TMAX_SUSCNTˤ1˸ꤵƤ
!  *  ΤǡԤ׵ͥȿsuscntˤɬפʤ
!  *
!  *  TCBΤĤΥեɤϡΥ֤ǤΤͭͤݻ
!  *  ʳξͤݾڤʤʤäơȤƤϤʤʤˡ
!  *  եɤͭͤݻϼ̤ꡥ
!  *
!  *  Ͼͭ
!  *  		p_tinibtstatactque
!  *  ٻ߾ְʳͭʵٻ߾֤ǤϽͤˤʤäƤˡ
!  *  		prioritywupqueenatextexptnleftotm
!  *  Ԥ֡Ԥ֤ޤˤͭ
   *  		p_winfo
!  *  ¹ԤǤ֤Ʊ֥̿ȤФԤ֤ͭ
   *  		task_queue
!  *  ¹Բǽ֡Ԥ֡Ԥ֡Ԥ֤ͭ
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* 塼 */
! 	const TINIB		*p_tinib;		/* ֥åؤΥݥ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* ֡ɽ*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* ֡ɽ*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* ߤͥ١ɽ*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* ߤͥ١ɽ*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* ư׵ᥭ塼 */
! 	BIT_FIELD_BOOL	wupque : 1;		/* ׵ᥭ塼 */
! 	BIT_FIELD_BOOL	enatex : 1;		/* 㳰ľ */
  
! 	TEXPTN			texptn;			/* α㳰װ */
! 	WINFO			*p_winfo;		/* Ԥ֥åؤΥݥ */
  #ifdef TOPPERS_SUPPORT_OVRHDR
! 	OVRTIM			leftotm;		/* Ĥץå */
  #endif /* TOPPERS_SUPPORT_OVRHDR */
! 	TSKCTXB			tskctxb;		/* ƥȥ֥å */
  } TCB;
  
  /*
!  *  ¹Ծ֤Υ
   *
!  *  ¹Ծ֤ΥʡץåƥȤäƤ륿ˤ
!  *  TCBؤݥ󥿡¹Ծ֤ΥʤNULLˤ롥
   *
!  *  ӥνǡʥӥƤӽФ
!  *  ˤ˴ؤ򻲾Ȥp_runtskȤp_runtsk񤭴
!  *  ΤϡǥѥåʤȽˤΤߤǤ롥
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   *
!  *  ¹ԤǤ륿Ǻǹ̤ͥΥTCBؤݥ󥿡
!  *  ԤǤ륿ʤNULLˤ롥
   *
!  *  ǥѥåػ߾֤ʤɡǥѥåαƤ֤p_runtsk
!  *  ȰפƤȤϸ¤ʤ
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   *
!  *  ߥϥɥ顿CPU㳰ϥɥνиˡǥѥåޤ
!  *  㳰롼εư׵᤹뤳Ȥ򼨤ե饰
   */
  extern bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   *
!  *  ͥ٥ޥ֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   *
!  *  ǥѥåػ߾֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   *
!  *  ͥ٥ޥ֤Ǥꡤǥѥåľ֤Ǥʥǥ
!  *  ѥåػ߾֤ǤʤˤȤ򼨤ե饰
   */
  extern bool_t	dspflg;
  
  /*
!  *  ǥ塼
   *
!  *  ǥ塼ϡ¹ԤǤ֤Υ뤿Υ塼Ǥ롥
!  *  ¹Ծ֤ΥƤ뤿ᡤǥʼ¹Բǽ˥塼Ȥ
!  *  ̾ΤΤǤϤʤǥ塼Ȥ̾Τ夷Ƥ뤿ᡤ
!  *  ̾ΤǸƤ֤Ȥˤ롥
   *
!  *  ǥ塼ϡͥ٤ȤΥ塼ǹƤ롥
!  *  TCBϡͥ٤Υ塼Ͽ롥
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   *
!  *  ǥ塼ΥΨ褯Ԥˡͥ٤ȤΥ塼
!  *  ˥äƤ뤫ɤ򼨤ӥåȥޥåפѰդƤ롥ӥ
!  *  ȥޥåפȤȤǡꥢβ򸺤餹ȤǤ뤬
!  *  ӥå̿᤬¤Ƥʤץåǡͥ٤ʳʤ
!  *  ˤϡӥåȥޥåΥСإåɤΤˡդ˸Ψ
!  *  ǽ⤢롥
   *
!  *  ͥ٤16ʳǤ뤳ȤꤷƤ뤿ᡤuint16_tȤƤ롥
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  ֥åΥꥢkernel_cfg.c
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  ơ֥kernel_cfg.c
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBΥꥢkernel_cfg.c
   */
  extern TCB	tcb_table[];
  
  /*
!  *  ο
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  IDTCBФΥޥ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCB饿IDФΥޥ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  ⥸塼ν
   */
  extern void	initialize_task(void);
  
  /*
!  *  ǹ̥ͥΥ
   *
!  *  ǥ塼κǹ̤ͥΥ򥵡TCBؤΥݥ
!  *  ֤ǥ塼ξˤϡδؿƤӽФƤϤʤʤ
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥ǥ塼
!  *  ͥ٤ǹ̤ͥΥͥ٤⤤ϡ
!  *  ǹ̤ͥΥ򹹿ǥѥåľ֤Ǥtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥p_tcbǻꤷ
!  *  ǹ̤ͥΥǤäˤϡǹ̤ͥΥ
!  *  ꤷʤǥѥåľ֤Ǥtrue֤Ǥʤ
!  *  false֤ξ֤Ϲʤ
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤Ȥ롥ޤεư
!  *  ˽٤ѿνȡưΤΥƥȤ
!  *  ꤹ롥
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤¹ԤǤ֤Ȥ롥
!  *  ¹ԤǤ֤ܤؤΥǥѥåɬפʾtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  ͥ٤ѹ
   *
!  *  p_tcbǻꤵ륿ͥ٤newpriɽˤѹ롥ޤ
!  *  ɬפʾˤϺǹ̤ͥΥ򹹿ǥѥåľ֤
!  *  true֤Ǥʤfalse֤
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  ǥ塼βž
   *
!  *  ǥ塼Ρpriǻꤵͥ٤Υ塼ž롥
!  *  ޤɬפʾˤϺǹ̤ͥΥѹǥѥå
!  *  αƤʤtrue֤Ǥʤfalse֤
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  㳰롼θƽФ
   *
!  *  㳰롼ƤӽФƤӽФˡ¹Ծ֤Υ
!  *  α㳰װ򥯥ꥢ㳰ػ߾֤ˤCPUå
!  *  롥
!  *
!  *  㳰롼󤫤ȡޤCPUå֤ᤷδ
!  *  α㳰װ0ǤʤʤäƤСƤӥ㳰롼
!  *  ƤӽФα㳰װ0ξˤϡ㳰ľ֤ˤƴؿ
!  *  ꥿󤹤롥
!  *
!  *  δؿϡ¹Ծ֤Υ㳰ľ֡enatex
!  *  trueˤǡα㳰װ0Ǥʤtexptn0Ǥʤ˾˸ƤӽФ
!  *  ȤꤷƤ롥δؿϡCPUå֤ǸƤӽФʤФʤ
!  *  ʤ
   */
  extern void	call_texrtn(void);
  
  /*
!  *  㳰롼εư
   *
!  *  ¹Ծ֤Υ㳰롼εưƤС
!  *  㳰롼ƤӽФCPU㳰롼ƤӽФ
!  *  ϡŪCPUå롥
!  *
!  *  δؿϡǥѥåߥϥɥ顿CPU㳰ϥɥνи
!  *  ƤӽФ뤳ȤꤷƤ롥δؿϡCPUå
!  *  ǸƤӽФʤФʤʤ
   *
!  *  ¹ԸΨ夲뤿ˡδؿ򥿡åȰ¸ǵҤƤ褤
!  *  ξˤϡOMIT_CALLTEXޥ롥
   */
  extern void	calltex(void);
  
--- 101,482 ----
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  タスク待ち要因判別マクロ
   *
!  *  TSTAT_WAIT_SLPはタスクが起床待ちであるかどうかを，TSTAT_WAIT_WOBJ
!  *  はタスクが同期・通信オブジェクトに対する待ちであるか（言い換えると，
!  *  同期通信オブジェクトの待ちキューにつながれているか）どうかを判別す
!  *  る．また，TSTAT_WAIT_WOBJCBはタスクが同期・通信オブジェクトの管理
!  *  ブロックの共通部分（WOBJCB）の待ちキューにつながれているかどうかを
!  *  判別する．
!  *
!  *  TSTAT_WAIT_SLPは，任意のタスク状態の中から，タスクが起床待ちである
!  *  ことを判別できる．すなわち，TSTAT_WAITINGにより待ち状態であることを
!  *  判別せずに，TSTAT_SLPだけを用いて起床待ち状態であることを判別できる．
!  *  これを効率的に実現するために，TS_WAIT_SLPの値を，(0x00U << 3)ではな
!  *  く(0x01U << 3)としている．そのため，タスクが時間経過待ち状態である
!  *  ことを判別するためのTSTAT_WAIT_DLYを，TSTAT_WAIT_SLPと同様の方法で
!  *  実現することはできない．
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* 待ち要因の取出しマスク */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  待ち情報ブロック（WINFO）の定義
   *
!  *  タスクが待ち状態の間は，TCBおよびそのp_winfoで指されるWINFOを次の
!  *  ように設定しなければならない．
   *
!  *  (a) TCBのタスク状態を待ち状態（TS_WAITING）にする．その際に，待ち
!  *  要因（TS_WAIT_???）も設定する．
   *
!  *  (b) タイムアウトを監視するために，タイムイベントブロックを登録する．
!  *  登録するタイムイベントブロックは，待ちに入るサービスコール処理関数
!  *  のローカル変数として確保し，それへのポインタをWINFOのp_tmevtbに記
!  *  憶する．タイムアウトの監視が必要ない場合（永久待ちの場合）には，
!  *  p_tmevtbをNULLにする．
!  *
!  *  同期・通信オブジェクトに対する待ち状態の場合には，標準のWINFOに
!  *  p_wobjcbフィールドを追加した構造体（WINFO_WOBJ，wait.hで定義）を使
!  *  う．また，以下の(c)〜(e)の設定を行う必要がある．同期・通信オブジェ
!  *  クトに関係しない待ち（起床待ち，時間経過待ち）の場合には，(c)〜(e)
!  *  は必要ない．
!  *
!  *  (c) TCBを待ち対象の同期・通信オブジェクトの待ちキューにつなぐ．待
!  *  ちキューにつなぐために，task_queueを使う．
!  *
!  *  (d) 待ち対象の同期・通信オブジェクトの管理ブロックへのポインタを，
!  *  WINFO_WOBJのp_wobjcbに記憶する．
!  *
!  *  (e) 待ち対象の同期・通信オブジェクトに依存して記憶することが必要な
!  *  情報がある場合には，WINFO_WOBJに必要な情報のためのフィールドを追加
!  *  した構造体を定義し，WINFO_WOBJの代わりに用いる．
!  *
!  *  待ち状態を解除する際には，待ち解除したタスクに対する返値をWINFOの
!  *  wercdに設定する．wercdが必要なのは待ち解除以降であるのに対して，
!  *  p_tmevtbは待ち解除後は必要ないため，メモリ節約のために共用体を使っ
!  *  ている．そのため，wercdへエラーコードを設定するのは，タイムイベント
!  *  ブロックを登録解除した後にしなければならない．
   */
  typedef union waiting_information {
! 	ER		wercd;			/* 待ち解除時のエラーコード */
! 	TMEVTB	*p_tmevtb;		/* 待ち状態用のタイムイベントブロック */
  } WINFO;
  
  /*
!  *  タスク初期化ブロック
   *
!  *  タスクに関する情報を，値が変わらないためにROMに置ける部分（タスク
!  *  初期化ブロック）と，値が変化するためにRAMに置かなければならない部
!  *  分（タスク管理ブロック，TCB）に分離し，TCB内に対応するタスク初期化
!  *  ブロックを指すポインタを入れる．タスク初期化ブロック内に対応する
!  *  TCBを指すポインタを入れる方法の方が，RAMの節約の観点からは望ましい
!  *  が，実行効率が悪くなるために採用していない．他のオブジェクトについ
!  *  ても同様に扱う．
   *
!  *  タスク初期化ブロックには，DEF_TEXで定義されるタスク例外処理ルーチ
!  *  ンに関する情報も含む．
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* タスク属性 */
! 	intptr_t	exinf;			/* タスクの拡張情報 */
! 	TASK		task;			/* タスクの起動番地 */
! 	uint_t		ipriority;		/* タスクの起動時優先度（内部表現） */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* タスク初期化コンテキストブロック */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* スタック領域のサイズ（丸めた値） */
! 	void		*stk;			/* スタック領域の先頭番地 */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* タスク例外処理ルーチン属性 */
! 	TEXRTN		texrtn;			/* タスク例外処理ルーチンの起動番地 */
  } TINIB;
  
  /*
!  *  TCB中のフィールドのビット幅の定義
   *
!  *  プロセッサによっては，TCB中のフィールドのビット幅でメモリ使用量と
!  *  性能がトレードオフになるため，ターゲット依存にフィールドのビット幅
!  *  を変更することを許している．
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityフィールドのビット幅 */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  タスク管理ブロック（TCB）
   *
!  *  ASPカーネルでは，タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）
!  *  と起床要求キューイング数の最大値（TMAX_WUPCNT）は1に固定されている
!  *  ため，キューイングされているかどうかの真偽値で表現することができる．
!  *  また，強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が1に固定されてい
!  *  るので，強制待ち要求ネスト数（suscnt）は必要ない．
!  *
!  *  TCBのいくつかのフィールドは，特定のタスク状態でのみ有効な値を保持し，
!  *  それ以外の場合は値が保証されない（よって，参照してはならない）．各
!  *  フィールドが有効な値を保持する条件は次の通り．
!  *
!  *  ・初期化後は常に有効：
!  *  		p_tinib，tstat，actque
!  *  ・休止状態以外で有効（休止状態では初期値になっている）：
!  *  		priority，wupque，enatex，texptn，leftotm
!  *  ・待ち状態（二重待ち状態を含む）で有効：
   *  		p_winfo
!  *  ・実行できる状態と同期・通信オブジェクトに対する待ち状態で有効：
   *  		task_queue
!  *  ・実行可能状態，待ち状態，強制待ち状態，二重待ち状態で有効：
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* タスクキュー */
! 	const TINIB		*p_tinib;		/* 初期化ブロックへのポインタ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* タスク状態（内部表現）*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* タスク状態（内部表現）*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* 現在の優先度（内部表現）*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* 現在の優先度（内部表現）*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* 起動要求キューイング */
! 	BIT_FIELD_BOOL	wupque : 1;		/* 起床要求キューイング */
! 	BIT_FIELD_BOOL	enatex : 1;		/* タスク例外処理許可状態 */
  
! 	TEXPTN			texptn;			/* 保留例外要因 */
! 	WINFO			*p_winfo;		/* 待ち情報ブロックへのポインタ */
  #ifdef TOPPERS_SUPPORT_OVRHDR
! 	OVRTIM			leftotm;		/* 残りプロセッサ時間 */
  #endif /* TOPPERS_SUPPORT_OVRHDR */
! 	TSKCTXB			tskctxb;		/* タスクコンテキストブロック */
  } TCB;
  
  /*
!  *  実行状態のタスク
   *
!  *  実行状態のタスク（＝プロセッサがコンテキストを持っているタスク）の
!  *  TCBを指すポインタ．実行状態のタスクがない場合はNULLにする．
   *
!  *  サービスコールの処理中で，自タスク（サービスコールを呼び出したタス
!  *  ク）に関する情報を参照する場合はp_runtskを使う．p_runtskを書き換え
!  *  るのは，ディスパッチャ（と初期化処理）のみである．
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   *
!  *  実行できるタスクの中で最高優先順位のタスクのTCBを指すポインタ．実
!  *  行できるタスクがない場合はNULLにする．
   *
!  *  ディスパッチ禁止状態など，ディスパッチが保留されている間はp_runtsk
!  *  と一致しているとは限らない．
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ディスパッチ／タスク例外処理ルーチン起動要求フラグ
   *
!  *  割込みハンドラ／CPU例外ハンドラの出口処理に，ディスパッチまたは
!  *  タスク例外処理ルーチンの起動を要求することを示すフラグ．
   */
  extern bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   *
!  *  割込み優先度マスク全解除状態であることを示すフラグ．
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   *
!  *  ディスパッチ禁止状態であることを示すフラグ．
   */
  extern bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   *
!  *  割込み優先度マスク全解除状態であり，ディスパッチ許可状態である（ディ
!  *  スパッチ禁止状態でない）ことを示すフラグ．
   */
  extern bool_t	dspflg;
  
  /*
!  *  レディキュー
   *
!  *  レディキューは，実行できる状態のタスクを管理するためのキューである．
!  *  実行状態のタスクも管理しているため，レディ（実行可能）キューという
!  *  名称は正確ではないが，レディキューという名称が定着しているため，こ
!  *  の名称で呼ぶことにする．
   *
!  *  レディキューは，優先度ごとのタスクキューで構成されている．タスクの
!  *  TCBは，該当する優先度のキューに登録される．
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   *
!  *  レディキューのサーチを効率よく行うために，優先度ごとのタスクキュー
!  *  にタスクが入っているかどうかを示すビットマップを用意している．ビッ
!  *  トマップを使うことで，メモリアクセスの回数を減らすことができるが，
!  *  ビット操作命令が充実していないプロセッサで，優先度の段階数が少ない
!  *  場合には，ビットマップ操作のオーバーヘッドのために，逆に効率が落ち
!  *  る可能性もある．
   *
!  *  優先度が16段階であることを仮定しているため，uint16_t型としている．
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  タスクIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  タスク初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  タスク生成順序テーブル（kernel_cfg.c）
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBのエリア（kernel_cfg.c）
   */
  extern TCB	tcb_table[];
  
  /*
!  *  タスクの数
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  タスクIDからTCBを取り出すためのマクロ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCBからタスクIDを取り出すためのマクロ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  タスク管理モジュールの初期化
   */
  extern void	initialize_task(void);
  
  /*
!  *  最高優先順位タスクのサーチ
   *
!  *  レディキュー中の最高優先順位のタスクをサーチし，そのTCBへのポインタ
!  *  を返す．レディキューが空の場合には，この関数を呼び出してはならない．
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューに挿入する．レディキューに挿入
!  *  したタスクの優先度が，最高優先順位のタスクの優先度よりも高い場合は，
!  *  最高優先順位のタスクを更新し，ディスパッチ許可状態であればtrueを返
!  *  す．そうでない場合はfalseを返す．
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューから削除する．p_tcbで指定した
!  *  タスクが最高優先順位のタスクであった場合には，最高優先順位のタスク
!  *  を設定しなおし，ディスパッチ許可状態であればtrueを返す．そうでない
!  *  場合はfalseを返す．タスクの状態は更新しない．
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  休止状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態とする．また，タスクの起動
!  *  時に初期化すべき変数の初期化と，タスク起動のためのコンテキストを設
!  *  定する．
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  休止状態から実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態から実行できる状態とする．
!  *  実行できる状態に遷移したタスクへのディスパッチが必要な場合はtrue，
!  *  そうでない場合はfalseを返す．
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  タスクの優先度の変更
   *
!  *  p_tcbで指定されるタスクの優先度をnewpri（内部表現）に変更する．また，
!  *  必要な場合には最高優先順位のタスクを更新し，ディスパッチ許可状態で
!  *  あればtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  レディキューの回転
   *
!  *  レディキュー中の，priで指定される優先度のタスクキューを回転させる．
!  *  また，必要な場合には最高優先順位のタスクを変更し，ディスパッチが保
!  *  留されていなければtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  タスク例外処理ルーチンを呼び出す．呼び出す前に，実行状態のタスクの
!  *  保留例外要因をクリアし，タスク例外処理禁止状態にし，CPUロックを解
!  *  除する．
!  *
!  *  タスク例外処理ルーチンから戻ると，まずCPUロック状態に戻し，その間
!  *  に保留例外要因が0でなくなっていれば，再びタスク例外処理ルーチンを
!  *  呼び出す．保留例外要因が0の場合には，例外処理許可状態にして関数か
!  *  らリターンする．
!  *
!  *  この関数は，実行状態のタスクが，タスク例外処理許可状態（enatexが
!  *  true）で，保留例外要因が0でない（texptnが0でない）場合に呼び出すこ
!  *  とを想定している．この関数は，CPUロック状態で呼び出さなければなら
!  *  ない．
   */
  extern void	call_texrtn(void);
  
  /*
!  *  タスク例外処理ルーチンの起動
   *
!  *  実行状態のタスクがタスク例外処理ルーチンの起動条件を満たしていれば，
!  *  タスク例外処理ルーチンを呼び出す．CPU例外処理ルーチンを呼び出す時
!  *  は，一時的にCPUロックを解除する．
!  *
!  *  この関数は，ディスパッチャや割込みハンドラ／CPU例外ハンドラの出口
!  *  処理から呼び出されることを想定している．この関数は，CPUロック状態
!  *  で呼び出さなければならない．
   *
!  *  実行効率を上げるために，この関数をターゲット依存部で記述してもよい．
!  *  その場合には，OMIT_CALLTEXをマクロ定義する．
   */
  extern void	calltex(void);
  
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/kernel/task_manage.c ASPs/asp/extension/ovrhdr/kernel/task_manage.c
*** 1.9.1/asp/extension/ovrhdr/kernel/task_manage.c	Fri Dec 31 22:43:06 2010
--- ASPs/asp/extension/ovrhdr/kernel/task_manage.c	Fri Dec  9 13:54:02 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: task_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: task_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		タスク管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "overrun.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
--- 51,57 ----
  #include "overrun.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
***************
*** 118,124 ****
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  εư
   */
  #ifdef TOPPERS_act_tsk
  
--- 118,124 ----
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  タスクの起動
   */
  #ifdef TOPPERS_act_tsk
  
***************
*** 157,163 ****
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  εư󥿥ƥѡ
   */
  #ifdef TOPPERS_iact_tsk
  
--- 157,163 ----
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  タスクの起動（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iact_tsk
  
***************
*** 196,202 ****
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  ư׵Υ󥻥
   */
  #ifdef TOPPERS_can_act
  
--- 196,202 ----
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  タスク起動要求のキャンセル
   */
  #ifdef TOPPERS_can_act
  
***************
*** 224,230 ****
  #endif /* TOPPERS_can_act */
  
  /*
!  *  νλ
   */
  #ifdef TOPPERS_ext_tsk
  
--- 224,230 ----
  #endif /* TOPPERS_can_act */
  
  /*
!  *  自タスクの終了
   */
  #ifdef TOPPERS_ext_tsk
  
***************
*** 238,246 ****
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUå֤ext_tskƤФ줿ϡCPUå
! 		 *  Ƥ饿λ롥ϡӥǤCPU
! 		 *  åάФ褤
  		 */
  	}
  	else {
--- 238,246 ----
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUロック状態でext_tskが呼ばれた場合は，CPUロックを解除し
! 		 *  てからタスクを終了する．実装上は，サービスコール内でのCPU
! 		 *  ロックを省略すればよいだけ．
  		 */
  	}
  	else {
***************
*** 248,263 ****
  	}
  	if (disdsp) {
  		/*
! 		 *  ǥѥåػ߾֤ext_tskƤФ줿ϡǥѥ
! 		 *  ľ֤ˤƤ饿λ롥
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  ͥ٥ޥIPMˤTIPM_ENAALLʳξ֤ext_tsk
! 		 *  ƤФ줿ϡIPMTIPM_ENAALLˤƤ饿λ
! 		 *  롥
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
--- 248,263 ----
  	}
  	if (disdsp) {
  		/*
! 		 *  ディスパッチ禁止状態でext_tskが呼ばれた場合は，ディスパッ
! 		 *  チ許可状態にしてからタスクを終了する．
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  割込み優先度マスク（IPM）がTIPM_ENAALL以外の状態でext_tsk
! 		 *  が呼ばれた場合は，IPMをTIPM_ENAALLにしてからタスクを終了す
! 		 *  る．
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
***************
*** 284,290 ****
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  ζλ
   */
  #ifdef TOPPERS_ter_tsk
  
--- 284,290 ----
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  タスクの強制終了
   */
  #ifdef TOPPERS_ter_tsk
  
***************
*** 307,315 ****
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbϼǤʤᡤʥ󥰥ץåǤϡ˼
! 			 *  Ծ֤Ǥʤmake_non_runnable(p_tcb)ǥǥѥ
! 			 *  ɬפˤʤ뤳ȤϤʤ
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
--- 307,315 ----
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbは自タスクでないため，（シングルプロセッサでは）実
! 			 *  行状態でなく，make_non_runnable(p_tcb)でタスクディスパッ
! 			 *  チが必要になることはない．
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
***************
*** 336,342 ****
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  Υ١ͥ٤ѹ
   */
  #ifdef TOPPERS_chg_pri
  
--- 336,342 ----
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  タスクのベース優先度の変更
   */
  #ifdef TOPPERS_chg_pri
  
***************
*** 375,381 ****
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  ͥ٤λ
   */
  #ifdef TOPPERS_get_pri
  
--- 375,381 ----
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  タスク優先度の参照
   */
  #ifdef TOPPERS_get_pri
  
***************
*** 408,414 ****
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  γĥλ
   */
  #ifdef TOPPERS_get_inf
  
--- 408,414 ----
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  自タスクの拡張情報の参照
   */
  #ifdef TOPPERS_get_inf
  
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/sample/sample1.c ASPs/asp/extension/ovrhdr/sample/sample1.c
*** 1.9.1/asp/extension/ovrhdr/sample/sample1.c	Fri Sep  7 17:06:21 2012
--- ASPs/asp/extension/ovrhdr/sample/sample1.c	Fri Dec  9 13:54:02 2022
***************
*** 8,110 ****
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: sample1.c 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /* 
!  *  ץץ(1)
   *
!  *  ASPͥδŪưǧ뤿Υץץࡥ
   *
!  *  ץγ:
   *
!  *  桼󥿥եĥᥤ󥿥ʥID: MAIN_TASKͥ
!  *  : MAIN_PRIORITYˤȡ3Ĥ¹Լ¹Ԥ륿ʥID:
!  *  TASK1TASK3ͥ: MID_PRIORITYˤǹ롥ޤư
!  *  2äμϥɥʼϥɥID: CYCHDR1ˤѤ롥
   *
!  *  ¹Լ¹Ԥ륿ϡtask_loop롼פ¹Ԥ٤ˡ
!  *  ¹Ǥ뤳Ȥ򤢤魯åɽ롥롼פ¹Ԥ
!  *  Τϡ롼פʤǥåϤȡ¿̤Υå
!  *  졤ץưǧ餯ʤ뤿Ǥ롥ޤ®ʥ
!  *  ꥢݡȤѤƥåϤˡ٤ƤΥå
!  *  ϤǤ褦ˡå̤¤Ȥͳ⤢롥
   *
!  *  ϥɥϡĤͥ١HIGH_PRIORITYMID_PRIORITY
!  *  LOW_PRIORITYˤΥǥ塼ž롥ץεưľϡ
!  *  ϥɥ߾֤ˤʤäƤ롥
   *
!  *  ᥤ󥿥ϡꥢI/OݡȤʸϤԤʸϤ
!  *  ԤäƤ֤ϡ¹Լ¹Ԥ륿¹ԤƤˡϤ줿
!  *  ʸб¹Ԥ롥Ϥ줿ʸȽδطϼ̤ꡥ
!  *  Control-Cޤ'Q'Ϥȡץλ롥
   *
!  *  '1' : оݥTASK1ڤ괹ʽˡ
!  *  '2' : оݥTASK2ڤ괹롥
!  *  '3' : оݥTASK3ڤ괹롥
!  *  'a' : оݥact_tskˤ굯ư롥
!  *  'A' : оݥФ뵯ư׵can_actˤꥭ󥻥뤹롥
!  *  'e' : оݥext_tskƤӽФλ롥
!  *  't' : оݥter_tskˤ궯λ롥
!  *  '>' : оݥͥ٤HIGH_PRIORITYˤ롥
!  *  '=' : оݥͥ٤MID_PRIORITYˤ롥
!  *  '<' : оݥͥ٤LOW_PRIORITYˤ롥
!  *  'G' : оݥͥ٤get_priɤ߽Ф
!  *  's' : оݥslp_tskƤӽФԤˤ롥
!  *  'S' : оݥtslp_tsk(10)ƤӽФԤˤ롥
!  *  'w' : оݥwup_tskˤ굯롥
!  *  'W' : оݥФ뵯׵can_wupˤꥭ󥻥뤹롥
!  *  'l' : оݥrel_waiˤ궯ŪԤˤ롥
!  *  'u' : оݥsus_tskˤ궯Ԥ֤ˤ롥
!  *  'm' : оݥζԤ֤rsm_tskˤ롥
!  *  'd' : оݥdly_tsk(10)ƤӽФַвԤˤ롥
!  *  'x' : оݥ㳰ѥ0x0001㳰׵᤹롥
!  *  'X' : оݥ㳰ѥ0x0002㳰׵᤹롥
!  *  'y' : оݥdis_texƤӽФ㳰ػߤ롥
!  *  'Y' : оݥena_texƤӽФ㳰Ĥ롥
!  *  'r' : 3Ĥͥ١HIGH_PRIORITYMID_PRIORITYLOW_PRIORITYˤΥ
!  *        ǥ塼ž롥
!  *  'c' : ϥɥưϤ롥
!  *  'C' : ϥɥưߤ롥
!  *  'b' : 顼ϥɥ5ø˵ư褦ưϤ롥
!  *  'B' : 顼ϥɥưߤ롥
!  *  'z' : оݥCPU㳰ȯʥλˡ
!  *  'Z' : оݥCPUå֤CPU㳰ȯʥץ
!  *        λˡ
!  *  'V' : get_utmǽɾѥƥ2ɤࡥ
!  *  'o' : оݥФƥХϥɥưϤ
!  *  'O' : оݥФƥХϥɥưߤ
!  *  'v' : ȯԤƥॳɽʥǥեȡˡ
!  *  'q' : ȯԤƥॳɽʤ
   */
  
  #include <kernel.h>
--- 8,110 ----
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: sample1.c 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /* 
!  *  サンプルプログラム(1)の本体
   *
!  *  ASPカーネルの基本的な動作を確認するためのサンプルプログラム．
   *
!  *  プログラムの概要:
   *
!  *  ユーザインタフェースを受け持つメインタスク（タスクID: MAIN_TASK，優
!  *  先度: MAIN_PRIORITY）と，3つの並行実行されるタスク（タスクID:
!  *  TASK1〜TASK3，初期優先度: MID_PRIORITY）で構成される．また，起動周
!  *  期が2秒の周期ハンドラ（周期ハンドラID: CYCHDR1）を用いる．
   *
!  *  並行実行されるタスクは，task_loop回空ループを実行する度に，タスクが
!  *  実行中であることをあらわすメッセージを表示する．空ループを実行する
!  *  のは，空ループなしでメッセージを出力すると，多量のメッセージが出力
!  *  され，プログラムの動作が確認しずらくなるためである．また，低速なシ
!  *  リアルポートを用いてメッセージを出力する場合に，すべてのメッセージ
!  *  が出力できるように，メッセージの量を制限するという理由もある．
   *
!  *  周期ハンドラは，三つの優先度（HIGH_PRIORITY，MID_PRIORITY，
!  *  LOW_PRIORITY）のレディキューを回転させる．プログラムの起動直後は，
!  *  周期ハンドラは停止状態になっている．
   *
!  *  メインタスクは，シリアルI/Oポートからの文字入力を行い（文字入力を
!  *  待っている間は，並行実行されるタスクが実行されている），入力された
!  *  文字に対応した処理を実行する．入力された文字と処理の関係は次の通り．
!  *  Control-Cまたは'Q'が入力されると，プログラムを終了する．
   *
!  *  '1' : 対象タスクをTASK1に切り換える（初期設定）．
!  *  '2' : 対象タスクをTASK2に切り換える．
!  *  '3' : 対象タスクをTASK3に切り換える．
!  *  'a' : 対象タスクをact_tskにより起動する．
!  *  'A' : 対象タスクに対する起動要求をcan_actによりキャンセルする．
!  *  'e' : 対象タスクにext_tskを呼び出させ，終了させる．
!  *  't' : 対象タスクをter_tskにより強制終了する．
!  *  '>' : 対象タスクの優先度をHIGH_PRIORITYにする．
!  *  '=' : 対象タスクの優先度をMID_PRIORITYにする．
!  *  '<' : 対象タスクの優先度をLOW_PRIORITYにする．
!  *  'G' : 対象タスクの優先度をget_priで読み出す．
!  *  's' : 対象タスクにslp_tskを呼び出させ，起床待ちにさせる．
!  *  'S' : 対象タスクにtslp_tsk(10秒)を呼び出させ，起床待ちにさせる．
!  *  'w' : 対象タスクをwup_tskにより起床する．
!  *  'W' : 対象タスクに対する起床要求をcan_wupによりキャンセルする．
!  *  'l' : 対象タスクをrel_waiにより強制的に待ち解除にする．
!  *  'u' : 対象タスクをsus_tskにより強制待ち状態にする．
!  *  'm' : 対象タスクの強制待ち状態をrsm_tskにより解除する．
!  *  'd' : 対象タスクにdly_tsk(10秒)を呼び出させ，時間経過待ちにさせる．
!  *  'x' : 対象タスクに例外パターン0x0001の例外処理を要求する．
!  *  'X' : 対象タスクに例外パターン0x0002の例外処理を要求する．
!  *  'y' : 対象タスクにdis_texを呼び出させ，タスク例外を禁止する．
!  *  'Y' : 対象タスクにena_texを呼び出させ，タスク例外を許可する．
!  *  'r' : 3つの優先度（HIGH_PRIORITY，MID_PRIORITY，LOW_PRIORITY）のレ
!  *        ディキューを回転させる．
!  *  'c' : 周期ハンドラを動作開始させる．
!  *  'C' : 周期ハンドラを動作停止させる．
!  *  'b' : アラームハンドラを5秒後に起動するよう動作開始させる．
!  *  'B' : アラームハンドラを動作停止させる．
!  *  'z' : 対象タスクにCPU例外を発生させる（タスクを終了させる）．
!  *  'Z' : 対象タスクにCPUロック状態でCPU例外を発生させる（プログラムを
!  *        終了する）．
!  *  'V' : get_utmで性能評価用システム時刻を2回読む．
!  *  'o' : 対象タスクに対してオーバランハンドラを動作開始させる
!  *  'O' : 対象タスクに対してオーバランハンドラを動作停止させる
!  *  'v' : 発行したシステムコールを表示する（デフォルト）．
!  *  'q' : 発行したシステムコールを表示しない．
   */
  
  #include <kernel.h>
***************
*** 116,122 ****
  #include "sample1.h"
  
  /*
!  *  ӥΥ顼Υ
   */
  Inline void
  svc_perror(const char *file, int_t line, const char *expr, ER ercd)
--- 116,122 ----
  #include "sample1.h"
  
  /*
!  *  サービスコールのエラーのログ出力
   */
  Inline void
  svc_perror(const char *file, int_t line, const char *expr, ER ercd)
***************
*** 129,146 ****
  #define	SVC_PERROR(expr)	svc_perror(__FILE__, __LINE__, #expr, (expr))
  
  /*
!  *  ¹Լ¹Ԥ륿ؤΥåΰ
   */
  char	message[3];
  
  /*
!  *  롼ײ
   */
! ulong_t	task_loop;		/* ǤΥ롼ײ */
! ulong_t	tex_loop;		/* 㳰롼ǤΥ롼ײ */
  
  /*
!  *  ¹Լ¹Ԥ륿
   */
  void task(intptr_t exinf)
  {
--- 129,146 ----
  #define	SVC_PERROR(expr)	svc_perror(__FILE__, __LINE__, #expr, (expr))
  
  /*
!  *  並行実行されるタスクへのメッセージ領域
   */
  char	message[3];
  
  /*
!  *  ループ回数
   */
! ulong_t	task_loop;		/* タスク内でのループ回数 */
! ulong_t	tex_loop;		/* 例外処理ルーチン内でのループ回数 */
  
  /*
!  *  並行実行されるタスク
   */
  void task(intptr_t exinf)
  {
***************
*** 216,222 ****
  }
  
  /*
!  *  ¹ԤƼ¹Ԥ륿ѤΥ㳰롼
   */
  void tex_routine(TEXPTN texptn, intptr_t exinf)
  {
--- 216,222 ----
  }
  
  /*
!  *  並行して実行されるタスク用のタスク例外処理ルーチン
   */
  void tex_routine(TEXPTN texptn, intptr_t exinf)
  {
***************
*** 234,240 ****
  }
  
  /*
!  *  CPU㳰ϥɥ
   */
  #ifdef CPUEXC1
  
--- 234,240 ----
  }
  
  /*
!  *  CPU例外ハンドラ
   */
  #ifdef CPUEXC1
  
***************
*** 270,279 ****
  #endif /* CPUEXC1 */
  
  /*
!  *  ϥɥ
   *
!  *  HIGH_PRIORITYMID_PRIORITYLOW_PRIORITY γͥ٤Υǥ塼
!  *  ž롥
   */
  void cyclic_handler(intptr_t exinf)
  {
--- 270,279 ----
  #endif /* CPUEXC1 */
  
  /*
!  *  周期ハンドラ
   *
!  *  HIGH_PRIORITY，MID_PRIORITY，LOW_PRIORITY の各優先度のレディキュー
!  *  を回転させる．
   */
  void cyclic_handler(intptr_t exinf)
  {
***************
*** 283,292 ****
  }
  
  /*
!  *  顼ϥɥ
   *
!  *  HIGH_PRIORITYMID_PRIORITYLOW_PRIORITY γͥ٤Υǥ塼
!  *  ž롥
   */
  void alarm_handler(intptr_t exinf)
  {
--- 283,292 ----
  }
  
  /*
!  *  アラームハンドラ
   *
!  *  HIGH_PRIORITY，MID_PRIORITY，LOW_PRIORITY の各優先度のレディキュー
!  *  を回転させる．
   */
  void alarm_handler(intptr_t exinf)
  {
***************
*** 296,302 ****
  }
  
  /*
!  *  Хϥɥ
   */
  #ifdef TOPPERS_SUPPORT_OVRHDR
  
--- 296,302 ----
  }
  
  /*
!  *  オーバランハンドラ
   */
  #ifdef TOPPERS_SUPPORT_OVRHDR
  
***************
*** 313,319 ****
  #endif /* TOPPERS_SUPPORT_OVRHDR */
  
  /*
!  *  ᥤ󥿥
   */
  void main_task(intptr_t exinf)
  {
--- 313,319 ----
  #endif /* TOPPERS_SUPPORT_OVRHDR */
  
  /*
!  *  メインタスク
   */
  void main_task(intptr_t exinf)
  {
***************
*** 334,344 ****
  	syslog(LOG_NOTICE, "Sample program starts (exinf = %d).", (int_t) exinf);
  
  	/*
! 	 *  ꥢݡȤν
  	 *
! 	 *  ƥƱꥢݡȤȤʤɡꥢ
! 	 *  ݡȤץѤߤξˤϤE_OBJ顼ˤʤ뤬پ
! 	 *  ʤ
  	 */
  	ercd = serial_opn_por(TASK_PORTID);
  	if (ercd < 0 && MERCD(ercd) != E_OBJ) {
--- 334,344 ----
  	syslog(LOG_NOTICE, "Sample program starts (exinf = %d).", (int_t) exinf);
  
  	/*
! 	 *  シリアルポートの初期化
  	 *
! 	 *  システムログタスクと同じシリアルポートを使う場合など，シリアル
! 	 *  ポートがオープン済みの場合にはここでE_OBJエラーになるが，支障は
! 	 *  ない．
  	 */
  	ercd = serial_opn_por(TASK_PORTID);
  	if (ercd < 0 && MERCD(ercd) != E_OBJ) {
***************
*** 349,383 ****
  							(IOCTL_CRLF | IOCTL_FCSND | IOCTL_FCRCV)));
  
  	/*
!  	 *  롼ײ
  	 *
! 	 *  ¹Լ¹Ԥ륿Ǥζ롼פβtask_loopˤϡ롼
! 	 *  פμ¹Ի֤0.4äˤʤ褦ꤹ롥Τˡ
! 	 *  LOOP_REFζ롼פμ¹Ի֤򡤤get_timƤ֤Ȥ
! 	 *  ¬ꤷ¬̤롼פμ¹Ի֤0.4äˤʤ롼ײ
! 	 *  ᡤtask_loopꤹ롥
  	 *
! 	 *  LOOP_REFϡǥեȤǤ1,000,000ꤷƤ뤬ꤷ
! 	 *  ٤ץåǤϡץץμ¹ԳϤ˻֤
! 	 *  ꤹȤ롥դꤷ®ץåǤϡ
! 	 *  LOOP_REFζ롼פμ¹Ի֤ûʤꡤtask_loopꤹ
! 	 *  θ礭ʤȤ꤬롥
  	 *
! 	 *  ǡΤ褦ʥåȤǤϡtarget_test.hǡLOOP_REFŬ
! 	 *  ڤͤΤ˾ޤ
  	 *
! 	 *  ޤtask_loopͤꤷˤϡͤTASK_LOOP˥
! 	 *  롥TASK_LOOPޥƤ硤嵭¬
! 	 *  Ԥ鷺ˡTASK_LOOP줿ͤ롼פβȤ롥
  	 *
! 	 * åȤˤäƤϡ롼פμ¹Ի֤1ܤ¬ǡ
! 	 * ĹˤʤΤ롥Τ褦ʥåȤǤϡMEASURE_TWICE
! 	 * ޥ뤳Ȥǡ1ܤ¬̤ΤƤơ2ܤ¬
! 	 * Ȥ
  	 *
! 	 *  㳰롼Ǥζ롼פβtex_loopˤϡ
! 	 *  task_loop4ʬ1͡ʶ롼פμ¹Ի֤0.1äˤʤ롼ײ
! 	 *  ˤꤹ롥
  	 */
  #ifdef TASK_LOOP
  	task_loop = TASK_LOOP;
--- 349,383 ----
  							(IOCTL_CRLF | IOCTL_FCSND | IOCTL_FCRCV)));
  
  	/*
!  	 *  ループ回数の設定
  	 *
! 	 *  並行実行されるタスク内での空ループの回数（task_loop）は，空ルー
! 	 *  プの実行時間が約0.4秒になるように設定する．この設定のために，
! 	 *  LOOP_REF回の空ループの実行時間を，その前後でget_timを呼ぶことで
! 	 *  測定し，その測定結果から空ループの実行時間が0.4秒になるループ回
! 	 *  数を求め，task_loopに設定する．
  	 *
! 	 *  LOOP_REFは，デフォルトでは1,000,000に設定しているが，想定したよ
! 	 *  り遅いプロセッサでは，サンプルプログラムの実行開始に時間がかか
! 	 *  りすぎるという問題を生じる．逆に想定したより速いプロセッサでは，
! 	 *  LOOP_REF回の空ループの実行時間が短くなり，task_loopに設定する値
! 	 *  の誤差が大きくなるという問題がある．
  	 *
! 	 *  そこで，そのようなターゲットでは，target_test.hで，LOOP_REFを適
! 	 *  切な値に定義するのが望ましい．
  	 *
! 	 *  また，task_loopの値を固定したい場合には，その値をTASK_LOOPにマ
! 	 *  クロ定義する．TASK_LOOPがマクロ定義されている場合，上記の測定を
! 	 *  行わずに，TASK_LOOPに定義された値を空ループの回数とする．
  	 *
! 	 * ターゲットによっては，空ループの実行時間の1回目の測定で，本来よ
! 	 * りも長めになるものがある．このようなターゲットでは，MEASURE_TWICE
! 	 * をマクロ定義することで，1回目の測定結果を捨てて，2回目の測定結果
! 	 * を使う．
  	 *
! 	 *  タスク例外処理ルーチン内での空ループの回数（tex_loop）は，
! 	 *  task_loopの4分の1の値（空ループの実行時間が0.1秒になるループ回
! 	 *  数）に設定する．
  	 */
  #ifdef TASK_LOOP
  	task_loop = TASK_LOOP;
***************
*** 400,413 ****
  	tex_loop = task_loop / 4;
  
  	/*
!  	 *  εư
  	 */
  	SVC_PERROR(act_tsk(TASK1));
  	SVC_PERROR(act_tsk(TASK2));
  	SVC_PERROR(act_tsk(TASK3));
  
  	/*
!  	 *  ᥤ롼
  	 */
  	do {
  		SVC_PERROR(serial_rea_dat(TASK_PORTID, &c, 1));
--- 400,413 ----
  	tex_loop = task_loop / 4;
  
  	/*
!  	 *  タスクの起動
  	 */
  	SVC_PERROR(act_tsk(TASK1));
  	SVC_PERROR(act_tsk(TASK2));
  	SVC_PERROR(act_tsk(TASK3));
  
  	/*
!  	 *  メインループ
  	 */
  	do {
  		SVC_PERROR(serial_rea_dat(TASK_PORTID, &c, 1));
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/sample/sample1.cfg ASPs/asp/extension/ovrhdr/sample/sample1.cfg
*** 1.9.1/asp/extension/ovrhdr/sample/sample1.cfg	Fri Sep  7 17:06:21 2012
--- ASPs/asp/extension/ovrhdr/sample/sample1.cfg	Fri Dec  9 13:54:02 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ץץ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  サンプルプログラム(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/ovrhdr/sample/sample1.h ASPs/asp/extension/ovrhdr/sample/sample1.h
*** 1.9.1/asp/extension/ovrhdr/sample/sample1.h	Fri Sep  7 17:06:21 2012
--- ASPs/asp/extension/ovrhdr/sample/sample1.h	Fri Dec  9 13:54:03 2022
***************
*** 8,83 ****
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   *
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   *
   *  $Id: sample1.h 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /*
!  *		ץץ(1)Υإåե
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
  
! #define MAIN_PRIORITY	5		/* ᥤ󥿥ͥ */
! 								/* HIGH_PRIORITY⤯뤳 */
  
! #define HIGH_PRIORITY	9		/* ¹Լ¹Ԥ륿ͥ */
  #define MID_PRIORITY	10
  #define LOW_PRIORITY	11
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  
  #ifndef TASK_PORTID
! #define	TASK_PORTID		1			/* ʸϤ륷ꥢݡID */
  #endif /* TASK_PORTID */
  
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  #ifndef LOOP_REF
! #define LOOP_REF		ULONG_C(1000000)	/* ®ٷ¬ѤΥ롼ײ */
  #endif /* LOOP_REF */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 8,83 ----
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   *
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   *
   *  $Id: sample1.h 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /*
!  *		サンプルプログラム(1)のヘッダファイル
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
  
! #define MAIN_PRIORITY	5		/* メインタスクの優先度 */
! 								/* HIGH_PRIORITYより高くすること */
  
! #define HIGH_PRIORITY	9		/* 並行実行されるタスクの優先度 */
  #define MID_PRIORITY	10
  #define LOW_PRIORITY	11
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  
  #ifndef TASK_PORTID
! #define	TASK_PORTID		1			/* 文字入力するシリアルポートID */
  #endif /* TASK_PORTID */
  
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  #ifndef LOOP_REF
! #define LOOP_REF		ULONG_C(1000000)	/* 速度計測用のループ回数 */
  #endif /* LOOP_REF */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/pri_level/include/kernel.h ASPs/asp/extension/pri_level/include/kernel.h
*** 1.9.1/asp/extension/pri_level/include/kernel.h	Sat Jan 11 22:54:05 2014
--- ASPs/asp/extension/pri_level/include/kernel.h	Fri Dec  9 13:54:03 2022
***************
*** 8,57 ****
   *  Copyright (C) 2004-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: kernel.h 2605 2014-01-11 13:54:04Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥ ɸإåե
   *
!  *  TOPPERS/ASPͥ뤬ݡȤ륵ӥȡɬפʥǡ
!  *  ޥޤإåե롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   *
!  *  Υե򥤥󥯥롼ɤ˥󥯥롼ɤƤ٤ե
!  *  Ϥʤ
   */
  
  #ifndef TOPPERS_KERNEL_H
--- 8,57 ----
   *  Copyright (C) 2004-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: kernel.h 2605 2014-01-11 13:54:04Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル 標準ヘッダファイル
   *
!  *  TOPPERS/ASPカーネルがサポートするサービスコールの宣言と，必要なデー
!  *  タ型，定数，マクロの定義を含むヘッダファイル．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   *
!  *  このファイルをインクルードする前にインクルードしておくべきファイル
!  *  はない．
   */
  
  #ifndef TOPPERS_KERNEL_H
***************
*** 62,93 ****
  #endif
  
  /*
!  *	TOPPERS̤Υǡޥ
   */
  #include <t_stddef.h>
  
  /*
!  *  åȰ¸
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ǡ
   */
  
  /*
!  *  ӥåȥѥ䥪ֹ֥η
   */
! typedef	uint_t		TEXPTN;		/* 㳰װΥӥåȥѥ */
! typedef	uint_t		FLGPTN;		/* ٥ȥե饰Υӥåȥѥ */
! typedef	uint_t		INTNO;		/* ֹ */
! typedef	uint_t		INHNO;		/* ߥϥɥֹ */
! typedef	uint_t		EXCNO;		/* CPU㳰ϥɥֹ */
  
  /*
!  *  ñ̤η
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
--- 62,93 ----
  #endif
  
  /*
!  *	TOPPERS共通のデータ型・定数・マクロ
   */
  #include <t_stddef.h>
  
  /*
!  *  ターゲット依存部
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  データ型の定義
   */
  
  /*
!  *  ビットパターンやオブジェクト番号の型定義
   */
! typedef	uint_t		TEXPTN;		/* タスク例外要因のビットパターン */
! typedef	uint_t		FLGPTN;		/* イベントフラグのビットパターン */
! typedef	uint_t		INTNO;		/* 割込み番号 */
! typedef	uint_t		INHNO;		/* 割込みハンドラ番号 */
! typedef	uint_t		EXCNO;		/* CPU例外ハンドラ番号 */
  
  /*
!  *  処理単位の型定義
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
***************
*** 100,202 ****
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  ΰݤΤη
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* åΰݤ뤿η */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* Ĺסΰݤ뤿η */
  
  /*
!  *  åإåη
   */
! typedef	struct t_msg {			/* ᡼ܥåΥåإå */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* ͥդåإå */
! 	T_MSG	msgque;				/* åإå */
! 	PRI		msgpri;				/* åͥ */
  } T_MSG_PRI;
  
  /*
!  *  ѥåȷ
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/*  */
! 	PRI		tskpri;		/* θͥ */
! 	PRI		tskbpri;	/* Υ١ͥ */
! 	STAT	tskwait;	/* Ԥװ */
! 	ID		wobjid;		/* ԤоݤΥ֥ȤID */
! 	TMO		lefttmo;	/* ॢȤޤǤλ */
! 	uint_t	actcnt;		/* ư׵ᥭ塼󥰿 */
! 	uint_t	wupcnt;		/* ׵ᥭ塼󥰿 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* 㳰ξ */
! 	TEXPTN	pndptn;		/* α㳰װ */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* ޥեԤƬΥIDֹ */
! 	uint_t	semcnt;		/* ޥեθߤλ񸻿 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* ٥ȥե饰ԤƬΥIDֹ */
! 	FLGPTN	flgptn;		/* ٥ȥե饰θߤΥӥåȥѥ */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* ǡ塼ԤƬΥIDֹ */
! 	ID		rtskid;		/* ǡ塼μԤƬΥIDֹ */
! 	uint_t	sdtqcnt;	/* ǡ塼ΰ˳ǼƤǡο */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* ͥ٥ǡ塼ԤƬΥ
! 						   IDֹ */
! 	ID		rtskid;		/* ͥ٥ǡ塼μԤƬΥ
! 						   IDֹ */
! 	uint_t	spdqcnt;	/* ͥ٥ǡ塼ΰ˳ǼƤǡ
! 						   ο */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* ᡼ܥåԤƬΥIDֹ */
! 	T_MSG	*pk_msg;	/* å塼ƬˤĤʤ줿å
! 						   Ƭ */
  } T_RMBX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* ĹסԤƬΥ
! 						   IDֹ */
! 	uint_t	fblkcnt;	/* Ĺסΰζΰ˳
! 						   դ뤳ȤǤĹ֥åο */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* ϥɥư */
! 	RELTIM	lefttim;	/* ˼ϥɥưޤǤл */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* 顼ϥɥư */
! 	RELTIM	lefttim;	/* 顼ϥɥưޤǤл */
  } T_RALM;
  
  /*
!  *  ӥ
   */
  
  /*
!  *  ǽ
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
--- 100,202 ----
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  メモリ領域確保のための型定義
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* スタック領域を確保するための型 */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* 固定長メモリプール領域を確保するための型 */
  
  /*
!  *  メッセージヘッダの型定義
   */
! typedef	struct t_msg {			/* メールボックスのメッセージヘッダ */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* 優先度付きメッセージヘッダ */
! 	T_MSG	msgque;				/* メッセージヘッダ */
! 	PRI		msgpri;				/* メッセージ優先度 */
  } T_MSG_PRI;
  
  /*
!  *  パケット形式の定義
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/* タスク状態 */
! 	PRI		tskpri;		/* タスクの現在優先度 */
! 	PRI		tskbpri;	/* タスクのベース優先度 */
! 	STAT	tskwait;	/* 待ち要因 */
! 	ID		wobjid;		/* 待ち対象のオブジェクトのID */
! 	TMO		lefttmo;	/* タイムアウトするまでの時間 */
! 	uint_t	actcnt;		/* 起動要求キューイング数 */
! 	uint_t	wupcnt;		/* 起床要求キューイング数 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* タスク例外処理の状態 */
! 	TEXPTN	pndptn;		/* 保留例外要因 */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* セマフォの待ち行列の先頭のタスクのID番号 */
! 	uint_t	semcnt;		/* セマフォの現在の資源数 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* イベントフラグの待ち行列の先頭のタスクのID番号 */
! 	FLGPTN	flgptn;		/* イベントフラグの現在のビットパターン */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* データキューの送信待ち行列の先頭のタスクのID番号 */
! 	ID		rtskid;		/* データキューの受信待ち行列の先頭のタスクのID番号 */
! 	uint_t	sdtqcnt;	/* データキュー管理領域に格納されているデータの数 */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* 優先度データキューの送信待ち行列の先頭のタスク
! 						   のID番号 */
! 	ID		rtskid;		/* 優先度データキューの受信待ち行列の先頭のタスク
! 						   のID番号 */
! 	uint_t	spdqcnt;	/* 優先度データキュー管理領域に格納されているデー
! 						   タの数 */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* メールボックスの待ち行列の先頭のタスクのID番号 */
! 	T_MSG	*pk_msg;	/* メッセージキューの先頭につながれたメッセージ
! 						   の先頭番地 */
  } T_RMBX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* 固定長メモリプールの待ち行列の先頭のタスクの
! 						   ID番号 */
! 	uint_t	fblkcnt;	/* 固定長メモリプール領域の空きメモリ領域に割り
! 						   付けることができる固定長メモリブロックの数 */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* 周期ハンドラの動作状態 */
! 	RELTIM	lefttim;	/* 次に周期ハンドラを起動する時刻までの相対時間 */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* アラームハンドラの動作状態 */
! 	RELTIM	lefttim;	/* アラームハンドラを起動する時刻までの相対時間 */
  } T_RALM;
  
  /*
!  *  サービスコールの宣言
   */
  
  /*
!  *  タスク管理機能
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
***************
*** 209,215 ****
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  °Ʊǽ
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
--- 209,215 ----
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  タスク付属同期機能
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
***************
*** 223,229 ****
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  㳰ǽ
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
--- 223,229 ----
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  タスク例外処理機能
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
***************
*** 233,239 ****
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  Ʊ̿ǽ
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
--- 233,239 ----
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  同期・通信機能
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
***************
*** 287,293 ****
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  סǽ
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
--- 287,293 ----
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  メモリプール管理機能
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
***************
*** 297,303 ****
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  ִǽ
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
--- 297,303 ----
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  時間管理機能
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
***************
*** 313,319 ****
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  ƥִǽ
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
--- 313,319 ----
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  システム状態管理機能
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
***************
*** 333,339 ****
  extern ER		ext_ker(void) throw();
  
  /*
!  *  ߴǽ
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
--- 333,339 ----
  extern ER		ext_ker(void) throw();
  
  /*
!  *  割込み管理機能
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
***************
*** 341,347 ****
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU㳰ǽ
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
--- 341,347 ----
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU例外管理機能
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
***************
*** 349,481 ****
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ֥°
   */
! #define TA_ACT			UINT_C(0x02)	/* ư줿֤ */
  
! #define TA_TPRI			UINT_C(0x01)	/* Ԥͥٽ */
! #define TA_MPRI			UINT_C(0x02)	/* å塼ͥٽ */
  
! #define TA_WMUL			UINT_C(0x02)	/* ʣԤ */
! #define TA_CLR			UINT_C(0x04)	/* ٥ȥե饰Υꥢ */
  
! #define TA_STA			UINT_C(0x02)	/* ϥɥư֤ */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* ͥγ */
  
! #define TA_ENAINT		UINT_C(0x01)	/* ׵ػߥե饰򥯥ꥢ */
! #define TA_EDGE			UINT_C(0x02)	/* åȥꥬ */
  
  /*
!  *  ӥư⡼ɤ
   */
! #define TWF_ORW			UINT_C(0x01)	/* ٥ȥե饰ORԤ */
! #define TWF_ANDW		UINT_C(0x02)	/* ٥ȥե饰ANDԤ */
  
  /*
!  *  ֥Ȥξ֤
   */
! #define TTS_RUN			UINT_C(0x01)	/* ¹Ծ */
! #define TTS_RDY			UINT_C(0x02)	/* ¹Բǽ */
! #define TTS_WAI			UINT_C(0x04)	/* Ԥ */
! #define TTS_SUS			UINT_C(0x08)	/* Ԥ */
! #define TTS_WAS			UINT_C(0x0c)	/* Ԥ */
! #define TTS_DMT			UINT_C(0x10)	/* ٻ߾ */
  
! #define TTW_SLP			UINT_C(0x0001)	/* Ԥ */
! #define TTW_DLY			UINT_C(0x0002)	/* ַвԤ */
! #define TTW_SEM			UINT_C(0x0004)	/* ޥեλ񸻳Ԥ */
! #define TTW_FLG			UINT_C(0x0008)	/* ٥ȥե饰Ԥ */
! #define TTW_SDTQ		UINT_C(0x0010)	/* ǡ塼ؤԤ */
! #define TTW_RDTQ		UINT_C(0x0020)	/* ǡ塼μԤ */
! #define TTW_SPDQ		UINT_C(0x0100)	/* ͥ٥ǡ塼ؤԤ */
! #define TTW_RPDQ		UINT_C(0x0200)	/* ͥ٥ǡ塼μԤ */
! #define TTW_MBX			UINT_C(0x0040)	/* ᡼ܥåμԤ */
! #define TTW_MPF			UINT_C(0x2000)	/* Ĺ֥åγԤ */
  
! #define TTEX_ENA		UINT_C(0x01)	/* 㳰ľ */
! #define TTEX_DIS		UINT_C(0x02)	/* 㳰ػ߾ */
  
! #define TCYC_STP		UINT_C(0x01)	/* ϥɥ餬ưƤʤ */
! #define TCYC_STA		UINT_C(0x02)	/* ϥɥ餬ưƤ */
  
! #define TALM_STP		UINT_C(0x01)	/* 顼ϥɥ餬ưƤʤ */
! #define TALM_STA		UINT_C(0x02)	/* 顼ϥɥ餬ưƤ */
  
  /*
!  *  ¾
   */
! #define TSK_SELF		0			/*  */
! #define TSK_NONE		0			/* 륿ʤ */
  
! #define TPRI_SELF		0			/* Υ١ͥ */
! #define TPRI_INI		0			/* εưͥ */
  
! #define TIPM_ENAALL		0			/* ͥ٥ޥ */
  
  /*
!  *  ȥޥ
   */
  
  /*
!  *  ݡȤ뵡ǽ
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_PRI_LEVEL		/* ͥ٤ϰϤγĥ */
  
  /*
!  *  ͥ٤ϰ
   */
! #define TMIN_TPRI		1			/* ͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_TPRI		256			/* ͥ٤κ͡ʺ͡*/
! #define TMIN_DPRI		1			/* ǡͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_DPRI		256			/* ǡͥ٤κ͡ʺ͡*/
! #define TMIN_MPRI		1			/* åͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_MPRI		256			/* åͥ٤κ͡ʺ͡*/
! #define TMIN_ISRPRI		1			/* ߥӥ롼ͥ٤κǾ */
! #define TMAX_ISRPRI		256			/* ߥӥ롼ͥ٤κ */
  
  /*
!  *  С
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* ͥΥ᡼ */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* ͥμֹ */
! #define TKERNEL_SPVER	UINT_C(0xf516)	/* ͥͤΥСֹ */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* ͥΥСֹ */
  
  /*
!  *  塼󥰲κ
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* ư׵ᥭ塼󥰿κ */
! #define TMAX_WUPCNT		UINT_C(1)		/* ׵ᥭ塼󥰿κ */
  
  /*
!  *  ӥåȥѥΥӥåȿ
   */
! #ifndef TBIT_TEXPTN					/* 㳰װΥӥåȿ */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* ٥ȥե饰Υӥåȿ */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  ΰݤΤΥޥ
   *
!  *  ʲTOPPERS_COUNT_SZTOPPERS_ROUND_SZϡunit2ζҾǤ
!  *  뤳ȤꤷƤ롥
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
--- 349,481 ----
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  オブジェクト属性の定義
   */
! #define TA_ACT			UINT_C(0x02)	/* タスクを起動された状態で生成 */
  
! #define TA_TPRI			UINT_C(0x01)	/* タスクの待ち行列を優先度順に */
! #define TA_MPRI			UINT_C(0x02)	/* メッセージキューを優先度順に */
  
! #define TA_WMUL			UINT_C(0x02)	/* 複数の待ちタスク */
! #define TA_CLR			UINT_C(0x04)	/* イベントフラグのクリア指定 */
  
! #define TA_STA			UINT_C(0x02)	/* 周期ハンドラを動作状態で生成 */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* カーネル管理外の割込み */
  
! #define TA_ENAINT		UINT_C(0x01)	/* 割込み要求禁止フラグをクリア */
! #define TA_EDGE			UINT_C(0x02)	/* エッジトリガ */
  
  /*
!  *  サービスコールの動作モードの定義
   */
! #define TWF_ORW			UINT_C(0x01)	/* イベントフラグのOR待ち */
! #define TWF_ANDW		UINT_C(0x02)	/* イベントフラグのAND待ち */
  
  /*
!  *  オブジェクトの状態の定義
   */
! #define TTS_RUN			UINT_C(0x01)	/* 実行状態 */
! #define TTS_RDY			UINT_C(0x02)	/* 実行可能状態 */
! #define TTS_WAI			UINT_C(0x04)	/* 待ち状態 */
! #define TTS_SUS			UINT_C(0x08)	/* 強制待ち状態 */
! #define TTS_WAS			UINT_C(0x0c)	/* 二重待ち状態 */
! #define TTS_DMT			UINT_C(0x10)	/* 休止状態 */
  
! #define TTW_SLP			UINT_C(0x0001)	/* 起床待ち */
! #define TTW_DLY			UINT_C(0x0002)	/* 時間経過待ち */
! #define TTW_SEM			UINT_C(0x0004)	/* セマフォの資源獲得待ち */
! #define TTW_FLG			UINT_C(0x0008)	/* イベントフラグ待ち */
! #define TTW_SDTQ		UINT_C(0x0010)	/* データキューへの送信待ち */
! #define TTW_RDTQ		UINT_C(0x0020)	/* データキューからの受信待ち */
! #define TTW_SPDQ		UINT_C(0x0100)	/* 優先度データキューへの送信待ち */
! #define TTW_RPDQ		UINT_C(0x0200)	/* 優先度データキューからの受信待ち */
! #define TTW_MBX			UINT_C(0x0040)	/* メールボックスからの受信待ち */
! #define TTW_MPF			UINT_C(0x2000)	/* 固定長メモリブロックの獲得待ち */
  
! #define TTEX_ENA		UINT_C(0x01)	/* タスク例外処理許可状態 */
! #define TTEX_DIS		UINT_C(0x02)	/* タスク例外処理禁止状態 */
  
! #define TCYC_STP		UINT_C(0x01)	/* 周期ハンドラが動作していない */
! #define TCYC_STA		UINT_C(0x02)	/* 周期ハンドラが動作している */
  
! #define TALM_STP		UINT_C(0x01)	/* アラームハンドラが動作していない */
! #define TALM_STA		UINT_C(0x02)	/* アラームハンドラが動作している */
  
  /*
!  *  その他の定数の定義
   */
! #define TSK_SELF		0			/* 自タスク指定 */
! #define TSK_NONE		0			/* 該当するタスクがない */
  
! #define TPRI_SELF		0			/* 自タスクのベース優先度 */
! #define TPRI_INI		0			/* タスクの起動時優先度 */
  
! #define TIPM_ENAALL		0			/* 割込み優先度マスク全解除 */
  
  /*
!  *  構成定数とマクロ
   */
  
  /*
!  *  サポートする機能
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_PRI_LEVEL		/* タスク優先度の範囲の拡張 */
  
  /*
!  *  優先度の範囲
   */
! #define TMIN_TPRI		1			/* タスク優先度の最小値（最高値）*/
! #define TMAX_TPRI		256			/* タスク優先度の最大値（最低値）*/
! #define TMIN_DPRI		1			/* データ優先度の最小値（最高値）*/
! #define TMAX_DPRI		256			/* データ優先度の最大値（最低値）*/
! #define TMIN_MPRI		1			/* メッセージ優先度の最小値（最高値）*/
! #define TMAX_MPRI		256			/* メッセージ優先度の最大値（最低値）*/
! #define TMIN_ISRPRI		1			/* 割込みサービスルーチン優先度の最小値 */
! #define TMAX_ISRPRI		256			/* 割込みサービスルーチン優先度の最大値 */
  
  /*
!  *  バージョン情報
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* カーネルのメーカーコード */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* カーネルの識別番号 */
! #define TKERNEL_SPVER	UINT_C(0xf516)	/* カーネル仕様のバージョン番号 */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* カーネルのバージョン番号 */
  
  /*
!  *  キューイング回数の最大値
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* 起動要求キューイング数の最大値 */
! #define TMAX_WUPCNT		UINT_C(1)		/* 起床要求キューイング数の最大値 */
  
  /*
!  *  ビットパターンのビット数
   */
! #ifndef TBIT_TEXPTN					/* タスク例外要因のビット数 */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* イベントフラグのビット数 */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  メモリ領域確保のためのマクロ
   *
!  *  以下のTOPPERS_COUNT_SZとTOPPERS_ROUND_SZの定義は，unitが2の巾乗であ
!  *  ることを仮定している．
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
***************
*** 491,499 ****
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  ¾ι
   */
! #define TMAX_MAXSEM		UINT_MAX	/* ޥեκ񸻿κ */
  
  #ifdef __cplusplus
  }
--- 491,499 ----
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  その他の構成定数
   */
! #define TMAX_MAXSEM		UINT_MAX	/* セマフォの最大資源数の最大値 */
  
  #ifdef __cplusplus
  }
diff -cr --new-file 1.9.1/asp/extension/pri_level/kernel/task.c ASPs/asp/extension/pri_level/kernel/task.c
*** 1.9.1/asp/extension/pri_level/kernel/task.c	Sat Aug 27 07:59:56 2011
--- ASPs/asp/extension/pri_level/kernel/task.c	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
***************
*** 62,103 ****
  #ifdef TOPPERS_tskini
  
  /*
!  *  ¹Ծ֤Υ
   */
  TCB		*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   */
  TCB		*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   */
  bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   */
  bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   */
  bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   */
  bool_t	dspflg;
  
  /*
!  *  ǥ塼
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   */
  #ifdef PRIMAP_LEVEL_1
  uint16_t	ready_primap;
--- 62,103 ----
  #ifdef TOPPERS_tskini
  
  /*
!  *  実行状態のタスク
   */
  TCB		*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   */
  TCB		*p_schedtsk;
  
  /*
!  *  タスクディスパッチ／タスク例外処理ルーチン起動要求フラグ
   */
  bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   */
  bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   */
  bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   */
  bool_t	dspflg;
  
  /*
!  *  レディキュー
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   */
  #ifdef PRIMAP_LEVEL_1
  uint16_t	ready_primap;
***************
*** 107,113 ****
  #endif /* PRIMAP_LEVEL_1 */
  
  /*
!  *  ⥸塼ν
   */
  void
  initialize_task(void)
--- 107,113 ----
  #endif /* PRIMAP_LEVEL_1 */
  
  /*
!  *  タスク管理モジュールの初期化
   */
  void
  initialize_task(void)
***************
*** 149,170 ****
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ӥåȥޥåץؿ
   *
!  *  bitmap1ΥӥåȤ⡤ǤⲼ̡ʱˤΤΤ򥵡Υӥ
!  *  ֹ֤ӥåֹϡǲ̥ӥåȤ0Ȥ롥bitmap0
!  *  ƤϤʤʤδؿǤϡbitmap16ӥåȤǤ뤳Ȥꤷ
!  *  uint16_tȤƤ롥
   *
!  *  ӥåȥ̿ĥץåǤϡӥåȥ̿Ȥ褦
!  *  ľΨɤ礬롥Τ褦ʾˤϡå
!  *  ¸ǥӥåȥ̿Ȥäbitmap_search
!  *  OMIT_BITMAP_SEARCHޥФ褤ޤӥåȥ̿
!  *  դʤɤͳͥ٤ȥӥåȤȤбѹ
!  *  ϡPRIMAP_BITޥФ褤
   *
!  *  ޤ饤֥ffsʤ顤Τ褦ƥ饤֥ؿ
!  *  ȤäΨɤǽ⤢롥
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
--- 149,170 ----
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ビットマップサーチ関数
   *
!  *  bitmap内の1のビットの内，最も下位（右）のものをサーチし，そのビッ
!  *  ト番号を返す．ビット番号は，最下位ビットを0とする．bitmapに0を指定
!  *  してはならない．この関数では，bitmapが16ビットであることを仮定し，
!  *  uint16_t型としている．
   *
!  *  ビットサーチ命令を持つプロセッサでは，ビットサーチ命令を使うように
!  *  書き直した方が効率が良い場合がある．このような場合には，ターゲット
!  *  依存部でビットサーチ命令を使ったbitmap_searchを定義し，
!  *  OMIT_BITMAP_SEARCHをマクロ定義すればよい．また，ビットサーチ命令の
!  *  サーチ方向が逆などの理由で優先度とビットとの対応を変更したい場合に
!  *  は，PRIMAP_BITをマクロ定義すればよい．
   *
!  *  また，ライブラリにffsがあるなら，次のように定義してライブラリ関数を
!  *  使った方が効率が良い可能性もある．
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
***************
*** 196,202 ****
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline bool_t
  primap_empty(void)
--- 196,202 ----
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  優先度ビットマップが空かのチェック
   */
  Inline bool_t
  primap_empty(void)
***************
*** 209,215 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥ
   */
  Inline uint_t
  primap_search(void)
--- 209,215 ----
  }
  
  /*
!  *  優先度ビットマップのサーチ
   */
  Inline uint_t
  primap_search(void)
***************
*** 225,231 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline void
  primap_set(uint_t pri)
--- 225,231 ----
  }
  
  /*
!  *  優先度ビットマップのセット
   */
  Inline void
  primap_set(uint_t pri)
***************
*** 239,245 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥꥢ
   */
  Inline void
  primap_clear(uint_t pri)
--- 239,245 ----
  }
  
  /*
!  *  優先度ビットマップのクリア
   */
  Inline void
  primap_clear(uint_t pri)
***************
*** 255,261 ****
  }
  
  /*
!  *  ǹ̥ͥΥ
   */
  #ifdef TOPPERS_tsksched
  
--- 255,261 ----
  }
  
  /*
!  *  最高優先順位タスクのサーチ
   */
  #ifdef TOPPERS_tsksched
  
***************
*** 271,281 ****
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡ¹ԤǤ륿ʤä
!  *  ȡp_tcbͥ٤ǹ̤ͥΥͥ٤⤤Ǥ
!  *  롥
   */
  #ifdef TOPPERS_tskrun
  
--- 271,281 ----
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  実行できる状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，実行できるタスクがなかった場合
!  *  と，p_tcbの優先度が最高優先順位のタスクの優先度よりも高い場合であ
!  *  る．
   */
  #ifdef TOPPERS_tskrun
  
***************
*** 297,308 ****
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡp_tcbǹ̤ͥΥ
!  *  äǤ롥p_tcbƱͥ٤Υ¾ˤϡp_tcb
!  *  μΥǹ̤ͥˤʤ롥Ǥʤϡǥ塼
!  *  ɬפ롥
   */
  #ifdef TOPPERS_tsknrun
  
--- 297,308 ----
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，p_tcbが最高優先順位のタスクで
!  *  あった場合である．p_tcbと同じ優先度のタスクが他にある場合は，p_tcb
!  *  の次のタスクが最高優先順位になる．そうでない場合は，レディキューを
!  *  サーチする必要がある．
   */
  #ifdef TOPPERS_tsknrun
  
***************
*** 332,338 ****
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  ٻ߾֤ؤ
   */
  #ifdef TOPPERS_tskdmt
  
--- 332,338 ----
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  休止状態への遷移
   */
  #ifdef TOPPERS_tskdmt
  
***************
*** 350,356 ****
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   */
  #ifdef TOPPERS_tskact
  
--- 350,356 ----
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  休止状態から実行できる状態への遷移
   */
  #ifdef TOPPERS_tskact
  
***************
*** 366,381 ****
  #endif /* TOPPERS_tskact */
  
  /*
!  *  ͥ٤ѹ
   *
!  *  ¹ԤǤ֤ξˤϡǥ塼Ǥΰ֤ѹ
!  *  롥֥ȤԤ塼Ԥ֤ˤʤäƤˤϡ
!  *  塼Ǥΰ֤ѹ롥
   *
!  *  ǹ̤ͥΥ򹹿Τϡ(1) p_tcbǹ̤ͥΥ
!  *  Ǥäơͥ٤򲼤硤(2) p_tcbǹ̤ͥΥ
!  *  ǤϤʤѹͥ٤ǹ̤ͥΥͥ٤⤤
!  *  Ǥ롥(1)ξˤϡǥ塼򥵡ɬפ롥
   */
  #ifdef TOPPERS_tskpri
  
--- 366,381 ----
  #endif /* TOPPERS_tskact */
  
  /*
!  *  タスクの優先度の変更
   *
!  *  タスクが実行できる状態の場合には，レディキューの中での位置を変更す
!  *  る．オブジェクトの待ちキューの中で待ち状態になっている場合には，待
!  *  ちキューの中での位置を変更する．
   *
!  *  最高優先順位のタスクを更新するのは，(1) p_tcbが最高優先順位のタス
!  *  クであって，その優先度を下げた場合，(2) p_tcbが最高優先順位のタス
!  *  クではなく，変更後の優先度が最高優先順位のタスクの優先度よりも高い
!  *  場合である．(1)の場合には，レディキューをサーチする必要がある．
   */
  #ifdef TOPPERS_tskpri
  
***************
*** 389,395 ****
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤ξ
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
--- 389,395 ----
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  タスクが実行できる状態の場合
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
***************
*** 414,421 ****
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  Ʊ֥̿Ȥδ֥åζ
! 			 *  ʬWOBJCBˤԤ塼ˤĤʤƤ
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
--- 414,421 ----
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  タスクが，同期・通信オブジェクトの管理ブロックの共通部
! 			 *  分（WOBJCB）の待ちキューにつながれている場合
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
***************
*** 427,436 ****
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  ǥ塼βž
   *
!  *  ǹ̤ͥΥ򹹿Τϡǹ̤ͥΥ
!  *  塼˰ưǤ롥
   */
  #ifdef TOPPERS_tskrot
  
--- 427,436 ----
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  レディキューの回転
   *
!  *  最高優先順位のタスクを更新するのは，最高優先順位のタスクがタスクキ
!  *  ューの末尾に移動した場合である．
   */
  #ifdef TOPPERS_tskrot
  
***************
*** 454,463 ****
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  㳰롼θƽФ
   *
!  *  ASPͥǤϡ㳰롼CPUå֤ܤ
!  *  ξ֤ᤵ˥꥿󤷤硤ͥ뤬ξ֤᤹
   */
  #ifdef TOPPERS_tsktex
  
--- 454,463 ----
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  ASPカーネルでは，タスク例外処理ルーチン内でCPUロック状態に遷移し，
!  *  元の状態に戻さずにリターンした場合，カーネルが元の状態に戻す．
   */
  #ifdef TOPPERS_tsktex
  
***************
*** 490,499 ****
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  dispatchƤӽФϡߺƵƽФˤʤä
! 			 *  뤬dispatchƤp_runtsk->enatexfalseˤ
! 			 *  лپ㤬ʤͳˤĤƤϡTOPPERS/ASP 
! 			 *  ͥ ߷ץפ򻲾ȤΤȡ
  			 */
  			dispatch();
  		}
--- 490,499 ----
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  ここでdispatchを呼び出す処理は，相互再帰呼出しになって
! 			 *  いるが，dispatchを呼ぶ前にp_runtsk->enatexをfalseにして
! 			 *  おけば支障がない．その理由については，「TOPPERS/ASP カー
! 			 *  ネル 設計メモ」を参照のこと．
  			 */
  			dispatch();
  		}
***************
*** 502,508 ****
  }
  
  /*
!  *  㳰롼εư
   */
  #ifndef OMIT_CALLTEX
  
--- 502,508 ----
  }
  
  /*
!  *  タスク例外処理ルーチンの起動
   */
  #ifndef OMIT_CALLTEX
  
diff -cr --new-file 1.9.1/asp/extension/pri_level/kernel/task.h ASPs/asp/extension/pri_level/kernel/task.h
*** 1.9.1/asp/extension/pri_level/kernel/task.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/pri_level/kernel/task.h	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #ifndef TOPPERS_TASK_H
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #ifndef TOPPERS_TASK_H
***************
*** 51,99 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  ͥ٤ɽɽѴޥ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  ֤ɽ
   *
!  *  TCBΥ֤Ǥϡ¹Ծ֡RUNNINGˤȼ¹Բǽ֡READY
!  *  ϶̤ʤξ֤Τơ¹ԤǤ֡RUNNABLEˤȸƤ֡
!  *  Ԥ֤ϡ(TS_WAITING | TS_SUSPENDED)ɽTS_WAIT_???
!  *  װɽԤ֡Ԥ֤ޤˤξˤΤꤹ롥
!  */
! #define TS_DORMANT		0x00U			/* ٻ߾ */
! #define TS_RUNNABLE		0x01U			/* ¹ԤǤ */
! #define TS_WAITING		0x02U			/* Ԥ */
! #define TS_SUSPENDED	0x04U			/* Ԥ */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* ַвԤ */
! #define TS_WAIT_SLP		(0x01U << 3)	/* Ԥ */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* ǡ塼μԤ */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* ͥ٥ǡ塼μԤ */
! #define TS_WAIT_SEM		(0x04U << 3)	/* ޥե񸻤γԤ */
! #define TS_WAIT_FLG		(0x05U << 3)	/* ٥ȥե饰Ԥ */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* ǡ塼ؤԤ */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* ͥ٥ǡ塼ؤԤ */
! #define TS_WAIT_MBX		(0x08U << 3)	/* ᡼ܥåμԤ */
! #define TS_WAIT_MPF		(0x09U << 3)	/* Ĺ֥åγԤ */
! 
! /*
!  *  Ƚ̥ޥ
!  *
!  *  TSTAT_DORMANTϥٻ߾֤Ǥ뤫ɤTSTAT_RUNNABLE
!  *  ¹ԤǤ֤Ǥ뤫ɤȽ̤롥TSTAT_WAITING
!  *  ֤Ԥ֤Τ줫Ǥ뤫ɤTSTAT_SUSPENDED
!  *  Ԥ֤Ԥ֤Τ줫Ǥ뤫ɤȽ̤롥
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
--- 51,99 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  タスク優先度の内部表現・外部表現変換マクロ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  タスク状態の内部表現
   *
!  *  TCB中のタスク状態では，実行状態（RUNNING）と実行可能状態（READY）
!  *  は区別しない．両状態を総称して，実行できる状態（RUNNABLE）と呼ぶ．
!  *  二重待ち状態は，(TS_WAITING | TS_SUSPENDED)で表す．TS_WAIT_???は待
!  *  ち要因を表し，待ち状態（二重待ち状態を含む）の場合にのみ設定する．
!  */
! #define TS_DORMANT		0x00U			/* 休止状態 */
! #define TS_RUNNABLE		0x01U			/* 実行できる状態 */
! #define TS_WAITING		0x02U			/* 待ち状態 */
! #define TS_SUSPENDED	0x04U			/* 強制待ち状態 */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* 時間経過待ち */
! #define TS_WAIT_SLP		(0x01U << 3)	/* 起床待ち */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* データキューからの受信待ち */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* 優先度データキューからの受信待ち */
! #define TS_WAIT_SEM		(0x04U << 3)	/* セマフォ資源の獲得待ち */
! #define TS_WAIT_FLG		(0x05U << 3)	/* イベントフラグ待ち */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* データキューへの送信待ち */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* 優先度データキューへの送信待ち */
! #define TS_WAIT_MBX		(0x08U << 3)	/* メールボックスからの受信待ち */
! #define TS_WAIT_MPF		(0x09U << 3)	/* 固定長メモリブロックの獲得待ち */
! 
! /*
!  *  タスク状態判別マクロ
!  *
!  *  TSTAT_DORMANTはタスクが休止状態であるかどうかを，TSTAT_RUNNABLEは
!  *  タスクが実行できる状態であるかどうかを判別する．TSTAT_WAITINGは待
!  *  ち状態と二重待ち状態のいずれかであるかどうかを，TSTAT_SUSPENDEDは
!  *  強制待ち状態と二重待ち状態のいずれかであるかどうかを判別する．
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
***************
*** 101,496 ****
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  ԤװȽ̥ޥ
   *
!  *  TSTAT_WAIT_SLPϥԤǤ뤫ɤTSTAT_WAIT_WOBJ
!  *  ϥƱ֥̿ȤФԤǤ뤫ʸȡ
!  *  Ʊ֥̿ȤԤ塼ˤĤʤƤ뤫ˤɤȽ̤
!  *  롥ޤTSTAT_WAIT_WOBJCBϥƱ֥̿Ȥδ
!  *  ֥åζʬWOBJCBˤԤ塼ˤĤʤƤ뤫ɤ
!  *  Ƚ̤롥
!  *
!  *  TSTAT_WAIT_SLPϡǤդΥ֤椫顤ԤǤ
!  *  ȤȽ̤Ǥ롥ʤTSTAT_WAITINGˤԤ֤Ǥ뤳Ȥ
!  *  Ƚ̤ˡTSTAT_SLPѤƵԤ֤Ǥ뤳ȤȽ̤Ǥ롥
!  *  ΨŪ˼¸뤿ˡTS_WAIT_SLPͤ(0x00U << 3)ǤϤ
!  *  (0x01U << 3)ȤƤ롥ΤᡤַвԤ֤Ǥ
!  *  ȤȽ̤뤿TSTAT_WAIT_DLYTSTAT_WAIT_SLPƱͤˡ
!  *  ¸뤳ȤϤǤʤ
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* ԤװμФޥ */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  Ԥ֥åWINFOˤ
   *
!  *  Ԥ֤δ֤ϡTCBӤp_winfoǻؤWINFO򼡤
!  *  褦ꤷʤФʤʤ
   *
!  *  (a) TCBΥ֤Ԥ֡TS_WAITINGˤˤ롥κݤˡԤ
!  *  װTS_WAIT_???ˤꤹ롥
   *
!  *  (b) ॢȤƻ뤹뤿ˡ।٥ȥ֥åϿ롥
!  *  Ͽ륿।٥ȥ֥åϡԤ륵ӥؿ
!  *  ΥѿȤƳݤؤΥݥ󥿤WINFOp_tmevtb˵
!  *  롥ॢȤδƻ뤬ɬפʤʱʵԤξˤˤϡ
!  *  p_tmevtbNULLˤ롥
!  *
!  *  Ʊ֥̿ȤФԤ֤ξˤϡɸWINFO
!  *  p_wobjcbեɤɲä¤ΡWINFO_WOBJwait.hˤ
!  *  ޤʲ(c)(e)Ԥɬפ롥Ʊ֥̿
!  *  Ȥ˴طʤԤʵԤַвԤˤξˤϡ(c)(e)
!  *  ɬפʤ
!  *
!  *  (c) TCBԤоݤƱ֥̿ȤԤ塼ˤĤʤ
!  *  塼ˤĤʤˡtask_queueȤ
!  *
!  *  (d) ԤоݤƱ֥̿Ȥδ֥åؤΥݥ󥿤
!  *  WINFO_WOBJp_wobjcb˵롥
!  *
!  *  (e) ԤоݤƱ֥̿Ȥ˰¸Ƶ뤳Ȥɬפ
!  *  󤬤ˤϡWINFO_WOBJɬפʾΤΥեɤɲ
!  *  ¤ΤWINFO_WOBJѤ롥
!  *
!  *  Ԥ֤ݤˤϡԤФͤWINFO
!  *  wercdꤹ롥wercdɬפʤΤԤʹߤǤΤФơ
!  *  p_tmevtbԤɬפʤᡤΤ˶ΤȤ
!  *  Ƥ롥Τᡤwercdإ顼ɤꤹΤϡ।٥
!  *  ֥åϿˤʤФʤʤ
   */
  typedef union waiting_information {
! 	ER		wercd;			/* ԤΥ顼 */
! 	TMEVTB	*p_tmevtb;		/* ԤѤΥ।٥ȥ֥å */
  } WINFO;
  
  /*
!  *  ֥å
   *
!  *  ˴ؤͤѤʤROM֤ʬʥ
!  *  ֥åˤȡͤѲ뤿RAM֤ʤФʤʤ
!  *  ʬʥ֥åTCBˤʬΥTCBб륿
!  *  ֥åؤݥ󥿤롥֥åб
!  *  TCBؤݥ󥿤ˡRAMδ˾ޤ
!  *  ¹ԸΨʤ뤿˺ѤƤʤ¾Υ֥ȤˤĤ
!  *  ƤƱͤ˰
   *
!  *  ֥åˤϡDEF_TEX륿㳰롼
!  *  ˴ؤޤࡥ
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* ° */
! 	intptr_t	exinf;			/* γĥ */
! 	TASK		task;			/* εư */
! 	uint_t		ipriority;		/* εưͥ١ɽ */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* ƥȥ֥å */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* åΰΥʴݤ᤿͡ */
! 	void		*stk;			/* åΰƬ */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* 㳰롼° */
! 	TEXRTN		texrtn;			/* 㳰롼εư */
  } TINIB;
  
  /*
!  *  TCBΥեɤΥӥå
   *
!  *  ץåˤäƤϡTCBΥեɤΥӥåǥ̤
!  *  ǽȥ졼ɥդˤʤ뤿ᡤåȰ¸˥եɤΥӥå
!  *  ѹ뤳ȤƤ롥
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityեɤΥӥå */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  ֥åTCB
   *
!  *  ASPͥǤϡεư׵ᥭ塼󥰿κ͡TMAX_ACTCNT
!  *  ȵ׵ᥭ塼󥰿κ͡TMAX_WUPCNTˤ1˸ꤵƤ
!  *  ᡤ塼󥰤Ƥ뤫ɤοͤɽ뤳ȤǤ롥
!  *  ޤԤ׵ͥȿκ͡TMAX_SUSCNTˤ1˸ꤵƤ
!  *  ΤǡԤ׵ͥȿsuscntˤɬפʤ
!  *
!  *  TCBΤĤΥեɤϡΥ֤ǤΤͭͤݻ
!  *  ʳξͤݾڤʤʤäơȤƤϤʤʤˡ
!  *  եɤͭͤݻϼ̤ꡥ
!  *
!  *  Ͼͭ
!  *  		p_tinibtstatactque
!  *  ٻ߾ְʳͭʵٻ߾֤ǤϽͤˤʤäƤˡ
!  *  		prioritywupqueenatextexptn
!  *  Ԥ֡Ԥ֤ޤˤͭ
   *  		p_winfo
!  *  ¹ԤǤ֤Ʊ֥̿ȤФԤ֤ͭ
   *  		task_queue
!  *  ¹Բǽ֡Ԥ֡Ԥ֡Ԥ֤ͭ
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* 塼 */
! 	const TINIB		*p_tinib;		/* ֥åؤΥݥ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* ֡ɽ*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* ֡ɽ*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* ߤͥ١ɽ*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* ߤͥ١ɽ*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* ư׵ᥭ塼 */
! 	BIT_FIELD_BOOL	wupque : 1;		/* ׵ᥭ塼 */
! 	BIT_FIELD_BOOL	enatex : 1;		/* 㳰ľ */
! 
! 	TEXPTN			texptn;			/* α㳰װ */
! 	WINFO			*p_winfo;		/* Ԥ֥åؤΥݥ */
! 	TSKCTXB			tskctxb;		/* ƥȥ֥å */
  } TCB;
  
  /*
!  *  ¹Ծ֤Υ
   *
!  *  ¹Ծ֤ΥʡץåƥȤäƤ륿ˤ
!  *  TCBؤݥ󥿡¹Ծ֤ΥʤNULLˤ롥
   *
!  *  ӥνǡʥӥƤӽФ
!  *  ˤ˴ؤ򻲾Ȥp_runtskȤp_runtsk񤭴
!  *  ΤϡǥѥåʤȽˤΤߤǤ롥
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   *
!  *  ¹ԤǤ륿Ǻǹ̤ͥΥTCBؤݥ󥿡
!  *  ԤǤ륿ʤNULLˤ롥
   *
!  *  ǥѥåػ߾֤ʤɡǥѥåαƤ֤p_runtsk
!  *  ȰפƤȤϸ¤ʤ
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   *
!  *  ߥϥɥ顿CPU㳰ϥɥνиˡǥѥåޤ
!  *  㳰롼εư׵᤹뤳Ȥ򼨤ե饰
   */
  extern bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   *
!  *  ͥ٥ޥ֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   *
!  *  ǥѥåػ߾֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   *
!  *  ͥ٥ޥ֤Ǥꡤǥѥåľ֤Ǥʥǥ
!  *  ѥåػ߾֤ǤʤˤȤ򼨤ե饰
   */
  extern bool_t	dspflg;
  
  /*
!  *  ǥ塼
   *
!  *  ǥ塼ϡ¹ԤǤ֤Υ뤿Υ塼Ǥ롥
!  *  ¹Ծ֤ΥƤ뤿ᡤǥʼ¹Բǽ˥塼Ȥ
!  *  ̾ΤΤǤϤʤǥ塼Ȥ̾Τ夷Ƥ뤿ᡤ
!  *  ̾ΤǸƤ֤Ȥˤ롥
   *
!  *  ǥ塼ϡͥ٤ȤΥ塼ǹƤ롥
!  *  TCBϡͥ٤Υ塼Ͽ롥
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   *
!  *  ǥ塼ΥΨ褯Ԥˡͥ٤ȤΥ塼
!  *  ˥äƤ뤫ɤ򼨤ӥåȥޥåפѰդƤ롥ӥ
!  *  ȥޥåפȤȤǡꥢβ򸺤餹ȤǤ뤬
!  *  ӥå̿᤬¤Ƥʤץåǡͥ٤ʳʤ
!  *  ˤϡӥåȥޥåΥСإåɤΤˡդ˸Ψ
!  *  ǽ⤢롥
   *
!  *  ͥ٤ʳˤꡤӥåȥޥåפ1ʳˤ뤫2ʳˤ뤫
!  *  ꤹ롥2ʳ­ʤˤбƤʤ
   */
! #define TBIT_PRIMAP		16				/* ӥåȥޥå1Ĥʳ */
  
  #if TNUM_TPRI <= TBIT_PRIMAP
! #define PRIMAP_LEVEL_1					/* ӥåȥޥåפ1ʳ */
  #elif TNUM_TPRI <= TBIT_PRIMAP * TBIT_PRIMAP
! #define PRIMAP_LEVEL_2					/* ӥåȥޥåפ2ʳ */
  #define TNUM_PRIMAP2	((TNUM_TPRI + TBIT_PRIMAP - 1) / TBIT_PRIMAP)
  #else
  #error too many task priority levels.
  #endif
  
  #ifdef PRIMAP_LEVEL_1
! extern uint16_t	ready_primap;					/* ͥ٥ӥåȥޥå */
  #else /* PRIMAP_LEVEL_1 */
! extern uint16_t	ready_primap1;					/* 1ܤͥ٥ӥåȥޥå */
! extern uint16_t	ready_primap2[TNUM_PRIMAP2];	/* 2ܤͥ٥ӥåȥޥå */
  #endif /* PRIMAP_LEVEL_1 */
  
  /*
!  *  IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  ֥åΥꥢkernel_cfg.c
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  ơ֥kernel_cfg.c
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBΥꥢkernel_cfg.c
   */
  extern TCB	tcb_table[];
  
  /*
!  *  ο
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  IDTCBФΥޥ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCB饿IDФΥޥ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  ⥸塼ν
   */
  extern void	initialize_task(void);
  
  /*
!  *  ǹ̥ͥΥ
   *
!  *  ǥ塼κǹ̤ͥΥ򥵡TCBؤΥݥ
!  *  ֤ǥ塼ξˤϡδؿƤӽФƤϤʤʤ
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥ǥ塼
!  *  ͥ٤ǹ̤ͥΥͥ٤⤤ϡ
!  *  ǹ̤ͥΥ򹹿ǥѥåľ֤Ǥtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥p_tcbǻꤷ
!  *  ǹ̤ͥΥǤäˤϡǹ̤ͥΥ
!  *  ꤷʤǥѥåľ֤Ǥtrue֤Ǥʤ
!  *  false֤ξ֤Ϲʤ
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤Ȥ롥ޤεư
!  *  ˽٤ѿνȡưΤΥƥȤ
!  *  ꤹ롥
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤¹ԤǤ֤Ȥ롥
!  *  ¹ԤǤ֤ܤؤΥǥѥåɬפʾtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  ͥ٤ѹ
   *
!  *  p_tcbǻꤵ륿ͥ٤newpriɽˤѹ롥ޤ
!  *  ɬפʾˤϺǹ̤ͥΥ򹹿ǥѥåľ֤
!  *  true֤Ǥʤfalse֤
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  ǥ塼βž
   *
!  *  ǥ塼Ρpriǻꤵͥ٤Υ塼ž롥
!  *  ޤɬפʾˤϺǹ̤ͥΥѹǥѥå
!  *  αƤʤtrue֤Ǥʤfalse֤
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  㳰롼θƽФ
   *
!  *  㳰롼ƤӽФƤӽФˡ¹Ծ֤Υ
!  *  α㳰װ򥯥ꥢ㳰ػ߾֤ˤCPUå
!  *  롥
!  *
!  *  㳰롼󤫤ȡޤCPUå֤ᤷδ
!  *  α㳰װ0ǤʤʤäƤСƤӥ㳰롼
!  *  ƤӽФα㳰װ0ξˤϡ㳰ľ֤ˤƴؿ
!  *  ꥿󤹤롥
!  *
!  *  δؿϡ¹Ծ֤Υ㳰ľ֡enatex
!  *  trueˤǡα㳰װ0Ǥʤtexptn0Ǥʤ˾˸ƤӽФ
!  *  ȤꤷƤ롥δؿϡCPUå֤ǸƤӽФʤФʤ
!  *  ʤ
   */
  extern void	call_texrtn(void);
  
  /*
!  *  㳰롼εư
   *
!  *  ¹Ծ֤Υ㳰롼εưƤС
!  *  㳰롼ƤӽФCPU㳰롼ƤӽФ
!  *  ϡŪCPUå롥
!  *
!  *  δؿϡǥѥåߥϥɥ顿CPU㳰ϥɥνи
!  *  ƤӽФ뤳ȤꤷƤ롥δؿϡCPUå
!  *  ǸƤӽФʤФʤʤ
   *
!  *  ¹ԸΨ夲뤿ˡδؿ򥿡åȰ¸ǵҤƤ褤
!  *  ξˤϡOMIT_CALLTEXޥ롥
   */
  extern void	calltex(void);
  
--- 101,496 ----
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  タスク待ち要因判別マクロ
   *
!  *  TSTAT_WAIT_SLPはタスクが起床待ちであるかどうかを，TSTAT_WAIT_WOBJ
!  *  はタスクが同期・通信オブジェクトに対する待ちであるか（言い換えると，
!  *  同期通信オブジェクトの待ちキューにつながれているか）どうかを判別す
!  *  る．また，TSTAT_WAIT_WOBJCBはタスクが同期・通信オブジェクトの管理
!  *  ブロックの共通部分（WOBJCB）の待ちキューにつながれているかどうかを
!  *  判別する．
!  *
!  *  TSTAT_WAIT_SLPは，任意のタスク状態の中から，タスクが起床待ちである
!  *  ことを判別できる．すなわち，TSTAT_WAITINGにより待ち状態であることを
!  *  判別せずに，TSTAT_SLPだけを用いて起床待ち状態であることを判別できる．
!  *  これを効率的に実現するために，TS_WAIT_SLPの値を，(0x00U << 3)ではな
!  *  く(0x01U << 3)としている．そのため，タスクが時間経過待ち状態である
!  *  ことを判別するためのTSTAT_WAIT_DLYを，TSTAT_WAIT_SLPと同様の方法で
!  *  実現することはできない．
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* 待ち要因の取出しマスク */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  待ち情報ブロック（WINFO）の定義
   *
!  *  タスクが待ち状態の間は，TCBおよびそのp_winfoで指されるWINFOを次の
!  *  ように設定しなければならない．
   *
!  *  (a) TCBのタスク状態を待ち状態（TS_WAITING）にする．その際に，待ち
!  *  要因（TS_WAIT_???）も設定する．
   *
!  *  (b) タイムアウトを監視するために，タイムイベントブロックを登録する．
!  *  登録するタイムイベントブロックは，待ちに入るサービスコール処理関数
!  *  のローカル変数として確保し，それへのポインタをWINFOのp_tmevtbに記
!  *  憶する．タイムアウトの監視が必要ない場合（永久待ちの場合）には，
!  *  p_tmevtbをNULLにする．
!  *
!  *  同期・通信オブジェクトに対する待ち状態の場合には，標準のWINFOに
!  *  p_wobjcbフィールドを追加した構造体（WINFO_WOBJ，wait.hで定義）を使
!  *  う．また，以下の(c)〜(e)の設定を行う必要がある．同期・通信オブジェ
!  *  クトに関係しない待ち（起床待ち，時間経過待ち）の場合には，(c)〜(e)
!  *  は必要ない．
!  *
!  *  (c) TCBを待ち対象の同期・通信オブジェクトの待ちキューにつなぐ．待
!  *  ちキューにつなぐために，task_queueを使う．
!  *
!  *  (d) 待ち対象の同期・通信オブジェクトの管理ブロックへのポインタを，
!  *  WINFO_WOBJのp_wobjcbに記憶する．
!  *
!  *  (e) 待ち対象の同期・通信オブジェクトに依存して記憶することが必要な
!  *  情報がある場合には，WINFO_WOBJに必要な情報のためのフィールドを追加
!  *  した構造体を定義し，WINFO_WOBJの代わりに用いる．
!  *
!  *  待ち状態を解除する際には，待ち解除したタスクに対する返値をWINFOの
!  *  wercdに設定する．wercdが必要なのは待ち解除以降であるのに対して，
!  *  p_tmevtbは待ち解除後は必要ないため，メモリ節約のために共用体を使っ
!  *  ている．そのため，wercdへエラーコードを設定するのは，タイムイベント
!  *  ブロックを登録解除した後にしなければならない．
   */
  typedef union waiting_information {
! 	ER		wercd;			/* 待ち解除時のエラーコード */
! 	TMEVTB	*p_tmevtb;		/* 待ち状態用のタイムイベントブロック */
  } WINFO;
  
  /*
!  *  タスク初期化ブロック
   *
!  *  タスクに関する情報を，値が変わらないためにROMに置ける部分（タスク
!  *  初期化ブロック）と，値が変化するためにRAMに置かなければならない部
!  *  分（タスク管理ブロック，TCB）に分離し，TCB内に対応するタスク初期化
!  *  ブロックを指すポインタを入れる．タスク初期化ブロック内に対応する
!  *  TCBを指すポインタを入れる方法の方が，RAMの節約の観点からは望ましい
!  *  が，実行効率が悪くなるために採用していない．他のオブジェクトについ
!  *  ても同様に扱う．
   *
!  *  タスク初期化ブロックには，DEF_TEXで定義されるタスク例外処理ルーチ
!  *  ンに関する情報も含む．
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* タスク属性 */
! 	intptr_t	exinf;			/* タスクの拡張情報 */
! 	TASK		task;			/* タスクの起動番地 */
! 	uint_t		ipriority;		/* タスクの起動時優先度（内部表現） */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* タスク初期化コンテキストブロック */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* スタック領域のサイズ（丸めた値） */
! 	void		*stk;			/* スタック領域の先頭番地 */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* タスク例外処理ルーチン属性 */
! 	TEXRTN		texrtn;			/* タスク例外処理ルーチンの起動番地 */
  } TINIB;
  
  /*
!  *  TCB中のフィールドのビット幅の定義
   *
!  *  プロセッサによっては，TCB中のフィールドのビット幅でメモリ使用量と
!  *  性能がトレードオフになるため，ターゲット依存にフィールドのビット幅
!  *  を変更することを許している．
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityフィールドのビット幅 */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  タスク管理ブロック（TCB）
   *
!  *  ASPカーネルでは，タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）
!  *  と起床要求キューイング数の最大値（TMAX_WUPCNT）は1に固定されている
!  *  ため，キューイングされているかどうかの真偽値で表現することができる．
!  *  また，強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が1に固定されてい
!  *  るので，強制待ち要求ネスト数（suscnt）は必要ない．
!  *
!  *  TCBのいくつかのフィールドは，特定のタスク状態でのみ有効な値を保持し，
!  *  それ以外の場合は値が保証されない（よって，参照してはならない）．各
!  *  フィールドが有効な値を保持する条件は次の通り．
!  *
!  *  ・初期化後は常に有効：
!  *  		p_tinib，tstat，actque
!  *  ・休止状態以外で有効（休止状態では初期値になっている）：
!  *  		priority，wupque，enatex，texptn
!  *  ・待ち状態（二重待ち状態を含む）で有効：
   *  		p_winfo
!  *  ・実行できる状態と同期・通信オブジェクトに対する待ち状態で有効：
   *  		task_queue
!  *  ・実行可能状態，待ち状態，強制待ち状態，二重待ち状態で有効：
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* タスクキュー */
! 	const TINIB		*p_tinib;		/* 初期化ブロックへのポインタ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* タスク状態（内部表現）*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* タスク状態（内部表現）*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* 現在の優先度（内部表現）*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* 現在の優先度（内部表現）*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* 起動要求キューイング */
! 	BIT_FIELD_BOOL	wupque : 1;		/* 起床要求キューイング */
! 	BIT_FIELD_BOOL	enatex : 1;		/* タスク例外処理許可状態 */
! 
! 	TEXPTN			texptn;			/* 保留例外要因 */
! 	WINFO			*p_winfo;		/* 待ち情報ブロックへのポインタ */
! 	TSKCTXB			tskctxb;		/* タスクコンテキストブロック */
  } TCB;
  
  /*
!  *  実行状態のタスク
   *
!  *  実行状態のタスク（＝プロセッサがコンテキストを持っているタスク）の
!  *  TCBを指すポインタ．実行状態のタスクがない場合はNULLにする．
   *
!  *  サービスコールの処理中で，自タスク（サービスコールを呼び出したタス
!  *  ク）に関する情報を参照する場合はp_runtskを使う．p_runtskを書き換え
!  *  るのは，ディスパッチャ（と初期化処理）のみである．
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   *
!  *  実行できるタスクの中で最高優先順位のタスクのTCBを指すポインタ．実
!  *  行できるタスクがない場合はNULLにする．
   *
!  *  ディスパッチ禁止状態など，ディスパッチが保留されている間はp_runtsk
!  *  と一致しているとは限らない．
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ディスパッチ／タスク例外処理ルーチン起動要求フラグ
   *
!  *  割込みハンドラ／CPU例外ハンドラの出口処理に，ディスパッチまたは
!  *  タスク例外処理ルーチンの起動を要求することを示すフラグ．
   */
  extern bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   *
!  *  割込み優先度マスク全解除状態であることを示すフラグ．
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   *
!  *  ディスパッチ禁止状態であることを示すフラグ．
   */
  extern bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   *
!  *  割込み優先度マスク全解除状態であり，ディスパッチ許可状態である（ディ
!  *  スパッチ禁止状態でない）ことを示すフラグ．
   */
  extern bool_t	dspflg;
  
  /*
!  *  レディキュー
   *
!  *  レディキューは，実行できる状態のタスクを管理するためのキューである．
!  *  実行状態のタスクも管理しているため，レディ（実行可能）キューという
!  *  名称は正確ではないが，レディキューという名称が定着しているため，こ
!  *  の名称で呼ぶことにする．
   *
!  *  レディキューは，優先度ごとのタスクキューで構成されている．タスクの
!  *  TCBは，該当する優先度のキューに登録される．
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   *
!  *  レディキューのサーチを効率よく行うために，優先度ごとのタスクキュー
!  *  にタスクが入っているかどうかを示すビットマップを用意している．ビッ
!  *  トマップを使うことで，メモリアクセスの回数を減らすことができるが，
!  *  ビット操作命令が充実していないプロセッサで，優先度の段階数が少ない
!  *  場合には，ビットマップ操作のオーバーヘッドのために，逆に効率が落ち
!  *  る可能性もある．
   *
!  *  優先度の段階数により，ビットマップを1段階にするか2段階にするかを決
!  *  定する．2段階で足りない場合には対応していない．
   */
! #define TBIT_PRIMAP		16				/* ビットマップ1つあたりの段階数 */
  
  #if TNUM_TPRI <= TBIT_PRIMAP
! #define PRIMAP_LEVEL_1					/* ビットマップを1段階に */
  #elif TNUM_TPRI <= TBIT_PRIMAP * TBIT_PRIMAP
! #define PRIMAP_LEVEL_2					/* ビットマップを2段階に */
  #define TNUM_PRIMAP2	((TNUM_TPRI + TBIT_PRIMAP - 1) / TBIT_PRIMAP)
  #else
  #error too many task priority levels.
  #endif
  
  #ifdef PRIMAP_LEVEL_1
! extern uint16_t	ready_primap;					/* 優先度ビットマップ */
  #else /* PRIMAP_LEVEL_1 */
! extern uint16_t	ready_primap1;					/* 1段目の優先度ビットマップ */
! extern uint16_t	ready_primap2[TNUM_PRIMAP2];	/* 2段目の優先度ビットマップ */
  #endif /* PRIMAP_LEVEL_1 */
  
  /*
!  *  タスクIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  タスク初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  タスク生成順序テーブル（kernel_cfg.c）
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBのエリア（kernel_cfg.c）
   */
  extern TCB	tcb_table[];
  
  /*
!  *  タスクの数
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  タスクIDからTCBを取り出すためのマクロ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCBからタスクIDを取り出すためのマクロ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  タスク管理モジュールの初期化
   */
  extern void	initialize_task(void);
  
  /*
!  *  最高優先順位タスクのサーチ
   *
!  *  レディキュー中の最高優先順位のタスクをサーチし，そのTCBへのポインタ
!  *  を返す．レディキューが空の場合には，この関数を呼び出してはならない．
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューに挿入する．レディキューに挿入
!  *  したタスクの優先度が，最高優先順位のタスクの優先度よりも高い場合は，
!  *  最高優先順位のタスクを更新し，ディスパッチ許可状態であればtrueを返
!  *  す．そうでない場合はfalseを返す．
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューから削除する．p_tcbで指定した
!  *  タスクが最高優先順位のタスクであった場合には，最高優先順位のタスク
!  *  を設定しなおし，ディスパッチ許可状態であればtrueを返す．そうでない
!  *  場合はfalseを返す．タスクの状態は更新しない．
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  休止状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態とする．また，タスクの起動
!  *  時に初期化すべき変数の初期化と，タスク起動のためのコンテキストを設
!  *  定する．
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  休止状態から実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態から実行できる状態とする．
!  *  実行できる状態に遷移したタスクへのディスパッチが必要な場合はtrue，
!  *  そうでない場合はfalseを返す．
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  タスクの優先度の変更
   *
!  *  p_tcbで指定されるタスクの優先度をnewpri（内部表現）に変更する．また，
!  *  必要な場合には最高優先順位のタスクを更新し，ディスパッチ許可状態で
!  *  あればtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  レディキューの回転
   *
!  *  レディキュー中の，priで指定される優先度のタスクキューを回転させる．
!  *  また，必要な場合には最高優先順位のタスクを変更し，ディスパッチが保
!  *  留されていなければtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  タスク例外処理ルーチンを呼び出す．呼び出す前に，実行状態のタスクの
!  *  保留例外要因をクリアし，タスク例外処理禁止状態にし，CPUロックを解
!  *  除する．
!  *
!  *  タスク例外処理ルーチンから戻ると，まずCPUロック状態に戻し，その間
!  *  に保留例外要因が0でなくなっていれば，再びタスク例外処理ルーチンを
!  *  呼び出す．保留例外要因が0の場合には，例外処理許可状態にして関数か
!  *  らリターンする．
!  *
!  *  この関数は，実行状態のタスクが，タスク例外処理許可状態（enatexが
!  *  true）で，保留例外要因が0でない（texptnが0でない）場合に呼び出すこ
!  *  とを想定している．この関数は，CPUロック状態で呼び出さなければなら
!  *  ない．
   */
  extern void	call_texrtn(void);
  
  /*
!  *  タスク例外処理ルーチンの起動
   *
!  *  実行状態のタスクがタスク例外処理ルーチンの起動条件を満たしていれば，
!  *  タスク例外処理ルーチンを呼び出す．CPU例外処理ルーチンを呼び出す時
!  *  は，一時的にCPUロックを解除する．
!  *
!  *  この関数は，ディスパッチャや割込みハンドラ／CPU例外ハンドラの出口
!  *  処理から呼び出されることを想定している．この関数は，CPUロック状態
!  *  で呼び出さなければならない．
   *
!  *  実行効率を上げるために，この関数をターゲット依存部で記述してもよい．
!  *  その場合には，OMIT_CALLTEXをマクロ定義する．
   */
  extern void	calltex(void);
  
diff -cr --new-file 1.9.1/asp/extension/pri_level/test/test_task1.h ASPs/asp/extension/pri_level/test/test_task1.h
*** 1.9.1/asp/extension/pri_level/test/test_task1.h	Sat Apr 12 10:31:22 2008
--- ASPs/asp/extension/pri_level/test/test_task1.h	Fri Dec  9 13:54:03 2022
***************
*** 5,67 ****
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_task1.h 496 2007-08-20 02:53:40Z hiro $
   */
  
  /* 
!  *		⥸塼Υƥ(1)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	18		/* ͥ */
! #define MID_PRIORITY	137		/* ͥ */
! #define LOW_PRIORITY	255		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_task1.h 496 2007-08-20 02:53:40Z hiro $
   */
  
  /* 
!  *		タスク管理モジュールのテスト(1)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	18		/* 高優先度 */
! #define MID_PRIORITY	137		/* 中優先度 */
! #define LOW_PRIORITY	255		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/rstr_task/include/kernel.h ASPs/asp/extension/rstr_task/include/kernel.h
*** 1.9.1/asp/extension/rstr_task/include/kernel.h	Sun Aug 17 21:42:45 2014
--- ASPs/asp/extension/rstr_task/include/kernel.h	Fri Dec  9 13:54:03 2022
***************
*** 8,57 ****
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥ ɸإåե
   *
!  *  TOPPERS/ASPͥ뤬ݡȤ륵ӥȡɬפʥǡ
!  *  ޥޤإåե롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   *
!  *  Υե򥤥󥯥롼ɤ˥󥯥롼ɤƤ٤ե
!  *  Ϥʤ
   */
  
  #ifndef TOPPERS_KERNEL_H
--- 8,57 ----
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル 標準ヘッダファイル
   *
!  *  TOPPERS/ASPカーネルがサポートするサービスコールの宣言と，必要なデー
!  *  タ型，定数，マクロの定義を含むヘッダファイル．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   *
!  *  このファイルをインクルードする前にインクルードしておくべきファイル
!  *  はない．
   */
  
  #ifndef TOPPERS_KERNEL_H
***************
*** 62,93 ****
  #endif
  
  /*
!  *	TOPPERS̤Υǡޥ
   */
  #include <t_stddef.h>
  
  /*
!  *  åȰ¸
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ǡ
   */
  
  /*
!  *  ӥåȥѥ䥪ֹ֥η
   */
! typedef	uint_t		TEXPTN;		/* 㳰װΥӥåȥѥ */
! typedef	uint_t		FLGPTN;		/* ٥ȥե饰Υӥåȥѥ */
! typedef	uint_t		INTNO;		/* ֹ */
! typedef	uint_t		INHNO;		/* ߥϥɥֹ */
! typedef	uint_t		EXCNO;		/* CPU㳰ϥɥֹ */
  
  /*
!  *  ñ̤η
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
--- 62,93 ----
  #endif
  
  /*
!  *	TOPPERS共通のデータ型・定数・マクロ
   */
  #include <t_stddef.h>
  
  /*
!  *  ターゲット依存部
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  データ型の定義
   */
  
  /*
!  *  ビットパターンやオブジェクト番号の型定義
   */
! typedef	uint_t		TEXPTN;		/* タスク例外要因のビットパターン */
! typedef	uint_t		FLGPTN;		/* イベントフラグのビットパターン */
! typedef	uint_t		INTNO;		/* 割込み番号 */
! typedef	uint_t		INHNO;		/* 割込みハンドラ番号 */
! typedef	uint_t		EXCNO;		/* CPU例外ハンドラ番号 */
  
  /*
!  *  処理単位の型定義
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
***************
*** 100,202 ****
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  ΰݤΤη
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* åΰݤ뤿η */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* Ĺסΰݤ뤿η */
  
  /*
!  *  åإåη
   */
! typedef	struct t_msg {			/* ᡼ܥåΥåإå */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* ͥդåإå */
! 	T_MSG	msgque;				/* åإå */
! 	PRI		msgpri;				/* åͥ */
  } T_MSG_PRI;
  
  /*
!  *  ѥåȷ
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/*  */
! 	PRI		tskpri;		/* θͥ */
! 	PRI		tskbpri;	/* Υ١ͥ */
! 	STAT	tskwait;	/* Ԥװ */
! 	ID		wobjid;		/* ԤоݤΥ֥ȤID */
! 	TMO		lefttmo;	/* ॢȤޤǤλ */
! 	uint_t	actcnt;		/* ư׵ᥭ塼󥰿 */
! 	uint_t	wupcnt;		/* ׵ᥭ塼󥰿 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* 㳰ξ */
! 	TEXPTN	pndptn;		/* α㳰װ */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* ޥեԤƬΥIDֹ */
! 	uint_t	semcnt;		/* ޥեθߤλ񸻿 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* ٥ȥե饰ԤƬΥIDֹ */
! 	FLGPTN	flgptn;		/* ٥ȥե饰θߤΥӥåȥѥ */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* ǡ塼ԤƬΥIDֹ */
! 	ID		rtskid;		/* ǡ塼μԤƬΥIDֹ */
! 	uint_t	sdtqcnt;	/* ǡ塼ΰ˳ǼƤǡο */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* ͥ٥ǡ塼ԤƬΥ
! 						   IDֹ */
! 	ID		rtskid;		/* ͥ٥ǡ塼μԤƬΥ
! 						   IDֹ */
! 	uint_t	spdqcnt;	/* ͥ٥ǡ塼ΰ˳ǼƤǡ
! 						   ο */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* ᡼ܥåԤƬΥIDֹ */
! 	T_MSG	*pk_msg;	/* å塼ƬˤĤʤ줿å
! 						   Ƭ */
  } T_RMBX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* ĹסԤƬΥ
! 						   IDֹ */
! 	uint_t	fblkcnt;	/* Ĺסΰζΰ˳
! 						   դ뤳ȤǤĹ֥åο */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* ϥɥư */
! 	RELTIM	lefttim;	/* ˼ϥɥưޤǤл */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* 顼ϥɥư */
! 	RELTIM	lefttim;	/* 顼ϥɥưޤǤл */
  } T_RALM;
  
  /*
!  *  ӥ
   */
  
  /*
!  *  ǽ
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
--- 100,202 ----
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  メモリ領域確保のための型定義
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* スタック領域を確保するための型 */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* 固定長メモリプール領域を確保するための型 */
  
  /*
!  *  メッセージヘッダの型定義
   */
! typedef	struct t_msg {			/* メールボックスのメッセージヘッダ */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* 優先度付きメッセージヘッダ */
! 	T_MSG	msgque;				/* メッセージヘッダ */
! 	PRI		msgpri;				/* メッセージ優先度 */
  } T_MSG_PRI;
  
  /*
!  *  パケット形式の定義
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/* タスク状態 */
! 	PRI		tskpri;		/* タスクの現在優先度 */
! 	PRI		tskbpri;	/* タスクのベース優先度 */
! 	STAT	tskwait;	/* 待ち要因 */
! 	ID		wobjid;		/* 待ち対象のオブジェクトのID */
! 	TMO		lefttmo;	/* タイムアウトするまでの時間 */
! 	uint_t	actcnt;		/* 起動要求キューイング数 */
! 	uint_t	wupcnt;		/* 起床要求キューイング数 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* タスク例外処理の状態 */
! 	TEXPTN	pndptn;		/* 保留例外要因 */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* セマフォの待ち行列の先頭のタスクのID番号 */
! 	uint_t	semcnt;		/* セマフォの現在の資源数 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* イベントフラグの待ち行列の先頭のタスクのID番号 */
! 	FLGPTN	flgptn;		/* イベントフラグの現在のビットパターン */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* データキューの送信待ち行列の先頭のタスクのID番号 */
! 	ID		rtskid;		/* データキューの受信待ち行列の先頭のタスクのID番号 */
! 	uint_t	sdtqcnt;	/* データキュー管理領域に格納されているデータの数 */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* 優先度データキューの送信待ち行列の先頭のタスク
! 						   のID番号 */
! 	ID		rtskid;		/* 優先度データキューの受信待ち行列の先頭のタスク
! 						   のID番号 */
! 	uint_t	spdqcnt;	/* 優先度データキュー管理領域に格納されているデー
! 						   タの数 */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* メールボックスの待ち行列の先頭のタスクのID番号 */
! 	T_MSG	*pk_msg;	/* メッセージキューの先頭につながれたメッセージ
! 						   の先頭番地 */
  } T_RMBX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* 固定長メモリプールの待ち行列の先頭のタスクの
! 						   ID番号 */
! 	uint_t	fblkcnt;	/* 固定長メモリプール領域の空きメモリ領域に割り
! 						   付けることができる固定長メモリブロックの数 */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* 周期ハンドラの動作状態 */
! 	RELTIM	lefttim;	/* 次に周期ハンドラを起動する時刻までの相対時間 */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* アラームハンドラの動作状態 */
! 	RELTIM	lefttim;	/* アラームハンドラを起動する時刻までの相対時間 */
  } T_RALM;
  
  /*
!  *  サービスコールの宣言
   */
  
  /*
!  *  タスク管理機能
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
***************
*** 210,216 ****
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  °Ʊǽ
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
--- 210,216 ----
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  タスク付属同期機能
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
***************
*** 224,230 ****
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  㳰ǽ
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
--- 224,230 ----
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  タスク例外処理機能
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
***************
*** 234,240 ****
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  Ʊ̿ǽ
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
--- 234,240 ----
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  同期・通信機能
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
***************
*** 288,294 ****
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  סǽ
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
--- 288,294 ----
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  メモリプール管理機能
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
***************
*** 298,304 ****
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  ִǽ
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
--- 298,304 ----
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  時間管理機能
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
***************
*** 314,320 ****
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  ƥִǽ
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
--- 314,320 ----
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  システム状態管理機能
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
***************
*** 334,340 ****
  extern ER		ext_ker(void) throw();
  
  /*
!  *  ߴǽ
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
--- 334,340 ----
  extern ER		ext_ker(void) throw();
  
  /*
!  *  割込み管理機能
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
***************
*** 342,348 ****
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU㳰ǽ
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
--- 342,348 ----
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU例外管理機能
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
***************
*** 350,483 ****
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ֥°
   */
! #define TA_ACT			UINT_C(0x02)	/* ư줿֤ */
! #define TA_RSTR			UINT_C(0x04)	/* 󥿥 */
  
! #define TA_TPRI			UINT_C(0x01)	/* Ԥͥٽ */
! #define TA_MPRI			UINT_C(0x02)	/* å塼ͥٽ */
  
! #define TA_WMUL			UINT_C(0x02)	/* ʣԤ */
! #define TA_CLR			UINT_C(0x04)	/* ٥ȥե饰Υꥢ */
  
! #define TA_STA			UINT_C(0x02)	/* ϥɥư֤ */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* ͥγ */
  
! #define TA_ENAINT		UINT_C(0x01)	/* ׵ػߥե饰򥯥ꥢ */
! #define TA_EDGE			UINT_C(0x02)	/* åȥꥬ */
  
  /*
!  *  ӥư⡼ɤ
   */
! #define TWF_ORW			UINT_C(0x01)	/* ٥ȥե饰ORԤ */
! #define TWF_ANDW		UINT_C(0x02)	/* ٥ȥե饰ANDԤ */
  
  /*
!  *  ֥Ȥξ֤
   */
! #define TTS_RUN			UINT_C(0x01)	/* ¹Ծ */
! #define TTS_RDY			UINT_C(0x02)	/* ¹Բǽ */
! #define TTS_WAI			UINT_C(0x04)	/* Ԥ */
! #define TTS_SUS			UINT_C(0x08)	/* Ԥ */
! #define TTS_WAS			UINT_C(0x0c)	/* Ԥ */
! #define TTS_DMT			UINT_C(0x10)	/* ٻ߾ */
  
! #define TTW_SLP			UINT_C(0x0001)	/* Ԥ */
! #define TTW_DLY			UINT_C(0x0002)	/* ַвԤ */
! #define TTW_SEM			UINT_C(0x0004)	/* ޥեλ񸻳Ԥ */
! #define TTW_FLG			UINT_C(0x0008)	/* ٥ȥե饰Ԥ */
! #define TTW_SDTQ		UINT_C(0x0010)	/* ǡ塼ؤԤ */
! #define TTW_RDTQ		UINT_C(0x0020)	/* ǡ塼μԤ */
! #define TTW_SPDQ		UINT_C(0x0100)	/* ͥ٥ǡ塼ؤԤ */
! #define TTW_RPDQ		UINT_C(0x0200)	/* ͥ٥ǡ塼μԤ */
! #define TTW_MBX			UINT_C(0x0040)	/* ᡼ܥåμԤ */
! #define TTW_MPF			UINT_C(0x2000)	/* Ĺ֥åγԤ */
  
! #define TTEX_ENA		UINT_C(0x01)	/* 㳰ľ */
! #define TTEX_DIS		UINT_C(0x02)	/* 㳰ػ߾ */
  
! #define TCYC_STP		UINT_C(0x01)	/* ϥɥ餬ưƤʤ */
! #define TCYC_STA		UINT_C(0x02)	/* ϥɥ餬ưƤ */
  
! #define TALM_STP		UINT_C(0x01)	/* 顼ϥɥ餬ưƤʤ */
! #define TALM_STA		UINT_C(0x02)	/* 顼ϥɥ餬ưƤ */
  
  /*
!  *  ¾
   */
! #define TSK_SELF		0			/*  */
! #define TSK_NONE		0			/* 륿ʤ */
  
! #define TPRI_SELF		0			/* Υ١ͥ */
! #define TPRI_INI		0			/* εưͥ */
  
! #define TIPM_ENAALL		0			/* ͥ٥ޥ */
  
  /*
!  *  ȥޥ
   */
  
  /*
!  *  ݡȤ뵡ǽ
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_RSTR_TASK		/* 󥿥ǽĥ */
  
  /*
!  *  ͥ٤ϰ
   */
! #define TMIN_TPRI		1			/* ͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_TPRI		16			/* ͥ٤κ͡ʺ͡*/
! #define TMIN_DPRI		1			/* ǡͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_DPRI		16			/* ǡͥ٤κ͡ʺ͡*/
! #define TMIN_MPRI		1			/* åͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_MPRI		16			/* åͥ٤κ͡ʺ͡*/
! #define TMIN_ISRPRI		1			/* ߥӥ롼ͥ٤κǾ */
! #define TMAX_ISRPRI		16			/* ߥӥ롼ͥ٤κ */
  
  /*
!  *  С
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* ͥΥ᡼ */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* ͥμֹ */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* ͥͤΥСֹ */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* ͥΥСֹ */
  
  /*
!  *  塼󥰲κ
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* ư׵ᥭ塼󥰿κ */
! #define TMAX_WUPCNT		UINT_C(1)		/* ׵ᥭ塼󥰿κ */
  
  /*
!  *  ӥåȥѥΥӥåȿ
   */
! #ifndef TBIT_TEXPTN					/* 㳰װΥӥåȿ */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* ٥ȥե饰Υӥåȿ */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  ΰݤΤΥޥ
   *
!  *  ʲTOPPERS_COUNT_SZTOPPERS_ROUND_SZϡunit2ζҾǤ
!  *  뤳ȤꤷƤ롥
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
--- 350,483 ----
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  オブジェクト属性の定義
   */
! #define TA_ACT			UINT_C(0x02)	/* タスクを起動された状態で生成 */
! #define TA_RSTR			UINT_C(0x04)	/* 制約タスク */
  
! #define TA_TPRI			UINT_C(0x01)	/* タスクの待ち行列を優先度順に */
! #define TA_MPRI			UINT_C(0x02)	/* メッセージキューを優先度順に */
  
! #define TA_WMUL			UINT_C(0x02)	/* 複数の待ちタスク */
! #define TA_CLR			UINT_C(0x04)	/* イベントフラグのクリア指定 */
  
! #define TA_STA			UINT_C(0x02)	/* 周期ハンドラを動作状態で生成 */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* カーネル管理外の割込み */
  
! #define TA_ENAINT		UINT_C(0x01)	/* 割込み要求禁止フラグをクリア */
! #define TA_EDGE			UINT_C(0x02)	/* エッジトリガ */
  
  /*
!  *  サービスコールの動作モードの定義
   */
! #define TWF_ORW			UINT_C(0x01)	/* イベントフラグのOR待ち */
! #define TWF_ANDW		UINT_C(0x02)	/* イベントフラグのAND待ち */
  
  /*
!  *  オブジェクトの状態の定義
   */
! #define TTS_RUN			UINT_C(0x01)	/* 実行状態 */
! #define TTS_RDY			UINT_C(0x02)	/* 実行可能状態 */
! #define TTS_WAI			UINT_C(0x04)	/* 待ち状態 */
! #define TTS_SUS			UINT_C(0x08)	/* 強制待ち状態 */
! #define TTS_WAS			UINT_C(0x0c)	/* 二重待ち状態 */
! #define TTS_DMT			UINT_C(0x10)	/* 休止状態 */
  
! #define TTW_SLP			UINT_C(0x0001)	/* 起床待ち */
! #define TTW_DLY			UINT_C(0x0002)	/* 時間経過待ち */
! #define TTW_SEM			UINT_C(0x0004)	/* セマフォの資源獲得待ち */
! #define TTW_FLG			UINT_C(0x0008)	/* イベントフラグ待ち */
! #define TTW_SDTQ		UINT_C(0x0010)	/* データキューへの送信待ち */
! #define TTW_RDTQ		UINT_C(0x0020)	/* データキューからの受信待ち */
! #define TTW_SPDQ		UINT_C(0x0100)	/* 優先度データキューへの送信待ち */
! #define TTW_RPDQ		UINT_C(0x0200)	/* 優先度データキューからの受信待ち */
! #define TTW_MBX			UINT_C(0x0040)	/* メールボックスからの受信待ち */
! #define TTW_MPF			UINT_C(0x2000)	/* 固定長メモリブロックの獲得待ち */
  
! #define TTEX_ENA		UINT_C(0x01)	/* タスク例外処理許可状態 */
! #define TTEX_DIS		UINT_C(0x02)	/* タスク例外処理禁止状態 */
  
! #define TCYC_STP		UINT_C(0x01)	/* 周期ハンドラが動作していない */
! #define TCYC_STA		UINT_C(0x02)	/* 周期ハンドラが動作している */
  
! #define TALM_STP		UINT_C(0x01)	/* アラームハンドラが動作していない */
! #define TALM_STA		UINT_C(0x02)	/* アラームハンドラが動作している */
  
  /*
!  *  その他の定数の定義
   */
! #define TSK_SELF		0			/* 自タスク指定 */
! #define TSK_NONE		0			/* 該当するタスクがない */
  
! #define TPRI_SELF		0			/* 自タスクのベース優先度 */
! #define TPRI_INI		0			/* タスクの起動時優先度 */
  
! #define TIPM_ENAALL		0			/* 割込み優先度マスク全解除 */
  
  /*
!  *  構成定数とマクロ
   */
  
  /*
!  *  サポートする機能
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
! #define TOPPERS_SUPPORT_RSTR_TASK		/* 制約タスク機能拡張 */
  
  /*
!  *  優先度の範囲
   */
! #define TMIN_TPRI		1			/* タスク優先度の最小値（最高値）*/
! #define TMAX_TPRI		16			/* タスク優先度の最大値（最低値）*/
! #define TMIN_DPRI		1			/* データ優先度の最小値（最高値）*/
! #define TMAX_DPRI		16			/* データ優先度の最大値（最低値）*/
! #define TMIN_MPRI		1			/* メッセージ優先度の最小値（最高値）*/
! #define TMAX_MPRI		16			/* メッセージ優先度の最大値（最低値）*/
! #define TMIN_ISRPRI		1			/* 割込みサービスルーチン優先度の最小値 */
! #define TMAX_ISRPRI		16			/* 割込みサービスルーチン優先度の最大値 */
  
  /*
!  *  バージョン情報
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* カーネルのメーカーコード */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* カーネルの識別番号 */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* カーネル仕様のバージョン番号 */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* カーネルのバージョン番号 */
  
  /*
!  *  キューイング回数の最大値
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* 起動要求キューイング数の最大値 */
! #define TMAX_WUPCNT		UINT_C(1)		/* 起床要求キューイング数の最大値 */
  
  /*
!  *  ビットパターンのビット数
   */
! #ifndef TBIT_TEXPTN					/* タスク例外要因のビット数 */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* イベントフラグのビット数 */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  メモリ領域確保のためのマクロ
   *
!  *  以下のTOPPERS_COUNT_SZとTOPPERS_ROUND_SZの定義は，unitが2の巾乗であ
!  *  ることを仮定している．
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
***************
*** 493,501 ****
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  ¾ι
   */
! #define TMAX_MAXSEM		UINT_MAX	/* ޥեκ񸻿κ */
  
  #ifdef __cplusplus
  }
--- 493,501 ----
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  その他の構成定数
   */
! #define TMAX_MAXSEM		UINT_MAX	/* セマフォの最大資源数の最大値 */
  
  #ifdef __cplusplus
  }
diff -cr --new-file 1.9.1/asp/extension/rstr_task/kernel/Makefile.kernel ASPs/asp/extension/rstr_task/kernel/Makefile.kernel
*** 1.9.1/asp/extension/rstr_task/kernel/Makefile.kernel	Fri Aug  6 15:15:19 2010
--- ASPs/asp/extension/rstr_task/kernel/Makefile.kernel	Fri Dec  9 13:54:03 2022
***************
*** 8,52 ****
  #  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! #  ܥեȥѤΤޤࡥʲƱˤѡʣ
! #  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! #  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! #      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! #      ˴ޤޤƤ뤳ȡ
! #  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! #      ѤǤǺۤˤϡۤȼɥȡ
! #      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! #      ̵ݾڵǺܤ뤳ȡ
! #  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! #      ѤǤʤǺۤˤϡΤ줫ξ
! #      ȡ
! #    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! #        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! #    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! #        𤹤뤳ȡ
! #  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! #      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! #      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! #      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! #      դ뤳ȡ
  # 
! #  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! #  TOPPERSץȤϡܥեȥ˴ؤơλŪ
! #  ФŬޤơʤݾڤԤʤޤܥեȥ
! #  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! #  Ǥʤ
  # 
  #  $Id: Makefile.kernel 1887 2010-08-06 06:15:19Z ertl-hiro $
  # 
  
  #
! #		ͥΥե빽
  #
  
  #
! #  1ĤΥե뤫ʣΥ֥ȥե褦˺
! #  줿եΥꥹ
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
--- 8,52 ----
  #  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! #  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! #  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! #  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! #      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! #      スコード中に含まれていること．
! #  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! #      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! #      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! #      の無保証規定を掲載すること．
! #  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! #      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! #      と．
! #    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! #        作権表示，この利用条件および下記の無保証規定を掲載すること．
! #    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! #        報告すること．
! #  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! #      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! #      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! #      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! #      免責すること．
  # 
! #  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! #  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! #  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! #  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! #  の責任を負わない．
  # 
  #  $Id: Makefile.kernel 1887 2010-08-06 06:15:19Z ertl-hiro $
  # 
  
  #
! #		カーネルのファイル構成の定義
  #
  
  #
! #  1つのソースファイルから複数のオブジェクトファイルを生成するように作
! #  成されたソースファイルのリスト
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
***************
*** 55,61 ****
  				sys_manage.c interrupt.c exception.c
  
  #
! #  ƥե뤫륪֥ȥեΥꥹ
  #
  startup = sta_ker.o ext_ker.o
  
--- 55,61 ----
  				sys_manage.c interrupt.c exception.c
  
  #
! #  各ソースファイルから生成されるオブジェクトファイルのリスト
  #
  startup = sta_ker.o ext_ker.o
  
***************
*** 112,118 ****
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  륪֥ȥեΰ¸ط
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
--- 112,118 ----
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  生成されるオブジェクトファイルの依存関係の定義
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
diff -cr --new-file 1.9.1/asp/extension/rstr_task/kernel/allfunc.h ASPs/asp/extension/rstr_task/kernel/allfunc.h
*** 1.9.1/asp/extension/rstr_task/kernel/allfunc.h	Fri Aug  6 15:15:19 2010
--- ASPs/asp/extension/rstr_task/kernel/allfunc.h	Fri Dec  9 13:54:03 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: allfunc.h 1887 2010-08-06 06:15:19Z ertl-hiro $
   */
  
  /*
!  *		٤Ƥδؿ򥳥ѥ뤹뤿
   */
  
  #ifndef TOPPERS_ALLFUNC_H
--- 6,45 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: allfunc.h 1887 2010-08-06 06:15:19Z ertl-hiro $
   */
  
  /*
!  *		すべての関数をコンパイルするための定義
   */
  
  #ifndef TOPPERS_ALLFUNC_H
diff -cr --new-file 1.9.1/asp/extension/rstr_task/kernel/check.h ASPs/asp/extension/rstr_task/kernel/check.h
*** 1.9.1/asp/extension/rstr_task/kernel/check.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/rstr_task/kernel/check.h	Fri Dec  9 13:54:03 2022
***************
*** 8,54 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: check.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		顼åѥޥ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  ͥ٤ϰϤȽ
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
--- 8,54 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: check.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		エラーチェック用マクロ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  優先度の範囲の判定
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
***************
*** 58,64 ****
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
--- 58,64 ----
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  タスク優先度のチェック（E_PAR）
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
***************
*** 82,88 ****
  } while (false)
  
  /*
!  *  ॢȻͤΥåE_PAR
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
--- 82,88 ----
  } while (false)
  
  /*
!  *  タイムアウト指定値のチェック（E_PAR）
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
***************
*** 92,98 ****
  } while (false)
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
--- 92,98 ----
  } while (false)
  
  /*
!  *  割込み優先度のチェック（E_PAR）
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
***************
*** 102,108 ****
  } while (false)
  
  /*
!  *  ֹΥåE_PAR
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
--- 102,108 ----
  } while (false)
  
  /*
!  *  割込み番号のチェック（E_PAR）
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
***************
*** 112,118 ****
  } while (false)
  
  /*
!  *  ¾Υѥ᡼顼ΥåE_PAR
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
--- 112,118 ----
  } while (false)
  
  /*
!  *  その他のパラメータエラーのチェック（E_PAR）
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
***************
*** 122,128 ****
  } while (false)
  
  /*
!  *  ֥IDϰϤȽ
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
--- 122,128 ----
  } while (false)
  
  /*
!  *  オブジェクトIDの範囲の判定
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
***************
*** 135,141 ****
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  ֥IDΥåE_ID
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
--- 135,141 ----
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  オブジェクトIDのチェック（E_ID）
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
***************
*** 208,214 ****
  } while (false)
  
  /*
!  *  ƽФƥȤΥåE_CTX
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
--- 208,214 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストのチェック（E_CTX）
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
***************
*** 225,231 ****
  } while (false)
  
  /*
!  *  ƽФƥȤCPUå֤ΥåE_CTX
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
--- 225,231 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストとCPUロック状態のチェック（E_CTX）
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
***************
*** 242,249 ****
  } while (false)
  
  /*
!  *  ǥѥåα֤ǤʤΥåE_CTX
!  *  󥿥ǤʤΥåE_NOSPT
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
--- 242,249 ----
  } while (false)
  
  /*
!  *  ディスパッチ保留状態でないかのチェック（E_CTX）
!  *  自タスクが制約タスクでないかのチェック（E_NOSPT）
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
***************
*** 257,263 ****
  } while (false)
  
  /*
!  *  оݥ󥿥ǤʤΥåE_NOSPT
   */
  #define CHECK_NONRSTR(p_tcb) do {							\
  	if (((p_tcb)->p_tinib->tskatr & TA_RSTR) != 0U) {		\
--- 257,263 ----
  } while (false)
  
  /*
!  *  対象タスクが制約タスクでないかのチェック（E_NOSPT）
   */
  #define CHECK_NONRSTR(p_tcb) do {							\
  	if (((p_tcb)->p_tinib->tskatr & TA_RSTR) != 0U) {		\
***************
*** 267,273 ****
  } while (false)
  
  /*
!  *  ¾Υƥȥ顼ΥåE_CTX
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
--- 267,273 ----
  } while (false)
  
  /*
!  *  その他のコンテキストエラーのチェック（E_CTX）
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
***************
*** 277,283 ****
  } while (false)
  
  /*
!  *  ꤷƤʤΥåE_ILUSE
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
--- 277,283 ----
  } while (false)
  
  /*
!  *  自タスクを指定していないかのチェック（E_ILUSE）
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
***************
*** 287,293 ****
  } while (false)
  
  /*
!  *  ¾ѥ顼ΥåE_ILUSE
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
--- 287,293 ----
  } while (false)
  
  /*
!  *  その他の不正使用エラーのチェック（E_ILUSE）
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
diff -cr --new-file 1.9.1/asp/extension/rstr_task/kernel/kernel.tf ASPs/asp/extension/rstr_task/kernel/kernel.tf
*** 1.9.1/asp/extension/rstr_task/kernel/kernel.tf	Sun May  4 22:18:02 2014
--- ASPs/asp/extension/rstr_task/kernel/kernel.tf	Fri Dec  9 13:54:03 2022
***************
*** 8,48 ****
  $   Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   $Id: kernel.tf 2595 2014-01-02 12:00:09Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.h
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
--- 8,48 ----
  $   Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   $Id: kernel.tf 2595 2014-01-02 12:00:09Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.hの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
***************
*** 91,97 ****
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.c
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
--- 91,97 ----
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.cの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
***************
*** 105,111 ****
  $NL$
  
  $ 
! $  󥯥롼ɥǥ쥯ƥ֡#include
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
--- 105,111 ----
  $NL$
  
  $ 
! $  インクルードディレクティブ（#include）
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
***************
*** 115,121 ****
  $NL$
  
  $ 
! $  ֥ȤIDֹݻѿ
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
--- 115,121 ----
  $NL$
  
  $ 
! $  オブジェクトのID番号を保持する変数
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
***************
*** 152,158 ****
  $END$
  
  $ 
! $  ȥ졼ޥΥǥե
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
--- 152,158 ----
  $END$
  
  $ 
! $  トレースログマクロのデフォルト定義
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
***************
*** 168,224 ****
  $NL$
  
  $ 
! $  
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 1İʾ¸ߤ뤳ȤΥå
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ IDֹκ
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ 顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrʡTA_ACT|TA_RSTRϡˤǤʤE_RSATR
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TA_RSTR|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)ǤʤE_PAR
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrTA_NULLˤǤʤE_RSATR
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ åΰ˴ؤ륨顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// stksz0ʲåκǾ͡TARGET_MIN_STKSZˤ
! $	// E_PAR
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszåΰΥȤʤE_PAR
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  $END$
  
! $ åΰ
  $FOREACH tskid TSK.ID_LIST$
  	$IF EQ(TSK.STK[tskid], "NULL")$
  		$IF (TSK.TSKATR[tskid] & TA_RSTR) == 0$
--- 168,224 ----
  $NL$
  
  $ 
! $  タスク
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ タスクが1個以上存在することのチェック
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ タスクID番号の最大値
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ エラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrが（［TA_ACT|TA_RSTR］）でない場合（E_RSATR）
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TA_RSTR|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)でない場合（E_PAR）
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrが（TA_NULL）でない場合（E_RSATR）
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ スタック領域に関するエラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// stkszが0以下か，ターゲット定義の最小値（TARGET_MIN_STKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  $END$
  
! $ スタック領域の生成
  $FOREACH tskid TSK.ID_LIST$
  	$IF EQ(TSK.STK[tskid], "NULL")$
  		$IF (TSK.TSKATR[tskid] & TA_RSTR) == 0$
***************
*** 228,234 ****
  		$ELSE$
  			$TSK.TINIB_STKSZ[tskid] = FORMAT("ROUND_STK_T(%1%)", TSK.STKSZ[tskid])$
  			$TSK.TINIB_STK[tskid] = CONCAT("_kernel_shared_stack_", +TSK.ITSKPRI[tskid])$
! $ 			// 󥿥ѤζͭåΥ
  			$IF !LENGTH(shared_stack_size[TSK.ITSKPRI[tskid]])
  					|| shared_stack_size[TSK.ITSKPRI[tskid]] < TSK.STKSZ[tskid]$
  				$shared_stack_size[TSK.ITSKPRI[tskid]] = TSK.STKSZ[tskid]$
--- 228,234 ----
  		$ELSE$
  			$TSK.TINIB_STKSZ[tskid] = FORMAT("ROUND_STK_T(%1%)", TSK.STKSZ[tskid])$
  			$TSK.TINIB_STK[tskid] = CONCAT("_kernel_shared_stack_", +TSK.ITSKPRI[tskid])$
! $ 			// 制約タスク用の共有スタックのサイズを求める
  			$IF !LENGTH(shared_stack_size[TSK.ITSKPRI[tskid]])
  					|| shared_stack_size[TSK.ITSKPRI[tskid]] < TSK.STKSZ[tskid]$
  				$shared_stack_size[TSK.ITSKPRI[tskid]] = TSK.STKSZ[tskid]$
***************
*** 246,320 ****
  $END$
  $NL$
  
! $ ֥åʥ1İʾ¸ߤ
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// °ĥ󡤵ưϡưͥ
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// ƥȥ֥ååΰ
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// 㳰롼°ȵư
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ ֥å
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ ơ֥
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  ޥե
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ޥեIDֹκ
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ ޥե֥å
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)ǤʤE_PAR
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)ǤʤE_PAR
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// ޥե֥å
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ޥե֥å
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
--- 246,320 ----
  $END$
  $NL$
  
! $ タスク初期化ブロックの生成（タスクは1個以上存在する）
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// タスク属性，拡張情報，起動番地，起動時優先度
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// タスク初期化コンテキストブロック，スタック領域
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// タスク例外処理ルーチンの属性と起動番地
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ タスク管理ブロックの生成
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ タスク生成順序テーブルの生成
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  セマフォ
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ セマフォID番号の最大値
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ セマフォ初期化ブロックの生成
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)でない場合（E_PAR）
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)でない場合（E_PAR）
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// セマフォ初期化ブロック
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// セマフォ管理ブロック
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
***************
*** 322,359 ****
  $END$$NL$
  
  $ 
! $  ٥ȥե饰
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ٥ȥե饰IDֹκ
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ ٥ȥե饰֥å
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrʡTA_TPRIϡáTA_WMULϡáTA_CLRϡˤǤʤE_RSATR
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnFLGPTN˳ǼǤʤE_PAR
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// ٥ȥե饰֥å
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ٥ȥե饰֥å
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
--- 322,359 ----
  $END$$NL$
  
  $ 
! $  イベントフラグ
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ イベントフラグID番号の最大値
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ イベントフラグ初期化ブロックの生成
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrが（［TA_TPRI］｜［TA_WMUL］｜［TA_CLR］）でない場合（E_RSATR）
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnがFLGPTNに格納できない場合（E_PAR）
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// イベントフラグ初期化ブロック
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// イベントフラグ管理ブロック
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
***************
*** 361,401 ****
  $END$$NL$
  
  $ 
! $  ǡ塼
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ǡ塼IDֹκ
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntξE_PAR
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbNULLǤʤE_NOSPT
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// ǡ塼ΰ
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// ǡ塼֥å
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
--- 361,401 ----
  $END$$NL$
  
  $ 
! $  データキュー
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ データキューID番号の最大値
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntが負の場合（E_PAR）
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// データキュー管理領域
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// データキュー初期化ブロックの生成
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
***************
*** 403,409 ****
  	};$NL$
  	$NL$
  
! $	// ǡ塼֥å
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
--- 403,409 ----
  	};$NL$
  	$NL$
  
! $	// データキュー管理ブロック
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
***************
*** 411,456 ****
  $END$$NL$
  
  $ 
! $  ͥ٥ǡ塼
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ͥ٥ǡ塼IDֹκ
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntξE_PAR
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)ǤʤE_PAR
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbNULLǤʤE_NOSPT
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// ͥ٥ǡ塼ΰ
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// ͥ٥ǡ塼֥å
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
--- 411,456 ----
  $END$$NL$
  
  $ 
! $  優先度データキュー
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 優先度データキューID番号の最大値
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntが負の場合（E_PAR）
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)でない場合（E_PAR）
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// 優先度データキュー管理領域
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// 優先度データキュー初期化ブロックの生成
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
***************
*** 458,464 ****
  	};$NL$
  	$NL$
  
! $	// ͥ٥ǡ塼֥å
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
--- 458,464 ----
  	};$NL$
  	$NL$
  
! $	// 優先度データキュー管理ブロック
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
***************
*** 466,508 ****
  $END$$NL$
  
  $ 
! $  ᡼ܥå
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ᡼ܥåIDֹκ
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ ᡼ܥå֥å
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrʡTA_TPRIϡáTA_MPRIϡˤǤʤE_RSATR
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)ǤʤE_PAR
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdNULLǤʤE_NOSPT
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// ᡼ܥå֥å
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ᡼ܥå֥å
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
--- 466,508 ----
  $END$$NL$
  
  $ 
! $  メールボックス
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ メールボックスID番号の最大値
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ メールボックス初期化ブロックの生成
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrが（［TA_TPRI］｜［TA_MPRI］）でない場合（E_RSATR）
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)でない場合（E_PAR）
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdがNULLでない場合（E_NOSPT）
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// メールボックス初期化ブロック
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// メールボックス管理ブロック
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
***************
*** 510,558 ****
  $END$$NL$
  
  $ 
! $  Ĺס
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ĹסIDֹκ
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcnt0ʲξE_PAR
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blksz0ʲξE_PAR
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbNULLǤʤE_NOSPT
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// Ĺס֥å
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
--- 510,558 ----
  $END$$NL$
  
  $ 
! $  固定長メモリプール
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 固定長メモリプールID番号の最大値
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcntが0以下の場合（E_PAR）
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkszが0以下の場合（E_PAR）
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール領域
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール管理領域
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// 固定長メモリプール初期化ブロックの生成
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
***************
*** 560,566 ****
  	};$NL$
  	$NL$
  
! $	// Ĺס֥å
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
--- 560,566 ----
  	};$NL$
  	$NL$
  
! $	// 固定長メモリプール管理ブロック
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
***************
*** 568,615 ****
  $END$$NL$
  
  $ 
! $  ϥɥ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ϥɥIDֹκ
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ ϥɥơ֥
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrʡTA_STAϡˤǤʤE_RSATR
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// ٹcycatrTA_STAꤵƤơ(cycphs == 0)ξ
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// ϥɥ֥å
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ϥɥ֥å
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
--- 568,615 ----
  $END$$NL$
  
  $ 
! $  周期ハンドラ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 周期ハンドラID番号の最大値
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ 周期ハンドラ初期化テーブルの生成
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrが（［TA_STA］）でない場合（E_RSATR）
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// 警告：cycatrにTA_STAが設定されていて，(cycphs == 0)の場合
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// 周期ハンドラ初期化ブロック
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 周期ハンドラ管理ブロック
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
***************
*** 617,649 ****
  $END$$NL$
  
  $ 
! $  顼ϥɥ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 顼ϥɥIDֹκ
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ 顼ϥɥ֥å
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrTA_NULLˤǤʤE_RSATR
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// 顼ϥɥ֥å
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 顼ϥɥ֥å
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
--- 617,649 ----
  $END$$NL$
  
  $ 
! $  アラームハンドラ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ アラームハンドラID番号の最大値
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ アラームハンドラ初期化ブロックの生成
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrが（TA_NULL）でない場合（E_RSATR）
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// アラームハンドラ初期化ブロック
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// アラームハンドラ管理ブロック
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
***************
*** 651,664 ****
  $END$$NL$
  
  $ 
! $  ߴǽ
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ֹȳߥϥɥֹѴơ֥κ
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
--- 651,664 ----
  $END$$NL$
  
  $ 
! $  割込み管理機能
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 割込み番号と割込みハンドラ番号の変換テーブルの作成
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
***************
*** 670,684 ****
  	$i = i + 1$
  $END$
  
! $ ׵饤˴ؤ륨顼å
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoCFG_INTФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoCFG_INTˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
--- 670,684 ----
  	$i = i + 1$
  $END$
  
! $ 割込み要求ラインに関するエラーチェック
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoがCFG_INTに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoがCFG_INTによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
***************
*** 687,712 ****
  		$j = j + 1$
  	$END$
  
! $	// intatrʡTA_ENAINTϡáTA_EDGEϡˤǤʤE_RSATR
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriCFG_INTФͥ٤ȤʤE_PAR
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵ줿E_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵʤäE_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
--- 687,712 ----
  		$j = j + 1$
  	$END$
  
! $	// intatrが（［TA_ENAINT］｜［TA_EDGE］）でない場合（E_RSATR）
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriがCFG_INTに対する割込み優先度として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// カーネル管理に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定された場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定されなかった場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
***************
*** 715,729 ****
  	$i = i + 1$
  $END$
  
! $ ߥϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoDEF_INHФߥϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoDEF_INHˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
--- 715,729 ----
  	$i = i + 1$
  $END$
  
! $ 割込みハンドラに関するエラーチェック
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoがDEF_INHに対する割込みハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoがDEF_INHによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
***************
*** 732,752 ****
  		$j = j + 1$
  	$END$
  
! $	// inhatrTA_NULLˤǤʤE_RSATR
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	//ꤵƤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	// ꤵƤʤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
--- 732,752 ----
  		$j = j + 1$
  	$END$
  
! $	// inhatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// カーネル管理に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	//　が指定されている場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	// が指定されていない場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
***************
*** 755,775 ****
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoбintnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrTA_NONKERNELꤵƤ餺inhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRI⾮E_OBJ
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrTA_NONKERNELꤵƤꡤinhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRIʾǤE_OBJ
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
--- 755,775 ----
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoに対応するintnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrにTA_NONKERNELが指定されておらず，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRIよりも小さい場合（E_OBJ）
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrにTA_NONKERNELが指定されており，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRI以上である場合（E_OBJ）
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
***************
*** 779,797 ****
  	$i = i + 1$
  $END$
  
! $ ߥӥ롼ISRˤ˴ؤ륨顼åȳߥϥɥ
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrTA_NULLˤǤʤE_RSATR
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoATT_ISRФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)ǤʤE_PAR
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
--- 779,797 ----
  	$i = i + 1$
  $END$
  
! $ 割込みサービスルーチン（ISR）に関するエラーチェックと割込みハンドラの生成
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrが（TA_NULL）でない場合（E_RSATR）
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoがATT_ISRに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)でない場合（E_PAR）
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
***************
*** 800,806 ****
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// ֹintnoФϿ줿ISRΥꥹȤκ
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
--- 800,806 ----
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// 割込み番号intnoに対して登録されたISRのリストの作成
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
***************
*** 809,827 ****
  		$END$
  	$END$
  
! $	// ֹintnoФϿ줿ISR¸ߤ
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoбinhnoФDEF_INHE_OBJ
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoФCFG_INTꤵ줿ͥ٤TMIN_INTPRI
! $			// ⾮E_OBJ
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
--- 809,827 ----
  		$END$
  	$END$
  
! $	// 割込み番号intnoに対して登録されたISRが存在する場合
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoに対応するinhnoに対してDEF_INHがある場合（E_OBJ）
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoに対してCFG_INTで設定された割込み優先度がTMIN_INTPRI
! $			// よりも小さい場合（E_OBJ）
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
***************
*** 833,839 ****
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISRѤγߥϥɥ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
--- 833,839 ----
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISR用の割込みハンドラ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
***************
*** 845,851 ****
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRͥٽ˸ƤӽФ
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
--- 845,851 ----
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRを優先度順に呼び出す
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
***************
*** 858,869 ****
  $NL$
  
  $ 
! $  ߴǽΤɸŪʽ
  $ 
! $ ߥϥɥνɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ ߥϥɥ
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
--- 858,869 ----
  $NL$
  
  $ 
! $  割込み管理機能のための標準的な初期化情報の生成
  $ 
! $ 割込みハンドラの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ 割込みハンドラ数
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
***************
*** 874,880 ****
  $END$
  $NL$
  
! $ ߥϥɥơ֥
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
--- 874,880 ----
  $END$
  $NL$
  
! $ 割込みハンドラ初期化テーブル
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
***************
*** 890,904 ****
  $END$$NL$
  $END$
  
! $ ׵饤νɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ ׵饤
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ ׵饤ơ֥
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
--- 890,904 ----
  $END$$NL$
  $END$
  
! $ 割込み要求ラインの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ 割込み要求ライン数
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ 割込み要求ライン初期化テーブル
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
***************
*** 911,932 ****
  $END$
  
  $ 
! $  CPU㳰ǽ
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU㳰ϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoDEF_EXCФCPU㳰ϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoDEF_EXCˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
--- 911,932 ----
  $END$
  
  $ 
! $  CPU例外管理機能
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU例外ハンドラに関するエラーチェック
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoがDEF_EXCに対するCPU例外ハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoがDEF_EXCによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
***************
*** 935,951 ****
  		$j = j + 1$
  	$END$
  
! $	// excatrTA_NULLˤǤʤE_RSATR
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU㳰ϥɥΤɸŪʽ
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU㳰ϥɥ
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
--- 935,951 ----
  		$j = j + 1$
  	$END$
  
! $	// excatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU例外ハンドラのための標準的な初期化情報の生成
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU例外ハンドラ数
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
***************
*** 954,960 ****
  $END$
  $NL$
  
! $ CPU㳰ϥɥơ֥
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
--- 954,960 ----
  $END$
  $NL$
  
! $ CPU例外ハンドラ初期化テーブル
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
***************
*** 967,973 ****
  $END$
  
  $ 
! $  󥿥ƥѤΥåΰ
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
--- 967,973 ----
  $END$
  
  $ 
! $  非タスクコンテキスト用のスタック領域
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
***************
*** 975,981 ****
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSʤΥǥեͤ
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
--- 975,981 ----
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSがない場合のデフォルト値の設定
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
***************
*** 990,1015 ****
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// ŪAPIDEF_ICSפʣE_OBJ
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istksz0ʲåκǾ͡TARGET_MIN_ISTKSZˤ
! $	// E_PAR
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszåΰΥȤʤE_PAR
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// åΰμưդ
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
--- 990,1015 ----
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// 静的API「DEF_ICS」が複数ある（E_OBJ）
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istkszが0以下か，ターゲット定義の最小値（TARGET_MIN_ISTKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// スタック領域の自動割付け
  		static STK_T				_kernel_istack[COUNT_STK_T($ICS.ISTKSZ[1]$)];$NL$
  		#define TOPPERS_ISTKSZ		ROUND_STK_T($ICS.ISTKSZ[1]$)$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
***************
*** 1020,1026 ****
  $END$
  $NL$
  
! $ 󥿥ƥѤΥåΰ
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
--- 1020,1026 ----
  $END$
  $NL$
  
! $ 非タスクコンテキスト用のスタック領域
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
***************
*** 1030,1036 ****
  $NL$
  
  $ 
! $  ।٥ȴ
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
--- 1030,1036 ----
  $NL$
  
  $ 
! $  タイムイベント管理
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
***************
*** 1040,1046 ****
  $NL$
  
  $ 
! $  ƥ⥸塼νؿ
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
--- 1040,1046 ----
  $NL$
  
  $ 
! $  各モジュールの初期化関数
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
***************
*** 1064,1070 ****
  $NL$
  
  $ 
! $  롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
--- 1064,1070 ----
  $NL$
  
  $ 
! $  初期化ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
***************
*** 1074,1080 ****
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrTA_NULLˤǤʤE_RSATR
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
--- 1074,1080 ----
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrが（TA_NULL）でない場合（E_RSATR）
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
***************
*** 1084,1090 ****
  $NL$
  
  $ 
! $  λ롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
--- 1084,1090 ----
  $NL$
  
  $ 
! $  終了処理ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
***************
*** 1094,1100 ****
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrTA_NULLˤǤʤE_RSATR
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
--- 1094,1100 ----
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrが（TA_NULL）でない場合（E_RSATR）
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
diff -cr --new-file 1.9.1/asp/extension/rstr_task/kernel/sys_manage.c ASPs/asp/extension/rstr_task/kernel/sys_manage.c
*** 1.9.1/asp/extension/rstr_task/kernel/sys_manage.c	Fri Dec 31 22:43:06 2010
--- ASPs/asp/extension/rstr_task/kernel/sys_manage.c	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: sys_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		ƥִǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: sys_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		システム状態管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ROT_RDQ_ENTER
  #define LOG_ROT_RDQ_ENTER(tskpri)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ROT_RDQ_ENTER
  #define LOG_ROT_RDQ_ENTER(tskpri)
***************
*** 172,178 ****
  #endif /* LOG_SNS_KER_LEAVE */
  
  /*
!  *  ̤ͥβž
   */
  #ifdef TOPPERS_rot_rdq
  
--- 172,178 ----
  #endif /* LOG_SNS_KER_LEAVE */
  
  /*
!  *  タスクの優先順位の回転
   */
  #ifdef TOPPERS_rot_rdq
  
***************
*** 212,218 ****
  #endif /* TOPPERS_rot_rdq */
  
  /*
!  *  ̤ͥβž󥿥ƥѡ
   */
  #ifdef TOPPERS_irot_rdq
  
--- 212,218 ----
  #endif /* TOPPERS_rot_rdq */
  
  /*
!  *  タスクの優先順位の回転（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_irot_rdq
  
***************
*** 250,256 ****
  #endif /* TOPPERS_irot_rdq */
  
  /*
!  *  ¹Ծ֤ΥIDλ
   */
  #ifdef TOPPERS_get_tid
  
--- 250,256 ----
  #endif /* TOPPERS_irot_rdq */
  
  /*
!  *  実行状態のタスクIDの参照
   */
  #ifdef TOPPERS_get_tid
  
***************
*** 275,281 ****
  #endif /* TOPPERS_get_tid */
  
  /*
!  *  ¹Ծ֤ΥIDλȡ󥿥ƥѡ
   */
  #ifdef TOPPERS_iget_tid
  
--- 275,281 ----
  #endif /* TOPPERS_get_tid */
  
  /*
!  *  実行状態のタスクIDの参照（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iget_tid
  
***************
*** 300,306 ****
  #endif /* TOPPERS_iget_tid */
  
  /*
!  *  CPUå֤ؤΰܹ
   */
  #ifdef TOPPERS_loc_cpu
  
--- 300,306 ----
  #endif /* TOPPERS_iget_tid */
  
  /*
!  *  CPUロック状態への移行
   */
  #ifdef TOPPERS_loc_cpu
  
***************
*** 325,331 ****
  #endif /* TOPPERS_loc_cpu */
  
  /*
!  *  CPUå֤ؤΰܹԡ󥿥ƥѡ
   */
  #ifdef TOPPERS_iloc_cpu
  
--- 325,331 ----
  #endif /* TOPPERS_loc_cpu */
  
  /*
!  *  CPUロック状態への移行（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iloc_cpu
  
***************
*** 350,360 ****
  #endif /* TOPPERS_iloc_cpu */
  
  /*
!  *  CPUå֤β
   *
!  *  CPUåϡǥѥåɬפȤʤ륵ӥƤӽФ
!  *  ȤϤǤʤᡤCPUå֤β˥ǥѥåư
!  *  ɬפϤʤ
   */
  #ifdef TOPPERS_unl_cpu
  
--- 350,360 ----
  #endif /* TOPPERS_iloc_cpu */
  
  /*
!  *  CPUロック状態の解除
   *
!  *  CPUロック中は，ディスパッチが必要となるサービスコールを呼び出すこ
!  *  とはできないため，CPUロック状態の解除時にディスパッチャを起動する
!  *  必要はない．
   */
  #ifdef TOPPERS_unl_cpu
  
***************
*** 379,389 ****
  #endif /* TOPPERS_unl_cpu */
  
  /*
!  *  CPUå֤β󥿥ƥѡ
   *
!  *  CPUåϡǥѥåɬפȤʤ륵ӥƤӽФ
!  *  ȤϤǤʤᡤCPUå֤β˥ǥѥåεư
!  *  ᤹ɬפϤʤ
   */
  #ifdef TOPPERS_iunl_cpu
  
--- 379,389 ----
  #endif /* TOPPERS_unl_cpu */
  
  /*
!  *  CPUロック状態の解除（非タスクコンテキスト用）
   *
!  *  CPUロック中は，ディスパッチが必要となるサービスコールを呼び出すこ
!  *  とはできないため，CPUロック状態の解除時にディスパッチャの起動を要
!  *  求する必要はない．
   */
  #ifdef TOPPERS_iunl_cpu
  
***************
*** 408,414 ****
  #endif /* TOPPERS_iunl_cpu */
  
  /*
!  *  ǥѥåζػ
   */
  #ifdef TOPPERS_dis_dsp
  
--- 408,414 ----
  #endif /* TOPPERS_iunl_cpu */
  
  /*
!  *  ディスパッチの禁止
   */
  #ifdef TOPPERS_dis_dsp
  
***************
*** 434,440 ****
  #endif /* TOPPERS_dis_dsp */
  
  /*
!  *  ǥѥåε
   */
  #ifdef TOPPERS_ena_dsp
  
--- 434,440 ----
  #endif /* TOPPERS_dis_dsp */
  
  /*
!  *  ディスパッチの許可
   */
  #ifdef TOPPERS_ena_dsp
  
***************
*** 465,471 ****
  #endif /* TOPPERS_ena_dsp */
  
  /*
!  *  ƥȤλ
   */
  #ifdef TOPPERS_sns_ctx
  
--- 465,471 ----
  #endif /* TOPPERS_ena_dsp */
  
  /*
!  *  コンテキストの参照
   */
  #ifdef TOPPERS_sns_ctx
  
***************
*** 483,489 ****
  #endif /* TOPPERS_sns_ctx */
  
  /*
!  *  CPUå֤λ
   */
  #ifdef TOPPERS_sns_loc
  
--- 483,489 ----
  #endif /* TOPPERS_sns_ctx */
  
  /*
!  *  CPUロック状態の参照
   */
  #ifdef TOPPERS_sns_loc
  
***************
*** 501,507 ****
  #endif /* TOPPERS_sns_loc */
  
  /*
!  *  ǥѥåػ߾֤λ
   */
  #ifdef TOPPERS_sns_dsp
  
--- 501,507 ----
  #endif /* TOPPERS_sns_loc */
  
  /*
!  *  ディスパッチ禁止状態の参照
   */
  #ifdef TOPPERS_sns_dsp
  
***************
*** 519,525 ****
  #endif /* TOPPERS_sns_dsp */
  
  /*
!  *  ǥѥåα֤λ
   */
  #ifdef TOPPERS_sns_dpn
  
--- 519,525 ----
  #endif /* TOPPERS_sns_dsp */
  
  /*
!  *  ディスパッチ保留状態の参照
   */
  #ifdef TOPPERS_sns_dpn
  
***************
*** 537,543 ****
  #endif /* TOPPERS_sns_dpn */
  
  /*
!  *  ͥư֤λ
   */
  #ifdef TOPPERS_sns_ker
  
--- 537,543 ----
  #endif /* TOPPERS_sns_dpn */
  
  /*
!  *  カーネル非動作状態の参照
   */
  #ifdef TOPPERS_sns_ker
  
diff -cr --new-file 1.9.1/asp/extension/rstr_task/kernel/task.c ASPs/asp/extension/rstr_task/kernel/task.c
*** 1.9.1/asp/extension/rstr_task/kernel/task.c	Sat Aug 27 07:59:56 2011
--- ASPs/asp/extension/rstr_task/kernel/task.c	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
***************
*** 62,108 ****
  #ifdef TOPPERS_tskini
  
  /*
!  *  ¹Ծ֤Υ
   */
  TCB		*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   */
  TCB		*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   */
  bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   */
  bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   */
  bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   */
  bool_t	dspflg;
  
  /*
!  *  ǥ塼
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   */
  uint16_t	ready_primap;
  
  /*
!  *  ⥸塼ν
   */
  void
  initialize_task(void)
--- 62,108 ----
  #ifdef TOPPERS_tskini
  
  /*
!  *  実行状態のタスク
   */
  TCB		*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   */
  TCB		*p_schedtsk;
  
  /*
!  *  タスクディスパッチ／タスク例外処理ルーチン起動要求フラグ
   */
  bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   */
  bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   */
  bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   */
  bool_t	dspflg;
  
  /*
!  *  レディキュー
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   */
  uint16_t	ready_primap;
  
  /*
!  *  タスク管理モジュールの初期化
   */
  void
  initialize_task(void)
***************
*** 137,158 ****
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ӥåȥޥåץؿ
   *
!  *  bitmap1ΥӥåȤ⡤ǤⲼ̡ʱˤΤΤ򥵡Υӥ
!  *  ֹ֤ӥåֹϡǲ̥ӥåȤ0Ȥ롥bitmap0
!  *  ƤϤʤʤδؿǤϡbitmap16ӥåȤǤ뤳Ȥꤷ
!  *  uint16_tȤƤ롥
   *
!  *  ӥåȥ̿ĥץåǤϡӥåȥ̿Ȥ褦
!  *  ľΨɤ礬롥Τ褦ʾˤϡå
!  *  ¸ǥӥåȥ̿Ȥäbitmap_search
!  *  OMIT_BITMAP_SEARCHޥФ褤ޤӥåȥ̿
!  *  դʤɤͳͥ٤ȥӥåȤȤбѹ
!  *  ϡPRIMAP_BITޥФ褤
   *
!  *  ޤ饤֥ffsʤ顤Τ褦ƥ饤֥ؿ
!  *  ȤäΨɤǽ⤢롥
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
--- 137,158 ----
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ビットマップサーチ関数
   *
!  *  bitmap内の1のビットの内，最も下位（右）のものをサーチし，そのビッ
!  *  ト番号を返す．ビット番号は，最下位ビットを0とする．bitmapに0を指定
!  *  してはならない．この関数では，bitmapが16ビットであることを仮定し，
!  *  uint16_t型としている．
   *
!  *  ビットサーチ命令を持つプロセッサでは，ビットサーチ命令を使うように
!  *  書き直した方が効率が良い場合がある．このような場合には，ターゲット
!  *  依存部でビットサーチ命令を使ったbitmap_searchを定義し，
!  *  OMIT_BITMAP_SEARCHをマクロ定義すればよい．また，ビットサーチ命令の
!  *  サーチ方向が逆などの理由で優先度とビットとの対応を変更したい場合に
!  *  は，PRIMAP_BITをマクロ定義すればよい．
   *
!  *  また，ライブラリにffsがあるなら，次のように定義してライブラリ関数を
!  *  使った方が効率が良い可能性もある．
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
***************
*** 184,190 ****
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline bool_t
  primap_empty(void)
--- 184,190 ----
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  優先度ビットマップが空かのチェック
   */
  Inline bool_t
  primap_empty(void)
***************
*** 193,199 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥ
   */
  Inline uint_t
  primap_search(void)
--- 193,199 ----
  }
  
  /*
!  *  優先度ビットマップのサーチ
   */
  Inline uint_t
  primap_search(void)
***************
*** 202,208 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline void
  primap_set(uint_t pri)
--- 202,208 ----
  }
  
  /*
!  *  優先度ビットマップのセット
   */
  Inline void
  primap_set(uint_t pri)
***************
*** 211,217 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥꥢ
   */
  Inline void
  primap_clear(uint_t pri)
--- 211,217 ----
  }
  
  /*
!  *  優先度ビットマップのクリア
   */
  Inline void
  primap_clear(uint_t pri)
***************
*** 220,226 ****
  }
  
  /*
!  *  ǹ̥ͥΥ
   */
  #ifdef TOPPERS_tsksched
  
--- 220,226 ----
  }
  
  /*
!  *  最高優先順位タスクのサーチ
   */
  #ifdef TOPPERS_tsksched
  
***************
*** 236,246 ****
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡ¹ԤǤ륿ʤä
!  *  ȡp_tcbͥ٤ǹ̤ͥΥͥ٤⤤Ǥ
!  *  롥
   */
  #ifdef TOPPERS_tskrun
  
--- 236,246 ----
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  実行できる状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，実行できるタスクがなかった場合
!  *  と，p_tcbの優先度が最高優先順位のタスクの優先度よりも高い場合であ
!  *  る．
   */
  #ifdef TOPPERS_tskrun
  
***************
*** 262,273 ****
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡp_tcbǹ̤ͥΥ
!  *  äǤ롥p_tcbƱͥ٤Υ¾ˤϡp_tcb
!  *  μΥǹ̤ͥˤʤ롥Ǥʤϡǥ塼
!  *  ɬפ롥
   */
  #ifdef TOPPERS_tsknrun
  
--- 262,273 ----
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，p_tcbが最高優先順位のタスクで
!  *  あった場合である．p_tcbと同じ優先度のタスクが他にある場合は，p_tcb
!  *  の次のタスクが最高優先順位になる．そうでない場合は，レディキューを
!  *  サーチする必要がある．
   */
  #ifdef TOPPERS_tsknrun
  
***************
*** 297,303 ****
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  ٻ߾֤ؤ
   */
  #ifdef TOPPERS_tskdmt
  
--- 297,303 ----
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  休止状態への遷移
   */
  #ifdef TOPPERS_tskdmt
  
***************
*** 315,321 ****
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   */
  #ifdef TOPPERS_tskact
  
--- 315,321 ----
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  休止状態から実行できる状態への遷移
   */
  #ifdef TOPPERS_tskact
  
***************
*** 331,346 ****
  #endif /* TOPPERS_tskact */
  
  /*
!  *  ͥ٤ѹ
   *
!  *  ¹ԤǤ֤ξˤϡǥ塼Ǥΰ֤ѹ
!  *  롥֥ȤԤ塼Ԥ֤ˤʤäƤˤϡ
!  *  塼Ǥΰ֤ѹ롥
   *
!  *  ǹ̤ͥΥ򹹿Τϡ(1) p_tcbǹ̤ͥΥ
!  *  Ǥäơͥ٤򲼤硤(2) p_tcbǹ̤ͥΥ
!  *  ǤϤʤѹͥ٤ǹ̤ͥΥͥ٤⤤
!  *  Ǥ롥(1)ξˤϡǥ塼򥵡ɬפ롥
   */
  #ifdef TOPPERS_tskpri
  
--- 331,346 ----
  #endif /* TOPPERS_tskact */
  
  /*
!  *  タスクの優先度の変更
   *
!  *  タスクが実行できる状態の場合には，レディキューの中での位置を変更す
!  *  る．オブジェクトの待ちキューの中で待ち状態になっている場合には，待
!  *  ちキューの中での位置を変更する．
   *
!  *  最高優先順位のタスクを更新するのは，(1) p_tcbが最高優先順位のタス
!  *  クであって，その優先度を下げた場合，(2) p_tcbが最高優先順位のタス
!  *  クではなく，変更後の優先度が最高優先順位のタスクの優先度よりも高い
!  *  場合である．(1)の場合には，レディキューをサーチする必要がある．
   */
  #ifdef TOPPERS_tskpri
  
***************
*** 354,360 ****
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤ξ
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
--- 354,360 ----
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  タスクが実行できる状態の場合
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
***************
*** 379,386 ****
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  Ʊ֥̿Ȥδ֥åζ
! 			 *  ʬWOBJCBˤԤ塼ˤĤʤƤ
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
--- 379,386 ----
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  タスクが，同期・通信オブジェクトの管理ブロックの共通部
! 			 *  分（WOBJCB）の待ちキューにつながれている場合
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
***************
*** 392,398 ****
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  ͥ٤ΰ夲
   */
  #ifdef TOPPERS_tskrpri
  
--- 392,398 ----
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  自タスクの優先度の引き上げ
   */
  #ifdef TOPPERS_tskrpri
  
***************
*** 429,438 ****
  #endif /* TOPPERS_tskrpri */
  
  /*
!  *  ǥ塼βž
   *
!  *  ǹ̤ͥΥ򹹿Τϡǹ̤ͥΥ
!  *  塼˰ưǤ롥
   */
  #ifdef TOPPERS_tskrot
  
--- 429,438 ----
  #endif /* TOPPERS_tskrpri */
  
  /*
!  *  レディキューの回転
   *
!  *  最高優先順位のタスクを更新するのは，最高優先順位のタスクがタスクキ
!  *  ューの末尾に移動した場合である．
   */
  #ifdef TOPPERS_tskrot
  
***************
*** 455,464 ****
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  㳰롼θƽФ
   *
!  *  ASPͥǤϡ㳰롼CPUå֤ܤ
!  *  ξ֤ᤵ˥꥿󤷤硤ͥ뤬ξ֤᤹
   */
  #ifdef TOPPERS_tsktex
  
--- 455,464 ----
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  ASPカーネルでは，タスク例外処理ルーチン内でCPUロック状態に遷移し，
!  *  元の状態に戻さずにリターンした場合，カーネルが元の状態に戻す．
   */
  #ifdef TOPPERS_tsktex
  
***************
*** 491,500 ****
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  dispatchƤӽФϡߺƵƽФˤʤä
! 			 *  뤬dispatchƤp_runtsk->enatexfalseˤ
! 			 *  лپ㤬ʤͳˤĤƤϡTOPPERS/ASP 
! 			 *  ͥ ߷ץפ򻲾ȤΤȡ
  			 */
  			dispatch();
  		}
--- 491,500 ----
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  ここでdispatchを呼び出す処理は，相互再帰呼出しになって
! 			 *  いるが，dispatchを呼ぶ前にp_runtsk->enatexをfalseにして
! 			 *  おけば支障がない．その理由については，「TOPPERS/ASP カー
! 			 *  ネル 設計メモ」を参照のこと．
  			 */
  			dispatch();
  		}
***************
*** 503,509 ****
  }
  
  /*
!  *  㳰롼εư
   */
  #ifndef OMIT_CALLTEX
  
--- 503,509 ----
  }
  
  /*
!  *  タスク例外処理ルーチンの起動
   */
  #ifndef OMIT_CALLTEX
  
diff -cr --new-file 1.9.1/asp/extension/rstr_task/kernel/task.h ASPs/asp/extension/rstr_task/kernel/task.h
*** 1.9.1/asp/extension/rstr_task/kernel/task.h	Sun May  6 18:22:24 2012
--- ASPs/asp/extension/rstr_task/kernel/task.h	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #ifndef TOPPERS_TASK_H
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.h 2366 2012-05-06 09:22:22Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #ifndef TOPPERS_TASK_H
***************
*** 51,99 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  ͥ٤ɽɽѴޥ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  ֤ɽ
   *
!  *  TCBΥ֤Ǥϡ¹Ծ֡RUNNINGˤȼ¹Բǽ֡READY
!  *  ϶̤ʤξ֤Τơ¹ԤǤ֡RUNNABLEˤȸƤ֡
!  *  Ԥ֤ϡ(TS_WAITING | TS_SUSPENDED)ɽTS_WAIT_???
!  *  װɽԤ֡Ԥ֤ޤˤξˤΤꤹ롥
!  */
! #define TS_DORMANT		0x00U			/* ٻ߾ */
! #define TS_RUNNABLE		0x01U			/* ¹ԤǤ */
! #define TS_WAITING		0x02U			/* Ԥ */
! #define TS_SUSPENDED	0x04U			/* Ԥ */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* ַвԤ */
! #define TS_WAIT_SLP		(0x01U << 3)	/* Ԥ */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* ǡ塼μԤ */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* ͥ٥ǡ塼μԤ */
! #define TS_WAIT_SEM		(0x04U << 3)	/* ޥե񸻤γԤ */
! #define TS_WAIT_FLG		(0x05U << 3)	/* ٥ȥե饰Ԥ */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* ǡ塼ؤԤ */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* ͥ٥ǡ塼ؤԤ */
! #define TS_WAIT_MBX		(0x08U << 3)	/* ᡼ܥåμԤ */
! #define TS_WAIT_MPF		(0x09U << 3)	/* Ĺ֥åγԤ */
! 
! /*
!  *  Ƚ̥ޥ
!  *
!  *  TSTAT_DORMANTϥٻ߾֤Ǥ뤫ɤTSTAT_RUNNABLE
!  *  ¹ԤǤ֤Ǥ뤫ɤȽ̤롥TSTAT_WAITING
!  *  ֤Ԥ֤Τ줫Ǥ뤫ɤTSTAT_SUSPENDED
!  *  Ԥ֤Ԥ֤Τ줫Ǥ뤫ɤȽ̤롥
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
--- 51,99 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  タスク優先度の内部表現・外部表現変換マクロ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  タスク状態の内部表現
   *
!  *  TCB中のタスク状態では，実行状態（RUNNING）と実行可能状態（READY）
!  *  は区別しない．両状態を総称して，実行できる状態（RUNNABLE）と呼ぶ．
!  *  二重待ち状態は，(TS_WAITING | TS_SUSPENDED)で表す．TS_WAIT_???は待
!  *  ち要因を表し，待ち状態（二重待ち状態を含む）の場合にのみ設定する．
!  */
! #define TS_DORMANT		0x00U			/* 休止状態 */
! #define TS_RUNNABLE		0x01U			/* 実行できる状態 */
! #define TS_WAITING		0x02U			/* 待ち状態 */
! #define TS_SUSPENDED	0x04U			/* 強制待ち状態 */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* 時間経過待ち */
! #define TS_WAIT_SLP		(0x01U << 3)	/* 起床待ち */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* データキューからの受信待ち */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* 優先度データキューからの受信待ち */
! #define TS_WAIT_SEM		(0x04U << 3)	/* セマフォ資源の獲得待ち */
! #define TS_WAIT_FLG		(0x05U << 3)	/* イベントフラグ待ち */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* データキューへの送信待ち */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* 優先度データキューへの送信待ち */
! #define TS_WAIT_MBX		(0x08U << 3)	/* メールボックスからの受信待ち */
! #define TS_WAIT_MPF		(0x09U << 3)	/* 固定長メモリブロックの獲得待ち */
! 
! /*
!  *  タスク状態判別マクロ
!  *
!  *  TSTAT_DORMANTはタスクが休止状態であるかどうかを，TSTAT_RUNNABLEは
!  *  タスクが実行できる状態であるかどうかを判別する．TSTAT_WAITINGは待
!  *  ち状態と二重待ち状態のいずれかであるかどうかを，TSTAT_SUSPENDEDは
!  *  強制待ち状態と二重待ち状態のいずれかであるかどうかを判別する．
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
***************
*** 101,488 ****
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  ԤװȽ̥ޥ
   *
!  *  TSTAT_WAIT_SLPϥԤǤ뤫ɤTSTAT_WAIT_WOBJ
!  *  ϥƱ֥̿ȤФԤǤ뤫ʸȡ
!  *  Ʊ֥̿ȤԤ塼ˤĤʤƤ뤫ˤɤȽ̤
!  *  롥ޤTSTAT_WAIT_WOBJCBϥƱ֥̿Ȥδ
!  *  ֥åζʬWOBJCBˤԤ塼ˤĤʤƤ뤫ɤ
!  *  Ƚ̤롥
!  *
!  *  TSTAT_WAIT_SLPϡǤդΥ֤椫顤ԤǤ
!  *  ȤȽ̤Ǥ롥ʤTSTAT_WAITINGˤԤ֤Ǥ뤳Ȥ
!  *  Ƚ̤ˡTSTAT_SLPѤƵԤ֤Ǥ뤳ȤȽ̤Ǥ롥
!  *  ΨŪ˼¸뤿ˡTS_WAIT_SLPͤ(0x00U << 3)ǤϤ
!  *  (0x01U << 3)ȤƤ롥ΤᡤַвԤ֤Ǥ
!  *  ȤȽ̤뤿TSTAT_WAIT_DLYTSTAT_WAIT_SLPƱͤˡ
!  *  ¸뤳ȤϤǤʤ
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* ԤװμФޥ */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  Ԥ֥åWINFOˤ
   *
!  *  Ԥ֤δ֤ϡTCBӤp_winfoǻؤWINFO򼡤
!  *  褦ꤷʤФʤʤ
   *
!  *  (a) TCBΥ֤Ԥ֡TS_WAITINGˤˤ롥κݤˡԤ
!  *  װTS_WAIT_???ˤꤹ롥
   *
!  *  (b) ॢȤƻ뤹뤿ˡ।٥ȥ֥åϿ롥
!  *  Ͽ륿।٥ȥ֥åϡԤ륵ӥؿ
!  *  ΥѿȤƳݤؤΥݥ󥿤WINFOp_tmevtb˵
!  *  롥ॢȤδƻ뤬ɬפʤʱʵԤξˤˤϡ
!  *  p_tmevtbNULLˤ롥
!  *
!  *  Ʊ֥̿ȤФԤ֤ξˤϡɸWINFO
!  *  p_wobjcbեɤɲä¤ΡWINFO_WOBJwait.hˤ
!  *  ޤʲ(c)(e)Ԥɬפ롥Ʊ֥̿
!  *  Ȥ˴طʤԤʵԤַвԤˤξˤϡ(c)(e)
!  *  ɬפʤ
!  *
!  *  (c) TCBԤоݤƱ֥̿ȤԤ塼ˤĤʤ
!  *  塼ˤĤʤˡtask_queueȤ
!  *
!  *  (d) ԤоݤƱ֥̿Ȥδ֥åؤΥݥ󥿤
!  *  WINFO_WOBJp_wobjcb˵롥
!  *
!  *  (e) ԤоݤƱ֥̿Ȥ˰¸Ƶ뤳Ȥɬפ
!  *  󤬤ˤϡWINFO_WOBJɬפʾΤΥեɤɲ
!  *  ¤ΤWINFO_WOBJѤ롥
!  *
!  *  Ԥ֤ݤˤϡԤФͤWINFO
!  *  wercdꤹ롥wercdɬפʤΤԤʹߤǤΤФơ
!  *  p_tmevtbԤɬפʤᡤΤ˶ΤȤ
!  *  Ƥ롥Τᡤwercdإ顼ɤꤹΤϡ।٥
!  *  ֥åϿˤʤФʤʤ
   */
  typedef union waiting_information {
! 	ER		wercd;			/* ԤΥ顼 */
! 	TMEVTB	*p_tmevtb;		/* ԤѤΥ।٥ȥ֥å */
  } WINFO;
  
  /*
!  *  ֥å
   *
!  *  ˴ؤͤѤʤROM֤ʬʥ
!  *  ֥åˤȡͤѲ뤿RAM֤ʤФʤʤ
!  *  ʬʥ֥åTCBˤʬΥTCBб륿
!  *  ֥åؤݥ󥿤롥֥åб
!  *  TCBؤݥ󥿤ˡRAMδ˾ޤ
!  *  ¹ԸΨʤ뤿˺ѤƤʤ¾Υ֥ȤˤĤ
!  *  ƤƱͤ˰
   *
!  *  ֥åˤϡDEF_TEX륿㳰롼
!  *  ˴ؤޤࡥ
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* ° */
! 	intptr_t	exinf;			/* γĥ */
! 	TASK		task;			/* εư */
! 	uint_t		ipriority;		/* εưͥ١ɽ */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* ƥȥ֥å */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* åΰΥʴݤ᤿͡ */
! 	void		*stk;			/* åΰƬ */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* 㳰롼° */
! 	TEXRTN		texrtn;			/* 㳰롼εư */
  } TINIB;
  
  /*
!  *  TCBΥեɤΥӥå
   *
!  *  ץåˤäƤϡTCBΥեɤΥӥåǥ̤
!  *  ǽȥ졼ɥդˤʤ뤿ᡤåȰ¸˥եɤΥӥå
!  *  ѹ뤳ȤƤ롥
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityեɤΥӥå */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  ֥åTCB
   *
!  *  ASPͥǤϡεư׵ᥭ塼󥰿κ͡TMAX_ACTCNT
!  *  ȵ׵ᥭ塼󥰿κ͡TMAX_WUPCNTˤ1˸ꤵƤ
!  *  ᡤ塼󥰤Ƥ뤫ɤοͤɽ뤳ȤǤ롥
!  *  ޤԤ׵ͥȿκ͡TMAX_SUSCNTˤ1˸ꤵƤ
!  *  ΤǡԤ׵ͥȿsuscntˤɬפʤ
!  *
!  *  TCBΤĤΥեɤϡΥ֤ǤΤͭͤݻ
!  *  ʳξͤݾڤʤʤäơȤƤϤʤʤˡ
!  *  եɤͭͤݻϼ̤ꡥ
!  *
!  *  Ͼͭ
!  *  		p_tinibtstatactque
!  *  ٻ߾ְʳͭʵٻ߾֤ǤϽͤˤʤäƤˡ
!  *  		prioritywupqueenatextexptn
!  *  Ԥ֡Ԥ֤ޤˤͭ
   *  		p_winfo
!  *  ¹ԤǤ֤Ʊ֥̿ȤФԤ֤ͭ
   *  		task_queue
!  *  ¹Բǽ֡Ԥ֡Ԥ֡Ԥ֤ͭ
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* 塼 */
! 	const TINIB		*p_tinib;		/* ֥åؤΥݥ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* ֡ɽ*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* ֡ɽ*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* ߤͥ١ɽ*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* ߤͥ١ɽ*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* ư׵ᥭ塼 */
! 	BIT_FIELD_BOOL	wupque : 1;		/* ׵ᥭ塼 */
! 	BIT_FIELD_BOOL	enatex : 1;		/* 㳰ľ */
! 
! 	TEXPTN			texptn;			/* α㳰װ */
! 	WINFO			*p_winfo;		/* Ԥ֥åؤΥݥ */
! 	TSKCTXB			tskctxb;		/* ƥȥ֥å */
  } TCB;
  
  /*
!  *  ¹Ծ֤Υ
   *
!  *  ¹Ծ֤ΥʡץåƥȤäƤ륿ˤ
!  *  TCBؤݥ󥿡¹Ծ֤ΥʤNULLˤ롥
   *
!  *  ӥνǡʥӥƤӽФ
!  *  ˤ˴ؤ򻲾Ȥp_runtskȤp_runtsk񤭴
!  *  ΤϡǥѥåʤȽˤΤߤǤ롥
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   *
!  *  ¹ԤǤ륿Ǻǹ̤ͥΥTCBؤݥ󥿡
!  *  ԤǤ륿ʤNULLˤ롥
   *
!  *  ǥѥåػ߾֤ʤɡǥѥåαƤ֤p_runtsk
!  *  ȰפƤȤϸ¤ʤ
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   *
!  *  ߥϥɥ顿CPU㳰ϥɥνиˡǥѥåޤ
!  *  㳰롼εư׵᤹뤳Ȥ򼨤ե饰
   */
  extern bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   *
!  *  ͥ٥ޥ֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   *
!  *  ǥѥåػ߾֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   *
!  *  ͥ٥ޥ֤Ǥꡤǥѥåľ֤Ǥʥǥ
!  *  ѥåػ߾֤ǤʤˤȤ򼨤ե饰
   */
  extern bool_t	dspflg;
  
  /*
!  *  ǥ塼
   *
!  *  ǥ塼ϡ¹ԤǤ֤Υ뤿Υ塼Ǥ롥
!  *  ¹Ծ֤ΥƤ뤿ᡤǥʼ¹Բǽ˥塼Ȥ
!  *  ̾ΤΤǤϤʤǥ塼Ȥ̾Τ夷Ƥ뤿ᡤ
!  *  ̾ΤǸƤ֤Ȥˤ롥
   *
!  *  ǥ塼ϡͥ٤ȤΥ塼ǹƤ롥
!  *  TCBϡͥ٤Υ塼Ͽ롥
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   *
!  *  ǥ塼ΥΨ褯Ԥˡͥ٤ȤΥ塼
!  *  ˥äƤ뤫ɤ򼨤ӥåȥޥåפѰդƤ롥ӥ
!  *  ȥޥåפȤȤǡꥢβ򸺤餹ȤǤ뤬
!  *  ӥå̿᤬¤Ƥʤץåǡͥ٤ʳʤ
!  *  ˤϡӥåȥޥåΥСإåɤΤˡդ˸Ψ
!  *  ǽ⤢롥
   *
!  *  ͥ٤16ʳǤ뤳ȤꤷƤ뤿ᡤuint16_tȤƤ롥
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  ֥åΥꥢkernel_cfg.c
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  ơ֥kernel_cfg.c
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBΥꥢkernel_cfg.c
   */
  extern TCB	tcb_table[];
  
  /*
!  *  ο
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  IDTCBФΥޥ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCB饿IDФΥޥ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  ⥸塼ν
   */
  extern void	initialize_task(void);
  
  /*
!  *  ǹ̥ͥΥ
   *
!  *  ǥ塼κǹ̤ͥΥ򥵡TCBؤΥݥ
!  *  ֤ǥ塼ξˤϡδؿƤӽФƤϤʤʤ
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥ǥ塼
!  *  ͥ٤ǹ̤ͥΥͥ٤⤤ϡ
!  *  ǹ̤ͥΥ򹹿ǥѥåľ֤Ǥtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥p_tcbǻꤷ
!  *  ǹ̤ͥΥǤäˤϡǹ̤ͥΥ
!  *  ꤷʤǥѥåľ֤Ǥtrue֤Ǥʤ
!  *  false֤ξ֤Ϲʤ
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤Ȥ롥ޤεư
!  *  ˽٤ѿνȡưΤΥƥȤ
!  *  ꤹ롥
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤¹ԤǤ֤Ȥ롥
!  *  ¹ԤǤ֤ܤؤΥǥѥåɬפʾtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  ͥ٤ѹ
   *
!  *  p_tcbǻꤵ륿ͥ٤newpriɽˤѹ롥ޤ
!  *  ɬפʾˤϺǹ̤ͥΥ򹹿ǥѥåľ֤
!  *  true֤Ǥʤfalse֤
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  ͥ٤ΰ夲
   *
!  *  ͥ٤newpriɽˤѹ롥ޤɬפʾ
!  *  Ϻǹ̤ͥΥ򹹿ǥѥåľ֤Ǥtrue
!  *  ֤Ǥʤfalse֤
   */
  extern bool_t	raise_priority(uint_t newpri);
  
  /*
!  *  ǥ塼βž
   *
!  *  ǥ塼Ρp_queueǻꤵ륿塼ž롥ޤ
!  *  ɬפʾˤϺǹ̤ͥΥѹǥѥåα
!  *  Ƥʤtrue֤Ǥʤfalse֤
   */
  extern bool_t	rotate_ready_queue(QUEUE *p_queue);
  
  /*
!  *  㳰롼θƽФ
   *
!  *  㳰롼ƤӽФƤӽФˡ¹Ծ֤Υ
!  *  α㳰װ򥯥ꥢ㳰ػ߾֤ˤCPUå
!  *  롥
!  *
!  *  㳰롼󤫤ȡޤCPUå֤ᤷδ
!  *  α㳰װ0ǤʤʤäƤСƤӥ㳰롼
!  *  ƤӽФα㳰װ0ξˤϡ㳰ľ֤ˤƴؿ
!  *  ꥿󤹤롥
!  *
!  *  δؿϡ¹Ծ֤Υ㳰ľ֡enatex
!  *  trueˤǡα㳰װ0Ǥʤtexptn0Ǥʤ˾˸ƤӽФ
!  *  ȤꤷƤ롥δؿϡCPUå֤ǸƤӽФʤФʤ
!  *  ʤ
   */
  extern void	call_texrtn(void);
  
  /*
!  *  㳰롼εư
   *
!  *  ¹Ծ֤Υ㳰롼εưƤС
!  *  㳰롼ƤӽФCPU㳰롼ƤӽФ
!  *  ϡŪCPUå롥
!  *
!  *  δؿϡǥѥåߥϥɥ顿CPU㳰ϥɥνи
!  *  ƤӽФ뤳ȤꤷƤ롥δؿϡCPUå
!  *  ǸƤӽФʤФʤʤ
   *
!  *  ¹ԸΨ夲뤿ˡδؿ򥿡åȰ¸ǵҤƤ褤
!  *  ξˤϡOMIT_CALLTEXޥ롥
   */
  extern void	calltex(void);
  
--- 101,488 ----
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  タスク待ち要因判別マクロ
   *
!  *  TSTAT_WAIT_SLPはタスクが起床待ちであるかどうかを，TSTAT_WAIT_WOBJ
!  *  はタスクが同期・通信オブジェクトに対する待ちであるか（言い換えると，
!  *  同期通信オブジェクトの待ちキューにつながれているか）どうかを判別す
!  *  る．また，TSTAT_WAIT_WOBJCBはタスクが同期・通信オブジェクトの管理
!  *  ブロックの共通部分（WOBJCB）の待ちキューにつながれているかどうかを
!  *  判別する．
!  *
!  *  TSTAT_WAIT_SLPは，任意のタスク状態の中から，タスクが起床待ちである
!  *  ことを判別できる．すなわち，TSTAT_WAITINGにより待ち状態であることを
!  *  判別せずに，TSTAT_SLPだけを用いて起床待ち状態であることを判別できる．
!  *  これを効率的に実現するために，TS_WAIT_SLPの値を，(0x00U << 3)ではな
!  *  く(0x01U << 3)としている．そのため，タスクが時間経過待ち状態である
!  *  ことを判別するためのTSTAT_WAIT_DLYを，TSTAT_WAIT_SLPと同様の方法で
!  *  実現することはできない．
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* 待ち要因の取出しマスク */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  待ち情報ブロック（WINFO）の定義
   *
!  *  タスクが待ち状態の間は，TCBおよびそのp_winfoで指されるWINFOを次の
!  *  ように設定しなければならない．
   *
!  *  (a) TCBのタスク状態を待ち状態（TS_WAITING）にする．その際に，待ち
!  *  要因（TS_WAIT_???）も設定する．
   *
!  *  (b) タイムアウトを監視するために，タイムイベントブロックを登録する．
!  *  登録するタイムイベントブロックは，待ちに入るサービスコール処理関数
!  *  のローカル変数として確保し，それへのポインタをWINFOのp_tmevtbに記
!  *  憶する．タイムアウトの監視が必要ない場合（永久待ちの場合）には，
!  *  p_tmevtbをNULLにする．
!  *
!  *  同期・通信オブジェクトに対する待ち状態の場合には，標準のWINFOに
!  *  p_wobjcbフィールドを追加した構造体（WINFO_WOBJ，wait.hで定義）を使
!  *  う．また，以下の(c)〜(e)の設定を行う必要がある．同期・通信オブジェ
!  *  クトに関係しない待ち（起床待ち，時間経過待ち）の場合には，(c)〜(e)
!  *  は必要ない．
!  *
!  *  (c) TCBを待ち対象の同期・通信オブジェクトの待ちキューにつなぐ．待
!  *  ちキューにつなぐために，task_queueを使う．
!  *
!  *  (d) 待ち対象の同期・通信オブジェクトの管理ブロックへのポインタを，
!  *  WINFO_WOBJのp_wobjcbに記憶する．
!  *
!  *  (e) 待ち対象の同期・通信オブジェクトに依存して記憶することが必要な
!  *  情報がある場合には，WINFO_WOBJに必要な情報のためのフィールドを追加
!  *  した構造体を定義し，WINFO_WOBJの代わりに用いる．
!  *
!  *  待ち状態を解除する際には，待ち解除したタスクに対する返値をWINFOの
!  *  wercdに設定する．wercdが必要なのは待ち解除以降であるのに対して，
!  *  p_tmevtbは待ち解除後は必要ないため，メモリ節約のために共用体を使っ
!  *  ている．そのため，wercdへエラーコードを設定するのは，タイムイベント
!  *  ブロックを登録解除した後にしなければならない．
   */
  typedef union waiting_information {
! 	ER		wercd;			/* 待ち解除時のエラーコード */
! 	TMEVTB	*p_tmevtb;		/* 待ち状態用のタイムイベントブロック */
  } WINFO;
  
  /*
!  *  タスク初期化ブロック
   *
!  *  タスクに関する情報を，値が変わらないためにROMに置ける部分（タスク
!  *  初期化ブロック）と，値が変化するためにRAMに置かなければならない部
!  *  分（タスク管理ブロック，TCB）に分離し，TCB内に対応するタスク初期化
!  *  ブロックを指すポインタを入れる．タスク初期化ブロック内に対応する
!  *  TCBを指すポインタを入れる方法の方が，RAMの節約の観点からは望ましい
!  *  が，実行効率が悪くなるために採用していない．他のオブジェクトについ
!  *  ても同様に扱う．
   *
!  *  タスク初期化ブロックには，DEF_TEXで定義されるタスク例外処理ルーチ
!  *  ンに関する情報も含む．
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* タスク属性 */
! 	intptr_t	exinf;			/* タスクの拡張情報 */
! 	TASK		task;			/* タスクの起動番地 */
! 	uint_t		ipriority;		/* タスクの起動時優先度（内部表現） */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* タスク初期化コンテキストブロック */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* スタック領域のサイズ（丸めた値） */
! 	void		*stk;			/* スタック領域の先頭番地 */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* タスク例外処理ルーチン属性 */
! 	TEXRTN		texrtn;			/* タスク例外処理ルーチンの起動番地 */
  } TINIB;
  
  /*
!  *  TCB中のフィールドのビット幅の定義
   *
!  *  プロセッサによっては，TCB中のフィールドのビット幅でメモリ使用量と
!  *  性能がトレードオフになるため，ターゲット依存にフィールドのビット幅
!  *  を変更することを許している．
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityフィールドのビット幅 */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  タスク管理ブロック（TCB）
   *
!  *  ASPカーネルでは，タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）
!  *  と起床要求キューイング数の最大値（TMAX_WUPCNT）は1に固定されている
!  *  ため，キューイングされているかどうかの真偽値で表現することができる．
!  *  また，強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が1に固定されてい
!  *  るので，強制待ち要求ネスト数（suscnt）は必要ない．
!  *
!  *  TCBのいくつかのフィールドは，特定のタスク状態でのみ有効な値を保持し，
!  *  それ以外の場合は値が保証されない（よって，参照してはならない）．各
!  *  フィールドが有効な値を保持する条件は次の通り．
!  *
!  *  ・初期化後は常に有効：
!  *  		p_tinib，tstat，actque
!  *  ・休止状態以外で有効（休止状態では初期値になっている）：
!  *  		priority，wupque，enatex，texptn
!  *  ・待ち状態（二重待ち状態を含む）で有効：
   *  		p_winfo
!  *  ・実行できる状態と同期・通信オブジェクトに対する待ち状態で有効：
   *  		task_queue
!  *  ・実行可能状態，待ち状態，強制待ち状態，二重待ち状態で有効：
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* タスクキュー */
! 	const TINIB		*p_tinib;		/* 初期化ブロックへのポインタ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* タスク状態（内部表現）*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* タスク状態（内部表現）*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* 現在の優先度（内部表現）*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* 現在の優先度（内部表現）*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* 起動要求キューイング */
! 	BIT_FIELD_BOOL	wupque : 1;		/* 起床要求キューイング */
! 	BIT_FIELD_BOOL	enatex : 1;		/* タスク例外処理許可状態 */
! 
! 	TEXPTN			texptn;			/* 保留例外要因 */
! 	WINFO			*p_winfo;		/* 待ち情報ブロックへのポインタ */
! 	TSKCTXB			tskctxb;		/* タスクコンテキストブロック */
  } TCB;
  
  /*
!  *  実行状態のタスク
   *
!  *  実行状態のタスク（＝プロセッサがコンテキストを持っているタスク）の
!  *  TCBを指すポインタ．実行状態のタスクがない場合はNULLにする．
   *
!  *  サービスコールの処理中で，自タスク（サービスコールを呼び出したタス
!  *  ク）に関する情報を参照する場合はp_runtskを使う．p_runtskを書き換え
!  *  るのは，ディスパッチャ（と初期化処理）のみである．
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   *
!  *  実行できるタスクの中で最高優先順位のタスクのTCBを指すポインタ．実
!  *  行できるタスクがない場合はNULLにする．
   *
!  *  ディスパッチ禁止状態など，ディスパッチが保留されている間はp_runtsk
!  *  と一致しているとは限らない．
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ディスパッチ／タスク例外処理ルーチン起動要求フラグ
   *
!  *  割込みハンドラ／CPU例外ハンドラの出口処理に，ディスパッチまたは
!  *  タスク例外処理ルーチンの起動を要求することを示すフラグ．
   */
  extern bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   *
!  *  割込み優先度マスク全解除状態であることを示すフラグ．
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   *
!  *  ディスパッチ禁止状態であることを示すフラグ．
   */
  extern bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   *
!  *  割込み優先度マスク全解除状態であり，ディスパッチ許可状態である（ディ
!  *  スパッチ禁止状態でない）ことを示すフラグ．
   */
  extern bool_t	dspflg;
  
  /*
!  *  レディキュー
   *
!  *  レディキューは，実行できる状態のタスクを管理するためのキューである．
!  *  実行状態のタスクも管理しているため，レディ（実行可能）キューという
!  *  名称は正確ではないが，レディキューという名称が定着しているため，こ
!  *  の名称で呼ぶことにする．
   *
!  *  レディキューは，優先度ごとのタスクキューで構成されている．タスクの
!  *  TCBは，該当する優先度のキューに登録される．
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   *
!  *  レディキューのサーチを効率よく行うために，優先度ごとのタスクキュー
!  *  にタスクが入っているかどうかを示すビットマップを用意している．ビッ
!  *  トマップを使うことで，メモリアクセスの回数を減らすことができるが，
!  *  ビット操作命令が充実していないプロセッサで，優先度の段階数が少ない
!  *  場合には，ビットマップ操作のオーバーヘッドのために，逆に効率が落ち
!  *  る可能性もある．
   *
!  *  優先度が16段階であることを仮定しているため，uint16_t型としている．
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  タスクIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  タスク初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  タスク生成順序テーブル（kernel_cfg.c）
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBのエリア（kernel_cfg.c）
   */
  extern TCB	tcb_table[];
  
  /*
!  *  タスクの数
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  タスクIDからTCBを取り出すためのマクロ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCBからタスクIDを取り出すためのマクロ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  タスク管理モジュールの初期化
   */
  extern void	initialize_task(void);
  
  /*
!  *  最高優先順位タスクのサーチ
   *
!  *  レディキュー中の最高優先順位のタスクをサーチし，そのTCBへのポインタ
!  *  を返す．レディキューが空の場合には，この関数を呼び出してはならない．
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューに挿入する．レディキューに挿入
!  *  したタスクの優先度が，最高優先順位のタスクの優先度よりも高い場合は，
!  *  最高優先順位のタスクを更新し，ディスパッチ許可状態であればtrueを返
!  *  す．そうでない場合はfalseを返す．
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューから削除する．p_tcbで指定した
!  *  タスクが最高優先順位のタスクであった場合には，最高優先順位のタスク
!  *  を設定しなおし，ディスパッチ許可状態であればtrueを返す．そうでない
!  *  場合はfalseを返す．タスクの状態は更新しない．
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  休止状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態とする．また，タスクの起動
!  *  時に初期化すべき変数の初期化と，タスク起動のためのコンテキストを設
!  *  定する．
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  休止状態から実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態から実行できる状態とする．
!  *  実行できる状態に遷移したタスクへのディスパッチが必要な場合はtrue，
!  *  そうでない場合はfalseを返す．
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  タスクの優先度の変更
   *
!  *  p_tcbで指定されるタスクの優先度をnewpri（内部表現）に変更する．また，
!  *  必要な場合には最高優先順位のタスクを更新し，ディスパッチ許可状態で
!  *  あればtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  自タスクの優先度の引き上げ
   *
!  *  自タスクの優先度をnewpri（内部表現）に変更する．また，必要な場合に
!  *  は最高優先順位のタスクを更新し，ディスパッチ許可状態であればtrueを
!  *  返す．そうでない場合はfalseを返す．
   */
  extern bool_t	raise_priority(uint_t newpri);
  
  /*
!  *  レディキューの回転
   *
!  *  レディキュー中の，p_queueで指定されるタスクキューを回転させる．また，
!  *  必要な場合には最高優先順位のタスクを変更し，ディスパッチが保留され
!  *  ていなければtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	rotate_ready_queue(QUEUE *p_queue);
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  タスク例外処理ルーチンを呼び出す．呼び出す前に，実行状態のタスクの
!  *  保留例外要因をクリアし，タスク例外処理禁止状態にし，CPUロックを解
!  *  除する．
!  *
!  *  タスク例外処理ルーチンから戻ると，まずCPUロック状態に戻し，その間
!  *  に保留例外要因が0でなくなっていれば，再びタスク例外処理ルーチンを
!  *  呼び出す．保留例外要因が0の場合には，例外処理許可状態にして関数か
!  *  らリターンする．
!  *
!  *  この関数は，実行状態のタスクが，タスク例外処理許可状態（enatexが
!  *  true）で，保留例外要因が0でない（texptnが0でない）場合に呼び出すこ
!  *  とを想定している．この関数は，CPUロック状態で呼び出さなければなら
!  *  ない．
   */
  extern void	call_texrtn(void);
  
  /*
!  *  タスク例外処理ルーチンの起動
   *
!  *  実行状態のタスクがタスク例外処理ルーチンの起動条件を満たしていれば，
!  *  タスク例外処理ルーチンを呼び出す．CPU例外処理ルーチンを呼び出す時
!  *  は，一時的にCPUロックを解除する．
!  *
!  *  この関数は，ディスパッチャや割込みハンドラ／CPU例外ハンドラの出口
!  *  処理から呼び出されることを想定している．この関数は，CPUロック状態
!  *  で呼び出さなければならない．
   *
!  *  実行効率を上げるために，この関数をターゲット依存部で記述してもよい．
!  *  その場合には，OMIT_CALLTEXをマクロ定義する．
   */
  extern void	calltex(void);
  
diff -cr --new-file 1.9.1/asp/extension/rstr_task/kernel/task_manage.c ASPs/asp/extension/rstr_task/kernel/task_manage.c
*** 1.9.1/asp/extension/rstr_task/kernel/task_manage.c	Fri Dec 31 22:43:06 2010
--- ASPs/asp/extension/rstr_task/kernel/task_manage.c	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task_manage.c 2018 2010-12-31 13:43:05Z ertl-hiro $
   */
  
  /*
!  *		タスク管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 50,56 ****
  #include "wait.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
--- 50,56 ----
  #include "wait.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
***************
*** 125,131 ****
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  εư
   */
  #ifdef TOPPERS_act_tsk
  
--- 125,131 ----
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  タスクの起動
   */
  #ifdef TOPPERS_act_tsk
  
***************
*** 164,170 ****
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  εư󥿥ƥѡ
   */
  #ifdef TOPPERS_iact_tsk
  
--- 164,170 ----
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  タスクの起動（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iact_tsk
  
***************
*** 203,209 ****
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  ư׵Υ󥻥
   */
  #ifdef TOPPERS_can_act
  
--- 203,209 ----
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  タスク起動要求のキャンセル
   */
  #ifdef TOPPERS_can_act
  
***************
*** 231,237 ****
  #endif /* TOPPERS_can_act */
  
  /*
!  *  νλ
   */
  #ifdef TOPPERS_ext_tsk
  
--- 231,237 ----
  #endif /* TOPPERS_can_act */
  
  /*
!  *  自タスクの終了
   */
  #ifdef TOPPERS_ext_tsk
  
***************
*** 245,253 ****
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUå֤ext_tskƤФ줿ϡCPUå
! 		 *  Ƥ饿λ롥ϡӥǤCPU
! 		 *  åάФ褤
  		 */
  	}
  	else {
--- 245,253 ----
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUロック状態でext_tskが呼ばれた場合は，CPUロックを解除し
! 		 *  てからタスクを終了する．実装上は，サービスコール内でのCPU
! 		 *  ロックを省略すればよいだけ．
  		 */
  	}
  	else {
***************
*** 255,270 ****
  	}
  	if (disdsp) {
  		/*
! 		 *  ǥѥåػ߾֤ext_tskƤФ줿ϡǥѥ
! 		 *  ľ֤ˤƤ饿λ롥
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  ͥ٥ޥIPMˤTIPM_ENAALLʳξ֤ext_tsk
! 		 *  ƤФ줿ϡIPMTIPM_ENAALLˤƤ饿λ
! 		 *  롥
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
--- 255,270 ----
  	}
  	if (disdsp) {
  		/*
! 		 *  ディスパッチ禁止状態でext_tskが呼ばれた場合は，ディスパッ
! 		 *  チ許可状態にしてからタスクを終了する．
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  割込み優先度マスク（IPM）がTIPM_ENAALL以外の状態でext_tsk
! 		 *  が呼ばれた場合は，IPMをTIPM_ENAALLにしてからタスクを終了す
! 		 *  る．
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
***************
*** 288,294 ****
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  ζλ
   */
  #ifdef TOPPERS_ter_tsk
  
--- 288,294 ----
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  タスクの強制終了
   */
  #ifdef TOPPERS_ter_tsk
  
***************
*** 311,319 ****
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbϼǤʤᡤʥ󥰥ץåǤϡ˼
! 			 *  Ծ֤Ǥʤmake_non_runnable(p_tcb)ǥǥѥ
! 			 *  ɬפˤʤ뤳ȤϤʤ
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
--- 311,319 ----
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbは自タスクでないため，（シングルプロセッサでは）実
! 			 *  行状態でなく，make_non_runnable(p_tcb)でタスクディスパッ
! 			 *  チが必要になることはない．
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
***************
*** 340,346 ****
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  Υ١ͥ٤ѹ
   */
  #ifdef TOPPERS_chg_pri
  
--- 340,346 ----
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  タスクのベース優先度の変更
   */
  #ifdef TOPPERS_chg_pri
  
***************
*** 380,386 ****
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  ͥ٤ΰ夲
   */
  #ifdef TOPPERS_ras_pri
  
--- 380,386 ----
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  自タスクの優先度の引き上げ
   */
  #ifdef TOPPERS_ras_pri
  
***************
*** 416,422 ****
  #endif /* TOPPERS_ras_pri */
  
  /*
!  *  ͥ٤λ
   */
  #ifdef TOPPERS_get_pri
  
--- 416,422 ----
  #endif /* TOPPERS_ras_pri */
  
  /*
!  *  タスク優先度の参照
   */
  #ifdef TOPPERS_get_pri
  
***************
*** 449,455 ****
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  γĥλ
   */
  #ifdef TOPPERS_get_inf
  
--- 449,455 ----
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  自タスクの拡張情報の参照
   */
  #ifdef TOPPERS_get_inf
  
diff -cr --new-file 1.9.1/asp/extension/rstr_task/kernel/task_sync.c ASPs/asp/extension/rstr_task/kernel/task_sync.c
*** 1.9.1/asp/extension/rstr_task/kernel/task_sync.c	Fri Aug  6 15:15:19 2010
--- ASPs/asp/extension/rstr_task/kernel/task_sync.c	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task_sync.c 1887 2010-08-06 06:15:19Z ertl-hiro $
   */
  
  /*
!  *		°Ʊǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task_sync.c 1887 2010-08-06 06:15:19Z ertl-hiro $
   */
  
  /*
!  *		タスク付属同期機能
   */
  
  #include "kernel_impl.h"
***************
*** 50,56 ****
  #include "wait.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SLP_TSK_ENTER
  #define LOG_SLP_TSK_ENTER()
--- 50,56 ----
  #include "wait.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SLP_TSK_ENTER
  #define LOG_SLP_TSK_ENTER()
***************
*** 133,139 ****
  #endif /* LOG_DLY_TSK_LEAVE */
  
  /*
!  *  Ԥ
   */
  #ifdef TOPPERS_slp_tsk
  
--- 133,139 ----
  #endif /* LOG_DLY_TSK_LEAVE */
  
  /*
!  *  起床待ち
   */
  #ifdef TOPPERS_slp_tsk
  
***************
*** 168,174 ****
  #endif /* TOPPERS_slp_tsk */
  
  /*
!  *  ԤʥॢȤ
   */
  #ifdef TOPPERS_tslp_tsk
  
--- 168,174 ----
  #endif /* TOPPERS_slp_tsk */
  
  /*
!  *  起床待ち（タイムアウトあり）
   */
  #ifdef TOPPERS_tslp_tsk
  
***************
*** 208,214 ****
  #endif /* TOPPERS_tslp_tsk */
  
  /*
!  *  ε
   */
  #ifdef TOPPERS_wup_tsk
  
--- 208,214 ----
  #endif /* TOPPERS_tslp_tsk */
  
  /*
!  *  タスクの起床
   */
  #ifdef TOPPERS_wup_tsk
  
***************
*** 251,257 ****
  #endif /* TOPPERS_wup_tsk */
  
  /*
!  *  ε󥿥ƥѡ
   */
  #ifdef TOPPERS_iwup_tsk
  
--- 251,257 ----
  #endif /* TOPPERS_wup_tsk */
  
  /*
!  *  タスクの起床（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iwup_tsk
  
***************
*** 294,300 ****
  #endif /* TOPPERS_iwup_tsk */
  
  /*
!  *  ׵Υ󥻥
   */
  #ifdef TOPPERS_can_wup
  
--- 294,300 ----
  #endif /* TOPPERS_iwup_tsk */
  
  /*
!  *  タスク起床要求のキャンセル
   */
  #ifdef TOPPERS_can_wup
  
***************
*** 328,334 ****
  #endif /* TOPPERS_can_wup */
  
  /*
!  *  Ԥ֤ζ
   */
  #ifdef TOPPERS_rel_wai
  
--- 328,334 ----
  #endif /* TOPPERS_can_wup */
  
  /*
!  *  待ち状態の強制解除
   */
  #ifdef TOPPERS_rel_wai
  
***************
*** 364,370 ****
  #endif /* TOPPERS_rel_wai */
  
  /*
!  *  Ԥ֤ζ󥿥ƥѡ
   */
  #ifdef TOPPERS_irel_wai
  
--- 364,370 ----
  #endif /* TOPPERS_rel_wai */
  
  /*
!  *  待ち状態の強制解除（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_irel_wai
  
***************
*** 400,406 ****
  #endif /* TOPPERS_irel_wai */
  
  /*
!  *  Ԥ֤ؤΰܹ
   */
  #ifdef TOPPERS_sus_tsk
  
--- 400,406 ----
  #endif /* TOPPERS_irel_wai */
  
  /*
!  *  強制待ち状態への移行
   */
  #ifdef TOPPERS_sus_tsk
  
***************
*** 425,431 ****
  	}
  	else if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤鶯Ԥ֤ؤ
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 425,431 ----
  	}
  	else if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  実行できる状態から強制待ち状態への遷移
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 439,445 ****
  	}
  	else {
  		/*
! 		 *  Ԥ֤Ԥ֤ؤ
  		 */
  		p_tcb->tstat |= TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 439,445 ----
  	}
  	else {
  		/*
! 		 *  待ち状態から二重待ち状態への遷移
  		 */
  		p_tcb->tstat |= TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 455,461 ****
  #endif /* TOPPERS_sus_tsk */
  
  /*
!  *  Ԥ֤κƳ
   */
  #ifdef TOPPERS_rsm_tsk
  
--- 455,461 ----
  #endif /* TOPPERS_sus_tsk */
  
  /*
!  *  強制待ち状態からの再開
   */
  #ifdef TOPPERS_rsm_tsk
  
***************
*** 477,483 ****
  	}
  	else if (!TSTAT_WAITING(p_tcb->tstat)) {
  		/*
! 		 *  Ԥ֤¹ԤǤ֤ؤ
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
--- 477,483 ----
  	}
  	else if (!TSTAT_WAITING(p_tcb->tstat)) {
  		/*
! 		 *  強制待ち状態から実行できる状態への遷移
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
***************
*** 488,494 ****
  	}
  	else {
  		/*
! 		 *  Ԥ֤Ԥ֤ؤ
  		 */
  		p_tcb->tstat &= ~TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 488,494 ----
  	}
  	else {
  		/*
! 		 *  二重待ち状態から待ち状態への遷移
  		 */
  		p_tcb->tstat &= ~TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 504,510 ****
  #endif /* TOPPERS_rsm_tsk */
  
  /*
!  *  ٱ
   */
  #ifdef TOPPERS_dly_tsk
  
--- 504,510 ----
  #endif /* TOPPERS_rsm_tsk */
  
  /*
!  *  自タスクの遅延
   */
  #ifdef TOPPERS_dly_tsk
  
diff -cr --new-file 1.9.1/asp/extension/rstr_task/test/test_rstr1.c ASPs/asp/extension/rstr_task/test/test_rstr1.c
*** 1.9.1/asp/extension/rstr_task/test/test_rstr1.c	Sun Oct 13 23:20:12 2013
--- ASPs/asp/extension/rstr_task/test/test_rstr1.c	Fri Dec  9 13:54:03 2022
***************
*** 5,61 ****
   *  Copyright (C) 2010-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_rstr1.c 2537 2013-10-13 14:20:09Z ertl-hiro $
   */
  
  /* 
!  *		󥿥Υƥ(1)
   *
!  * ڥƥȤŪ
   *
!  *  󥿥δŪʿ񤤡ras_priӥʳưˤƥ
!  *  Ȥ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) 󥿥Ԥ֤ˤǽΤ륵ӥ
!  *      ƤӽФ硤E_NOSPT顼Ȥʤ
   *		(A-1) slp_tsk
   *		(A-2) tslp_tsk
   *		(A-3) dly_tsk
!  *       ¾ˤ⤢뤬α
!  *	(B) 󥿥оݤȤơchg_priwup_tskiwup_tskcan_wup
!  *	    rel_waiirel_waisus_tskrsm_tskƤӽФ硤E_NOSPT
!  *	    顼Ȥʤ
   *		(B-1) chg_pri
   *		(B-2) wup_tsk
   *		(B-3) iwup_tsk
--- 5,61 ----
   *  Copyright (C) 2010-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_rstr1.c 2537 2013-10-13 14:20:09Z ertl-hiro $
   */
  
  /* 
!  *		制約タスクのテスト(1)
   *
!  * 【テストの目的】
   *
!  *  制約タスクの基本的な振舞い（ras_priサービスコール以外の動作）をテス
!  *  トする．
   *
!  * 【テスト項目】
   *
!  *	(A) 制約タスクが，自タスクを待ち状態にする可能性のあるサービスコー
!  *      ルを呼び出した場合，E_NOSPTエラーとなる
   *		(A-1) slp_tsk
   *		(A-2) tslp_tsk
   *		(A-3) dly_tsk
!  *      ※ 他にもあるが，これだけに留める
!  *	(B) 制約タスクを対象として，chg_pri，wup_tsk，iwup_tsk，can_wup，
!  *	    rel_wai，irel_wai，sus_tsk，rsm_tskを呼び出した場合，E_NOSPTエ
!  *	    ラーとなる
   *		(B-1) chg_pri
   *		(B-2) wup_tsk
   *		(B-3) iwup_tsk
***************
*** 64,95 ****
   *		(B-6) irel_wai
   *		(B-7) sus_tsk
   *		(B-8) rsm_tsk
!  *  (C) rot_rdqirot_rdqϡоͥ٤ļ¹ԤǤ֤Υ
!  *      ǺǤ̤ͥ⤤󥿥Ǥ硤E_NOSPT顼
!  *      Ȥʤ
!  *		(C-1) rot_rdqư
!  *		(C-2) rot_rdqE_NOSPT֤
!  *		(C-3) irot_rdqư
!  *		(C-4) irot_rdqE_NOSPT֤
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥󥿥
!  *	TASK3: ͥ٥󥿥
!  *	TASK4: ͥ٥󥿥
!  *	ALM1:  顼ϥɥ
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *	1:	act_tsk(TASK2)
!  *	== TASK2-1ͥ١==
   *	2:	slp_tsk() -> E_NOSPT						... (A-1)
   *	3:	tslp_tsk(10) -> E_NOSPT						... (A-2)
   *	4:	dly_tsk(10) -> E_NOSPT						... (A-3)
   *  5:	ext_tsk()
!  *	== TASK1³==
   *	6:	chg_pri(TASK3, HIGH_PRIORITY) -> E_NOSPT	... (B-1)
   *	7:	wup_tsk(TASK3) -> E_NOSPT					... (B-2)
   *	8:	can_wup(TASK3) -> E_NOSPT					... (B-4)
--- 64,95 ----
   *		(B-6) irel_wai
   *		(B-7) sus_tsk
   *		(B-8) rsm_tsk
!  *  (C) rot_rdq，irot_rdqは，対象優先度を持つ実行できる状態のタスクの中
!  *      で最も優先順位が高いタスクが制約タスクである場合，E_NOSPTエラー
!  *      となる
!  *		(C-1) rot_rdqが正しく動作する
!  *		(C-2) rot_rdqがE_NOSPTを返す
!  *		(C-3) irot_rdqが正しく動作する
!  *		(C-4) irot_rdqがE_NOSPTを返す
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 中優先度タスク，メインタスク，最初から起動
!  *	TASK2: 高優先度タスク，制約タスク
!  *	TASK3: 中優先度タスク，制約タスク
!  *	TASK4: 中優先度タスク，制約タスク
!  *	ALM1:  アラームハンドラ
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：中）==
   *	1:	act_tsk(TASK2)
!  *	== TASK2-1（優先度：高）==
   *	2:	slp_tsk() -> E_NOSPT						... (A-1)
   *	3:	tslp_tsk(10) -> E_NOSPT						... (A-2)
   *	4:	dly_tsk(10) -> E_NOSPT						... (A-3)
   *  5:	ext_tsk()
!  *	== TASK1（続き）==
   *	6:	chg_pri(TASK3, HIGH_PRIORITY) -> E_NOSPT	... (B-1)
   *	7:	wup_tsk(TASK3) -> E_NOSPT					... (B-2)
   *	8:	can_wup(TASK3) -> E_NOSPT					... (B-4)
***************
*** 107,133 ****
   *	19:	irot_rdq(MID_PRIORITY)						... (C-3)
   *	20:	irot_rdq(MID_PRIORITY) -> E_NOSPT			... (C-4)
   *	21:	RETURN
!  *	== TASK3-1ͥ١==
   *	22:	act_tsk(TASK2)
!  *	== TASK2-2ͥ١2 ==
   *	23:	rot_rdq(MID_PRIORITY) -> E_NOSPT			... (C-2)
   *	24:	ext_tsk()
!  *	== TASK3-1³==
   *	25:	ext_tsk()
!  *	== TASK4-1ͥ١1 ==
   *	26:	ext_tsk()
!  *	== TASK1³==
   *	27:	act_tsk(TASK3)
   *	28:	act_tsk(TASK4)
   *	29:	act_tsk(TASK2)
!  *	== TASK2-3ͥ١3 ==
   *	30:	rot_rdq(MID_PRIORITY)						... (C-1)
   *	31:	ext_tsk()
!  *	== TASK3-2ͥ١2 ==
   *	32:	ext_tsk()
!  *	== TASK4-2ͥ١2 ==
   *	33:	ext_tsk()
!  *	== TASK1³==
   *	34: END
   */
  
--- 107,133 ----
   *	19:	irot_rdq(MID_PRIORITY)						... (C-3)
   *	20:	irot_rdq(MID_PRIORITY) -> E_NOSPT			... (C-4)
   *	21:	RETURN
!  *	== TASK3-1（優先度：中）==
   *	22:	act_tsk(TASK2)
!  *	== TASK2-2（優先度：高）2回め ==
   *	23:	rot_rdq(MID_PRIORITY) -> E_NOSPT			... (C-2)
   *	24:	ext_tsk()
!  *	== TASK3-1（続き）==
   *	25:	ext_tsk()
!  *	== TASK4-1（優先度：中）1回め ==
   *	26:	ext_tsk()
!  *	== TASK1（続き）==
   *	27:	act_tsk(TASK3)
   *	28:	act_tsk(TASK4)
   *	29:	act_tsk(TASK2)
!  *	== TASK2-3（優先度：高）3回め ==
   *	30:	rot_rdq(MID_PRIORITY)						... (C-1)
   *	31:	ext_tsk()
!  *	== TASK3-2（優先度：中）2回め ==
   *	32:	ext_tsk()
!  *	== TASK4-2（優先度：中）2回め ==
   *	33:	ext_tsk()
!  *	== TASK1（続き）==
   *	34: END
   */
  
diff -cr --new-file 1.9.1/asp/extension/rstr_task/test/test_rstr1.cfg ASPs/asp/extension/rstr_task/test/test_rstr1.cfg
*** 1.9.1/asp/extension/rstr_task/test/test_rstr1.cfg	Fri Aug  6 15:15:19 2010
--- ASPs/asp/extension/rstr_task/test/test_rstr1.cfg	Fri Dec  9 13:54:03 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  󥿥Υƥ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  制約タスクのテスト(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/rstr_task/test/test_rstr1.h ASPs/asp/extension/rstr_task/test/test_rstr1.h
*** 1.9.1/asp/extension/rstr_task/test/test_rstr1.h	Fri Aug  6 15:15:19 2010
--- ASPs/asp/extension/rstr_task/test/test_rstr1.h	Fri Dec  9 13:54:03 2022
***************
*** 5,67 ****
   *  Copyright (C) 2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_rstr1.h 1887 2010-08-06 06:15:19Z ertl-hiro $
   */
  
  /* 
!  *		󥿥Υƥ(1)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	4		/* ͥ */
! #define MID_PRIORITY	9		/* ͥ */
! #define LOW_PRIORITY	14		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_rstr1.h 1887 2010-08-06 06:15:19Z ertl-hiro $
   */
  
  /* 
!  *		制約タスクのテスト(1)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	4		/* 高優先度 */
! #define MID_PRIORITY	9		/* 中優先度 */
! #define LOW_PRIORITY	14		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/extension/rstr_task/test/test_rstr2.c ASPs/asp/extension/rstr_task/test/test_rstr2.c
*** 1.9.1/asp/extension/rstr_task/test/test_rstr2.c	Sun Oct 13 23:20:12 2013
--- ASPs/asp/extension/rstr_task/test/test_rstr2.c	Fri Dec  9 13:54:03 2022
***************
*** 5,78 ****
   *  Copyright (C) 2010-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_rstr2.c 2537 2013-10-13 14:20:09Z ertl-hiro $
   */
  
  /* 
!  *		󥿥Υƥ(2)
   *
!  * ڥƥȤŪ
   *
!  *  ras_priӥưƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) 󥿥ras_priƤӽФͥ٤夲
!  *		(A-1) ǥѥåľ֤ǸƤӽФ
!  *		(A-2) ǥѥåػ߾֤ǡǹ̥ͥ¹Ծ֤Ǥ
!  *		      ˸ƤӽФ
!  *	(B) ͥ٤夬ä󥿥ras_pri(TPRI_INI)ƤӽФư
!  *      ͥ٤᤹
!  *		(B-1) ưͥ٤⤤ͥ٤Υ¹Բǽξˡ
!  *		      ڴ뤳Ȥǧ
!  *		(B-2) ưͥ٤Ʊͥ٤Υ¹Բǽξˡ
!  *		      ڴʤȤǧ
!  *		(B-3) ưͥ٤㤤ͥ٤Υ¹Բǽξˡ
!  *		      ڴʤȤǧ
!  *	(C) 󥿥ras_priƤӽФưͥ٤㤤ͥ٤
!  *	    ѹ褦ȤȡE_ILUSEˤʤ뤳Ȥǧ
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥󥿥
!  *	TASK3: ͥ٥
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *	1:	act_tsk(TASK2)
   *	2:	slp_tsk()
!  *	== TASK2ͥ١==
   *	3:	get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	4:	ras_pri(HIGH_PRIORITY)
--- 5,78 ----
   *  Copyright (C) 2010-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_rstr2.c 2537 2013-10-13 14:20:09Z ertl-hiro $
   */
  
  /* 
!  *		制約タスクのテスト(2)
   *
!  * 【テストの目的】
   *
!  *  ras_priサービスコールの動作をテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) 制約タスクからras_priを呼び出し，優先度を上げる
!  *		(A-1) ディスパッチ許可状態で呼び出した場合
!  *		(A-2) ディスパッチ禁止状態で，最高優先順位タスクが実行状態でな
!  *		      い場合に呼び出した場合
!  *	(B) 優先度が上がった制約タスクからras_pri(TPRI_INI)を呼び出し，起動
!  *      時優先度に戻す
!  *		(B-1) 起動時優先度よりも高い優先度のタスクが実行可能の場合に，
!  *		      タスク切換えが起こることを確認する
!  *		(B-2) 起動時優先度と同じ優先度のタスクが実行可能の場合に，タス
!  *		      ク切換えが起こらないことを確認する
!  *		(B-3) 起動時優先度よりも低い優先度のタスクが実行可能の場合に，
!  *		      タスク切換えが起こらないことを確認する
!  *	(C) 制約タスクからras_priを呼び出し，起動時優先度よりも低い優先度に
!  *	    変更しようとすると，E_ILUSEになることを確認する
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 中優先度タスク，メインタスク，最初から起動
!  *	TASK2: 中優先度タスク，制約タスク
!  *	TASK3: 高優先度タスク
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：中）==
   *	1:	act_tsk(TASK2)
   *	2:	slp_tsk()
!  *	== TASK2（優先度：中）==
   *	3:	get_pri(TSK_SELF, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	4:	ras_pri(HIGH_PRIORITY)
***************
*** 81,104 ****
   *	6:	act_tsk(TASK3)
   *	7:	ras_pri(LOW_PRIORITY) -> E_ILUSE			... (C)
   *	8:	ras_pri(TPRI_INI)							... (B-1)
!  *	== TASK3ͥ١==
   *	9:	get_pri(TASK2, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	10:	slp_tsk()
!  *	== TASK2³==
   *	11:	dis_dsp()
   *	12:	wup_tsk(TASK3)
   *	13:	ras_pri(HIGH_PRIORITY)						... (A-2)
   *	14:	ena_dsp()
   *	15:	ras_pri(TPRI_INI)							... (B-3)
!  *	== TASK3³==
   *	16:	chg_pri(TSK_SELF, LOW_PRIORITY)
!  *	== TASK2³==
   *	17:	ras_pri(HIGH_PRIORITY)
   *	18:	wup_tsk(TASK1)
   *	19:	ras_pri(TPRI_INI)							... (B-2)
   *	20:	ext_tsk()
!  *	== TASK1³==
   *	21: END
   */
  
--- 81,104 ----
   *	6:	act_tsk(TASK3)
   *	7:	ras_pri(LOW_PRIORITY) -> E_ILUSE			... (C)
   *	8:	ras_pri(TPRI_INI)							... (B-1)
!  *	== TASK3（優先度：高）==
   *	9:	get_pri(TASK2, &tskpri)
   *		assert(tskpri == MID_PRIORITY)
   *	10:	slp_tsk()
!  *	== TASK2（続き）==
   *	11:	dis_dsp()
   *	12:	wup_tsk(TASK3)
   *	13:	ras_pri(HIGH_PRIORITY)						... (A-2)
   *	14:	ena_dsp()
   *	15:	ras_pri(TPRI_INI)							... (B-3)
!  *	== TASK3（続き）==
   *	16:	chg_pri(TSK_SELF, LOW_PRIORITY)
!  *	== TASK2（続き）==
   *	17:	ras_pri(HIGH_PRIORITY)
   *	18:	wup_tsk(TASK1)
   *	19:	ras_pri(TPRI_INI)							... (B-2)
   *	20:	ext_tsk()
!  *	== TASK1（続き）==
   *	21: END
   */
  
diff -cr --new-file 1.9.1/asp/extension/rstr_task/test/test_rstr2.cfg ASPs/asp/extension/rstr_task/test/test_rstr2.cfg
*** 1.9.1/asp/extension/rstr_task/test/test_rstr2.cfg	Fri Aug  6 15:15:19 2010
--- ASPs/asp/extension/rstr_task/test/test_rstr2.cfg	Fri Dec  9 13:54:03 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  󥿥Υƥ(2)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  制約タスクのテスト(2)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/extension/rstr_task/test/test_rstr2.h ASPs/asp/extension/rstr_task/test/test_rstr2.h
*** 1.9.1/asp/extension/rstr_task/test/test_rstr2.h	Fri Aug  6 15:15:19 2010
--- ASPs/asp/extension/rstr_task/test/test_rstr2.h	Fri Dec  9 13:54:03 2022
***************
*** 5,67 ****
   *  Copyright (C) 2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_rstr2.h 1887 2010-08-06 06:15:19Z ertl-hiro $
   */
  
  /* 
!  *		󥿥Υƥ(2)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	4		/* ͥ */
! #define MID_PRIORITY	9		/* ͥ */
! #define LOW_PRIORITY	14		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_rstr2.h 1887 2010-08-06 06:15:19Z ertl-hiro $
   */
  
  /* 
!  *		制約タスクのテスト(2)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	4		/* 高優先度 */
! #define MID_PRIORITY	9		/* 中優先度 */
! #define LOW_PRIORITY	14		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/include/histogram.h ASPs/asp/include/histogram.h
*** 1.9.1/asp/include/histogram.h	Fri Jun 17 16:57:51 2011
--- ASPs/asp/include/histogram.h	Fri Dec  9 13:54:03 2022
***************
*** 5,44 ****
   *  Copyright (C) 2006-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: histogram.h 2097 2011-06-17 07:57:50Z ertl-hiro $
   */
  
  /*
!  *		¹Իʬ۽ץ⥸塼
   */
  
  #ifndef TOPPERS_HISTOGRAM_H
--- 5,44 ----
   *  Copyright (C) 2006-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: histogram.h 2097 2011-06-17 07:57:50Z ertl-hiro $
   */
  
  /*
!  *		実行時間分布集計モジュール
   */
  
  #ifndef TOPPERS_HISTOGRAM_H
***************
*** 49,70 ****
  #endif
  
  /*
!  *  ¹Իʬ۷¬ν
   */
  extern void	init_hist(ID histid, uint_t maxval, uint_t histarea[]);
  
  /*
!  *  ¹Իַ¬γ
   */
  extern void	begin_measure(ID histid);
  
  /*
!  *  ¹Իַ¬νλ
   */
  extern void	end_measure(ID histid);
  
  /*
!  *  ¹Իʬ۷¬ɽ
   */
  extern void	print_hist(ID histid);
  
--- 49,70 ----
  #endif
  
  /*
!  *  実行時間分布計測の初期化
   */
  extern void	init_hist(ID histid, uint_t maxval, uint_t histarea[]);
  
  /*
!  *  実行時間計測の開始
   */
  extern void	begin_measure(ID histid);
  
  /*
!  *  実行時間計測の終了
   */
  extern void	end_measure(ID histid);
  
  /*
!  *  実行時間分布計測の表示
   */
  extern void	print_hist(ID histid);
  
diff -cr --new-file 1.9.1/asp/include/itron.h ASPs/asp/include/itron.h
*** 1.9.1/asp/include/itron.h	Sun Apr 27 02:20:09 2014
--- ASPs/asp/include/itron.h	Fri Dec  9 13:54:03 2022
***************
*** 7,55 ****
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: itron.h 1762 2010-02-18 02:24:39Z ertl-hiro $
   */
  
  /*
!  *		ITRONͶ̵Υǡޥ
   *
!  *  ΥإåեϡITRONͶ̵Υǡޥ
!  *  ǡTOPPERS̥إåե˴ޤޤʤΤޤࡥITRON
!  *  ͤȤθߴɬפȤ륢ץꥱ󤬥󥯥롼ɤ뤳Ȥ
!  *  ꤷƤ롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   */
  
  #ifndef TOPPERS_ITRON_H
--- 7,55 ----
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: itron.h 1762 2010-02-18 02:24:39Z ertl-hiro $
   */
  
  /*
!  *		ITRON仕様共通規定のデータ型・定数・マクロ
   *
!  *  このヘッダファイルは，ITRON仕様共通規定のデータ型・定数・マクロの中
!  *  で，TOPPERS共通ヘッダファイルに含まれないものの定義を含む．ITRON仕
!  *  様との互換性を必要とするアプリケーションがインクルードすることを想
!  *  定している．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   */
  
  #ifndef TOPPERS_ITRON_H
***************
*** 60,132 ****
  #endif
  
  /*
!  *  TOPPERS̥إåե
   */
  #include "t_stddef.h"
  
  /*
!  *  ITRONͶ̥ǡ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  #ifdef INT8_MAX
! typedef	int8_t			B;			/* դ8ӥå */
  #endif /* INT8_MAX */
  
  #ifdef UINT8_MAX
! typedef	uint8_t			UB;			/* ̵8ӥå */
! typedef	uint8_t			VB;			/* ޤʤ8ӥåȤ */
  #endif /* UINT8_MAX */
  
! typedef	int16_t			H;			/* դ16ӥå */
! typedef	uint16_t		UH;			/* ̵16ӥå */
! typedef	uint16_t		VH;			/* ޤʤ16ӥåȤ */
! 
! typedef	int32_t			W;			/* դ32ӥå */
! typedef	uint32_t		UW;			/* ̵32ӥå */
! typedef	uint32_t		VW;			/* ޤʤ32ӥåȤ */
  
  #ifdef INT64_MAX
! typedef	int64_t			D;			/* դ64ӥå */
  #endif /* INT64_MAX */
  
  #ifdef UINT64_MAX
! typedef	uint64_t		UD;			/* ̵64ӥå */
! typedef	uint64_t		VD;			/* ޤʤ64ӥåȤ */
  #endif /* UINT64_MAX */
  
! typedef	void			*VP;		/* ޤʤΤؤΥݥ */
  
! typedef int_t			INT;		/* ʥդ */
! typedef uint_t			UINT;		/* ʥ̵ */
  
! typedef bool_t			BOOL;		/*  */
  
! typedef	intptr_t		VP_INT;		/* ݥ󥿤ޤդ */
  
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ITRONͶ
   */
! #define	TRUE		true			/*  */
! #define	FALSE		false			/*  */
  
  /*
!  *  ֥°
   */
! #define TA_HLNG			UINT_C(0x00)	/* ѥ󥿥ե */
! #define TA_TFIFO		UINT_C(0x00)	/* ԤFIFO */
! #define TA_MFIFO		UINT_C(0x00)	/* å塼FIFO */
! #define TA_WSGL			UINT_C(0x00)	/* Ԥ1ĤΤ */
  
  /*
!  *  ͥȲκ
   */
! #define TMAX_SUSCNT		UINT_C(1)		/* Ԥ׵ͥȿκ */
  
  /*
!  *  Ԥ֤ζƳ
   */
  #define frsm_tsk(tskid)		rsm_tsk(tskid)
  
--- 60,132 ----
  #endif
  
  /*
!  *  TOPPERS共通ヘッダファイル
   */
  #include "t_stddef.h"
  
  /*
!  *  ITRON仕様共通データ型
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  #ifdef INT8_MAX
! typedef	int8_t			B;			/* 符号付き8ビット整数 */
  #endif /* INT8_MAX */
  
  #ifdef UINT8_MAX
! typedef	uint8_t			UB;			/* 符号無し8ビット整数 */
! typedef	uint8_t			VB;			/* 型が定まらない8ビットの値 */
  #endif /* UINT8_MAX */
  
! typedef	int16_t			H;			/* 符号付き16ビット整数 */
! typedef	uint16_t		UH;			/* 符号無し16ビット整数 */
! typedef	uint16_t		VH;			/* 型が定まらない16ビットの値 */
! 
! typedef	int32_t			W;			/* 符号付き32ビット整数 */
! typedef	uint32_t		UW;			/* 符号無し32ビット整数 */
! typedef	uint32_t		VW;			/* 型が定まらない32ビットの値 */
  
  #ifdef INT64_MAX
! typedef	int64_t			D;			/* 符号付き64ビット整数 */
  #endif /* INT64_MAX */
  
  #ifdef UINT64_MAX
! typedef	uint64_t		UD;			/* 符号無し64ビット整数 */
! typedef	uint64_t		VD;			/* 型が定まらない64ビットの値 */
  #endif /* UINT64_MAX */
  
! typedef	void			*VP;		/* 型が定まらないものへのポインタ */
  
! typedef int_t			INT;		/* 自然なサイズの符号付き整数 */
! typedef uint_t			UINT;		/* 自然なサイズの符号無し整数 */
  
! typedef bool_t			BOOL;		/* 真偽値 */
  
! typedef	intptr_t		VP_INT;		/* ポインタまたは符号付き整数 */
  
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ITRON仕様共通定数
   */
! #define	TRUE		true			/* 真 */
! #define	FALSE		false			/* 偽 */
  
  /*
!  *  オブジェクト属性の定義
   */
! #define TA_HLNG			UINT_C(0x00)	/* 高級言語用インタフェース */
! #define TA_TFIFO		UINT_C(0x00)	/* タスクの待ち行列をFIFO順に */
! #define TA_MFIFO		UINT_C(0x00)	/* メッセージキューをFIFO順に */
! #define TA_WSGL			UINT_C(0x00)	/* 待ちタスクは1つのみ */
  
  /*
!  *  ネスト回数の最大値
   */
! #define TMAX_SUSCNT		UINT_C(1)		/* 強制待ち要求ネスト数の最大値 */
  
  /*
!  *  強制待ち状態からの強制再開
   */
  #define frsm_tsk(tskid)		rsm_tsk(tskid)
  
diff -cr --new-file 1.9.1/asp/include/kernel.h ASPs/asp/include/kernel.h
*** 1.9.1/asp/include/kernel.h	Sun Aug 17 21:42:45 2014
--- ASPs/asp/include/kernel.h	Fri Dec  9 13:54:03 2022
***************
*** 8,57 ****
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥ ɸإåե
   *
!  *  TOPPERS/ASPͥ뤬ݡȤ륵ӥȡɬפʥǡ
!  *  ޥޤإåե롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   *
!  *  Υե򥤥󥯥롼ɤ˥󥯥롼ɤƤ٤ե
!  *  Ϥʤ
   */
  
  #ifndef TOPPERS_KERNEL_H
--- 8,57 ----
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: kernel.h 2655 2014-08-17 12:42:44Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル 標準ヘッダファイル
   *
!  *  TOPPERS/ASPカーネルがサポートするサービスコールの宣言と，必要なデー
!  *  タ型，定数，マクロの定義を含むヘッダファイル．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   *
!  *  このファイルをインクルードする前にインクルードしておくべきファイル
!  *  はない．
   */
  
  #ifndef TOPPERS_KERNEL_H
***************
*** 62,93 ****
  #endif
  
  /*
!  *	TOPPERS̤Υǡޥ
   */
  #include <t_stddef.h>
  
  /*
!  *  åȰ¸
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ǡ
   */
  
  /*
!  *  ӥåȥѥ䥪ֹ֥η
   */
! typedef	uint_t		TEXPTN;		/* 㳰װΥӥåȥѥ */
! typedef	uint_t		FLGPTN;		/* ٥ȥե饰Υӥåȥѥ */
! typedef	uint_t		INTNO;		/* ֹ */
! typedef	uint_t		INHNO;		/* ߥϥɥֹ */
! typedef	uint_t		EXCNO;		/* CPU㳰ϥɥֹ */
  
  /*
!  *  ñ̤η
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
--- 62,93 ----
  #endif
  
  /*
!  *	TOPPERS共通のデータ型・定数・マクロ
   */
  #include <t_stddef.h>
  
  /*
!  *  ターゲット依存部
   */
  #include "target_kernel.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  データ型の定義
   */
  
  /*
!  *  ビットパターンやオブジェクト番号の型定義
   */
! typedef	uint_t		TEXPTN;		/* タスク例外要因のビットパターン */
! typedef	uint_t		FLGPTN;		/* イベントフラグのビットパターン */
! typedef	uint_t		INTNO;		/* 割込み番号 */
! typedef	uint_t		INHNO;		/* 割込みハンドラ番号 */
! typedef	uint_t		EXCNO;		/* CPU例外ハンドラ番号 */
  
  /*
!  *  処理単位の型定義
   */
  typedef void	(*TASK)(intptr_t exinf);
  typedef void	(*TEXRTN)(TEXPTN texptn, intptr_t exinf);
***************
*** 100,202 ****
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  ΰݤΤη
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* åΰݤ뤿η */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* Ĺסΰݤ뤿η */
  
  /*
!  *  åإåη
   */
! typedef	struct t_msg {			/* ᡼ܥåΥåإå */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* ͥդåإå */
! 	T_MSG	msgque;				/* åإå */
! 	PRI		msgpri;				/* åͥ */
  } T_MSG_PRI;
  
  /*
!  *  ѥåȷ
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/*  */
! 	PRI		tskpri;		/* θͥ */
! 	PRI		tskbpri;	/* Υ١ͥ */
! 	STAT	tskwait;	/* Ԥװ */
! 	ID		wobjid;		/* ԤоݤΥ֥ȤID */
! 	TMO		lefttmo;	/* ॢȤޤǤλ */
! 	uint_t	actcnt;		/* ư׵ᥭ塼󥰿 */
! 	uint_t	wupcnt;		/* ׵ᥭ塼󥰿 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* 㳰ξ */
! 	TEXPTN	pndptn;		/* α㳰װ */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* ޥեԤƬΥIDֹ */
! 	uint_t	semcnt;		/* ޥեθߤλ񸻿 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* ٥ȥե饰ԤƬΥIDֹ */
! 	FLGPTN	flgptn;		/* ٥ȥե饰θߤΥӥåȥѥ */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* ǡ塼ԤƬΥIDֹ */
! 	ID		rtskid;		/* ǡ塼μԤƬΥIDֹ */
! 	uint_t	sdtqcnt;	/* ǡ塼ΰ˳ǼƤǡο */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* ͥ٥ǡ塼ԤƬΥ
! 						   IDֹ */
! 	ID		rtskid;		/* ͥ٥ǡ塼μԤƬΥ
! 						   IDֹ */
! 	uint_t	spdqcnt;	/* ͥ٥ǡ塼ΰ˳ǼƤǡ
! 						   ο */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* ᡼ܥåԤƬΥIDֹ */
! 	T_MSG	*pk_msg;	/* å塼ƬˤĤʤ줿å
! 						   Ƭ */
  } T_RMBX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* ĹסԤƬΥ
! 						   IDֹ */
! 	uint_t	fblkcnt;	/* Ĺסΰζΰ˳
! 						   դ뤳ȤǤĹ֥åο */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* ϥɥư */
! 	RELTIM	lefttim;	/* ˼ϥɥưޤǤл */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* 顼ϥɥư */
! 	RELTIM	lefttim;	/* 顼ϥɥưޤǤл */
  } T_RALM;
  
  /*
!  *  ӥ
   */
  
  /*
!  *  ǽ
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
--- 100,202 ----
  typedef void	(*TERRTN)(intptr_t exinf);
  
  /*
!  *  メモリ領域確保のための型定義
   */
  #ifndef TOPPERS_STK_T
  #define TOPPERS_STK_T	intptr_t
  #endif /* TOPPERS_STK_T */
! typedef	TOPPERS_STK_T	STK_T;	/* スタック領域を確保するための型 */
  
  #ifndef TOPPERS_MPF_T
  #define TOPPERS_MPF_T	intptr_t
  #endif /* TOPPERS_MPF_T */
! typedef	TOPPERS_MPF_T	MPF_T;	/* 固定長メモリプール領域を確保するための型 */
  
  /*
!  *  メッセージヘッダの型定義
   */
! typedef	struct t_msg {			/* メールボックスのメッセージヘッダ */
  	struct t_msg	*pk_next;
  } T_MSG;
  
! typedef	struct t_msg_pri {		/* 優先度付きメッセージヘッダ */
! 	T_MSG	msgque;				/* メッセージヘッダ */
! 	PRI		msgpri;				/* メッセージ優先度 */
  } T_MSG_PRI;
  
  /*
!  *  パケット形式の定義
   */
  typedef struct t_rtsk {
! 	STAT	tskstat;	/* タスク状態 */
! 	PRI		tskpri;		/* タスクの現在優先度 */
! 	PRI		tskbpri;	/* タスクのベース優先度 */
! 	STAT	tskwait;	/* 待ち要因 */
! 	ID		wobjid;		/* 待ち対象のオブジェクトのID */
! 	TMO		lefttmo;	/* タイムアウトするまでの時間 */
! 	uint_t	actcnt;		/* 起動要求キューイング数 */
! 	uint_t	wupcnt;		/* 起床要求キューイング数 */
  } T_RTSK;
  
  typedef struct t_rtex {
! 	STAT	texstat;	/* タスク例外処理の状態 */
! 	TEXPTN	pndptn;		/* 保留例外要因 */
  } T_RTEX;
  
  typedef struct t_rsem {
! 	ID		wtskid;		/* セマフォの待ち行列の先頭のタスクのID番号 */
! 	uint_t	semcnt;		/* セマフォの現在の資源数 */
  } T_RSEM;
  
  typedef struct t_rflg {
! 	ID		wtskid;		/* イベントフラグの待ち行列の先頭のタスクのID番号 */
! 	FLGPTN	flgptn;		/* イベントフラグの現在のビットパターン */
  } T_RFLG;
  
  typedef struct t_rdtq {
! 	ID		stskid;		/* データキューの送信待ち行列の先頭のタスクのID番号 */
! 	ID		rtskid;		/* データキューの受信待ち行列の先頭のタスクのID番号 */
! 	uint_t	sdtqcnt;	/* データキュー管理領域に格納されているデータの数 */
  } T_RDTQ;
  
  typedef struct t_rpdq {
! 	ID		stskid;		/* 優先度データキューの送信待ち行列の先頭のタスク
! 						   のID番号 */
! 	ID		rtskid;		/* 優先度データキューの受信待ち行列の先頭のタスク
! 						   のID番号 */
! 	uint_t	spdqcnt;	/* 優先度データキュー管理領域に格納されているデー
! 						   タの数 */
  } T_RPDQ;
  
  typedef struct t_rmbx {
! 	ID		wtskid;		/* メールボックスの待ち行列の先頭のタスクのID番号 */
! 	T_MSG	*pk_msg;	/* メッセージキューの先頭につながれたメッセージ
! 						   の先頭番地 */
  } T_RMBX;
  
  typedef struct t_rmpf {
! 	ID		wtskid;		/* 固定長メモリプールの待ち行列の先頭のタスクの
! 						   ID番号 */
! 	uint_t	fblkcnt;	/* 固定長メモリプール領域の空きメモリ領域に割り
! 						   付けることができる固定長メモリブロックの数 */
  } T_RMPF;
  
  typedef struct t_rcyc {
! 	STAT	cycstat;	/* 周期ハンドラの動作状態 */
! 	RELTIM	lefttim;	/* 次に周期ハンドラを起動する時刻までの相対時間 */
  } T_RCYC;
  
  typedef struct t_ralm {
! 	STAT	almstat;	/* アラームハンドラの動作状態 */
! 	RELTIM	lefttim;	/* アラームハンドラを起動する時刻までの相対時間 */
  } T_RALM;
  
  /*
!  *  サービスコールの宣言
   */
  
  /*
!  *  タスク管理機能
   */
  extern ER		act_tsk(ID tskid) throw();
  extern ER		iact_tsk(ID tskid) throw();
***************
*** 209,215 ****
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  °Ʊǽ
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
--- 209,215 ----
  extern ER		ref_tsk(ID tskid, T_RTSK *pk_rtsk) throw();
  
  /*
!  *  タスク付属同期機能
   */
  extern ER		slp_tsk(void) throw();
  extern ER		tslp_tsk(TMO tmout) throw();
***************
*** 223,229 ****
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  㳰ǽ
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
--- 223,229 ----
  extern ER		dly_tsk(RELTIM dlytim) throw();
  
  /*
!  *  タスク例外処理機能
   */
  extern ER		ras_tex(ID tskid, TEXPTN rasptn) throw();
  extern ER		iras_tex(ID tskid, TEXPTN rasptn) throw();
***************
*** 233,239 ****
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  Ʊ̿ǽ
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
--- 233,239 ----
  extern ER		ref_tex(ID tskid, T_RTEX *pk_rtex) throw();
  
  /*
!  *  同期・通信機能
   */
  extern ER		sig_sem(ID semid) throw();
  extern ER		isig_sem(ID semid) throw();
***************
*** 287,293 ****
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  סǽ
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
--- 287,293 ----
  extern ER		ref_mbx(ID mbxid, T_RMBX *pk_rmbx) throw();
  
  /*
!  *  メモリプール管理機能
   */
  extern ER		get_mpf(ID mpfid, void **p_blk) throw();
  extern ER		pget_mpf(ID mpfid, void **p_blk) throw();
***************
*** 297,303 ****
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  ִǽ
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
--- 297,303 ----
  extern ER		ref_mpf(ID mpfid, T_RMPF *pk_rmpf) throw();
  
  /*
!  *  時間管理機能
   */
  extern ER		get_tim(SYSTIM *p_systim) throw();
  extern ER		get_utm(SYSUTM *p_sysutm) throw();
***************
*** 313,319 ****
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  ƥִǽ
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
--- 313,319 ----
  extern ER		ref_alm(ID almid, T_RALM *pk_ralm) throw();
  
  /*
!  *  システム状態管理機能
   */
  extern ER		rot_rdq(PRI tskpri) throw();
  extern ER		irot_rdq(PRI tskpri) throw();
***************
*** 333,339 ****
  extern ER		ext_ker(void) throw();
  
  /*
!  *  ߴǽ
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
--- 333,339 ----
  extern ER		ext_ker(void) throw();
  
  /*
!  *  割込み管理機能
   */
  extern ER		dis_int(INTNO intno) throw();
  extern ER		ena_int(INTNO intno) throw();
***************
*** 341,347 ****
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU㳰ǽ
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
--- 341,347 ----
  extern ER		get_ipm(PRI *p_intpri) throw();
  
  /*
!  *  CPU例外管理機能
   */
  extern bool_t	xsns_dpn(void *p_excinf) throw();
  extern bool_t	xsns_xpn(void *p_excinf) throw();
***************
*** 349,479 ****
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ֥°
   */
! #define TA_ACT			UINT_C(0x02)	/* ư줿֤ */
  
! #define TA_TPRI			UINT_C(0x01)	/* Ԥͥٽ */
! #define TA_MPRI			UINT_C(0x02)	/* å塼ͥٽ */
  
! #define TA_WMUL			UINT_C(0x02)	/* ʣԤ */
! #define TA_CLR			UINT_C(0x04)	/* ٥ȥե饰Υꥢ */
  
! #define TA_STA			UINT_C(0x02)	/* ϥɥư֤ */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* ͥγ */
  
! #define TA_ENAINT		UINT_C(0x01)	/* ׵ػߥե饰򥯥ꥢ */
! #define TA_EDGE			UINT_C(0x02)	/* åȥꥬ */
  
  /*
!  *  ӥư⡼ɤ
   */
! #define TWF_ORW			UINT_C(0x01)	/* ٥ȥե饰ORԤ */
! #define TWF_ANDW		UINT_C(0x02)	/* ٥ȥե饰ANDԤ */
  
  /*
!  *  ֥Ȥξ֤
   */
! #define TTS_RUN			UINT_C(0x01)	/* ¹Ծ */
! #define TTS_RDY			UINT_C(0x02)	/* ¹Բǽ */
! #define TTS_WAI			UINT_C(0x04)	/* Ԥ */
! #define TTS_SUS			UINT_C(0x08)	/* Ԥ */
! #define TTS_WAS			UINT_C(0x0c)	/* Ԥ */
! #define TTS_DMT			UINT_C(0x10)	/* ٻ߾ */
  
! #define TTW_SLP			UINT_C(0x0001)	/* Ԥ */
! #define TTW_DLY			UINT_C(0x0002)	/* ַвԤ */
! #define TTW_SEM			UINT_C(0x0004)	/* ޥեλ񸻳Ԥ */
! #define TTW_FLG			UINT_C(0x0008)	/* ٥ȥե饰Ԥ */
! #define TTW_SDTQ		UINT_C(0x0010)	/* ǡ塼ؤԤ */
! #define TTW_RDTQ		UINT_C(0x0020)	/* ǡ塼μԤ */
! #define TTW_SPDQ		UINT_C(0x0100)	/* ͥ٥ǡ塼ؤԤ */
! #define TTW_RPDQ		UINT_C(0x0200)	/* ͥ٥ǡ塼μԤ */
! #define TTW_MBX			UINT_C(0x0040)	/* ᡼ܥåμԤ */
! #define TTW_MPF			UINT_C(0x2000)	/* Ĺ֥åγԤ */
  
! #define TTEX_ENA		UINT_C(0x01)	/* 㳰ľ */
! #define TTEX_DIS		UINT_C(0x02)	/* 㳰ػ߾ */
  
! #define TCYC_STP		UINT_C(0x01)	/* ϥɥ餬ưƤʤ */
! #define TCYC_STA		UINT_C(0x02)	/* ϥɥ餬ưƤ */
  
! #define TALM_STP		UINT_C(0x01)	/* 顼ϥɥ餬ưƤʤ */
! #define TALM_STA		UINT_C(0x02)	/* 顼ϥɥ餬ưƤ */
  
  /*
!  *  ¾
   */
! #define TSK_SELF		0			/*  */
! #define TSK_NONE		0			/* 륿ʤ */
  
! #define TPRI_SELF		0			/* Υ١ͥ */
! #define TPRI_INI		0			/* εưͥ */
  
! #define TIPM_ENAALL		0			/* ͥ٥ޥ */
  
  /*
!  *  ȥޥ
   */
  
  /*
!  *  ݡȤ뵡ǽ
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmݡȤƤ */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
  /*
!  *  ͥ٤ϰ
   */
! #define TMIN_TPRI		1			/* ͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_TPRI		16			/* ͥ٤κ͡ʺ͡*/
! #define TMIN_DPRI		1			/* ǡͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_DPRI		16			/* ǡͥ٤κ͡ʺ͡*/
! #define TMIN_MPRI		1			/* åͥ٤κǾ͡ʺǹ͡*/
! #define TMAX_MPRI		16			/* åͥ٤κ͡ʺ͡*/
! #define TMIN_ISRPRI		1			/* ߥӥ롼ͥ٤κǾ */
! #define TMAX_ISRPRI		16			/* ߥӥ롼ͥ٤κ */
  
  /*
!  *  С
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* ͥΥ᡼ */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* ͥμֹ */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* ͥͤΥСֹ */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* ͥΥСֹ */
  
  /*
!  *  塼󥰲κ
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* ư׵ᥭ塼󥰿κ */
! #define TMAX_WUPCNT		UINT_C(1)		/* ׵ᥭ塼󥰿κ */
  
  /*
!  *  ӥåȥѥΥӥåȿ
   */
! #ifndef TBIT_TEXPTN					/* 㳰װΥӥåȿ */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* ٥ȥե饰Υӥåȿ */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  ΰݤΤΥޥ
   *
!  *  ʲTOPPERS_COUNT_SZTOPPERS_ROUND_SZϡunit2ζҾǤ
!  *  뤳ȤꤷƤ롥
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
--- 349,479 ----
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  オブジェクト属性の定義
   */
! #define TA_ACT			UINT_C(0x02)	/* タスクを起動された状態で生成 */
  
! #define TA_TPRI			UINT_C(0x01)	/* タスクの待ち行列を優先度順に */
! #define TA_MPRI			UINT_C(0x02)	/* メッセージキューを優先度順に */
  
! #define TA_WMUL			UINT_C(0x02)	/* 複数の待ちタスク */
! #define TA_CLR			UINT_C(0x04)	/* イベントフラグのクリア指定 */
  
! #define TA_STA			UINT_C(0x02)	/* 周期ハンドラを動作状態で生成 */
  
! #define TA_NONKERNEL	UINT_C(0x02)	/* カーネル管理外の割込み */
  
! #define TA_ENAINT		UINT_C(0x01)	/* 割込み要求禁止フラグをクリア */
! #define TA_EDGE			UINT_C(0x02)	/* エッジトリガ */
  
  /*
!  *  サービスコールの動作モードの定義
   */
! #define TWF_ORW			UINT_C(0x01)	/* イベントフラグのOR待ち */
! #define TWF_ANDW		UINT_C(0x02)	/* イベントフラグのAND待ち */
  
  /*
!  *  オブジェクトの状態の定義
   */
! #define TTS_RUN			UINT_C(0x01)	/* 実行状態 */
! #define TTS_RDY			UINT_C(0x02)	/* 実行可能状態 */
! #define TTS_WAI			UINT_C(0x04)	/* 待ち状態 */
! #define TTS_SUS			UINT_C(0x08)	/* 強制待ち状態 */
! #define TTS_WAS			UINT_C(0x0c)	/* 二重待ち状態 */
! #define TTS_DMT			UINT_C(0x10)	/* 休止状態 */
  
! #define TTW_SLP			UINT_C(0x0001)	/* 起床待ち */
! #define TTW_DLY			UINT_C(0x0002)	/* 時間経過待ち */
! #define TTW_SEM			UINT_C(0x0004)	/* セマフォの資源獲得待ち */
! #define TTW_FLG			UINT_C(0x0008)	/* イベントフラグ待ち */
! #define TTW_SDTQ		UINT_C(0x0010)	/* データキューへの送信待ち */
! #define TTW_RDTQ		UINT_C(0x0020)	/* データキューからの受信待ち */
! #define TTW_SPDQ		UINT_C(0x0100)	/* 優先度データキューへの送信待ち */
! #define TTW_RPDQ		UINT_C(0x0200)	/* 優先度データキューからの受信待ち */
! #define TTW_MBX			UINT_C(0x0040)	/* メールボックスからの受信待ち */
! #define TTW_MPF			UINT_C(0x2000)	/* 固定長メモリブロックの獲得待ち */
  
! #define TTEX_ENA		UINT_C(0x01)	/* タスク例外処理許可状態 */
! #define TTEX_DIS		UINT_C(0x02)	/* タスク例外処理禁止状態 */
  
! #define TCYC_STP		UINT_C(0x01)	/* 周期ハンドラが動作していない */
! #define TCYC_STA		UINT_C(0x02)	/* 周期ハンドラが動作している */
  
! #define TALM_STP		UINT_C(0x01)	/* アラームハンドラが動作していない */
! #define TALM_STA		UINT_C(0x02)	/* アラームハンドラが動作している */
  
  /*
!  *  その他の定数の定義
   */
! #define TSK_SELF		0			/* 自タスク指定 */
! #define TSK_NONE		0			/* 該当するタスクがない */
  
! #define TPRI_SELF		0			/* 自タスクのベース優先度 */
! #define TPRI_INI		0			/* タスクの起動時優先度 */
  
! #define TIPM_ENAALL		0			/* 割込み優先度マスク全解除 */
  
  /*
!  *  構成定数とマクロ
   */
  
  /*
!  *  サポートする機能
   */
  #ifdef TOPPERS_TARGET_SUPPORT_DIS_INT
! #define TOPPERS_SUPPORT_DIS_INT			/* dis_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_DIS_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_ENA_INT
! #define TOPPERS_SUPPORT_ENA_INT			/* ena_intがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_ENA_INT */
  
  #ifdef TOPPERS_TARGET_SUPPORT_GET_UTM
! #define TOPPERS_SUPPORT_GET_UTM			/* get_utmがサポートされている */
  #endif /* TOPPERS_TARGET_SUPPORT_GET_UTM */
  
  /*
!  *  優先度の範囲
   */
! #define TMIN_TPRI		1			/* タスク優先度の最小値（最高値）*/
! #define TMAX_TPRI		16			/* タスク優先度の最大値（最低値）*/
! #define TMIN_DPRI		1			/* データ優先度の最小値（最高値）*/
! #define TMAX_DPRI		16			/* データ優先度の最大値（最低値）*/
! #define TMIN_MPRI		1			/* メッセージ優先度の最小値（最高値）*/
! #define TMAX_MPRI		16			/* メッセージ優先度の最大値（最低値）*/
! #define TMIN_ISRPRI		1			/* 割込みサービスルーチン優先度の最小値 */
! #define TMAX_ISRPRI		16			/* 割込みサービスルーチン優先度の最大値 */
  
  /*
!  *  バージョン情報
   */
! #define TKERNEL_MAKER	UINT_C(0x0118)	/* カーネルのメーカーコード */
! #define TKERNEL_PRID	UINT_C(0x0007)	/* カーネルの識別番号 */
! #define TKERNEL_SPVER	UINT_C(0xf517)	/* カーネル仕様のバージョン番号 */
! #define TKERNEL_PRVER	UINT_C(0x1091)	/* カーネルのバージョン番号 */
  
  /*
!  *  キューイング回数の最大値
   */
! #define TMAX_ACTCNT		UINT_C(1)		/* 起動要求キューイング数の最大値 */
! #define TMAX_WUPCNT		UINT_C(1)		/* 起床要求キューイング数の最大値 */
  
  /*
!  *  ビットパターンのビット数
   */
! #ifndef TBIT_TEXPTN					/* タスク例外要因のビット数 */
  #define TBIT_TEXPTN		(sizeof(TEXPTN) * CHAR_BIT)
  #endif /* TBIT_TEXPTN */
  
! #ifndef TBIT_FLGPTN					/* イベントフラグのビット数 */
  #define TBIT_FLGPTN		(sizeof(FLGPTN) * CHAR_BIT)
  #endif /* TBIT_FLGPTN */
  
  /*
!  *  メモリ領域確保のためのマクロ
   *
!  *  以下のTOPPERS_COUNT_SZとTOPPERS_ROUND_SZの定義は，unitが2の巾乗であ
!  *  ることを仮定している．
   */
  #ifndef TOPPERS_COUNT_SZ
  #define TOPPERS_COUNT_SZ(sz, unit)	(((sz) + (unit) - 1) / (unit))
***************
*** 489,497 ****
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  ¾ι
   */
! #define TMAX_MAXSEM		UINT_MAX	/* ޥեκ񸻿κ */
  
  #ifdef __cplusplus
  }
--- 489,497 ----
  #define ROUND_MPF_T(blksz)	TOPPERS_ROUND_SZ(blksz, sizeof(MPF_T))
  
  /*
!  *  その他の構成定数
   */
! #define TMAX_MAXSEM		UINT_MAX	/* セマフォの最大資源数の最大値 */
  
  #ifdef __cplusplus
  }
diff -cr --new-file 1.9.1/asp/include/log_output.h ASPs/asp/include/log_output.h
*** 1.9.1/asp/include/log_output.h	Sat Aug 27 07:39:16 2011
--- ASPs/asp/include/log_output.h	Fri Dec  9 13:54:03 2022
***************
*** 7,46 ****
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: log_output.h 2246 2011-08-26 22:39:15Z ertl-hiro $
   */
  
  /*
!  *		ƥΥեޥåȽ
   */
  
  #ifndef TOPPERS_LOG_OUTPUT_H
--- 7,46 ----
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: log_output.h 2246 2011-08-26 22:39:15Z ertl-hiro $
   */
  
  /*
!  *		システムログのフォーマット出力
   */
  
  #ifndef TOPPERS_LOG_OUTPUT_H
***************
*** 53,79 ****
  #include <t_syslog.h>
  
  /*
!  *  ʸ
   *
!  *  formatǻꤵեޥåȵҤp_argsǻꤵ󤫤
!  *  å1ʸϴؿputcѤƽϤ롥
   */
  extern void	syslog_printf(const char *format, const intptr_t *p_args,
  										void (*putc)(char)) throw();
  
  /*
!  *  ν
   *
!  *  p_syslogǻꤵʸ1ʸϴؿputc
!  *  ƽϤ롥
   */
  extern void	syslog_print(const SYSLOG *p_syslog, void (*putc)(char)) throw();
  
  /*
!  *  Ӽåʸ
   *
!  *  lostlogĤΥ󤬼줿ݤΥå1ʸϴؿputc
!  *  ѤƽϤ롥
   */
  extern void	syslog_lostmsg(uint_t lostlog, void (*putc)(char)) throw();
  
--- 53,79 ----
  #include <t_syslog.h>
  
  /*
!  *  文字列整形出力
   *
!  *  formatで指定されるフォーマット記述とp_argsで指定される引数列から作
!  *  成したメッセージを，1文字出力関数putcを用いて出力する．
   */
  extern void	syslog_printf(const char *format, const intptr_t *p_args,
  										void (*putc)(char)) throw();
  
  /*
!  *  ログ情報の出力
   *
!  *  p_syslogで指定されるログ情報を文字列に整形し，1文字出力関数putcを用
!  *  いて出力する．
   */
  extern void	syslog_print(const SYSLOG *p_syslog, void (*putc)(char)) throw();
  
  /*
!  *  ログ情報喪失メッセージ文字列
   *
!  *  lostlog個のログ情報が失われた旨のメッセージを，1文字出力関数putcを
!  *  用いて出力する．
   */
  extern void	syslog_lostmsg(uint_t lostlog, void (*putc)(char)) throw();
  
diff -cr --new-file 1.9.1/asp/include/queue.h ASPs/asp/include/queue.h
*** 1.9.1/asp/include/queue.h	Sat Aug 27 07:59:56 2011
--- ASPs/asp/include/queue.h	Fri Dec  9 13:54:03 2022
***************
*** 7,53 ****
   *  Copyright (C) 2006-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: queue.h 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		塼饤֥
   *
!  *  Υ塼饤֥Ǥϡ塼إåޤ󥰹¤Υ֥
!  *  󥯥塼򰷤Ūˤϡ塼إåμȥϥ塼
!  *  ƬΥȥꡤȥϥ塼ΥȥȤ롥ޤ
!  *  塼ƬΥȥȥȡ塼Υȥμ
!  *  ȥϡ塼إåȤ롥Υ塼ϡȥꡤȥ
!  *  ⼫ʬȤؤ塼إåǤ魯
   */
  
  #ifndef	TOPPERS_QUEUE_H
--- 7,53 ----
   *  Copyright (C) 2006-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: queue.h 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		キュー操作ライブラリ
   *
!  *  このキュー操作ライブラリでは，キューヘッダを含むリング構造のダブル
!  *  リンクキューを扱う．具体的には，キューヘッダの次エントリはキューの
!  *  先頭のエントリ，前エントリはキューの末尾のエントリとする．また，キ
!  *  ューの先頭のエントリの前エントリと，キューの末尾のエントリの次エン
!  *  トリは，キューヘッダとする．空のキューは，次エントリ，前エントリと
!  *  も自分自身を指すキューヘッダであらわす．
   */
  
  #ifndef	TOPPERS_QUEUE_H
***************
*** 58,74 ****
  #endif
  
  /*
!  *  塼Υǡ¤
   */
  typedef struct queue {
! 	struct queue *p_next;		/* ȥؤΥݥ */
! 	struct queue *p_prev;		/* ȥؤΥݥ */
  } QUEUE;
  
  /*
!  *  塼ν
   *
!  *  p_queueˤϥ塼إåꤹ롥
   */
  Inline void
  queue_initialize(QUEUE *p_queue)
--- 58,74 ----
  #endif
  
  /*
!  *  キューのデータ構造の定義
   */
  typedef struct queue {
! 	struct queue *p_next;		/* 次エントリへのポインタ */
! 	struct queue *p_prev;		/* 前エントリへのポインタ */
  } QUEUE;
  
  /*
!  *  キューの初期化
   *
!  *  p_queueにはキューヘッダを指定する．
   */
  Inline void
  queue_initialize(QUEUE *p_queue)
***************
*** 78,87 ****
  }
  
  /*
!  *  塼ȥؤ
   *
!  *  p_queuep_entry롥p_queue˥塼إåꤷ
!  *  ˤϡ塼p_entry뤳Ȥˤʤ롥
   */
  Inline void
  queue_insert_prev(QUEUE *p_queue, QUEUE *p_entry)
--- 78,87 ----
  }
  
  /*
!  *  キューの前エントリへの挿入
   *
!  *  p_queueの前にp_entryを挿入する．p_queueにキューヘッダを指定した場
!  *  合には，キューの末尾にp_entryを挿入することになる．
   */
  Inline void
  queue_insert_prev(QUEUE *p_queue, QUEUE *p_entry)
***************
*** 93,102 ****
  }
  
  /*
!  *  塼μȥؤ
   *
!  *  p_queueμp_entry롥p_queue˥塼إåꤷ
!  *  ˤϡ塼Ƭp_entry뤳Ȥˤʤ롥
   */
  Inline void
  queue_insert_next(QUEUE *p_queue, QUEUE *p_entry)
--- 93,102 ----
  }
  
  /*
!  *  キューの次エントリへの挿入
   *
!  *  p_queueの次にp_entryを挿入する．p_queueにキューヘッダを指定した場
!  *  合には，キューの先頭にp_entryを挿入することになる．
   */
  Inline void
  queue_insert_next(QUEUE *p_queue, QUEUE *p_entry)
***************
*** 108,116 ****
  }
  
  /*
!  *  ȥκ
   *
!  *  p_entry򥭥塼롥
   */
  Inline void
  queue_delete(QUEUE *p_entry)
--- 108,116 ----
  }
  
  /*
!  *  エントリの削除
   *
!  *  p_entryをキューから削除する．
   */
  Inline void
  queue_delete(QUEUE *p_entry)
***************
*** 120,131 ****
  }
  
  /*
!  *  塼μȥμФ
   *
!  *  p_queueμȥ򥭥塼ȥ֤
!  *  p_queue˥塼إåꤷˤϡ塼ƬΥȥ
!  *  ФȤˤʤ롥p_queue˶Υ塼ꤷƸƤӽФƤϤʤ
!  *  ʤ
   */
  Inline QUEUE *
  queue_delete_next(QUEUE *p_queue)
--- 120,131 ----
  }
  
  /*
!  *  キューの次エントリの取出し
   *
!  *  p_queueの次エントリをキューから削除し，削除したエントリを返す．
!  *  p_queueにキューヘッダを指定した場合には，キューの先頭のエントリを
!  *  取り出すことになる．p_queueに空のキューを指定して呼び出してはなら
!  *  ない．
   */
  Inline QUEUE *
  queue_delete_next(QUEUE *p_queue)
***************
*** 140,148 ****
  }
  
  /*
!  *  塼ɤΥå
   *
!  *  p_queueˤϥ塼إåꤹ롥
   */
  Inline bool_t
  queue_empty(QUEUE *p_queue)
--- 140,148 ----
  }
  
  /*
!  *  キューが空かどうかのチェック
   *
!  *  p_queueにはキューヘッダを指定する．
   */
  Inline bool_t
  queue_empty(QUEUE *p_queue)
diff -cr --new-file 1.9.1/asp/include/sil.h ASPs/asp/include/sil.h
*** 1.9.1/asp/include/sil.h	Sat Aug 27 06:00:20 2011
--- ASPs/asp/include/sil.h	Fri Dec  9 13:54:03 2022
***************
*** 7,56 ****
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: sil.h 2242 2011-08-26 21:00:19Z ertl-hiro $
   */
  
  /*
!  *		ƥ।󥿥ե쥤
   *
!  *  ƥ।󥿥ե쥤Υӥȥޥ
!  *  ɤޤإåե롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤȤǡޥʳεҤ
!  *  ȤǤ롥
   *
!  *  Υե򥤥󥯥롼ɤ˥󥯥롼ɤƤ٤ե
!  *  Ϥʤ
   */
  
  #ifndef TOPPERS_SIL_H
--- 7,56 ----
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: sil.h 2242 2011-08-26 21:00:19Z ertl-hiro $
   */
  
  /*
!  *		システムインタフェースレイヤ
   *
!  *  システムインタフェースレイヤのサービスコールの定義・宣言とマクロな
!  *  どの定義を含むヘッダファイル．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておくことで，マクロ定義以外の記述を
!  *  除くことができる．
   *
!  *  このファイルをインクルードする前にインクルードしておくべきファイル
!  *  はない．
   */
  
  #ifndef TOPPERS_SIL_H
***************
*** 61,91 ****
  #endif
  
  /*
!  *	TOPPERS̤Υǡޥ
   */
  #include <t_stddef.h>
  
  /*
!  *  åȰ¸
   */
  #include "target_sil.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ߥå֤
   *
!  *  SIL_PRE_LOCSIL_LOC_INT()SIL_UNL_INT()ϡåȰ¸
!  *  դ롥ǥեȤѰդƤʤ
   */
  
  /*
!  *  Ԥ
   */
  extern void	sil_dly_nse(ulong_t dlytim) throw();
  
  /*
!  *  ǥȿž
   */
  #ifndef TOPPERS_SIL_REV_ENDIAN_UINT16
  #define	TOPPERS_SIL_REV_ENDIAN_UINT16(data) \
--- 61,91 ----
  #endif
  
  /*
!  *	TOPPERS共通のデータ型・定数・マクロ
   */
  #include <t_stddef.h>
  
  /*
!  *  ターゲット依存部
   */
  #include "target_sil.h"
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  全割込みロック状態の制御
   *
!  *  SIL_PRE_LOC，SIL_LOC_INT()，SIL_UNL_INT()は，ターゲット依存部で用
!  *  意する．デフォルトの定義は用意していない．
   */
  
  /*
!  *  微少時間待ち
   */
  extern void	sil_dly_nse(ulong_t dlytim) throw();
  
  /*
!  *  エンディアンの反転
   */
  #ifndef TOPPERS_SIL_REV_ENDIAN_UINT16
  #define	TOPPERS_SIL_REV_ENDIAN_UINT16(data) \
***************
*** 99,110 ****
  #endif /* TOPPERS_SIL_REV_ENDIAN_UINT32 */
  
  /*
!  *  ֥ؿ
   */
  #ifndef TOPPERS_OMIT_SIL_ACCESS
  
  /*
!  *  8ӥåñ̤ɽФ
   */
  #ifdef UINT8_MAX
  
--- 99,110 ----
  #endif /* TOPPERS_SIL_REV_ENDIAN_UINT32 */
  
  /*
!  *  メモリ空間アクセス関数
   */
  #ifndef TOPPERS_OMIT_SIL_ACCESS
  
  /*
!  *  8ビット単位の読出し／書込み
   */
  #ifdef UINT8_MAX
  
***************
*** 126,132 ****
  #endif /* UINT8_MAX */
  
  /*
!  *  16ӥåñ̤ɽФ
   */
  
  Inline uint16_t
--- 126,132 ----
  #endif /* UINT8_MAX */
  
  /*
!  *  16ビット単位の読出し／書込み
   */
  
  Inline uint16_t
***************
*** 144,150 ****
  	*((volatile uint16_t *) mem) = data;
  }
  
! #ifdef SIL_ENDIAN_BIG			/* ӥåǥץå */
  
  #define	sil_reh_bem(mem)		sil_reh_mem(mem)
  #define	sil_wrh_bem(mem, data)	sil_wrh_mem(mem, data)
--- 144,150 ----
  	*((volatile uint16_t *) mem) = data;
  }
  
! #ifdef SIL_ENDIAN_BIG			/* ビッグエンディアンプロセッサ */
  
  #define	sil_reh_bem(mem)		sil_reh_mem(mem)
  #define	sil_wrh_bem(mem, data)	sil_wrh_mem(mem, data)
***************
*** 171,177 ****
  
  #endif /* TOPPERS_OMIT_SIL_WRH_LEM */
  #else /* SIL_ENDIAN_BIG */
! #ifdef SIL_ENDIAN_LITTLE		/* ȥ륨ǥץå */
  
  #define	sil_reh_lem(mem)		sil_reh_mem(mem)
  #define	sil_wrh_lem(mem, data)	sil_wrh_mem(mem, data)
--- 171,177 ----
  
  #endif /* TOPPERS_OMIT_SIL_WRH_LEM */
  #else /* SIL_ENDIAN_BIG */
! #ifdef SIL_ENDIAN_LITTLE		/* リトルエンディアンプロセッサ */
  
  #define	sil_reh_lem(mem)		sil_reh_mem(mem)
  #define	sil_wrh_lem(mem, data)	sil_wrh_mem(mem, data)
***************
*** 205,211 ****
  #endif /* SIL_ENDIAN_BIG */
  
  /*
!  *  32ӥåñ̤ɽФ
   */
  
  Inline uint32_t
--- 205,211 ----
  #endif /* SIL_ENDIAN_BIG */
  
  /*
!  *  32ビット単位の読出し／書込み
   */
  
  Inline uint32_t
***************
*** 223,229 ****
  	*((volatile uint32_t *) mem) = data;
  }
  
! #ifdef SIL_ENDIAN_BIG			/* ӥåǥץå */
  
  #define	sil_rew_bem(mem)		sil_rew_mem(mem)
  #define	sil_wrw_bem(mem, data)	sil_wrw_mem(mem, data)
--- 223,229 ----
  	*((volatile uint32_t *) mem) = data;
  }
  
! #ifdef SIL_ENDIAN_BIG			/* ビッグエンディアンプロセッサ */
  
  #define	sil_rew_bem(mem)		sil_rew_mem(mem)
  #define	sil_wrw_bem(mem, data)	sil_wrw_mem(mem, data)
***************
*** 249,255 ****
  }
  
  #endif /* TOPPERS_OMIT_SIL_WRW_LEM */
! #else /* SIL_ENDIAN_BIG */		/* ȥ륨ǥץå */
  
  #define	sil_rew_lem(mem)		sil_rew_mem(mem)
  #define	sil_wrw_lem(mem, data)	sil_wrw_mem(mem, data)
--- 249,255 ----
  }
  
  #endif /* TOPPERS_OMIT_SIL_WRW_LEM */
! #else /* SIL_ENDIAN_BIG */		/* リトルエンディアンプロセッサ */
  
  #define	sil_rew_lem(mem)		sil_rew_mem(mem)
  #define	sil_wrw_lem(mem, data)	sil_wrw_mem(mem, data)
diff -cr --new-file 1.9.1/asp/include/t_stddef.h ASPs/asp/include/t_stddef.h
*** 1.9.1/asp/include/t_stddef.h	Sun Apr 27 02:20:09 2014
--- ASPs/asp/include/t_stddef.h	Fri Dec  9 13:54:03 2022
***************
*** 7,58 ****
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: t_stddef.h 2406 2012-08-25 06:30:54Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS̥إåե
   *
!  *  TOPPERSϢΤ٤ƤΥեǥ󥯥롼ɤ٤إåե
!  *  롥ƼΥͥ䥽եȥʤǶ̤Ѥ뤳ȤꤷƤ
!  *  롥TOPPERSγƼΥͥ䥽եȥʤǶ̤Ѥǡ
!  *  ޥʤɤޤࡥ
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   *
!  *  Υե򥤥󥯥롼ɤ˥󥯥롼ɤƤ٤ե
!  *  Ϥʤ
   */
  
  #ifndef TOPPERS_T_STDDEF_H
--- 7,58 ----
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: t_stddef.h 2406 2012-08-25 06:30:54Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS共通ヘッダファイル
   *
!  *  TOPPERS関連のすべてのソースファイルでインクルードすべきヘッダファイ
!  *  ル．各種のカーネルやソフトウェア部品で共通に用いることを想定してい
!  *  る．TOPPERSの各種のカーネルやソフトウェア部品で共通に用いるデータ型，
!  *  定数，マクロの定義などを含む．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   *
!  *  このファイルをインクルードする前にインクルードしておくべきファイル
!  *  はない．
   */
  
  #ifndef TOPPERS_T_STDDEF_H
***************
*** 63,74 ****
  #endif
  
  /*
!  *  åȰ¸
   */
  #include "target_stddef.h"
  
  /*
!  *  C/EC++throw()н褹뤿
   */
  #if !defined(__cplusplus) || defined(__embedded_cplusplus)
  #define throw()
--- 63,74 ----
  #endif
  
  /*
!  *  ターゲット依存部
   */
  #include "target_stddef.h"
  
  /*
!  *  C言語/EC++でthrow()に対処するための定義
   */
  #if !defined(__cplusplus) || defined(__embedded_cplusplus)
  #define throw()
***************
*** 77,218 ****
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  åȰ¸ΥǡΥޥΥǥե
   */
  #ifndef TOPPERS_bool
! #define TOPPERS_bool	int				/* ֡뷿 */
  #endif /* TOPPERS_bool */
  
  #ifndef TOPPERS_size
! #define TOPPERS_size	uintptr_t		/*  */
  #endif /* TOPPERS_size */
  
  #ifndef TOPPERS_fp
  struct TOPPERS_dummy_t { int TOPPERS_dummy_field; };
  typedef	void			(*TOPPERS_fp_t)(struct TOPPERS_dummy_t);
! #define TOPPERS_fp		TOPPERS_fp_t	/* ץεư */
  #endif /* TOPPERS_fp */
  
  /*
!  *  ̥ǡ
   */
! typedef TOPPERS_bool	bool_t;		/*  */
  
! typedef signed int		int_t;		/* ʥդ */
! typedef unsigned int	uint_t;		/* ʥ̵ */
  
! typedef signed long		long_t;		/* ĹΥդ */
! typedef unsigned long	ulong_t;	/* ĹΥ̵ */
! 
! typedef int_t			FN;			/* ǽ */
! typedef	int_t			ER;			/* 顼 */
! typedef	int_t			ID;			/* ֥ȤIDֹ */
! typedef	uint_t			ATR;		/* ֥Ȥ° */
! typedef	uint_t			STAT;		/* ֥Ȥξ */
! typedef	uint_t			MODE;		/* ӥư⡼ */
! typedef	int_t			PRI;		/* ͥ */
! typedef	TOPPERS_size	SIZE;		/* ΰΥ */
! 
! typedef	int_t			TMO;		/* ॢȻ */
! typedef	uint_t			RELTIM;		/* л */
! typedef	ulong_t			SYSTIM;		/* ƥ */
! typedef	ulong_t			SYSUTM;		/* ǽɾѥƥ */
! 
! typedef	TOPPERS_fp		FP;			/* ץεư */
! 
! typedef	int_t			ER_BOOL;	/* 顼ɤޤϿ */
! typedef	int_t			ER_ID;		/* 顼ɤޤIDֹ */
! typedef	int_t			ER_UINT;	/* 顼ɤޤ̵ */
! 
! typedef uintptr_t		MB_T;		/* ΰݤ뤿Υǡ */
! 
! typedef	uint32_t		ACPTN;		/* ĥѥ */
! typedef	struct acvct {				/* ĥ٥ */
! 	ACPTN		acptn1;				/* ̾1Υĥѥ */
! 	ACPTN		acptn2;				/* ̾2Υĥѥ */
! 	ACPTN		acptn3;				/* Υĥѥ */
! 	ACPTN		acptn4;				/* Υĥѥ */
  } ACVCT;
  
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  ޥ
   */
  #ifndef UINT_C
! #define UINT_C(val)		(val ## U)		/* uint_tޥ */
  #endif /* UINT_C */
  
  #ifndef ULONG_C
! #define ULONG_C(val)	(val ## UL)		/* ulong_tޥ */
  #endif /* ULONG_C */
  
  /*
!  *  
   */
  #ifndef NULL
! #define NULL		0			/* ̵ݥ */
  #endif /* NULL */
  
  #ifndef true
! #define true		1			/*  */
  #endif /* true */
  
  #ifndef false
! #define false		0			/*  */
  #endif /* false */
  
! #define E_OK		0			/* ｪλ */
  
  /*
!  *  ᥤ󥨥顼
   */
! #define E_SYS		(-5)		/* ƥ२顼 */
! #define E_NOSPT		(-9)		/* ̤ݡȵǽ */
! #define E_RSFN		(-10)		/* ͽǽ */
! #define E_RSATR		(-11)		/* ͽ° */
! #define E_PAR		(-17)		/* ѥ᡼顼 */
! #define E_ID		(-18)		/* IDֹ */
! #define E_CTX		(-25)		/* ƥȥ顼 */
! #define E_MACV		(-26)		/* ꥢȿ */
! #define E_OACV		(-27)		/* ֥ȥȿ */
! #define E_ILUSE		(-28)		/* ӥ */
! #define E_NOMEM		(-33)		/* ­ */
! #define E_NOID		(-34)		/* IDֹ­ */
! #define E_NORES		(-35)		/* ­ */
! #define E_OBJ		(-41)		/* ֥Ⱦ֥顼 */
! #define E_NOEXS		(-42)		/* ֥̤ */
! #define E_QOVR		(-43)		/* 塼󥰥Сե */
! #define E_RLWAI		(-49)		/* Ԥ֤ζ */
! #define E_TMOUT		(-50)		/* ݡ󥰼Ԥޤϥॢ */
! #define E_DLT		(-51)		/* Ԥ֥Ȥκ */
! #define E_CLS		(-52)		/* Ԥ֥ȤξѲ */
! #define E_WBLK		(-57)		/* Υ֥å󥰼դ */
! #define E_BOVR		(-58)		/* ХåեСե */
  
  /*
!  *  ֥°
   */
! #define TA_NULL		UINT_C(0)	/* ֥°ꤷʤ */
  
  /*
!  *  ॢȻ
   */
! #define TMO_POL		0			/* ݡ */
! #define TMO_FEVR	(-1)		/* ʵԤ */
! #define TMO_NBLK	(-2)		/* Υ֥å */
  
  /*
!  *  ĥѥ
   */
! #define TACP_KERNEL		(0U)	/* ͥɥᥤ˥ */
! #define TACP_SHARED		(~0U)	/* ٤ƤΥɥᥤ󤫤饢 */
  
  /*
!  *  ˴ؤФΥޥ
   *
!  *  ʲALIGN_TYPEϡ饤Ȥñ̤2ζҾǤ뤳Ȥ
!  *  ꤷƤ롥
   */
  #ifndef offsetof
  #define	offsetof(structure, field)	((uintptr_t) &(((structure *) 0)->field))
--- 77,218 ----
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ターゲット依存のデータ型のマクロのデフォルト定義
   */
  #ifndef TOPPERS_bool
! #define TOPPERS_bool	int				/* ブール型 */
  #endif /* TOPPERS_bool */
  
  #ifndef TOPPERS_size
! #define TOPPERS_size	uintptr_t		/* サイズ型 */
  #endif /* TOPPERS_size */
  
  #ifndef TOPPERS_fp
  struct TOPPERS_dummy_t { int TOPPERS_dummy_field; };
  typedef	void			(*TOPPERS_fp_t)(struct TOPPERS_dummy_t);
! #define TOPPERS_fp		TOPPERS_fp_t	/* プログラムの起動番地 */
  #endif /* TOPPERS_fp */
  
  /*
!  *  共通データ型
   */
! typedef TOPPERS_bool	bool_t;		/* 真偽値 */
  
! typedef signed int		int_t;		/* 自然なサイズの符号付き整数 */
! typedef unsigned int	uint_t;		/* 自然なサイズの符号無し整数 */
  
! typedef signed long		long_t;		/* 長めのサイズの符号付き整数 */
! typedef unsigned long	ulong_t;	/* 長めのサイズの符号無し整数 */
! 
! typedef int_t			FN;			/* 機能コード */
! typedef	int_t			ER;			/* エラーコード */
! typedef	int_t			ID;			/* オブジェクトのID番号 */
! typedef	uint_t			ATR;		/* オブジェクトの属性 */
! typedef	uint_t			STAT;		/* オブジェクトの状態 */
! typedef	uint_t			MODE;		/* サービスコールの動作モード */
! typedef	int_t			PRI;		/* 優先度 */
! typedef	TOPPERS_size	SIZE;		/* メモリ領域のサイズ */
! 
! typedef	int_t			TMO;		/* タイムアウト指定 */
! typedef	uint_t			RELTIM;		/* 相対時間 */
! typedef	ulong_t			SYSTIM;		/* システム時刻 */
! typedef	ulong_t			SYSUTM;		/* 性能評価用システム時刻 */
! 
! typedef	TOPPERS_fp		FP;			/* プログラムの起動番地 */
! 
! typedef	int_t			ER_BOOL;	/* エラーコードまたは真偽値 */
! typedef	int_t			ER_ID;		/* エラーコードまたはID番号 */
! typedef	int_t			ER_UINT;	/* エラーコードまたは符号無し整数 */
! 
! typedef uintptr_t		MB_T;		/* 管理領域を確保するためのデータ型 */
! 
! typedef	uint32_t		ACPTN;		/* アクセス許可パターン */
! typedef	struct acvct {				/* アクセス許可ベクタ */
! 	ACPTN		acptn1;				/* 通常操作1のアクセス許可パターン */
! 	ACPTN		acptn2;				/* 通常操作2のアクセス許可パターン */
! 	ACPTN		acptn3;				/* 管理操作のアクセス許可パターン */
! 	ACPTN		acptn4;				/* 参照操作のアクセス許可パターン */
  } ACVCT;
  
  #endif /* TOPPERS_MACRO_ONLY */
  
  /*
!  *  整数定数を作るマクロ
   */
  #ifndef UINT_C
! #define UINT_C(val)		(val ## U)		/* uint_t型の定数を作るマクロ */
  #endif /* UINT_C */
  
  #ifndef ULONG_C
! #define ULONG_C(val)	(val ## UL)		/* ulong_t型の定数を作るマクロ */
  #endif /* ULONG_C */
  
  /*
!  *  一般定数
   */
  #ifndef NULL
! #define NULL		0			/* 無効ポインタ */
  #endif /* NULL */
  
  #ifndef true
! #define true		1			/* 真 */
  #endif /* true */
  
  #ifndef false
! #define false		0			/* 偽 */
  #endif /* false */
  
! #define E_OK		0			/* 正常終了 */
  
  /*
!  *  メインエラーコード
   */
! #define E_SYS		(-5)		/* システムエラー */
! #define E_NOSPT		(-9)		/* 未サポート機能 */
! #define E_RSFN		(-10)		/* 予約機能コード */
! #define E_RSATR		(-11)		/* 予約属性 */
! #define E_PAR		(-17)		/* パラメータエラー */
! #define E_ID		(-18)		/* 不正ID番号 */
! #define E_CTX		(-25)		/* コンテキストエラー */
! #define E_MACV		(-26)		/* メモリアクセス違反 */
! #define E_OACV		(-27)		/* オブジェクトアクセス違反 */
! #define E_ILUSE		(-28)		/* サービスコール不正使用 */
! #define E_NOMEM		(-33)		/* メモリ不足 */
! #define E_NOID		(-34)		/* ID番号不足 */
! #define E_NORES		(-35)		/* 資源不足 */
! #define E_OBJ		(-41)		/* オブジェクト状態エラー */
! #define E_NOEXS		(-42)		/* オブジェクト未生成 */
! #define E_QOVR		(-43)		/* キューイングオーバーフロー */
! #define E_RLWAI		(-49)		/* 待ち状態の強制解除 */
! #define E_TMOUT		(-50)		/* ポーリング失敗またはタイムアウト */
! #define E_DLT		(-51)		/* 待ちオブジェクトの削除 */
! #define E_CLS		(-52)		/* 待ちオブジェクトの状態変化 */
! #define E_WBLK		(-57)		/* ノンブロッキング受付け */
! #define E_BOVR		(-58)		/* バッファオーバーフロー */
  
  /*
!  *  オブジェクト属性
   */
! #define TA_NULL		UINT_C(0)	/* オブジェクト属性を指定しない */
  
  /*
!  *  タイムアウト指定
   */
! #define TMO_POL		0			/* ポーリング */
! #define TMO_FEVR	(-1)		/* 永久待ち */
! #define TMO_NBLK	(-2)		/* ノンブロッキング */
  
  /*
!  *  アクセス許可パターン
   */
! #define TACP_KERNEL		(0U)	/* カーネルドメインだけにアクセスを許可 */
! #define TACP_SHARED		(~0U)	/* すべてのドメインからアクセスを許可 */
  
  /*
!  *  型に関する情報を取り出すためのマクロ
   *
!  *  以下のALIGN_TYPEの定義は，アラインメントの単位が2の巾乗であることを
!  *  仮定している．
   */
  #ifndef offsetof
  #define	offsetof(structure, field)	((uintptr_t) &(((structure *) 0)->field))
***************
*** 222,234 ****
  #define alignof(type)	offsetof(struct { char field1; type field2; }, field2)
  #endif /* alignof */
  
! #ifndef ALIGN_TYPE				/* 饤ȤΥå */
  #define ALIGN_TYPE(addr, type) \
  						((((uintptr_t)(addr)) & (alignof(type) - 1)) == 0U)
  #endif /* ALIGN_TYPE */
  
  /*
!  *  assertޥ
   */
  #undef assert
  #ifndef NDEBUG
--- 222,234 ----
  #define alignof(type)	offsetof(struct { char field1; type field2; }, field2)
  #endif /* alignof */
  
! #ifndef ALIGN_TYPE				/* アラインメントのチェック */
  #define ALIGN_TYPE(addr, type) \
  						((((uintptr_t)(addr)) & (alignof(type) - 1)) == 0U)
  #endif /* ALIGN_TYPE */
  
  /*
!  *  assertマクロ
   */
  #undef assert
  #ifndef NDEBUG
***************
*** 243,256 ****
  #endif
  
  /*
!  *  顼ʬޥ
   *
!  *  ʲΥޥϡդ2ɽƤꡤե
!  *  黻ҡ>>ˤѥեȤ뤳ȤꤷƤ롥Ǥʤȯ
!  *  Ǥϡtarget_stddef.hǤ񤭤ʤФʤʤ
   *
!  *  MERCDޥϡᥤ󥨥顼ɤǤ뤳ȤꤷƤ롥
!  *  Ǥʤ硤2Ĥפʤʤ롥
   */
  #ifndef ERCD
  #define ERCD(mercd, sercd) \
--- 243,256 ----
  #endif
  
  /*
!  *  エラーコード生成・分解マクロ
   *
!  *  以下のマクロ定義は，符号付き整数が2の補数で表現されており，右シフト
!  *  演算子（>>）が算術シフトされることを仮定している．そうでない開発環
!  *  境では，target_stddef.hでこれらの定義を上書きしなければならない．
   *
!  *  MERCDマクロの定義は，メインエラーコードが負であることを仮定している．
!  *  そうでない場合，2つの定義が一致しなくなる．
   */
  #ifndef ERCD
  #define ERCD(mercd, sercd) \
***************
*** 270,281 ****
  #endif /* SERCD */
  
  /*
!  *  ĥѥޥ
   */
! #define TACP(domid)		(1U << ((domid) - 1))	/* domid˥ */
  
  /*
!  *  л֡RELTIMˤ˻Ǥ
   */
  #if UINT_MAX < LONG_MAX
  #define TMAX_RELTIM		((RELTIM) UINT_MAX)
--- 270,281 ----
  #endif /* SERCD */
  
  /*
!  *  アクセス許可パターン生成マクロ
   */
! #define TACP(domid)		(1U << ((domid) - 1))	/* domidだけにアクセスを許可 */
  
  /*
!  *  相対時間（RELTIM）に指定できる最大値
   */
  #if UINT_MAX < LONG_MAX
  #define TMAX_RELTIM		((RELTIM) UINT_MAX)
diff -cr --new-file 1.9.1/asp/include/t_stdlib.h ASPs/asp/include/t_stdlib.h
*** 1.9.1/asp/include/t_stdlib.h	Sat Apr 12 10:30:59 2008
--- ASPs/asp/include/t_stdlib.h	Fri Dec  9 13:54:03 2022
***************
*** 7,46 ****
   *  Copyright (C) 2004-2006 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: t_stdlib.h 264 2007-07-12 08:23:10Z hiro $
   */
  
  /*
!  *		Ūʥ饤֥ؿ
   */
  
  #ifndef TOPPERS_T_STDLIB_H
--- 7,46 ----
   *  Copyright (C) 2004-2006 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: t_stdlib.h 264 2007-07-12 08:23:10Z hiro $
   */
  
  /*
!  *		基本的なライブラリ関数
   */
  
  #ifndef TOPPERS_T_STDLIB_H
***************
*** 51,68 ****
  #endif
  
  /*
!  *  顼åʸ֤ؿ
   *
!  *  ercdǻꤵ줿顼ɤΥᥤ󥨥顼ɤ̾ΡE_PAR
!  *  E_OBJʤɡˤʸ֤ؿ
   */
  extern const char	*itron_strerror(ER ercd) throw();
  
  /*
!  *  顼åΥ
   *
!  *  ӥ뤬顼֤ˡΥեֹ̾桤ᥤ
!  *  󥨥顼ɽ뤿δؿ
   */
  extern void		t_perror(uint_t prio, const char *file, int_t line,
  									const char *expr, ER ercd) throw();
--- 51,68 ----
  #endif
  
  /*
!  *  エラーメッセージ文字列を返す関数
   *
!  *  ercdで指定されたエラーコードのメインエラーコードの名称（E_PAR，
!  *  E_OBJなど）の文字列を返す関数．
   */
  extern const char	*itron_strerror(ER ercd) throw();
  
  /*
!  *  エラーメッセージのログ出力
   *
!  *  サービスコールがエラーを返した場合に，そのファイル名，行番号，メイ
!  *  ンエラーコード等を表示するための関数．
   */
  extern void		t_perror(uint_t prio, const char *file, int_t line,
  									const char *expr, ER ercd) throw();
diff -cr --new-file 1.9.1/asp/include/t_syslog.h ASPs/asp/include/t_syslog.h
*** 1.9.1/asp/include/t_syslog.h	Mon Aug 20 18:30:01 2012
--- ASPs/asp/include/t_syslog.h	Fri Dec  9 13:54:03 2022
***************
*** 8,138 ****
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: t_syslog.h 2126 2011-06-26 01:07:35Z ertl-hiro $
   */
  
  /*
!  *		ƥϤԤ
   *
!  *  ƥӥϡƥΥϤ뤿Υӥ
!  *  Ǥ롥ͥ뤫ΥνϤˤѤ뤿ᡤԤ
!  *  ˤϤ뤳ȤϤʤ
   *
!  *  ϡͥΥХåե˽񤭹फ٥ʸ
!  *  ϴؿѤƽϤ롥ɤȤϡĥӥڤ
!  *  뤳ȤǤ롥
   *
!  *  Хåեΰ褬ХեˤϡŤäƾ
!  *  񤭤롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤȤǡޥʳεҤ
!  *  ȤǤ롥
   *
!  *  Υե򥤥󥯥롼ɤˡt_stddef.h򥤥󥯥롼ɤƤ
!  *  ȤɬפǤ롥
   */
  
  #ifndef TOPPERS_T_SYSLOG_H
  #define TOPPERS_T_SYSLOG_H
! 
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  /*
!  *  μ̤
   */
! #define LOG_TYPE_COMMENT	UINT_C(0x01)	/*  */
! #define LOG_TYPE_ASSERT		UINT_C(0x02)	/* μ */
  
! #define LOG_TYPE_INH		UINT_C(0x11)	/* ߥϥɥ */
! #define LOG_TYPE_ISR		UINT_C(0x12)	/* ߥӥ롼 */
! #define LOG_TYPE_CYC		UINT_C(0x13)	/* ϥɥ */
! #define LOG_TYPE_ALM		UINT_C(0x14)	/* 顼ϥɥ */
! #define LOG_TYPE_OVR		UINT_C(0x15)	/* Хϥɥ */
! #define LOG_TYPE_EXC		UINT_C(0x16)	/* CPU㳰ϥɥ */
! #define LOG_TYPE_TEX		UINT_C(0x17)	/* 㳰롼 */
! #define LOG_TYPE_TSKSTAT	UINT_C(0x18)	/* Ѳ */
! #define LOG_TYPE_DSP		UINT_C(0x19)	/* ǥѥå */
! #define LOG_TYPE_SVC		UINT_C(0x1a)	/* ӥ */
  
! #define LOG_ENTER			UINT_C(0x00)	/*  */
! #define LOG_LEAVE			UINT_C(0x80)	/* иλ */
  
  /*
!  *  ν٤
   */
! #define LOG_EMERG			UINT_C(0)		/* åȥͤ륨顼 */
  #define LOG_ALERT			UINT_C(1)
  #define LOG_CRIT			UINT_C(2)
! #define LOG_ERROR			UINT_C(3)		/* ƥ२顼 */
! #define LOG_WARNING			UINT_C(4)		/* ٹå */
  #define LOG_NOTICE			UINT_C(5)
  #define LOG_INFO			UINT_C(6)
! #define LOG_DEBUG			UINT_C(7)		/* ǥХåѥå */
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  Υǡ¤
   */
  
  #define TMAX_LOGINFO	6
  
  typedef struct {
! 	uint_t		logtype;				/* μ */
! 	SYSTIM		logtim;					/*  */
! 	intptr_t	loginfo[TMAX_LOGINFO];	/* ¾Υ */
  } SYSLOG;
  
  /*
!  *  ν٤Υӥåȥޥåפ뤿Υޥ
   */
  #define LOG_MASK(prio)		(1U << (prio))
  #define LOG_UPTO(prio)		((1U << ((prio) + 1)) - 1)
  
  /*
!  *  ѥåȷ
   */
  typedef struct t_syslog_rlog {
! 	uint_t	count;		/* ХåեΥο */
! 	uint_t	lost;		/* 줿ο */
! 	uint_t	logmask;	/* Хåե˵Ͽ٤ */
! 	uint_t	lowmask;	/* ٥Ϥ٤ */
  } T_SYSLOG_RLOG;
  
  /*
!  *  Ϥ뤿Υ饤֥ؿ
   */
  
  #ifndef TOPPERS_OMIT_SYSLOG
--- 8,138 ----
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: t_syslog.h 2126 2011-06-26 01:07:35Z ertl-hiro $
   */
  
  /*
!  *		システムログ出力を行うための定義
   *
!  *  システムログサービスは，システムのログ情報を出力するためのサービス
!  *  である．カーネルからのログ情報の出力にも用いるため，内部で待ち状態
!  *  にはいることはない．
   *
!  *  ログ情報は，カーネル内のログバッファに書き込むか，低レベルの文字出
!  *  力関数を用いて出力する．どちらを使うかは，拡張サービスコールで切り
!  *  換えることができる．
   *
!  *  ログバッファ領域がオーバフローした場合には，古いログ情報を消して上
!  *  書きする．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておくことで，マクロ定義以外の記述を
!  *  除くことができる．
   *
!  *  このファイルをインクルードする前に，t_stddef.hをインクルードしてお
!  *  くことが必要である．
   */
  
  #ifndef TOPPERS_T_SYSLOG_H
  #define TOPPERS_T_SYSLOG_H
! #define TOPPERS_OMIT_SYSLOG
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  /*
!  *  ログ情報の種別の定義
   */
! #define LOG_TYPE_COMMENT	UINT_C(0x01)	/* コメント */
! #define LOG_TYPE_ASSERT		UINT_C(0x02)	/* アサーションの失敗 */
  
! #define LOG_TYPE_INH		UINT_C(0x11)	/* 割込みハンドラ */
! #define LOG_TYPE_ISR		UINT_C(0x12)	/* 割込みサービスルーチン */
! #define LOG_TYPE_CYC		UINT_C(0x13)	/* 周期ハンドラ */
! #define LOG_TYPE_ALM		UINT_C(0x14)	/* アラームハンドラ */
! #define LOG_TYPE_OVR		UINT_C(0x15)	/* オーバランハンドラ */
! #define LOG_TYPE_EXC		UINT_C(0x16)	/* CPU例外ハンドラ */
! #define LOG_TYPE_TEX		UINT_C(0x17)	/* タスク例外処理ルーチン */
! #define LOG_TYPE_TSKSTAT	UINT_C(0x18)	/* タスク状態変化 */
! #define LOG_TYPE_DSP		UINT_C(0x19)	/* ディスパッチャ */
! #define LOG_TYPE_SVC		UINT_C(0x1a)	/* サービスコール */
  
! #define LOG_ENTER			UINT_C(0x00)	/* 入口／開始 */
! #define LOG_LEAVE			UINT_C(0x80)	/* 出口／終了 */
  
  /*
!  *  ログ情報の重要度の定義
   */
! #define LOG_EMERG			UINT_C(0)		/* シャットダウンに値するエラー */
  #define LOG_ALERT			UINT_C(1)
  #define LOG_CRIT			UINT_C(2)
! #define LOG_ERROR			UINT_C(3)		/* システムエラー */
! #define LOG_WARNING			UINT_C(4)		/* 警告メッセージ */
  #define LOG_NOTICE			UINT_C(5)
  #define LOG_INFO			UINT_C(6)
! #define LOG_DEBUG			UINT_C(7)		/* デバッグ用メッセージ */
  
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ログ情報のデータ構造
   */
  
  #define TMAX_LOGINFO	6
  
  typedef struct {
! 	uint_t		logtype;				/* ログ情報の種別 */
! 	SYSTIM		logtim;					/* ログ時刻 */
! 	intptr_t	loginfo[TMAX_LOGINFO];	/* その他のログ情報 */
  } SYSLOG;
  
  /*
!  *  ログ情報の重要度のビットマップを作るためのマクロ
   */
  #define LOG_MASK(prio)		(1U << (prio))
  #define LOG_UPTO(prio)		((1U << ((prio) + 1)) - 1)
  
  /*
!  *  パケット形式の定義
   */
  typedef struct t_syslog_rlog {
! 	uint_t	count;		/* ログバッファ中のログの数 */
! 	uint_t	lost;		/* 失われたログの数 */
! 	uint_t	logmask;	/* ログバッファに記録すべき重要度 */
! 	uint_t	lowmask;	/* 低レベル出力すべき重要度 */
  } T_SYSLOG_RLOG;
  
  /*
!  *  ログ情報を出力するためのライブラリ関数
   */
  
  #ifndef TOPPERS_OMIT_SYSLOG
***************
*** 228,241 ****
  }
  
  /*
!  *  ʥȡˤϤ뤿Υ饤֥ؿvasyslog.c
   */
  extern void	syslog(uint_t prio, const char *format, ...) throw();
  
  #else /* TOPPERS_OMIT_SYSLOG */
  
  /*
!  *  ƥϤ޻ߤ
   */
  
  Inline void
--- 228,241 ----
  }
  
  /*
!  *  ログ情報（コメント）を出力するためのライブラリ関数（vasyslog.c）
   */
  extern void	syslog(uint_t prio, const char *format, ...) throw();
  
  #else /* TOPPERS_OMIT_SYSLOG */
  
  /*
!  *  システムログ出力を抑止する場合
   */
  
  Inline void
***************
*** 285,295 ****
  #endif /* TOPPERS_OMIT_SYSLOG */
  
  /*
!  *  ʥȡˤϤ뤿Υޥ
   *
!  *  formatӸ³ΰå򡤽prioǥ
!  *  ȤƽϤ뤿Υޥarg1argnintptr_t˥㥹Ȥ
!  *  ᡤintptr_t˷ѴǤǤդηǤ褤
   */
  
  #define syslog_0(prio, format) \
--- 285,295 ----
  #endif /* TOPPERS_OMIT_SYSLOG */
  
  /*
!  *  ログ情報（コメント）を出力するためのマクロ
   *
!  *  formatおよび後続の引数から作成したメッセージを，重大度prioでログ情
!  *  報として出力するためのマクロ．arg1〜argnはintptr_t型にキャストする
!  *  ため，intptr_t型に型変換できる任意の型でよい．
   */
  
  #define syslog_0(prio, format) \
***************
*** 318,324 ****
  										(intptr_t)(arg4), (intptr_t)(arg5))
  
  /*
!  *  ʥμԡˤϤ뤿Υޥ
   */
  #ifndef TOPPERS_assert_fail
  #define TOPPERS_assert_fail(exp, file, line) \
--- 318,324 ----
  										(intptr_t)(arg4), (intptr_t)(arg5))
  
  /*
!  *  ログ情報（アサーションの失敗）を出力するためのマクロ
   */
  #ifndef TOPPERS_assert_fail
  #define TOPPERS_assert_fail(exp, file, line) \
diff -cr --new-file 1.9.1/asp/include/test_lib.h ASPs/asp/include/test_lib.h
*** 1.9.1/asp/include/test_lib.h	Sun Oct 13 21:31:22 2013
--- ASPs/asp/include/test_lib.h	Fri Dec  9 13:54:03 2022
***************
*** 5,44 ****
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_lib.h 2535 2013-10-13 12:31:18Z ertl-hiro $
   */
  
  /* 
!  *		ƥȥץѥ饤֥
   */
  
  #ifndef TOPPERS_TEST_LIB_H
--- 5,44 ----
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_lib.h 2535 2013-10-13 12:31:18Z ertl-hiro $
   */
  
  /* 
!  *		テストプログラム用ライブラリ
   */
  
  #ifndef TOPPERS_TEST_LIB_H
***************
*** 51,104 ****
  #include <t_stddef.h>
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *	ʿǴؿη
   */
  typedef ER (*BIT_FUNC)(void);
  
  /*
!  *	ʿǴؿ
   */
  extern void	set_bit_func(BIT_FUNC bit_func);
  
  /*
!  *  ƥȥץγ
   */
  extern void	test_start(char *progname);
  
  /*
!  *  ƥνϽ
   */
  extern void	syslog_flush(void);
  
  /*
!  *	ƥȥץνλ
   */
  extern void	test_finish(void);
  
  /*
!  *	åݥ
   */
  extern void	check_point(uint_t count);
  
  /*
!  *	λåݥ
   */
  extern void	check_finish(uint_t count);
  
  /*
!  *	å
   */
  extern void	_check_assert(const char *expr, const char *file, int_t line);
  #define check_assert(exp) \
  	((void)(!(exp) ? (_check_assert(#exp, __FILE__, __LINE__), 0) : 0))
  
  /*
!  *	顼ɥå
   */
  extern void	_check_ercd(ER ercd, const char *file, int_t line);
  #define check_ercd(ercd, expected_ercd) \
--- 51,104 ----
  #include <t_stddef.h>
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *	自己診断関数の型
   */
  typedef ER (*BIT_FUNC)(void);
  
  /*
!  *	自己診断関数の設定
   */
  extern void	set_bit_func(BIT_FUNC bit_func);
  
  /*
!  *  テストプログラムの開始
   */
  extern void	test_start(char *progname);
  
  /*
!  *  システムログの出力処理
   */
  extern void	syslog_flush(void);
  
  /*
!  *	テストプログラムの終了
   */
  extern void	test_finish(void);
  
  /*
!  *	チェックポイント
   */
  extern void	check_point(uint_t count);
  
  /*
!  *	完了チェックポイント
   */
  extern void	check_finish(uint_t count);
  
  /*
!  *	条件チェック
   */
  extern void	_check_assert(const char *expr, const char *file, int_t line);
  #define check_assert(exp) \
  	((void)(!(exp) ? (_check_assert(#exp, __FILE__, __LINE__), 0) : 0))
  
  /*
!  *	エラーコードチェック
   */
  extern void	_check_ercd(ER ercd, const char *file, int_t line);
  #define check_ercd(ercd, expected_ercd) \
***************
*** 106,112 ****
  					(_check_ercd(ercd, __FILE__, __LINE__), 0) : 0))
  
  /*
!  *	ƥ֤Υå
   */
  Inline void
  check_state(bool_t ctx, bool_t loc, PRI ipm, bool_t dsp,
--- 106,112 ----
  					(_check_ercd(ercd, __FILE__, __LINE__), 0) : 0))
  
  /*
!  *	システム状態のチェック
   */
  Inline void
  check_state(bool_t ctx, bool_t loc, PRI ipm, bool_t dsp,
***************
*** 119,125 ****
  	check_assert(sns_loc() == loc);
  	if (!loc) {
  		/*
! 		 *  IPMΥåϡCPUå֤ξˤΤ߹Ԥ
  		 */
  		ercd = get_ipm(&intpri);
  		check_ercd(ercd, E_OK);
--- 119,125 ----
  	check_assert(sns_loc() == loc);
  	if (!loc) {
  		/*
! 		 *  IPMのチェックは，CPUロック解除状態の場合にのみ行う．
  		 */
  		ercd = get_ipm(&intpri);
  		check_ercd(ercd, E_OK);
***************
*** 131,137 ****
  }
  
  /*
!  *	ƥ֤Υå󥿥ƥѡ
   */
  Inline void
  check_state_i(bool_t ctx, bool_t loc, bool_t dsp, bool_t dpn, bool_t tex)
--- 131,137 ----
  }
  
  /*
!  *	システム状態のチェック（非タスクコンテキスト用）
   */
  Inline void
  check_state_i(bool_t ctx, bool_t loc, bool_t dsp, bool_t dpn, bool_t tex)
diff -cr --new-file 1.9.1/asp/kernel/Makefile.kernel ASPs/asp/kernel/Makefile.kernel
*** 1.9.1/asp/kernel/Makefile.kernel	Sat Apr 12 10:30:58 2008
--- ASPs/asp/kernel/Makefile.kernel	Fri Dec  9 13:54:04 2022
***************
*** 8,52 ****
  #  Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! #  ܥեȥѤΤޤࡥʲƱˤѡʣ
! #  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! #  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! #      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! #      ˴ޤޤƤ뤳ȡ
! #  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! #      ѤǤǺۤˤϡۤȼɥȡ
! #      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! #      ̵ݾڵǺܤ뤳ȡ
! #  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! #      ѤǤʤǺۤˤϡΤ줫ξ
! #      ȡ
! #    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! #        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! #    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! #        𤹤뤳ȡ
! #  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! #      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! #      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! #      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! #      դ뤳ȡ
  # 
! #  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! #  TOPPERSץȤϡܥեȥ˴ؤơλŪ
! #  ФŬޤơʤݾڤԤʤޤܥեȥ
! #  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! #  Ǥʤ
  # 
  #  @(#) $Id: Makefile.kernel 877 2008-04-11 10:36:50Z hiro $
  # 
  
  #
! #		ͥΥե빽
  #
  
  #
! #  1ĤΥե뤫ʣΥ֥ȥե褦˺
! #  줿եΥꥹ
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
--- 8,52 ----
  #  Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! #  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! #  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! #  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! #      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! #      スコード中に含まれていること．
! #  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! #      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! #      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! #      の無保証規定を掲載すること．
! #  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! #      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! #      と．
! #    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! #        作権表示，この利用条件および下記の無保証規定を掲載すること．
! #    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! #        報告すること．
! #  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! #      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! #      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! #      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! #      免責すること．
  # 
! #  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! #  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! #  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! #  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! #  の責任を負わない．
  # 
  #  @(#) $Id: Makefile.kernel 877 2008-04-11 10:36:50Z hiro $
  # 
  
  #
! #		カーネルのファイル構成の定義
  #
  
  #
! #  1つのソースファイルから複数のオブジェクトファイルを生成するように作
! #  成されたソースファイルのリスト
  #
  KERNEL_FCSRCS = startup.c task.c wait.c time_event.c \
  				task_manage.c task_refer.c task_sync.c task_except.c \
***************
*** 55,61 ****
  				sys_manage.c interrupt.c exception.c
  
  #
! #  ƥե뤫륪֥ȥեΥꥹ
  #
  startup = sta_ker.o ext_ker.o
  
--- 55,61 ----
  				sys_manage.c interrupt.c exception.c
  
  #
! #  各ソースファイルから生成されるオブジェクトファイルのリスト
  #
  startup = sta_ker.o ext_ker.o
  
***************
*** 112,118 ****
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  륪֥ȥեΰ¸ط
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
--- 112,118 ----
  exception = excini.o xsns_dpn.o xsns_xpn.o
  
  #
! #  生成されるオブジェクトファイルの依存関係の定義
  #
  $(startup) $(startup:.o=.s) $(startup:.o=.d): startup.c
  $(task) $(task:.o=.s) $(task:.o=.d): task.c
diff -cr --new-file 1.9.1/asp/kernel/alarm.c ASPs/asp/kernel/alarm.c
*** 1.9.1/asp/kernel/alarm.c	Sun Jun 26 12:14:58 2011
--- ASPs/asp/kernel/alarm.c	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: alarm.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		顼ϥɥ鵡ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: alarm.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		アラームハンドラ機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "alarm.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ALM_ENTER
  #define LOG_ALM_ENTER(p_almcb)
--- 49,55 ----
  #include "alarm.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ALM_ENTER
  #define LOG_ALM_ENTER(p_almcb)
***************
*** 100,117 ****
  #endif /* LOG_REF_ALM_LEAVE */
  
  /*
!  *  顼ϥɥο
   */
  #define tnum_alm	((uint_t)(tmax_almid - TMIN_ALMID + 1))
  
  /*
!  *  顼ϥɥID饢顼ϥɥ֥åФΥޥ
   */
  #define INDEX_ALM(almid)	((uint_t)((almid) - TMIN_ALMID))
  #define get_almcb(almid)	(&(almcb_table[INDEX_ALM(almid)]))
  
  /*
!  *  顼ϥɥ鵡ǽν
   */
  #ifdef TOPPERS_almini
  
--- 100,117 ----
  #endif /* LOG_REF_ALM_LEAVE */
  
  /*
!  *  アラームハンドラの数
   */
  #define tnum_alm	((uint_t)(tmax_almid - TMIN_ALMID + 1))
  
  /*
!  *  アラームハンドラIDからアラームハンドラ管理ブロックを取り出すためのマクロ
   */
  #define INDEX_ALM(almid)	((uint_t)((almid) - TMIN_ALMID))
  #define get_almcb(almid)	(&(almcb_table[INDEX_ALM(almid)]))
  
  /*
!  *  アラームハンドラ機能の初期化
   */
  #ifdef TOPPERS_almini
  
***************
*** 131,137 ****
  #endif /* TOPPERS_almini */
  
  /*
!  *  顼ϥɥư
   */
  #ifdef TOPPERS_sta_alm
  
--- 131,137 ----
  #endif /* TOPPERS_almini */
  
  /*
!  *  アラームハンドラの動作開始
   */
  #ifdef TOPPERS_sta_alm
  
***************
*** 167,173 ****
  #endif /* TOPPERS_sta_alm */
  
  /*
!  *  顼ϥɥưϡ󥿥ƥѡ
   */
  #ifdef TOPPERS_ista_alm
  
--- 167,173 ----
  #endif /* TOPPERS_sta_alm */
  
  /*
!  *  アラームハンドラの動作開始（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_ista_alm
  
***************
*** 203,209 ****
  #endif /* TOPPERS_ista_alm */
  
  /*
!  *  顼ϥɥư
   */
  #ifdef TOPPERS_stp_alm
  
--- 203,209 ----
  #endif /* TOPPERS_ista_alm */
  
  /*
!  *  アラームハンドラの動作停止
   */
  #ifdef TOPPERS_stp_alm
  
***************
*** 234,240 ****
  #endif /* TOPPERS_stp_alm */
  
  /*
!  *  顼ϥɥưߡ󥿥ƥѡ
   */
  #ifdef TOPPERS_istp_alm
  
--- 234,240 ----
  #endif /* TOPPERS_stp_alm */
  
  /*
!  *  アラームハンドラの動作停止（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_istp_alm
  
***************
*** 265,271 ****
  #endif /* TOPPERS_istp_alm */
  
  /*
!  *  顼ϥɥξֻ
   */
  #ifdef TOPPERS_ref_alm
  
--- 265,271 ----
  #endif /* TOPPERS_istp_alm */
  
  /*
!  *  アラームハンドラの状態参照
   */
  #ifdef TOPPERS_ref_alm
  
***************
*** 299,305 ****
  #endif /* TOPPERS_ref_alm */
  
  /*
!  *  顼ϥɥ鵯ư롼
   */
  #ifdef TOPPERS_almcal
  
--- 299,305 ----
  #endif /* TOPPERS_ref_alm */
  
  /*
!  *  アラームハンドラ起動ルーチン
   */
  #ifdef TOPPERS_almcal
  
***************
*** 309,320 ****
  	PRI		saved_ipm;
  
  	/*
! 	 *  顼ϥɥ߾֤ˤ롥
  	 */
  	p_almcb->almsta = false;
  
  	/*
! 	 *  顼ϥɥCPUå֤ǸƤӽФ
  	 */
  	saved_ipm = i_get_ipm();
  	i_unlock_cpu();
--- 309,320 ----
  	PRI		saved_ipm;
  
  	/*
! 	 *  アラームハンドラを停止状態にする．
  	 */
  	p_almcb->almsta = false;
  
  	/*
! 	 *  アラームハンドラを，CPUロック解除状態で呼び出す．
  	 */
  	saved_ipm = i_get_ipm();
  	i_unlock_cpu();
diff -cr --new-file 1.9.1/asp/kernel/alarm.h ASPs/asp/kernel/alarm.h
*** 1.9.1/asp/kernel/alarm.h	Sat Apr 12 10:30:58 2008
--- ASPs/asp/kernel/alarm.h	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: alarm.h 748 2008-03-07 17:18:06Z hiro $
   */
  
  /*
!  *		顼ϥɥ鵡ǽ
   */
  
  #ifndef TOPPERS_ALARM_H
--- 8,47 ----
   *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: alarm.h 748 2008-03-07 17:18:06Z hiro $
   */
  
  /*
!  *		アラームハンドラ機能
   */
  
  #ifndef TOPPERS_ALARM_H
***************
*** 50,94 ****
  #include "time_event.h"
  
  /*
!  *  顼ϥɥ֥å
   */
  typedef struct alarm_handler_initialization_block {
! 	ATR			almatr;			/* 顼ϥɥ° */
! 	intptr_t	exinf;			/* 顼ϥɥγĥ */
! 	ALMHDR		almhdr;			/* 顼ϥɥεư */
  } ALMINIB;
  
  /*
!  *  顼ϥɥ֥å
   */
  typedef struct alarm_handler_control_block {
! 	const ALMINIB *p_alminib;	/* ֥åؤΥݥ */
! 	bool_t		almsta;			/* 顼ϥɥư */
! 	TMEVTB		tmevtb;			/* ।٥ȥ֥å */
  } ALMCB;
  
  /*
!  *  顼ϥɥIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_almid;
  
  /*
!  *  顼ϥɥ֥åΥꥢkernel_cfg.c
   */
  extern const ALMINIB	alminib_table[];
  
  /*
!  *  顼ϥɥ֥åΥꥢkernel_cfg.c
   */
  extern ALMCB	almcb_table[];
  
  /*
!  *  顼ϥɥ鵡ǽν
   */
  extern void	initialize_alarm(void);
  
  /*
!  *  顼ϥɥ鵯ư롼
   */
  extern void	call_almhdr(ALMCB *p_almcb);
  
--- 50,94 ----
  #include "time_event.h"
  
  /*
!  *  アラームハンドラ初期化ブロック
   */
  typedef struct alarm_handler_initialization_block {
! 	ATR			almatr;			/* アラームハンドラ属性 */
! 	intptr_t	exinf;			/* アラームハンドラの拡張情報 */
! 	ALMHDR		almhdr;			/* アラームハンドラの起動番地 */
  } ALMINIB;
  
  /*
!  *  アラームハンドラ管理ブロック
   */
  typedef struct alarm_handler_control_block {
! 	const ALMINIB *p_alminib;	/* 初期化ブロックへのポインタ */
! 	bool_t		almsta;			/* アラームハンドラの動作状態 */
! 	TMEVTB		tmevtb;			/* タイムイベントブロック */
  } ALMCB;
  
  /*
!  *  アラームハンドラIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_almid;
  
  /*
!  *  アラームハンドラ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const ALMINIB	alminib_table[];
  
  /*
!  *  アラームハンドラ管理ブロックのエリア（kernel_cfg.c）
   */
  extern ALMCB	almcb_table[];
  
  /*
!  *  アラームハンドラ機能の初期化
   */
  extern void	initialize_alarm(void);
  
  /*
!  *  アラームハンドラ起動ルーチン
   */
  extern void	call_almhdr(ALMCB *p_almcb);
  
diff -cr --new-file 1.9.1/asp/kernel/allfunc.h ASPs/asp/kernel/allfunc.h
*** 1.9.1/asp/kernel/allfunc.h	Thu Aug 12 17:22:06 2010
--- ASPs/asp/kernel/allfunc.h	Fri Dec  9 13:54:03 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: allfunc.h 879 2008-04-11 10:38:16Z hiro $
   */
  
  /*
!  *		٤Ƥδؿ򥳥ѥ뤹뤿
   */
  
  #ifndef TOPPERS_ALLFUNC_H
--- 6,45 ----
   *  Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: allfunc.h 879 2008-04-11 10:38:16Z hiro $
   */
  
  /*
!  *		すべての関数をコンパイルするための定義
   */
  
  #ifndef TOPPERS_ALLFUNC_H
diff -cr --new-file 1.9.1/asp/kernel/check.h ASPs/asp/kernel/check.h
*** 1.9.1/asp/kernel/check.h	Sun Aug 14 17:42:37 2011
--- ASPs/asp/kernel/check.h	Fri Dec  9 13:54:03 2022
***************
*** 8,54 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: check.h 2229 2011-08-14 08:42:37Z ertl-hiro $
   */
  
  /*
!  *		顼åѥޥ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  ͥ٤ϰϤȽ
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
--- 8,54 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: check.h 2229 2011-08-14 08:42:37Z ertl-hiro $
   */
  
  /*
!  *		エラーチェック用マクロ
   */
  
  #ifndef TOPPERS_CHECK_H
  #define TOPPERS_CHECK_H
  
  /*
!  *  優先度の範囲の判定
   */
  #define VALID_TPRI(tpri)	(TMIN_TPRI <= (tpri) && (tpri) <= TMAX_TPRI)
  
***************
*** 58,64 ****
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
--- 58,64 ----
  #endif /* VALID_INTPRI_CHGIPM */
  
  /*
!  *  タスク優先度のチェック（E_PAR）
   */
  #define CHECK_TPRI(tpri) do {								\
  	if (!VALID_TPRI(tpri)) {								\
***************
*** 82,88 ****
  } while (false)
  
  /*
!  *  ॢȻͤΥåE_PAR
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
--- 82,88 ----
  } while (false)
  
  /*
!  *  タイムアウト指定値のチェック（E_PAR）
   */
  #define CHECK_TMOUT(tmout) do {								\
  	if (!(TMO_FEVR <= (tmout))) {							\
***************
*** 92,98 ****
  } while (false)
  
  /*
!  *  ͥ٤ΥåE_PAR
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
--- 92,98 ----
  } while (false)
  
  /*
!  *  割込み優先度のチェック（E_PAR）
   */
  #define CHECK_INTPRI_CHGIPM(intpri) do {					\
  	if (!VALID_INTPRI_CHGIPM(intpri)) {						\
***************
*** 102,108 ****
  } while (false)
  
  /*
!  *  ֹΥåE_PAR
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
--- 102,108 ----
  } while (false)
  
  /*
!  *  割込み番号のチェック（E_PAR）
   */
  #define CHECK_INTNO_DISINT(intno) do {						\
  	if (!VALID_INTNO_DISINT(intno)) {						\
***************
*** 112,118 ****
  } while (false)
  
  /*
!  *  ¾Υѥ᡼顼ΥåE_PAR
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
--- 112,118 ----
  } while (false)
  
  /*
!  *  その他のパラメータエラーのチェック（E_PAR）
   */
  #define CHECK_PAR(exp) do {									\
  	if (!(exp)) {											\
***************
*** 122,128 ****
  } while (false)
  
  /*
!  *  ֥IDϰϤȽ
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
--- 122,128 ----
  } while (false)
  
  /*
!  *  オブジェクトIDの範囲の判定
   */
  #define VALID_TSKID(tskid)	(TMIN_TSKID <= (tskid) && (tskid) <= tmax_tskid)
  #define VALID_SEMID(semid)	(TMIN_SEMID <= (semid) && (semid) <= tmax_semid)
***************
*** 135,141 ****
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  ֥IDΥåE_ID
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
--- 135,141 ----
  #define VALID_ALMID(almid)	(TMIN_ALMID <= (almid) && (almid) <= tmax_almid)
  
  /*
!  *  オブジェクトIDのチェック（E_ID）
   */
  #define CHECK_TSKID(tskid) do {								\
  	if (!VALID_TSKID(tskid)) {								\
***************
*** 208,214 ****
  } while (false)
  
  /*
!  *  ƽФƥȤΥåE_CTX
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
--- 208,214 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストのチェック（E_CTX）
   */
  #define CHECK_TSKCTX() do {									\
  	if (sense_context()) {									\
***************
*** 225,231 ****
  } while (false)
  
  /*
!  *  ƽФƥȤCPUå֤ΥåE_CTX
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
--- 225,231 ----
  } while (false)
  
  /*
!  *  呼出しコンテキストとCPUロック状態のチェック（E_CTX）
   */
  #define CHECK_TSKCTX_UNL() do {								\
  	if (sense_context() || t_sense_lock()) {				\
***************
*** 242,248 ****
  } while (false)
  
  /*
!  *  ǥѥåα֤ǤʤΥåE_CTX
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
--- 242,248 ----
  } while (false)
  
  /*
!  *  ディスパッチ保留状態でないかのチェック（E_CTX）
   */
  #define CHECK_DISPATCH() do {								\
  	if (sense_context() || t_sense_lock() || !dspflg) {		\
***************
*** 252,258 ****
  } while (false)
  
  /*
!  *  ¾Υƥȥ顼ΥåE_CTX
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
--- 252,258 ----
  } while (false)
  
  /*
!  *  その他のコンテキストエラーのチェック（E_CTX）
   */
  #define CHECK_CTX(exp) do {									\
  	if (!(exp)) {											\
***************
*** 262,268 ****
  } while (false)
  
  /*
!  *  ꤷƤʤΥåE_ILUSE
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
--- 262,268 ----
  } while (false)
  
  /*
!  *  自タスクを指定していないかのチェック（E_ILUSE）
   */
  #define CHECK_NONSELF(p_tcb) do {							\
  	if ((p_tcb) == p_runtsk) {								\
***************
*** 272,278 ****
  } while (false)
  
  /*
!  *  ¾ѥ顼ΥåE_ILUSE
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
--- 272,278 ----
  } while (false)
  
  /*
!  *  その他の不正使用エラーのチェック（E_ILUSE）
   */
  #define CHECK_ILUSE(exp) do {								\
  	if (!(exp)) {											\
diff -cr --new-file 1.9.1/asp/kernel/cyclic.c ASPs/asp/kernel/cyclic.c
*** 1.9.1/asp/kernel/cyclic.c	Sun Jun 26 12:14:58 2011
--- ASPs/asp/kernel/cyclic.c	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: cyclic.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		ϥɥ鵡ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: cyclic.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		周期ハンドラ機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "cyclic.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_CYC_ENTER
  #define LOG_CYC_ENTER(p_cyccb)
--- 49,55 ----
  #include "cyclic.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_CYC_ENTER
  #define LOG_CYC_ENTER(p_cyccb)
***************
*** 84,101 ****
  #endif /* LOG_REF_CYC_LEAVE */
  
  /*
!  *  ϥɥο
   */
  #define tnum_cyc	((uint_t)(tmax_cycid - TMIN_CYCID + 1))
  
  /*
!  *  ϥɥIDϥɥ֥åФΥޥ
   */
  #define INDEX_CYC(cycid)	((uint_t)((cycid) - TMIN_CYCID))
  #define get_cyccb(cycid)	(&(cyccb_table[INDEX_CYC(cycid)]))
  
  /*
!  *  ϥɥ鵯ưΤΥ।٥ȥ֥åϿ
   */
  Inline void
  tmevtb_enqueue_cyc(CYCCB *p_cyccb, EVTTIM evttim)
--- 84,101 ----
  #endif /* LOG_REF_CYC_LEAVE */
  
  /*
!  *  周期ハンドラの数
   */
  #define tnum_cyc	((uint_t)(tmax_cycid - TMIN_CYCID + 1))
  
  /*
!  *  周期ハンドラIDから周期ハンドラ管理ブロックを取り出すためのマクロ
   */
  #define INDEX_CYC(cycid)	((uint_t)((cycid) - TMIN_CYCID))
  #define get_cyccb(cycid)	(&(cyccb_table[INDEX_CYC(cycid)]))
  
  /*
!  *  周期ハンドラ起動のためのタイムイベントブロックの登録
   */
  Inline void
  tmevtb_enqueue_cyc(CYCCB *p_cyccb, EVTTIM evttim)
***************
*** 106,112 ****
  }
  
  /*
!  *  ϥɥ鵡ǽν
   */
  #ifdef TOPPERS_cycini
  
--- 106,112 ----
  }
  
  /*
!  *  周期ハンドラ機能の初期化
   */
  #ifdef TOPPERS_cycini
  
***************
*** 132,138 ****
  #endif /* TOPPERS_cycini */
  
  /*
!  *  ϥɥư
   */
  #ifdef TOPPERS_sta_cyc
  
--- 132,138 ----
  #endif /* TOPPERS_cycini */
  
  /*
!  *  周期ハンドラの動作開始
   */
  #ifdef TOPPERS_sta_cyc
  
***************
*** 166,172 ****
  #endif /* TOPPERS_sta_cyc */
  
  /*
!  *  ϥɥư
   */
  #ifdef TOPPERS_stp_cyc
  
--- 166,172 ----
  #endif /* TOPPERS_sta_cyc */
  
  /*
!  *  周期ハンドラの動作停止
   */
  #ifdef TOPPERS_stp_cyc
  
***************
*** 197,203 ****
  #endif /* TOPPERS_stp_cyc */
  
  /*
!  *  ϥɥξֻ
   */
  #ifdef TOPPERS_ref_cyc
  
--- 197,203 ----
  #endif /* TOPPERS_stp_cyc */
  
  /*
!  *  周期ハンドラの状態参照
   */
  #ifdef TOPPERS_ref_cyc
  
***************
*** 231,237 ****
  #endif /* TOPPERS_ref_cyc */
  
  /*
!  *  ϥɥ鵯ư롼
   */
  #ifdef TOPPERS_cyccal
  
--- 231,237 ----
  #endif /* TOPPERS_ref_cyc */
  
  /*
!  *  周期ハンドラ起動ルーチン
   */
  #ifdef TOPPERS_cyccal
  
***************
*** 241,256 ****
  	PRI		saved_ipm;
  
  	/*
! 	 *  εưΤΥ।٥ȥ֥åϿ롥
  	 *
! 	 *  ƱƥåǼϥɥٵư٤ˤϡ
! 	 *  ؿsignal_timeäˡ٤δؿƤФ뤳Ȥˤ
! 	 *  롥
  	 */
  	tmevtb_enqueue_cyc(p_cyccb, p_cyccb->evttim + p_cyccb->p_cycinib->cyctim);
  
  	/*
! 	 *  ϥɥCPUå֤ǸƤӽФ
  	 */
  	saved_ipm = i_get_ipm();
  	i_unlock_cpu();
--- 241,256 ----
  	PRI		saved_ipm;
  
  	/*
! 	 *  次回の起動のためのタイムイベントブロックを登録する．
  	 *
! 	 *  同じタイムティックで周期ハンドラを再度起動すべき場合には，この
! 	 *  関数からsignal_timeに戻った後に，再度この関数が呼ばれることにな
! 	 *  る．
  	 */
  	tmevtb_enqueue_cyc(p_cyccb, p_cyccb->evttim + p_cyccb->p_cycinib->cyctim);
  
  	/*
! 	 *  周期ハンドラを，CPUロック解除状態で呼び出す．
  	 */
  	saved_ipm = i_get_ipm();
  	i_unlock_cpu();
diff -cr --new-file 1.9.1/asp/kernel/cyclic.h ASPs/asp/kernel/cyclic.h
*** 1.9.1/asp/kernel/cyclic.h	Sat Apr 12 10:30:59 2008
--- ASPs/asp/kernel/cyclic.h	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: cyclic.h 748 2008-03-07 17:18:06Z hiro $
   */
  
  /*
!  *		ϥɥ鵡ǽ
   */
  
  #ifndef TOPPERS_CYCLIC_H
--- 8,47 ----
   *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: cyclic.h 748 2008-03-07 17:18:06Z hiro $
   */
  
  /*
!  *		周期ハンドラ機能
   */
  
  #ifndef TOPPERS_CYCLIC_H
***************
*** 50,97 ****
  #include "time_event.h"
  
  /*
!  *  ϥɥ֥å
   */
  typedef struct cyclic_handler_initialization_block {
! 	ATR			cycatr;			/* ϥɥ° */
! 	intptr_t	exinf;			/* ϥɥγĥ */
! 	CYCHDR		cychdr;			/* ϥɥεư */
! 	RELTIM		cyctim;			/* ϥɥεư */
! 	RELTIM		cycphs;			/* ϥɥεư */
  } CYCINIB;
  
  /*
!  *  ϥɥ֥å
   */
  typedef struct cyclic_handler_control_block {
! 	const CYCINIB *p_cycinib;	/* ֥åؤΥݥ */
! 	bool_t		cycsta;			/* ϥɥư */
! 	EVTTIM		evttim;			/* ˼ϥɥư */
! 	TMEVTB		tmevtb;			/* ।٥ȥ֥å */
  } CYCCB;
  
  /*
!  *  ϥɥIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_cycid;
  
  /*
!  *  ϥɥ֥åΥꥢkernel_cfg.c
   */
  extern const CYCINIB	cycinib_table[];
  
  /*
!  *  ϥɥ֥åΥꥢkernel_cfg.c
   */
  extern CYCCB	cyccb_table[];
  
  /*
!  *  ϥɥ鵡ǽν
   */
  extern void	initialize_cyclic(void);
  
  /*
!  *  ϥɥ鵯ư롼
   */
  extern void	call_cychdr(CYCCB *p_cyccb);
  
--- 50,97 ----
  #include "time_event.h"
  
  /*
!  *  周期ハンドラ初期化ブロック
   */
  typedef struct cyclic_handler_initialization_block {
! 	ATR			cycatr;			/* 周期ハンドラ属性 */
! 	intptr_t	exinf;			/* 周期ハンドラの拡張情報 */
! 	CYCHDR		cychdr;			/* 周期ハンドラの起動番地 */
! 	RELTIM		cyctim;			/* 周期ハンドラの起動周期 */
! 	RELTIM		cycphs;			/* 周期ハンドラの起動位相 */
  } CYCINIB;
  
  /*
!  *  周期ハンドラ管理ブロック
   */
  typedef struct cyclic_handler_control_block {
! 	const CYCINIB *p_cycinib;	/* 初期化ブロックへのポインタ */
! 	bool_t		cycsta;			/* 周期ハンドラの動作状態 */
! 	EVTTIM		evttim;			/* 次に周期ハンドラを起動する時刻 */
! 	TMEVTB		tmevtb;			/* タイムイベントブロック */
  } CYCCB;
  
  /*
!  *  周期ハンドラIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_cycid;
  
  /*
!  *  周期ハンドラ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const CYCINIB	cycinib_table[];
  
  /*
!  *  周期ハンドラ管理ブロックのエリア（kernel_cfg.c）
   */
  extern CYCCB	cyccb_table[];
  
  /*
!  *  周期ハンドラ機能の初期化
   */
  extern void	initialize_cyclic(void);
  
  /*
!  *  周期ハンドラ起動ルーチン
   */
  extern void	call_cychdr(CYCCB *p_cyccb);
  
diff -cr --new-file 1.9.1/asp/kernel/dataqueue.c ASPs/asp/kernel/dataqueue.c
*** 1.9.1/asp/kernel/dataqueue.c	Sun Apr 13 18:38:35 2014
--- ASPs/asp/kernel/dataqueue.c	Fri Dec  9 13:54:03 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: dataqueue.c 2629 2014-04-13 09:38:28Z ertl-hiro $
   */
  
  /*
!  *		ǡ塼ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: dataqueue.c 2629 2014-04-13 09:38:28Z ertl-hiro $
   */
  
  /*
!  *		データキュー機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "dataqueue.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SND_DTQ_ENTER
  #define LOG_SND_DTQ_ENTER(dtqid, data)
--- 51,57 ----
  #include "dataqueue.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SND_DTQ_ENTER
  #define LOG_SND_DTQ_ENTER(dtqid, data)
***************
*** 142,159 ****
  #endif /* LOG_REF_DTQ_LEAVE */
  
  /*
!  *  ǡ塼ο
   */
  #define tnum_dtq	((uint_t)(tmax_dtqid - TMIN_DTQID + 1))
  
  /*
!  *  ǡ塼IDǡ塼֥åФΥޥ
   */
  #define INDEX_DTQ(dtqid)	((uint_t)((dtqid) - TMIN_DTQID))
  #define get_dtqcb(dtqid)	(&(dtqcb_table[INDEX_DTQ(dtqid)]))
  
  /*
!  *  ǡ塼ǽν
   */
  #ifdef TOPPERS_dtqini
  
--- 142,159 ----
  #endif /* LOG_REF_DTQ_LEAVE */
  
  /*
!  *  データキューの数
   */
  #define tnum_dtq	((uint_t)(tmax_dtqid - TMIN_DTQID + 1))
  
  /*
!  *  データキューIDからデータキュー管理ブロックを取り出すためのマクロ
   */
  #define INDEX_DTQ(dtqid)	((uint_t)((dtqid) - TMIN_DTQID))
  #define get_dtqcb(dtqid)	(&(dtqcb_table[INDEX_DTQ(dtqid)]))
  
  /*
!  *  データキュー機能の初期化
   */
  #ifdef TOPPERS_dtqini
  
***************
*** 177,183 ****
  #endif /* TOPPERS_dtqini */
  
  /*
!  *  ǡ塼ΰؤΥǡγǼ
   */
  #ifdef TOPPERS_dtqenq
  
--- 177,183 ----
  #endif /* TOPPERS_dtqini */
  
  /*
!  *  データキュー管理領域へのデータの格納
   */
  #ifdef TOPPERS_dtqenq
  
***************
*** 195,201 ****
  #endif /* TOPPERS_dtqenq */
  
  /*
!  *  ǡ塼ΰؤΥǡζǼ
   */
  #ifdef TOPPERS_dtqfenq
  
--- 195,201 ----
  #endif /* TOPPERS_dtqenq */
  
  /*
!  *  データキュー管理領域へのデータの強制格納
   */
  #ifdef TOPPERS_dtqfenq
  
***************
*** 218,224 ****
  #endif /* TOPPERS_dtqfenq */
  
  /*
!  *  ǡ塼ΰ褫ΥǡμФ
   */
  #ifdef TOPPERS_dtqdeq
  
--- 218,224 ----
  #endif /* TOPPERS_dtqfenq */
  
  /*
!  *  データキュー管理領域からのデータの取出し
   */
  #ifdef TOPPERS_dtqdeq
  
***************
*** 236,242 ****
  #endif /* TOPPERS_dtqdeq */
  
  /*
!  *  ǡ塼ؤΥǡ
   */
  #ifdef TOPPERS_dtqsnd
  
--- 236,242 ----
  #endif /* TOPPERS_dtqdeq */
  
  /*
!  *  データキューへのデータ送信
   */
  #ifdef TOPPERS_dtqsnd
  
***************
*** 264,270 ****
  #endif /* TOPPERS_dtqsnd */
  
  /*
!  *  ǡ塼ؤΥǡ
   */
  #ifdef TOPPERS_dtqfsnd
  
--- 264,270 ----
  #endif /* TOPPERS_dtqsnd */
  
  /*
!  *  データキューへのデータ強制送信
   */
  #ifdef TOPPERS_dtqfsnd
  
***************
*** 287,293 ****
  #endif /* TOPPERS_dtqfsnd */
  
  /*
!  *  ǡ塼Υǡ
   */
  #ifdef TOPPERS_dtqrcv
  
--- 287,293 ----
  #endif /* TOPPERS_dtqfsnd */
  
  /*
!  *  データキューからのデータ受信
   */
  #ifdef TOPPERS_dtqrcv
  
***************
*** 324,330 ****
  #endif /* TOPPERS_dtqrcv */
  
  /*
!  *  ǡ塼ؤ
   */
  #ifdef TOPPERS_snd_dtq
  
--- 324,330 ----
  #endif /* TOPPERS_dtqrcv */
  
  /*
!  *  データキューへの送信
   */
  #ifdef TOPPERS_snd_dtq
  
***************
*** 365,371 ****
  #endif /* TOPPERS_snd_dtq */
  
  /*
!  *  ǡ塼ؤʥݡ󥰡
   */
  #ifdef TOPPERS_psnd_dtq
  
--- 365,371 ----
  #endif /* TOPPERS_snd_dtq */
  
  /*
!  *  データキューへの送信（ポーリング）
   */
  #ifdef TOPPERS_psnd_dtq
  
***************
*** 401,407 ****
  #endif /* TOPPERS_psnd_dtq */
  
  /*
!  *  ǡ塼ؤʥݡ󥰡󥿥ƥѡ
   */
  #ifdef TOPPERS_ipsnd_dtq
  
--- 401,407 ----
  #endif /* TOPPERS_psnd_dtq */
  
  /*
!  *  データキューへの送信（ポーリング，非タスクコンテキスト用）
   */
  #ifdef TOPPERS_ipsnd_dtq
  
***************
*** 437,443 ****
  #endif /* TOPPERS_ipsnd_dtq */
  
  /*
!  *  ǡ塼ؤʥॢȤ
   */
  #ifdef TOPPERS_tsnd_dtq
  
--- 437,443 ----
  #endif /* TOPPERS_ipsnd_dtq */
  
  /*
!  *  データキューへの送信（タイムアウトあり）
   */
  #ifdef TOPPERS_tsnd_dtq
  
***************
*** 484,490 ****
  #endif /* TOPPERS_tsnd_dtq */
  
  /*
!  *  ǡ塼ؤζ
   */
  #ifdef TOPPERS_fsnd_dtq
  
--- 484,490 ----
  #endif /* TOPPERS_tsnd_dtq */
  
  /*
!  *  データキューへの強制送信
   */
  #ifdef TOPPERS_fsnd_dtq
  
***************
*** 515,521 ****
  #endif /* TOPPERS_fsnd_dtq */
  
  /*
!  *  ǡ塼ؤζ󥿥ƥѡ
   */
  #ifdef TOPPERS_ifsnd_dtq
  
--- 515,521 ----
  #endif /* TOPPERS_fsnd_dtq */
  
  /*
!  *  データキューへの強制送信（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_ifsnd_dtq
  
***************
*** 546,552 ****
  #endif /* TOPPERS_ifsnd_dtq */
  
  /*
!  *  ǡ塼μ
   */
  #ifdef TOPPERS_rcv_dtq
  
--- 546,552 ----
  #endif /* TOPPERS_ifsnd_dtq */
  
  /*
!  *  データキューからの受信
   */
  #ifdef TOPPERS_rcv_dtq
  
***************
*** 592,598 ****
  #endif /* TOPPERS_rcv_dtq */
  
  /*
!  *  ǡ塼μʥݡ󥰡
   */
  #ifdef TOPPERS_prcv_dtq
  
--- 592,598 ----
  #endif /* TOPPERS_rcv_dtq */
  
  /*
!  *  データキューからの受信（ポーリング）
   */
  #ifdef TOPPERS_prcv_dtq
  
***************
*** 628,634 ****
  #endif /* TOPPERS_prcv_dtq */
  
  /*
!  *  ǡ塼μʥॢȤ
   */
  #ifdef TOPPERS_trcv_dtq
  
--- 628,634 ----
  #endif /* TOPPERS_prcv_dtq */
  
  /*
!  *  データキューからの受信（タイムアウトあり）
   */
  #ifdef TOPPERS_trcv_dtq
  
***************
*** 679,685 ****
  #endif /* TOPPERS_trcv_dtq */
  
  /*
!  *  ǡ塼κƽ
   */
  #ifdef TOPPERS_ini_dtq
  
--- 679,685 ----
  #endif /* TOPPERS_trcv_dtq */
  
  /*
!  *  データキューの再初期化
   */
  #ifdef TOPPERS_ini_dtq
  
***************
*** 717,723 ****
  #endif /* TOPPERS_ini_dtq */
  
  /*
!  *  ǡ塼ξֻ
   */
  #ifdef TOPPERS_ref_dtq
  
--- 717,723 ----
  #endif /* TOPPERS_ini_dtq */
  
  /*
!  *  データキューの状態参照
   */
  #ifdef TOPPERS_ref_dtq
  
diff -cr --new-file 1.9.1/asp/kernel/dataqueue.h ASPs/asp/kernel/dataqueue.h
*** 1.9.1/asp/kernel/dataqueue.h	Wed Jun 12 20:57:00 2013
--- ASPs/asp/kernel/dataqueue.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: dataqueue.h 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		ǡ塼ǽ
   */
  
  #ifndef TOPPERS_DATAQUEUE_H
--- 8,47 ----
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: dataqueue.h 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		データキュー機能
   */
  
  #ifndef TOPPERS_DATAQUEUE_H
***************
*** 50,157 ****
  #include "wait.h"
  
  /*
!  *  ǡ֥å
   */
  typedef struct data_management_block {
! 	intptr_t	data;			/* ǡ */
  } DTQMB;
  
  /*
!  *  ǡ塼֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct dataqueue_initialization_block {
! 	ATR			dtqatr;			/* ǡ塼° */
! 	uint_t		dtqcnt;			/* ǡ塼 */
! 	DTQMB		*p_dtqmb;		/* ǡ塼ΰƬ */
  } DTQINIB;
  
  /*
!  *  ǡ塼֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct dataqueue_control_block {
! 	QUEUE		swait_queue;	/* ǡ塼Ԥ塼 */
! 	const DTQINIB *p_dtqinib;	/* ֥åؤΥݥ */
! 	QUEUE		rwait_queue;	/* ǡ塼Ԥ塼 */
! 	uint_t		count;			/* ǡ塼Υǡο */
! 	uint_t		head;			/* ǽΥǡγǼ */
! 	uint_t		tail;			/* ǸΥǡγǼμ */
  } DTQCB;
  
  /*
!  *  ǡ塼Ԥ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
!  *  ǡ塼ؤԤȥǡ塼μԤǡƱԤ
!  *  ֥åȤ
   */
  typedef struct dataqueue_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	DTQCB		*p_dtqcb;		/* ԤäƤǡ塼δ֥å */
! 	intptr_t	data;			/* ǡ */
  } WINFO_DTQ;
  
  /*
!  *  ǡ塼IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_dtqid;
  
  /*
!  *  ǡ塼֥åΥꥢkernel_cfg.c
   */
  extern const DTQINIB	dtqinib_table[];
  
  /*
!  *  ǡ塼֥åΥꥢkernel_cfg.c
   */
  extern DTQCB	dtqcb_table[];
  
  /*
!  *  ǡ塼֥åǡ塼IDФΥޥ
   */
  #define	DTQID(p_dtqcb)	((ID)(((p_dtqcb) - dtqcb_table) + TMIN_DTQID))
  
  /*
!  *  ǡ塼ǽν
   */
  extern void	initialize_dataqueue(void);
  
  /*
!  *  ǡ塼ΰؤΥǡγǼ
   */
  extern void	enqueue_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  ǡ塼ΰؤΥǡζǼ
   */
  extern void	force_enqueue_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  ǡ塼ΰ褫ΥǡμФ
   */
  extern void	dequeue_data(DTQCB *p_dtqcb, intptr_t *p_data);
  
  /*
!  *  ǡ塼ؤΥǡ
   */
  extern bool_t	send_data(DTQCB *p_dtqcb, intptr_t data, bool_t *p_dspreq);
  
  /*
!  *  ǡ塼ؤΥǡ
   */
  extern bool_t	force_send_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  ǡ塼Υǡ
   */
  extern bool_t	receive_data(DTQCB *p_dtqcb, intptr_t *p_data,
  													bool_t *p_dspreq);
--- 50,157 ----
  #include "wait.h"
  
  /*
!  *  データ管理ブロック
   */
  typedef struct data_management_block {
! 	intptr_t	data;			/* データ本体 */
  } DTQMB;
  
  /*
!  *  データキュー初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct dataqueue_initialization_block {
! 	ATR			dtqatr;			/* データキュー属性 */
! 	uint_t		dtqcnt;			/* データキューの容量 */
! 	DTQMB		*p_dtqmb;		/* データキュー管理領域の先頭番地 */
  } DTQINIB;
  
  /*
!  *  データキュー管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct dataqueue_control_block {
! 	QUEUE		swait_queue;	/* データキュー送信待ちキュー */
! 	const DTQINIB *p_dtqinib;	/* 初期化ブロックへのポインタ */
! 	QUEUE		rwait_queue;	/* データキュー受信待ちキュー */
! 	uint_t		count;			/* データキュー中のデータの数 */
! 	uint_t		head;			/* 最初のデータの格納場所 */
! 	uint_t		tail;			/* 最後のデータの格納場所の次 */
  } DTQCB;
  
  /*
!  *  データキュー待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
!  *  データキューへの送信待ちとデータキューからの受信待ちで，同じ待ち情
!  *  報ブロックを使う．
   */
  typedef struct dataqueue_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	DTQCB		*p_dtqcb;		/* 待っているデータキューの管理ブロック */
! 	intptr_t	data;			/* 送受信データ */
  } WINFO_DTQ;
  
  /*
!  *  データキューIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_dtqid;
  
  /*
!  *  データキュー初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const DTQINIB	dtqinib_table[];
  
  /*
!  *  データキュー管理ブロックのエリア（kernel_cfg.c）
   */
  extern DTQCB	dtqcb_table[];
  
  /*
!  *  データキュー管理ブロックからデータキューIDを取り出すためのマクロ
   */
  #define	DTQID(p_dtqcb)	((ID)(((p_dtqcb) - dtqcb_table) + TMIN_DTQID))
  
  /*
!  *  データキュー機能の初期化
   */
  extern void	initialize_dataqueue(void);
  
  /*
!  *  データキュー管理領域へのデータの格納
   */
  extern void	enqueue_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  データキュー管理領域へのデータの強制格納
   */
  extern void	force_enqueue_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  データキュー管理領域からのデータの取出し
   */
  extern void	dequeue_data(DTQCB *p_dtqcb, intptr_t *p_data);
  
  /*
!  *  データキューへのデータ送信
   */
  extern bool_t	send_data(DTQCB *p_dtqcb, intptr_t data, bool_t *p_dspreq);
  
  /*
!  *  データキューへのデータ強制送信
   */
  extern bool_t	force_send_data(DTQCB *p_dtqcb, intptr_t data);
  
  /*
!  *  データキューからのデータ受信
   */
  extern bool_t	receive_data(DTQCB *p_dtqcb, intptr_t *p_data,
  													bool_t *p_dspreq);
diff -cr --new-file 1.9.1/asp/kernel/eventflag.c ASPs/asp/kernel/eventflag.c
*** 1.9.1/asp/kernel/eventflag.c	Sun Jun 26 12:14:58 2011
--- ASPs/asp/kernel/eventflag.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: eventflag.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		٥ȥե饰ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: eventflag.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		イベントフラグ機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "eventflag.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SET_FLG_ENTER
  #define LOG_SET_FLG_ENTER(flgid, setptn)
--- 51,57 ----
  #include "eventflag.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SET_FLG_ENTER
  #define LOG_SET_FLG_ENTER(flgid, setptn)
***************
*** 118,135 ****
  #endif /* LOG_REF_FLG_LEAVE */
  
  /*
!  *  ٥ȥե饰ο
   */
  #define tnum_flg	((uint_t)(tmax_flgid - TMIN_FLGID + 1))
  
  /*
!  *  ٥ȥե饰ID饤٥ȥե饰֥åФΥޥ
   */
  #define INDEX_FLG(flgid)	((uint_t)((flgid) - TMIN_FLGID))
  #define get_flgcb(flgid)	(&(flgcb_table[INDEX_FLG(flgid)]))
  
  /*
!  *  ٥ȥե饰ǽν
   */
  #ifdef TOPPERS_flgini
  
--- 118,135 ----
  #endif /* LOG_REF_FLG_LEAVE */
  
  /*
!  *  イベントフラグの数
   */
  #define tnum_flg	((uint_t)(tmax_flgid - TMIN_FLGID + 1))
  
  /*
!  *  イベントフラグIDからイベントフラグ管理ブロックを取り出すためのマクロ
   */
  #define INDEX_FLG(flgid)	((uint_t)((flgid) - TMIN_FLGID))
  #define get_flgcb(flgid)	(&(flgcb_table[INDEX_FLG(flgid)]))
  
  /*
!  *  イベントフラグ機能の初期化
   */
  #ifdef TOPPERS_flgini
  
***************
*** 150,156 ****
  #endif /* TOPPERS_flgini */
  
  /*
!  *  ٥ȥե饰ԤΥå
   */
  #ifdef TOPPERS_flgcnd
  
--- 150,156 ----
  #endif /* TOPPERS_flgini */
  
  /*
!  *  イベントフラグ待ち解除条件のチェック
   */
  #ifdef TOPPERS_flgcnd
  
***************
*** 171,177 ****
  #endif /* TOPPERS_flgcnd */
  
  /*
!  *  ٥ȥե饰Υå
   */
  #ifdef TOPPERS_set_flg
  
--- 171,177 ----
  #endif /* TOPPERS_flgcnd */
  
  /*
!  *  イベントフラグのセット
   */
  #ifdef TOPPERS_set_flg
  
***************
*** 222,228 ****
  #endif /* TOPPERS_set_flg */
  
  /*
!  *  ٥ȥե饰Υåȡ󥿥ƥѡ
   */
  #ifdef TOPPERS_iset_flg
  
--- 222,228 ----
  #endif /* TOPPERS_set_flg */
  
  /*
!  *  イベントフラグのセット（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iset_flg
  
***************
*** 269,275 ****
  #endif /* TOPPERS_iset_flg */
  
  /*
!  *  ٥ȥե饰Υꥢ
   */
  #ifdef TOPPERS_clr_flg
  
--- 269,275 ----
  #endif /* TOPPERS_iset_flg */
  
  /*
!  *  イベントフラグのクリア
   */
  #ifdef TOPPERS_clr_flg
  
***************
*** 297,303 ****
  #endif /* TOPPERS_clr_flg */
  
  /*
!  *  ٥ȥե饰Ԥ
   */
  #ifdef TOPPERS_wai_flg
  
--- 297,303 ----
  #endif /* TOPPERS_clr_flg */
  
  /*
!  *  イベントフラグ待ち
   */
  #ifdef TOPPERS_wai_flg
  
***************
*** 344,350 ****
  #endif /* TOPPERS_wai_flg */
  
  /*
!  *  ٥ȥե饰Ԥʥݡ󥰡
   */
  #ifdef TOPPERS_pol_flg
  
--- 344,350 ----
  #endif /* TOPPERS_wai_flg */
  
  /*
!  *  イベントフラグ待ち（ポーリング）
   */
  #ifdef TOPPERS_pol_flg
  
***************
*** 382,388 ****
  #endif /* TOPPERS_pol_flg */
  
  /*
!  *  ٥ȥե饰ԤʥॢȤ
   */
  #ifdef TOPPERS_twai_flg
  
--- 382,388 ----
  #endif /* TOPPERS_pol_flg */
  
  /*
!  *  イベントフラグ待ち（タイムアウトあり）
   */
  #ifdef TOPPERS_twai_flg
  
***************
*** 435,441 ****
  #endif /* TOPPERS_twai_flg */
  
  /*
!  *  ٥ȥե饰κƽ
   */
  #ifdef TOPPERS_ini_flg
  
--- 435,441 ----
  #endif /* TOPPERS_twai_flg */
  
  /*
!  *  イベントフラグの再初期化
   */
  #ifdef TOPPERS_ini_flg
  
***************
*** 468,474 ****
  #endif /* TOPPERS_ini_flg */
  
  /*
!  *  ٥ȥե饰ξֻ
   */
  #ifdef TOPPERS_ref_flg
  
--- 468,474 ----
  #endif /* TOPPERS_ini_flg */
  
  /*
!  *  イベントフラグの状態参照
   */
  #ifdef TOPPERS_ref_flg
  
diff -cr --new-file 1.9.1/asp/kernel/eventflag.h ASPs/asp/kernel/eventflag.h
*** 1.9.1/asp/kernel/eventflag.h	Sun Aug 14 09:35:48 2011
--- ASPs/asp/kernel/eventflag.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: eventflag.h 2228 2011-08-14 00:35:44Z ertl-hiro $
   */
  
  /*
!  *		٥ȥե饰ǽ
   */
  
  #ifndef TOPPERS_EVENTFLAG_H
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: eventflag.h 2228 2011-08-14 00:35:44Z ertl-hiro $
   */
  
  /*
!  *		イベントフラグ機能
   */
  
  #ifndef TOPPERS_EVENTFLAG_H
***************
*** 50,124 ****
  #include "wait.h"
  
  /*
!  *  ٥ȥե饰֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct eventflag_initialization_block {
! 	ATR			flgatr;			/* ٥ȥե饰° */
! 	FLGPTN		iflgptn;		/* ٥ȥե饰Υӥåȥѥν */
  } FLGINIB;
  
  /*
!  *  ٥ȥե饰֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct eventflag_control_block {
! 	QUEUE		wait_queue;		/* ٥ȥե饰Ԥ塼 */
! 	const FLGINIB *p_flginib;	/* ֥åؤΥݥ */
! 	FLGPTN		flgptn;			/* ٥ȥե饰ߥѥ */
  } FLGCB;
  
  /*
!  *  ٥ȥե饰Ԥ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
   *
!  *  flgptnϡwaiptnwfmodeƱ˻ȤȤϤʤᡤΤ
!  *  Х󤹤뤳ȤǽǤ롥
   */
  typedef struct eventflag_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	FLGCB		*p_flgcb;		/* ԤäƤ륤٥ȥե饰δ֥å */
! 	FLGPTN		waiptn;			/* Ԥѥ */
! 	MODE		wfmode;			/* Ԥ⡼ */
! 	FLGPTN		flgptn;			/* ԤΥѥ */
  } WINFO_FLG;
  
  /*
!  *  ٥ȥե饰IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_flgid;
  
  /*
!  *  ٥ȥե饰֥åΥꥢkernel_cfg.c
   */
  extern const FLGINIB	flginib_table[];
  
  /*
!  *  ٥ȥե饰֥åΥꥢkernel_cfg.c
   */
  extern FLGCB	flgcb_table[];
  
  /*
!  *  ٥ȥե饰֥å饤٥ȥե饰IDФΥޥ
   */
  #define	FLGID(p_flgcb)	((ID)(((p_flgcb) - flgcb_table) + TMIN_FLGID))
  
  /*
!  *  ٥ȥե饰ǽν
   */
  extern void	initialize_eventflag(void);
  
  /*
!  *  ٥ȥե饰ԤΥå
   */
  extern bool_t	check_flg_cond(FLGCB *p_flgcb, FLGPTN waiptn,
  								MODE wfmode, FLGPTN *p_flgptn);
--- 50,124 ----
  #include "wait.h"
  
  /*
!  *  イベントフラグ初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct eventflag_initialization_block {
! 	ATR			flgatr;			/* イベントフラグ属性 */
! 	FLGPTN		iflgptn;		/* イベントフラグのビットパターンの初期値 */
  } FLGINIB;
  
  /*
!  *  イベントフラグ管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct eventflag_control_block {
! 	QUEUE		wait_queue;		/* イベントフラグ待ちキュー */
! 	const FLGINIB *p_flginib;	/* 初期化ブロックへのポインタ */
! 	FLGPTN		flgptn;			/* イベントフラグ現在パターン */
  } FLGCB;
  
  /*
!  *  イベントフラグ待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
   *
!  *  flgptnは，waiptnおよびwfmodeと同時に使うことはないため，共用体を使
!  *  えばメモリを節約することが可能である．
   */
  typedef struct eventflag_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	FLGCB		*p_flgcb;		/* 待っているイベントフラグの管理ブロック */
! 	FLGPTN		waiptn;			/* 待ちパターン */
! 	MODE		wfmode;			/* 待ちモード */
! 	FLGPTN		flgptn;			/* 待ち解除時のパターン */
  } WINFO_FLG;
  
  /*
!  *  イベントフラグIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_flgid;
  
  /*
!  *  イベントフラグ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const FLGINIB	flginib_table[];
  
  /*
!  *  イベントフラグ管理ブロックのエリア（kernel_cfg.c）
   */
  extern FLGCB	flgcb_table[];
  
  /*
!  *  イベントフラグ管理ブロックからイベントフラグIDを取り出すためのマクロ
   */
  #define	FLGID(p_flgcb)	((ID)(((p_flgcb) - flgcb_table) + TMIN_FLGID))
  
  /*
!  *  イベントフラグ機能の初期化
   */
  extern void	initialize_eventflag(void);
  
  /*
!  *  イベントフラグ待ち解除条件のチェック
   */
  extern bool_t	check_flg_cond(FLGCB *p_flgcb, FLGPTN waiptn,
  								MODE wfmode, FLGPTN *p_flgptn);
diff -cr --new-file 1.9.1/asp/kernel/exception.c ASPs/asp/kernel/exception.c
*** 1.9.1/asp/kernel/exception.c	Tue Apr 29 12:47:46 2014
--- ASPs/asp/kernel/exception.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: exception.c 2648 2014-04-29 03:47:45Z ertl-hiro $
   */
  
  /*
!  *		CPU㳰ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: exception.c 2648 2014-04-29 03:47:45Z ertl-hiro $
   */
  
  /*
!  *		CPU例外管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "exception.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_XSNS_DPN_ENTER
  #define LOG_XSNS_DPN_ENTER(p_excinf)
--- 49,55 ----
  #include "exception.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_XSNS_DPN_ENTER
  #define LOG_XSNS_DPN_ENTER(p_excinf)
***************
*** 68,74 ****
  #endif /* LOG_XSNS_XPN_LEAVE */
  
  /* 
!  *  CPU㳰ϥɥǽν
   */
  #ifdef TOPPERS_excini
  #ifndef OMIT_INITIALIZE_EXCEPTION
--- 68,74 ----
  #endif /* LOG_XSNS_XPN_LEAVE */
  
  /* 
!  *  CPU例外ハンドラ管理機能の初期化
   */
  #ifdef TOPPERS_excini
  #ifndef OMIT_INITIALIZE_EXCEPTION
***************
*** 89,102 ****
  #endif /* TOPPERS_excini */
  
  /*
!  *  CPU㳰ȯƥȤλ
   */
  
  /*
!  *  CPU㳰ȯΥǥѥåα֤λ
   *
!  *  CPU㳰ϥɥdisdspѲ뤳ȤϤʤᡤCPU㳰ȯ
!  *  disdsp¸ƤɬפϤʤ
   */
  #ifdef TOPPERS_xsns_dpn
  
--- 89,102 ----
  #endif /* TOPPERS_excini */
  
  /*
!  *  CPU例外の発生したコンテキストの参照
   */
  
  /*
!  *  CPU例外発生時のディスパッチ保留状態の参照
   *
!  *  CPU例外ハンドラ中でdisdspが変化することはないため，CPU例外が発生し
!  *  た時のdisdspを保存しておく必要はない．
   */
  #ifdef TOPPERS_xsns_dpn
  
***************
*** 115,125 ****
  #endif /* TOPPERS_xsns_dpn */
  
  /*
!  *  CPU㳰ȯΥ㳰α֤λ
   *
!  *  CPU㳰ϥɥp_runtskp_runtsk->enatexѲ뤳ȤϤʤ
!  *  ᡤCPU㳰ȯp_runtsk->enatex¸ƤɬפϤ
!  *  
   */
  #ifdef TOPPERS_xsns_xpn
  
--- 115,125 ----
  #endif /* TOPPERS_xsns_dpn */
  
  /*
!  *  CPU例外発生時のタスク例外処理保留状態の参照
   *
!  *  CPU例外ハンドラ中でp_runtskとp_runtsk->enatexが変化することはない
!  *  ため，CPU例外が発生した時のp_runtsk->enatexを保存しておく必要はな
!  *  い．
   */
  #ifdef TOPPERS_xsns_xpn
  
diff -cr --new-file 1.9.1/asp/kernel/exception.h ASPs/asp/kernel/exception.h
*** 1.9.1/asp/kernel/exception.h	Sat Apr 12 10:30:58 2008
--- ASPs/asp/kernel/exception.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: exception.h 648 2007-12-15 09:35:35Z hiro $
   */
  
  /*
!  *		CPU㳰ǽ
   */
  
  #ifndef TOPPERS_EXCEPTION_H
--- 8,47 ----
   *  Copyright (C) 2005-2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: exception.h 648 2007-12-15 09:35:35Z hiro $
   */
  
  /*
!  *		CPU例外管理機能
   */
  
  #ifndef TOPPERS_EXCEPTION_H
***************
*** 50,77 ****
  #ifndef OMIT_INITIALIZE_EXCEPTION
  
  /*
!  *  CPU㳰ϥɥ֥å
   */
  typedef struct cpu_exception_handler_initialization_block {
! 	EXCNO		excno;			/* CPU㳰ϥɥֹ */
! 	ATR			excatr;			/* CPU㳰ϥɥ° */
! 	FP			exc_entry;		/* CPU㳰ϥɥν */
  } EXCINIB;
  
  /*
!  *  CPU㳰ϥɥֹοkernel_cfg.c
   */
  extern const uint_t	tnum_excno;
  
  /*
!  *  CPU㳰ϥɥ֥åΥꥢkernel_cfg.c
   */
  extern const EXCINIB	excinib_table[];
  
  #endif /* OMIT_INITIALIZE_EXCEPTION */
  
  /*
!  *  CPU㳰ϥɥǽν
   */
  extern void	initialize_exception(void);
  
--- 50,77 ----
  #ifndef OMIT_INITIALIZE_EXCEPTION
  
  /*
!  *  CPU例外ハンドラ初期化ブロック
   */
  typedef struct cpu_exception_handler_initialization_block {
! 	EXCNO		excno;			/* CPU例外ハンドラ番号 */
! 	ATR			excatr;			/* CPU例外ハンドラ属性 */
! 	FP			exc_entry;		/* CPU例外ハンドラの出入口処理の番地 */
  } EXCINIB;
  
  /*
!  *  CPU例外ハンドラ番号の数（kernel_cfg.c）
   */
  extern const uint_t	tnum_excno;
  
  /*
!  *  CPU例外ハンドラ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const EXCINIB	excinib_table[];
  
  #endif /* OMIT_INITIALIZE_EXCEPTION */
  
  /*
!  *  CPU例外ハンドラ管理機能の初期化
   */
  extern void	initialize_exception(void);
  
diff -cr --new-file 1.9.1/asp/kernel/genoffset.tf ASPs/asp/kernel/genoffset.tf
*** 1.9.1/asp/kernel/genoffset.tf	Sun Apr  3 11:33:09 2011
--- ASPs/asp/kernel/genoffset.tf	Fri Dec  9 13:54:04 2022
***************
*** 7,54 ****
  $   Copyright (C) 2011 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   $Id: genoffset.tf 2046 2011-04-03 02:33:08Z ertl-hiro $
  $ 
  $ =====================================================================
  
  $ 
! $  #defineǥ쥯ƥ֤
  $ 
  $FUNCTION DEFINE$
  	#define $ARGV[1]$$TAB$$FORMAT("%d", +ARGV[2])$$NL$
  $END$
  
  $ 
! $  ӥåȤΥ
  $ 
  $FUNCTION SEARCH_BIT$
  	$_val = ARGV[1]$
--- 7,54 ----
  $   Copyright (C) 2011 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   $Id: genoffset.tf 2046 2011-04-03 02:33:08Z ertl-hiro $
  $ 
  $ =====================================================================
  
  $ 
! $  #defineディレクティブの生成
  $ 
  $FUNCTION DEFINE$
  	#define $ARGV[1]$$TAB$$FORMAT("%d", +ARGV[2])$$NL$
  $END$
  
  $ 
! $  ビットのサーチ
  $ 
  $FUNCTION SEARCH_BIT$
  	$_val = ARGV[1]$
***************
*** 61,67 ****
  $END$
  
  $ 
! $  ӥåȥեɤΥեåȤȥӥåȰ֤
  $ 
  $FUNCTION DEFINE_BIT$
  	$label = ARGV[1]$
--- 61,67 ----
  $END$
  
  $ 
! $  ビットフィールドのオフセットとビット位置の定義の生成
  $ 
  $FUNCTION DEFINE_BIT$
  	$label = ARGV[1]$
***************
*** 110,116 ****
  $END$
  
  $ 
! $  Х֤Υå
  $ 
  $FUNCTION MAGIC_CHECK$
  	$size = ARGV[1]$
--- 110,116 ----
  $END$
  
  $ 
! $  バイト配置のチェック
  $ 
  $FUNCTION MAGIC_CHECK$
  	$size = ARGV[1]$
***************
*** 139,145 ****
  $MAGIC_CHECK(4, { 0x12, 0x34, 0x56, 0x78 })$
  
  $ 
! $  եإå
  $ 
  $FILE "offset.h"$
  /* offset.h */$NL$
--- 139,145 ----
  $MAGIC_CHECK(4, { 0x12, 0x34, 0x56, 0x78 })$
  
  $ 
! $  ファイルヘッダの生成
  $ 
  $FILE "offset.h"$
  /* offset.h */$NL$
diff -cr --new-file 1.9.1/asp/kernel/interrupt.c ASPs/asp/kernel/interrupt.c
*** 1.9.1/asp/kernel/interrupt.c	Sun Jun 26 12:14:58 2011
--- ASPs/asp/kernel/interrupt.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: interrupt.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		ߴǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: interrupt.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		割込み管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 50,56 ****
  #include "interrupt.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_DIS_INT_ENTER
  #define LOG_DIS_INT_ENTER(intno)
--- 50,56 ----
  #include "interrupt.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_DIS_INT_ENTER
  #define LOG_DIS_INT_ENTER(intno)
***************
*** 85,91 ****
  #endif /* LOG_GET_IPM_LEAVE */
  
  /* 
!  *  ߴǽν
   */
  #ifdef TOPPERS_intini
  #ifndef OMIT_INITIALIZE_INTERRUPT
--- 85,91 ----
  #endif /* LOG_GET_IPM_LEAVE */
  
  /* 
!  *  割込み管理機能の初期化
   */
  #ifdef TOPPERS_intini
  #ifndef OMIT_INITIALIZE_INTERRUPT
***************
*** 111,118 ****
  #endif /* TOPPERS_intini */
  
  /*
!  *  ߤζػ
   */
  #ifdef TOPPERS_dis_int
  #ifdef TOPPERS_SUPPORT_DIS_INT
  
--- 111,119 ----
  #endif /* TOPPERS_intini */
  
  /*
!  *  割込みの禁止
   */
+ #undef TOPPERS_dis_int
  #ifdef TOPPERS_dis_int
  #ifdef TOPPERS_SUPPORT_DIS_INT
  
***************
*** 149,156 ****
  #endif /* TOPPERS_dis_int */
  
  /*
!  *  ߤε
   */
  #ifdef TOPPERS_ena_int
  #ifdef TOPPERS_SUPPORT_ENA_INT
  
--- 150,158 ----
  #endif /* TOPPERS_dis_int */
  
  /*
!  *  割込みの許可
   */
+ #undef TOPPERS_ena_int
  #ifdef TOPPERS_ena_int
  #ifdef TOPPERS_SUPPORT_ENA_INT
  
***************
*** 187,193 ****
  #endif /* TOPPERS_ena_int */
  
  /*
!  *  ͥ٥ޥѹ
   */
  #ifdef TOPPERS_chg_ipm
  
--- 189,195 ----
  #endif /* TOPPERS_ena_int */
  
  /*
!  *  割込み優先度マスクの変更
   */
  #ifdef TOPPERS_chg_ipm
  
***************
*** 229,235 ****
  #endif /* TOPPERS_chg_ipm */
  
  /*
!  *  ͥ٥ޥλ
   */
  #ifdef TOPPERS_get_ipm
  
--- 231,237 ----
  #endif /* TOPPERS_chg_ipm */
  
  /*
!  *  割込み優先度マスクの参照
   */
  #ifdef TOPPERS_get_ipm
  
diff -cr --new-file 1.9.1/asp/kernel/interrupt.h ASPs/asp/kernel/interrupt.h
*** 1.9.1/asp/kernel/interrupt.h	Sat Apr 12 10:30:58 2008
--- ASPs/asp/kernel/interrupt.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: interrupt.h 648 2007-12-15 09:35:35Z hiro $
   */
  
  /*
!  *		ߴǽ
   */
  
  #ifndef TOPPERS_INTERRUPT_H
--- 8,47 ----
   *  Copyright (C) 2005-2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: interrupt.h 648 2007-12-15 09:35:35Z hiro $
   */
  
  /*
!  *		割込み管理機能
   */
  
  #ifndef TOPPERS_INTERRUPT_H
***************
*** 50,96 ****
  #ifndef OMIT_INITIALIZE_INTERRUPT
  
  /*
!  *  ߥϥɥ֥å
   */
  typedef struct interrupt_handler_initialization_block {
! 	INHNO		inhno;			/* ߥϥɥֹ */
! 	ATR			inhatr;			/* ߥϥɥ° */
! 	FP			int_entry;		/* ߥϥɥν */
  } INHINIB;
  
  /*
!  *  ׵饤֥å
   */
  typedef struct interrupt_request_initialization_block {
! 	INTNO		intno;			/* ֹ */
! 	ATR			intatr;			/* ° */
! 	PRI			intpri;			/* ͥ */
  } INTINIB;
  
  /*
!  *  ߥϥɥֹοkernel_cfg.c
   */
  extern const uint_t	tnum_inhno;
  
  /*
!  *  ߥϥɥ֥åΥꥢkernel_cfg.c
   */
  extern const INHINIB	inhinib_table[];
  
  /*
!  *  ׵饤οkernel_cfg.c
   */
  extern const uint_t	tnum_intno;
  
  /*
!  *  ׵饤֥åΥꥢkernel_cfg.c
   */
  extern const INTINIB	intinib_table[];
  
  #endif /* OMIT_INITIALIZE_INTERRUPT */
  
  /*
!  *  ߴǽν
   */
  extern void	initialize_interrupt(void);
  
--- 50,96 ----
  #ifndef OMIT_INITIALIZE_INTERRUPT
  
  /*
!  *  割込みハンドラ初期化ブロック
   */
  typedef struct interrupt_handler_initialization_block {
! 	INHNO		inhno;			/* 割込みハンドラ番号 */
! 	ATR			inhatr;			/* 割込みハンドラ属性 */
! 	FP			int_entry;		/* 割込みハンドラの出入口処理の番地 */
  } INHINIB;
  
  /*
!  *  割込み要求ライン初期化ブロック
   */
  typedef struct interrupt_request_initialization_block {
! 	INTNO		intno;			/* 割込み番号 */
! 	ATR			intatr;			/* 割込み属性 */
! 	PRI			intpri;			/* 割込み優先度 */
  } INTINIB;
  
  /*
!  *  割込みハンドラ番号の数（kernel_cfg.c）
   */
  extern const uint_t	tnum_inhno;
  
  /*
!  *  割込みハンドラ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const INHINIB	inhinib_table[];
  
  /*
!  *  割込み要求ラインの数（kernel_cfg.c）
   */
  extern const uint_t	tnum_intno;
  
  /*
!  *  割込み要求ライン初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const INTINIB	intinib_table[];
  
  #endif /* OMIT_INITIALIZE_INTERRUPT */
  
  /*
!  *  割込み管理機能の初期化
   */
  extern void	initialize_interrupt(void);
  
diff -cr --new-file 1.9.1/asp/kernel/kernel.tf ASPs/asp/kernel/kernel.tf
*** 1.9.1/asp/kernel/kernel.tf	Mon Nov 17 03:35:25 2014
--- ASPs/asp/kernel/kernel.tf	Fri Dec  9 13:54:04 2022
***************
*** 8,48 ****
  $   Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   $Id: kernel.tf 2663 2014-11-16 18:35:25Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.h
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
--- 8,48 ----
  $   Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   $Id: kernel.tf 2663 2014-11-16 18:35:25Z ertl-hiro $
  $  
  $ =====================================================================
  
  $ =====================================================================
! $ kernel_cfg.hの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.h"$
***************
*** 91,97 ****
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.c
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
--- 91,97 ----
  #endif /* TOPPERS_KERNEL_CFG_H */$NL$
  
  $ =====================================================================
! $ kernel_cfg.cの生成
  $ =====================================================================
  
  $FILE "kernel_cfg.c"$
***************
*** 105,111 ****
  $NL$
  
  $ 
! $  󥯥롼ɥǥ쥯ƥ֡#include
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
--- 105,111 ----
  $NL$
  
  $ 
! $  インクルードディレクティブ（#include）
  $ 
  /*$NL$
  $SPC$*  Include Directives (#include)$NL$
***************
*** 115,121 ****
  $NL$
  
  $ 
! $  ֥ȤIDֹݻѿ
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
--- 115,121 ----
  $NL$
  
  $ 
! $  オブジェクトのID番号を保持する変数
  $ 
  $IF USE_EXTERNAL_ID$
  	/*$NL$
***************
*** 152,169 ****
  $END$
  
  $
! $  åΰγݴؿ
  $
  $IF !ISFUNCTION("ALLOC_STACK")$
  $FUNCTION ALLOC_STACK$
! $	// 礭˴ݤ᤿ǳݤ
  	static STK_T $ARGV[1]$[COUNT_STK_T($ARGV[2]$)];$NL$
  	$RESULT = FORMAT("ROUND_STK_T(%1%)", ARGV[2])$
  $END$
  $END$
  
  $ 
! $  ȥ졼ޥΥǥե
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
--- 152,169 ----
  $END$
  
  $
! $  スタック領域の確保関数
  $
  $IF !ISFUNCTION("ALLOC_STACK")$
  $FUNCTION ALLOC_STACK$
! $	// 大きい方に丸めたサイズで確保する
  	static STK_T $ARGV[1]$[COUNT_STK_T($ARGV[2]$)];$NL$
  	$RESULT = FORMAT("ROUND_STK_T(%1%)", ARGV[2])$
  $END$
  $END$
  
  $ 
! $  トレースログマクロのデフォルト定義
  $ 
  /*$NL$
  $SPC$*  Default Definitions of Trace Log Macros$NL$
***************
*** 179,228 ****
  $NL$
  
  $ 
! $  
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 1İʾ¸ߤ뤳ȤΥå
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ IDֹκ
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ 顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrʡTA_ACTϡˤǤʤE_RSATR
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)ǤʤE_PAR
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrTA_NULLˤǤʤE_RSATR
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ åΰȤ˴ؤ륨顼å
  $FOREACH tskid TSK.ID_LIST$
! $	// stksz0ʲåκǾ͡TARGET_MIN_STKSZˤ
! $	// E_PAR
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszåΰΥȤʤE_PAR
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
--- 179,228 ----
  $NL$
  
  $ 
! $  タスク
  $ 
  /*$NL$
  $SPC$*  Task Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ タスクが1個以上存在することのチェック
  $IF !LENGTH(TSK.ID_LIST)$
  	$ERROR$$FORMAT(_("no task is registered"))$$END$
  $END$
  
! $ タスクID番号の最大値
  const ID _kernel_tmax_tskid = (TMIN_TSKID + TNUM_TSKID - 1);$NL$
  $NL$
  
! $ エラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// tskatrが（［TA_ACT］）でない場合（E_RSATR）
  	$IF (TSK.TSKATR[tskid] & ~(TA_ACT|TARGET_TSKATR)) != 0$
  		$ERROR TSK.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "tskatr", TSK.TSKATR[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $	// (TMIN_TPRI <= itskpri && itskpri <= TMAX_TPRI)でない場合（E_PAR）
  	$IF !(TMIN_TPRI <= TSK.ITSKPRI[tskid] && TSK.ITSKPRI[tskid] <= TMAX_TPRI)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "itskpri", TSK.ITSKPRI[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// texatrが（TA_NULL）でない場合（E_RSATR）
  	$IF LENGTH(TSK.TEXATR[tskid]) && TSK.TEXATR[tskid] != 0$
  		$ERROR DEF_TEX.TEXT_LINE[tskid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "texatr", TSK.TEXATR[tskid], tskid, "DEF_TEX")$$END$
  	$END$
  $END$
  
! $ スタック領域の生成とそれに関するエラーチェック
  $FOREACH tskid TSK.ID_LIST$
! $	// stkszが0以下か，ターゲット定義の最小値（TARGET_MIN_STKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF TSK.STKSZ[tskid] <= 0 || (TARGET_MIN_STKSZ
  									&& TSK.STKSZ[tskid] < TARGET_MIN_STKSZ)$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is too small"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
  	$END$
  
! $ 	// stkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(TSK.STK[tskid], "NULL") && CHECK_STKSZ_ALIGN
  							&& (TSK.STKSZ[tskid] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR TSK.TEXT_LINE[tskid]$E_PAR: $FORMAT(_("%1% `%2%\' of `%3%\' in %4% is not aligned"), "stksz", TSK.STKSZ[tskid], tskid, "CRE_TSK")$$END$
***************
*** 239,313 ****
  $END$
  $NL$
  
! $ ֥åʥ1İʾ¸ߤ
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// °ĥ󡤵ưϡưͥ
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// ƥȥ֥ååΰ
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// 㳰롼°ȵư
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ ֥å
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ ơ֥
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  ޥե
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ޥեIDֹκ
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ ޥե֥å
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)ǤʤE_PAR
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)ǤʤE_PAR
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// ޥե֥å
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ޥե֥å
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
--- 239,313 ----
  $END$
  $NL$
  
! $ タスク初期化ブロックの生成（タスクは1個以上存在する）
  const TINIB _kernel_tinib_table[TNUM_TSKID] = {$NL$
  $JOINEACH tskid TSK.ID_LIST ",\n"$
! $	// タスク属性，拡張情報，起動番地，起動時優先度
  	$TAB${
  	$SPC$($TSK.TSKATR[tskid]$), (intptr_t)($TSK.EXINF[tskid]$),
  	$SPC$((TASK)($TSK.TASK[tskid]$)), INT_PRIORITY($TSK.ITSKPRI[tskid]$),
  
! $	// タスク初期化コンテキストブロック，スタック領域
  	$IF USE_TSKINICTXB$
  		$GENERATE_TSKINICTXB(tskid)$
  	$ELSE$
  		$SPC$$TSK.TINIB_STKSZ[tskid]$, $TSK.TINIB_STK[tskid]$,
  	$END$
  
! $	// タスク例外処理ルーチンの属性と起動番地
  	$SPC$($ALT(TSK.TEXATR[tskid],"TA_NULL")$), ($ALT(TSK.TEXRTN[tskid],"NULL")$) }
  $END$$NL$
  };$NL$
  $NL$
  
! $ タスク管理ブロックの生成
  TCB _kernel_tcb_table[TNUM_TSKID];$NL$
  $NL$
  
! $ タスク生成順序テーブルの生成
  const ID _kernel_torder_table[TNUM_TSKID] = {$NL$
  $TAB$$JOINEACH tskid TSK.ORDER_LIST ", "$$tskid$$END$$NL$
  };$NL$
  $NL$
  
  $ 
! $  セマフォ
  $ 
  /*$NL$
  $SPC$*  Semaphore Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ セマフォID番号の最大値
  const ID _kernel_tmax_semid = (TMIN_SEMID + TNUM_SEMID - 1);$NL$
  $NL$
  
! $ セマフォ初期化ブロックの生成
  $IF LENGTH(SEM.ID_LIST)$
  	const SEMINIB _kernel_seminib_table[TNUM_SEMID] = {$NL$
  	$JOINEACH semid SEM.ID_LIST ",\n"$
! $		// sematrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (SEM.SEMATR[semid] & ~TA_TPRI) != 0$
  			$ERROR SEM.TEXT_LINE[semid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "sematr", SEM.SEMATR[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (0 <= isemcnt && isemcnt <= maxsem)でない場合（E_PAR）
  		$IF !(0 <= SEM.ISEMCNT[semid] && SEM.ISEMCNT[semid] <= SEM.MAXSEM[semid])$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "isemcnt", SEM.ISEMCNT[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// (1 <= maxsem && maxsem <= TMAX_MAXSEM)でない場合（E_PAR）
  		$IF !(1 <= SEM.MAXSEM[semid] && SEM.MAXSEM[semid] <= TMAX_MAXSEM)$
  			$ERROR SEM.TEXT_LINE[semid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxsem", SEM.MAXSEM[semid], semid, "CRE_SEM")$$END$
  		$END$
  
! $		// セマフォ初期化ブロック
  		$TAB${ ($SEM.SEMATR[semid]$), ($SEM.ISEMCNT[semid]$), ($SEM.MAXSEM[semid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// セマフォ管理ブロック
  	SEMCB _kernel_semcb_table[TNUM_SEMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const SEMINIB, _kernel_seminib_table);$NL$
***************
*** 315,352 ****
  $END$$NL$
  
  $ 
! $  ٥ȥե饰
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ٥ȥե饰IDֹκ
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ ٥ȥե饰֥å
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrʡTA_TPRIϡáTA_WMULϡáTA_CLRϡˤǤʤE_RSATR
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnFLGPTN˳ǼǤʤE_PAR
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// ٥ȥե饰֥å
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ٥ȥե饰֥å
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
--- 315,352 ----
  $END$$NL$
  
  $ 
! $  イベントフラグ
  $ 
  /*$NL$
  $SPC$*  Eventflag Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ イベントフラグID番号の最大値
  const ID _kernel_tmax_flgid = (TMIN_FLGID + TNUM_FLGID - 1);$NL$
  $NL$
  
! $ イベントフラグ初期化ブロックの生成
  $IF LENGTH(FLG.ID_LIST)$
  	const FLGINIB _kernel_flginib_table[TNUM_FLGID] = {$NL$
  	$JOINEACH flgid FLG.ID_LIST ",\n"$
! $		// flgatrが（［TA_TPRI］｜［TA_WMUL］｜［TA_CLR］）でない場合（E_RSATR）
  		$IF (FLG.FLGATR[flgid] & ~(TA_TPRI|TA_WMUL|TA_CLR)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "flgatr", FLG.FLGATR[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// iflgptnがFLGPTNに格納できない場合（E_PAR）
  		$IF (FLG.IFLGPTN[flgid] & ~((1 << TBIT_FLGPTN) - 1)) != 0$
  			$ERROR FLG.TEXT_LINE[flgid]$E_PAR: $FORMAT(_("too large %1% `%2%\' of `%3%\' in %4%"), "iflgptn", FLG.IFLGPTN[flgid], flgid, "CRE_FLG")$$END$
  		$END$
  
! $		// イベントフラグ初期化ブロック
  		$TAB${ ($FLG.FLGATR[flgid]$), ($FLG.IFLGPTN[flgid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// イベントフラグ管理ブロック
  	FLGCB _kernel_flgcb_table[TNUM_FLGID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const FLGINIB, _kernel_flginib_table);$NL$
***************
*** 354,394 ****
  $END$$NL$
  
  $ 
! $  ǡ塼
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ǡ塼IDֹκ
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntξE_PAR
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbNULLǤʤE_NOSPT
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// ǡ塼ΰ
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// ǡ塼֥å
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
--- 354,394 ----
  $END$$NL$
  
  $ 
! $  データキュー
  $ 
  /*$NL$
  $SPC$*  Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ データキューID番号の最大値
  const ID _kernel_tmax_dtqid = (TMIN_DTQID + TNUM_DTQID - 1);$NL$
  $NL$
  
  $IF LENGTH(DTQ.ID_LIST)$
  	$FOREACH dtqid DTQ.ID_LIST$
! $		// dtqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (DTQ.DTQATR[dtqid] & ~TA_TPRI) != 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqatr", DTQ.DTQATR[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqcntが負の場合（E_PAR）
  		$IF DTQ.DTQCNT[dtqid] < 0$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqcnt", DTQ.DTQCNT[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// dtqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(DTQ.DTQMB[dtqid], "NULL")$
  			$ERROR DTQ.TEXT_LINE[dtqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "dtqmb", DTQ.DTQMB[dtqid], dtqid, "CRE_DTQ")$$END$
  		$END$
  
! $		// データキュー管理領域
  		$IF DTQ.DTQCNT[dtqid]$
  			static DTQMB _kernel_dtqmb_$dtqid$[$DTQ.DTQCNT[dtqid]$];$NL$
  		$END$
  	$END$
  
! $	// データキュー初期化ブロックの生成
  	const DTQINIB _kernel_dtqinib_table[TNUM_DTQID] = {$NL$
  	$JOINEACH dtqid DTQ.ID_LIST ",\n"$
  		$TAB${ ($DTQ.DTQATR[dtqid]$), ($DTQ.DTQCNT[dtqid]$), $IF DTQ.DTQCNT[dtqid]$(_kernel_dtqmb_$dtqid$)$ELSE$NULL$END$ }
***************
*** 396,402 ****
  	};$NL$
  	$NL$
  
! $	// ǡ塼֥å
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
--- 396,402 ----
  	};$NL$
  	$NL$
  
! $	// データキュー管理ブロック
  	DTQCB _kernel_dtqcb_table[TNUM_DTQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const DTQINIB, _kernel_dtqinib_table);$NL$
***************
*** 404,449 ****
  $END$$NL$
  
  $ 
! $  ͥ٥ǡ塼
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ͥ٥ǡ塼IDֹκ
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntξE_PAR
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)ǤʤE_PAR
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbNULLǤʤE_NOSPT
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// ͥ٥ǡ塼ΰ
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// ͥ٥ǡ塼֥å
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
--- 404,449 ----
  $END$$NL$
  
  $ 
! $  優先度データキュー
  $ 
  /*$NL$
  $SPC$*  Priority Dataqueue Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 優先度データキューID番号の最大値
  const ID _kernel_tmax_pdqid = (TMIN_PDQID + TNUM_PDQID - 1);$NL$
  $NL$
  
  $IF LENGTH(PDQ.ID_LIST)$
  	$FOREACH pdqid PDQ.ID_LIST$
! $		// pdqatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (PDQ.PDQATR[pdqid] & ~TA_TPRI) != 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqatr", PDQ.PDQATR[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqcntが負の場合（E_PAR）
  		$IF PDQ.PDQCNT[pdqid] < 0$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqcnt", PDQ.PDQCNT[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// (TMIN_DPRI <= maxdpri && maxdpri <= TMAX_DPRI)でない場合（E_PAR）
  		$IF !(TMIN_DPRI <= PDQ.MAXDPRI[pdqid] && PDQ.MAXDPRI[pdqid] <= TMAX_DPRI)$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxdpri", PDQ.MAXDPRI[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// pdqmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(PDQ.PDQMB[pdqid], "NULL")$
  			$ERROR PDQ.TEXT_LINE[pdqid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "pdqmb", PDQ.PDQMB[pdqid], pdqid, "CRE_PDQ")$$END$
  		$END$
  
! $		// 優先度データキュー管理領域
  		$IF PDQ.PDQCNT[pdqid]$
  			static PDQMB _kernel_pdqmb_$pdqid$[$PDQ.PDQCNT[pdqid]$];$NL$
  		$END$
  	$END$
  
! $	// 優先度データキュー初期化ブロックの生成
  	const PDQINIB _kernel_pdqinib_table[TNUM_PDQID] = {$NL$
  	$JOINEACH pdqid PDQ.ID_LIST ",\n"$
  		$TAB${ ($PDQ.PDQATR[pdqid]$), ($PDQ.PDQCNT[pdqid]$), ($PDQ.MAXDPRI[pdqid]$), $IF PDQ.PDQCNT[pdqid]$(_kernel_pdqmb_$pdqid$)$ELSE$NULL$END$ }
***************
*** 451,457 ****
  	};$NL$
  	$NL$
  
! $	// ͥ٥ǡ塼֥å
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
--- 451,457 ----
  	};$NL$
  	$NL$
  
! $	// 優先度データキュー管理ブロック
  	PDQCB _kernel_pdqcb_table[TNUM_PDQID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const PDQINIB, _kernel_pdqinib_table);$NL$
***************
*** 459,501 ****
  $END$$NL$
  
  $ 
! $  ᡼ܥå
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ᡼ܥåIDֹκ
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ ᡼ܥå֥å
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrʡTA_TPRIϡáTA_MPRIϡˤǤʤE_RSATR
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)ǤʤE_PAR
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdNULLǤʤE_NOSPT
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// ᡼ܥå֥å
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ᡼ܥå֥å
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
--- 459,501 ----
  $END$$NL$
  
  $ 
! $  メールボックス
  $ 
  /*$NL$
  $SPC$*  Mailbox Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ メールボックスID番号の最大値
  const ID _kernel_tmax_mbxid = (TMIN_MBXID + TNUM_MBXID - 1);$NL$
  $NL$
  
! $ メールボックス初期化ブロックの生成
  $IF LENGTH(MBX.ID_LIST)$
  	const MBXINIB _kernel_mbxinib_table[TNUM_MBXID] = {$NL$
  	$JOINEACH mbxid MBX.ID_LIST ",\n"$
! $		// mbxatrが（［TA_TPRI］｜［TA_MPRI］）でない場合（E_RSATR）
  		$IF (MBX.MBXATR[mbxid] & ~(TA_TPRI|TA_MPRI)) != 0$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mbxatr", MBX.MBXATR[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// (TMIN_MPRI <= maxmpri && maxmpri <= TMAX_MPRI)でない場合（E_PAR）
  		$IF !(TMIN_MPRI <= MBX.MAXMPRI[mbxid] && MBX.MAXMPRI[mbxid] <= TMAX_MPRI)$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "maxmpri", MBX.MAXMPRI[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// mprihdがNULLでない場合（E_NOSPT）
  		$IF !EQ(MBX.MPRIHD[mbxid], "NULL")$
  			$ERROR MBX.TEXT_LINE[mbxid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mprihd", MBX.MPRIHD[mbxid], mbxid, "CRE_MBX")$$END$
  		$END$
  
! $		// メールボックス初期化ブロック
  		$TAB${ ($MBX.MBXATR[mbxid]$), ($MBX.MAXMPRI[mbxid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// メールボックス管理ブロック
  	MBXCB _kernel_mbxcb_table[TNUM_MBXID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MBXINIB, _kernel_mbxinib_table);$NL$
***************
*** 503,551 ****
  $END$$NL$
  
  $ 
! $  Ĺס
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ĹסIDֹκ
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrʡTA_TPRIϡˤǤʤE_RSATR
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcnt0ʲξE_PAR
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blksz0ʲξE_PAR
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbNULLǤʤE_NOSPT
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// Ĺסΰ
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// Ĺס֥å
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
--- 503,551 ----
  $END$$NL$
  
  $ 
! $  固定長メモリプール
  $ 
  /*$NL$
  $SPC$*  Fixed-sized Memorypool Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 固定長メモリプールID番号の最大値
  const ID _kernel_tmax_mpfid = (TMIN_MPFID + TNUM_MPFID - 1);$NL$
  $NL$
  
  $IF LENGTH(MPF.ID_LIST)$
  	$FOREACH mpfid MPF.ID_LIST$
! $		// mpfatrが（［TA_TPRI］）でない場合（E_RSATR）
  		$IF (MPF.MPFATR[mpfid] & ~TA_TPRI) != 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfatr", MPF.MPFATR[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkcntが0以下の場合（E_PAR）
  		$IF MPF.BLKCNT[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blkcnt", MPF.BLKCNT[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// blkszが0以下の場合（E_PAR）
  		$IF MPF.BLKSZ[mpfid] <= 0$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "blksz", MPF.BLKSZ[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール領域
  		$IF EQ(MPF.MPF[mpfid], "NULL")$
  			static MPF_T _kernel_mpf_$mpfid$[($MPF.BLKCNT[mpfid]$) * COUNT_MPF_T($MPF.BLKSZ[mpfid]$)];$NL$
  		$END$
  
! $		// mpfmbがNULLでない場合（E_NOSPT）
  		$IF !EQ(MPF.MPFMB[mpfid], "NULL")$
  			$ERROR MPF.TEXT_LINE[mpfid]$E_NOSPT: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "mpfmb", MPF.MPFMB[mpfid], mpfid, "CRE_MPF")$$END$
  		$END$
  
! $		// 固定長メモリプール管理領域
  		static MPFMB _kernel_mpfmb_$mpfid$[$MPF.BLKCNT[mpfid]$];$NL$
  	$END$
  
! $	// 固定長メモリプール初期化ブロックの生成
  	const MPFINIB _kernel_mpfinib_table[TNUM_MPFID] = {$NL$
  	$JOINEACH mpfid MPF.ID_LIST ",\n"$
  		$TAB${ ($MPF.MPFATR[mpfid]$), ($MPF.BLKCNT[mpfid]$), ROUND_MPF_T($MPF.BLKSZ[mpfid]$), $IF EQ(MPF.MPF[mpfid],"NULL")$(_kernel_mpf_$mpfid$)$ELSE$(void *)($MPF.MPF[mpfid]$)$END$, (_kernel_mpfmb_$mpfid$) }
***************
*** 553,559 ****
  	};$NL$
  	$NL$
  
! $	// Ĺס֥å
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
--- 553,559 ----
  	};$NL$
  	$NL$
  
! $	// 固定長メモリプール管理ブロック
  	MPFCB _kernel_mpfcb_table[TNUM_MPFID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const MPFINIB, _kernel_mpfinib_table);$NL$
***************
*** 561,608 ****
  $END$$NL$
  
  $ 
! $  ϥɥ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ϥɥIDֹκ
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ ϥɥơ֥
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrʡTA_STAϡˤǤʤE_RSATR
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)ǤʤE_PAR
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// ٹcycatrTA_STAꤵƤơ(cycphs == 0)ξ
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// ϥɥ֥å
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// ϥɥ֥å
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
--- 561,608 ----
  $END$$NL$
  
  $ 
! $  周期ハンドラ
  $ 
  /*$NL$
  $SPC$*  Cyclic Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 周期ハンドラID番号の最大値
  const ID _kernel_tmax_cycid = (TMIN_CYCID + TNUM_CYCID - 1);$NL$
  $NL$
  
! $ 周期ハンドラ初期化テーブルの生成
  $IF LENGTH(CYC.ID_LIST)$
  	const CYCINIB _kernel_cycinib_table[TNUM_CYCID] = {$NL$
  	$JOINEACH cycid CYC.ID_LIST ",\n"$
! $		// cycatrが（［TA_STA］）でない場合（E_RSATR）
  		$IF (CYC.CYCATR[cycid] & ~TA_STA) != 0$
  			$ERROR CYC.TEXT_LINE[cycid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycatr", CYC.CYCATR[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 < cyctim && cyctim <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 < CYC.CYCTIM[cycid] && CYC.CYCTIM[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cyctim", CYC.CYCTIM[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// (0 <= cycphs && cycphs <= TMAX_RELTIM)でない場合（E_PAR）
  		$IF !(0 <= CYC.CYCPHS[cycid] && CYC.CYCPHS[cycid] <= TMAX_RELTIM)$
  			$ERROR CYC.TEXT_LINE[cycid]$E_PAR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "cycphs", CYC.CYCPHS[cycid], cycid, "CRE_CYC")$$END$
  		$END$
  
! $		// 警告：cycatrにTA_STAが設定されていて，(cycphs == 0)の場合
  		$IF (CYC.CYCATR[cycid] & TA_STA) != 0 && CYC.CYCPHS[cycid] == 0$
  			$WARNING CYC.TEXT_LINE[cycid]$$FORMAT(_("%1% is not recommended when %2% is set to %3% in %4%"), "cycphs==0", "TA_STA", "cycatr", "CRE_CYC")$$END$
  		$END$
  
! $		// 周期ハンドラ初期化ブロック
  		$TAB${ ($CYC.CYCATR[cycid]$), (intptr_t)($CYC.EXINF[cycid]$), ($CYC.CYCHDR[cycid]$), ($CYC.CYCTIM[cycid]$), ($CYC.CYCPHS[cycid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 周期ハンドラ管理ブロック
  	CYCCB _kernel_cyccb_table[TNUM_CYCID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const CYCINIB, _kernel_cycinib_table);$NL$
***************
*** 610,642 ****
  $END$$NL$
  
  $ 
! $  顼ϥɥ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 顼ϥɥIDֹκ
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ 顼ϥɥ֥å
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrTA_NULLˤǤʤE_RSATR
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// 顼ϥɥ֥å
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// 顼ϥɥ֥å
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
--- 610,642 ----
  $END$$NL$
  
  $ 
! $  アラームハンドラ
  $ 
  /*$NL$
  $SPC$*  Alarm Handler Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ アラームハンドラID番号の最大値
  const ID _kernel_tmax_almid = (TMIN_ALMID + TNUM_ALMID - 1);$NL$
  $NL$
  
! $ アラームハンドラ初期化ブロックの生成
  $IF LENGTH(ALM.ID_LIST)$
  	const ALMINIB _kernel_alminib_table[TNUM_ALMID] = {$NL$
  	$JOINEACH almid ALM.ID_LIST ",\n"$
! $		// almatrが（TA_NULL）でない場合（E_RSATR）
  		$IF ALM.ALMATR[almid] != 0$
  			$ERROR ALM.TEXT_LINE[almid]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of `%3%\' in %4%"), "almatr", ALM.ALMATR[almid], almid, "CRE_ALM")$$END$
  		$END$
  
! $		// アラームハンドラ初期化ブロック
  		$TAB${ ($ALM.ALMATR[almid]$), (intptr_t)($ALM.EXINF[almid]$), ($ALM.ALMHDR[almid]$) }
  	$END$$NL$
  	};$NL$
  	$NL$
  
! $	// アラームハンドラ管理ブロック
  	ALMCB _kernel_almcb_table[TNUM_ALMID];$NL$
  $ELSE$
  	TOPPERS_EMPTY_LABEL(const ALMINIB, _kernel_alminib_table);$NL$
***************
*** 644,657 ****
  $END$$NL$
  
  $ 
! $  ߴǽ
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ ֹȳߥϥɥֹѴơ֥κ
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
--- 644,657 ----
  $END$$NL$
  
  $ 
! $  割込み管理機能
  $ 
  /*$NL$
  $SPC$*  Interrupt Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ 割込み番号と割込みハンドラ番号の変換テーブルの作成
  $IF LENGTH(INTNO_ATTISR_VALID) != LENGTH(INHNO_ATTISR_VALID)$
  	$ERROR$length of `INTNO_ATTISR_VALID' is different from length of `INHNO_ATTISR_VALID'$END$
  $END$
***************
*** 663,677 ****
  	$i = i + 1$
  $END$
  
! $ ׵饤˴ؤ륨顼å
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoCFG_INTФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoCFG_INTˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
--- 663,677 ----
  	$i = i + 1$
  $END$
  
! $ 割込み要求ラインに関するエラーチェック
  $i = 0$
  $FOREACH intno INT.ORDER_LIST$
! $	// intnoがCFG_INTに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_CFGINT_VALID, INT.INTNO[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intnoがCFG_INTによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH intno2 INT.ORDER_LIST$
  		$IF INT.INTNO[intno] == INT.INTNO[intno2] && j < i$
***************
*** 680,705 ****
  		$j = j + 1$
  	$END$
  
! $	// intatrʡTA_ENAINTϡáTA_EDGEϡˤǤʤE_RSATR
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriCFG_INTФͥ٤ȤʤE_PAR
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵ줿E_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤintnoФơintpriTMIN_INTPRI
! $	// ⾮ͤꤵʤäE_OBJ
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
--- 680,705 ----
  		$j = j + 1$
  	$END$
  
! $	// intatrが（［TA_ENAINT］｜［TA_EDGE］）でない場合（E_RSATR）
  	$IF (INT.INTATR[intno] & ~(TA_ENAINT|TA_EDGE|TARGET_INTATR)) != 0$
  		$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "intatr", INT.INTATR[intno], "intno", INT.INTNO[intno], "CFG_INT")$$END$
  	$END$
  
! $	// intpriがCFG_INTに対する割込み優先度として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTPRI_CFGINT_VALID, INT.INTPRI[intno]))$
  		$ERROR INT.TEXT_LINE[intno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intpri", INT.INTPRI[intno], "CFG_INT")$$END$
  	$END$
  
! $	// カーネル管理に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定された場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_KERNEL, intno))$
  		$IF INT.INTPRI[intno] < TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must not have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているintnoに対して，intpriにTMIN_INTPRI
! $	// よりも小さい値が指定されなかった場合（E_OBJ）
  	$IF LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))$
  		$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  			$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' must have higher priority than %3%"), "intno", INT.INTNO[intno], "TMIN_INTPRI")$$END$
***************
*** 708,722 ****
  	$i = i + 1$
  $END$
  
! $ ߥϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoDEF_INHФߥϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoDEF_INHˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
--- 708,722 ----
  	$i = i + 1$
  $END$
  
! $ 割込みハンドラに関するエラーチェック
  $i = 0$
  $FOREACH inhno INH.ORDER_LIST$
! $	// inhnoがDEF_INHに対する割込みハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INHNO_DEFINH_VALID, INH.INHNO[inhno]))$
  		$ERROR INH.TEXT_LINE[inhno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// inhnoがDEF_INHによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH inhno2 INH.ORDER_LIST$
  		$IF INH.INHNO[inhno] == INH.INHNO[inhno2] && j < i$
***************
*** 725,745 ****
  		$j = j + 1$
  	$END$
  
! $	// inhatrTA_NULLˤǤʤE_RSATR
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	//ꤵƤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// ͥ˸ꤵƤinhnoФơinhatrTA_NONKERNEL
! $	// ꤵƤʤE_RSATR
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
--- 725,745 ----
  		$j = j + 1$
  	$END$
  
! $	// inhatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (INH.INHATR[inhno] & ~TARGET_INHATR) != 0$
  		$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "inhatr", INH.INHATR[inhno], "inhno", INH.INHNO[inhno], "DEF_INH")$$END$
  	$END$
  
! $	// カーネル管理に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	//　が指定されている場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_KERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) != 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must not be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
  		$END$
  	$END$
  
! $	// カーネル管理外に固定されているinhnoに対して，inhatrにTA_NONKERNEL
! $	// が指定されていない場合（E_RSATR）
  	$IF LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))$
  		$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
  			$ERROR INH.TEXT_LINE[inhno]$E_RSATR: $FORMAT(_("%1% `%2%\' must be non-kernel interrupt"), "inhno", INH.INHNO[inhno])$$END$
***************
*** 748,768 ****
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoбintnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrTA_NONKERNELꤵƤ餺inhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRI⾮E_OBJ
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrTA_NONKERNELꤵƤꡤinhnoб
! $				// intnoФCFG_INTꤵ줿ͥ٤
! $				// TMIN_INTPRIʾǤE_OBJ
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
--- 748,768 ----
  
  	$IF LENGTH(INTNO[INH.INHNO[inhno]])$
  		$intno = INTNO[INH.INHNO[inhno]]$
! $		// inhnoに対応するintnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR INH.TEXT_LINE[inhno]$E_OBJ: $FORMAT(_("%1% `%2%\' corresponding to %3% `%4%\' is not configured with %5%"), "intno", INT.INTNO[intno], "inhno", INH.INHNO[inhno], "CFG_INT")$$END$
  		$ELSE$
  			$IF (INH.INHATR[inhno] & TA_NONKERNEL) == 0$
! $				// inhatrにTA_NONKERNELが指定されておらず，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRIよりも小さい場合（E_OBJ）
  				$IF INT.INTPRI[intno] < TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
  			$ELSE$
! $				// inhatrにTA_NONKERNELが指定されており，inhnoに対応
! $				// するintnoに対してCFG_INTで設定された割込み優先度が
! $				// TMIN_INTPRI以上である場合（E_OBJ）
  				$IF INT.INTPRI[intno] >= TMIN_INTPRI$
  					$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is lower than or equal to %5%"), "intpri", INT.INTPRI[intno], "inhno", INH.INHNO[inhno], "TMIN_INTPRI")$$END$
  				$END$
***************
*** 772,790 ****
  	$i = i + 1$
  $END$
  
! $ ߥӥ롼ISRˤ˴ؤ륨顼åȳߥϥɥ
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrTA_NULLˤǤʤE_RSATR
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoATT_ISRФֹȤʤE_PAR
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)ǤʤE_PAR
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
--- 772,790 ----
  	$i = i + 1$
  $END$
  
! $ 割込みサービスルーチン（ISR）に関するエラーチェックと割込みハンドラの生成
  $FOREACH order ISR.ORDER_LIST$
! $	// isratrが（TA_NULL）でない場合（E_RSATR）
  	$IF (ISR.ISRATR[order] & ~TARGET_ISRATR) != 0$
  		$ERROR ISR.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isratr", ISR.ISRATR[order], "ATT_ISR")$$END$
  	$END$
  
! $	// intnoがATT_ISRに対する割込み番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(INTNO_ATTISR_VALID, ISR.INTNO[order]))$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "intno", ISR.INTNO[order], "ATT_ISR")$$END$
  	$END$
  
! $	// (TMIN_ISRPRI <= isrpri && isrpri <= TMAX_ISRPRI)でない場合（E_PAR）
  	$IF !(TMIN_ISRPRI <= ISR.ISRPRI[order] && ISR.ISRPRI[order] <= TMAX_ISRPRI)$
  		$ERROR ISR.TEXT_LINE[order]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "isrpri", ISR.ISRPRI[order], "ATT_ISR")$$END$
  	$END$
***************
*** 793,799 ****
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// ֹintnoФϿ줿ISRΥꥹȤκ
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
--- 793,799 ----
  $FOREACH intno INTNO_ATTISR_VALID$
  	$inhno = INHNO[intno]$
  
! $	// 割込み番号intnoに対して登録されたISRのリストの作成
  	$isr_order_list = {}$
  	$FOREACH order ISR.ORDER_LIST$
  		$IF ISR.INTNO[order] == intno$
***************
*** 802,820 ****
  		$END$
  	$END$
  
! $	// ֹintnoФϿ줿ISR¸ߤ
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoбinhnoФDEF_INHE_OBJ
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoФCFG_INTʤE_OBJ
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoФCFG_INTꤵ줿ͥ٤TMIN_INTPRI
! $			// ⾮E_OBJ
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
--- 802,820 ----
  		$END$
  	$END$
  
! $	// 割込み番号intnoに対して登録されたISRが存在する場合
  	$IF LENGTH(isr_order_list) > 0$
! $		// intnoに対応するinhnoに対してDEF_INHがある場合（E_OBJ）
  		$IF LENGTH(INH.INHNO[inhno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' in %3% is duplicated with %4% `%5%\'"), "intno", ISR.INTNO[order_for_error], "ATT_ISR", "inhno", INH.INHNO[inhno])$$END$
  		$END$
  
! $		// intnoに対するCFG_INTがない場合（E_OBJ）
  		$IF !LENGTH(INT.INTNO[intno])$
  			$ERROR ISR.TEXT_LINE[order_for_error]$E_OBJ: $FORMAT(_("%1% `%2%\' is not configured with %3%"), "intno", ISR.INTNO[order_for_error], "CFG_INT")$$END$
  		$ELSE$
! $			// intnoに対してCFG_INTで設定された割込み優先度がTMIN_INTPRI
! $			// よりも小さい場合（E_OBJ）
  			$IF INT.INTPRI[intno] < TMIN_INTPRI$
  				$ERROR INT.TEXT_LINE[intno]$E_OBJ: $FORMAT(_("%1% `%2%\' configured for %3% `%4%\' is higher than %5%"), "intpri", INT.INTPRI[intno], "intno", ISR.INTNO[order_for_error], "TMIN_INTPRI")$$END$
  			$END$
***************
*** 826,832 ****
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISRѤγߥϥɥ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
--- 826,832 ----
  		$INH.INTHDR[inhno] = CONCAT("_kernel_inthdr_", intno)$
  		$INH.ORDER_LIST = APPEND(INH.ORDER_LIST, inhno)$
  
! $		// ISR用の割込みハンドラ
  		void$NL$
  		_kernel_inthdr_$intno$(void)$NL$
  		{$NL$
***************
*** 838,844 ****
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRͥٽ˸ƤӽФ
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
--- 838,844 ----
  		$ELSE$
  			$TAB$i_begin_int($intno$);$NL$
  		$END$
! $		// ISRを優先度順に呼び出す
  		$JOINEACH order SORT(isr_order_list, "ISR.ISRPRI") "\tif (i_sense_lock()) {\n\t\ti_unlock_cpu();\n\t}\n\ti_set_ipm(saved_ipm);\n"$
  			$TAB$LOG_ISR_ENTER($intno$);$NL$
  			$TAB$((ISR)($ISR.ISR[order]$))((intptr_t)($ISR.EXINF[order]$));$NL$
***************
*** 851,862 ****
  $NL$
  
  $ 
! $  ߴǽΤɸŪʽ
  $ 
! $ ߥϥɥνɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ ߥϥɥ
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
--- 851,862 ----
  $NL$
  
  $ 
! $  割込み管理機能のための標準的な初期化情報の生成
  $ 
! $ 割込みハンドラの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INHINIB_TABLE,0)$
  
! $ 割込みハンドラ数
  #define TNUM_INHNO	$LENGTH(INH.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_inhno = TNUM_INHNO;$NL$
  $NL$
***************
*** 867,873 ****
  $END$
  $NL$
  
! $ ߥϥɥơ֥
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
--- 867,873 ----
  $END$
  $NL$
  
! $ 割込みハンドラ初期化テーブル
  $IF LENGTH(INH.ORDER_LIST)$
  	const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
  	$JOINEACH inhno INH.ORDER_LIST ",\n"$
***************
*** 883,897 ****
  $END$$NL$
  $END$
  
! $ ׵饤νɬפʾ
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ ׵饤
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ ׵饤ơ֥
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
--- 883,897 ----
  $END$$NL$
  $END$
  
! $ 割込み要求ラインの初期化に必要な情報
  $IF !OMIT_INITIALIZE_INTERRUPT || ALT(USE_INTINIB_TABLE,0)$
  
! $ 割込み要求ライン数
  #define TNUM_INTNO	$LENGTH(INT.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_intno = TNUM_INTNO;$NL$
  $NL$
  
! $ 割込み要求ライン初期化テーブル
  $IF LENGTH(INT.ORDER_LIST)$
  	const INTINIB _kernel_intinib_table[TNUM_INTNO] = {$NL$
  	$JOINEACH intno INT.ORDER_LIST ",\n"$
***************
*** 904,925 ****
  $END$
  
  $ 
! $  CPU㳰ǽ
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU㳰ϥɥ˴ؤ륨顼å
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoDEF_EXCФCPU㳰ϥɥֹȤʤE_PAR
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoDEF_EXCˤäѤߤξE_OBJ
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
--- 904,925 ----
  $END$
  
  $ 
! $  CPU例外管理機能
  $ 
  /*$NL$
  $SPC$*  CPU Exception Management Functions$NL$
  $SPC$*/$NL$
  $NL$
  
! $ CPU例外ハンドラに関するエラーチェック
  $i = 0$
  $FOREACH excno EXC.ORDER_LIST$
! $	// excnoがDEF_EXCに対するCPU例外ハンドラ番号として正しくない場合（E_PAR）
  	$IF !LENGTH(FIND(EXCNO_DEFEXC_VALID, EXC.EXCNO[excno]))$
  		$ERROR EXC.TEXT_LINE[excno]$E_PAR: $FORMAT(_("illegal %1% `%2%\' in %3%"), "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  
! $	// excnoがDEF_EXCによって設定済みの場合（E_OBJ）
  	$j = 0$
  	$FOREACH excno2 EXC.ORDER_LIST$
  		$IF EXC.EXCNO[excno] == EXC.EXCNO[excno2] && j < i$
***************
*** 928,944 ****
  		$j = j + 1$
  	$END$
  
! $	// excatrTA_NULLˤǤʤE_RSATR
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU㳰ϥɥΤɸŪʽ
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU㳰ϥɥ
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
--- 928,944 ----
  		$j = j + 1$
  	$END$
  
! $	// excatrが（TA_NULL）でない場合（E_RSATR）
  	$IF (EXC.EXCATR[excno] & ~TARGET_EXCATR) != 0$
  		$ERROR EXC.TEXT_LINE[excno]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "excatr", EXC.EXCATR[excno], "excno", EXC.EXCNO[excno], "DEF_EXC")$$END$
  	$END$
  	$i = i + 1$
  $END$
  
! $ CPU例外ハンドラのための標準的な初期化情報の生成
  $IF !OMIT_INITIALIZE_EXCEPTION$
  
! $ CPU例外ハンドラ数
  #define TNUM_EXCNO	$LENGTH(EXC.ORDER_LIST)$$NL$
  const uint_t _kernel_tnum_excno = TNUM_EXCNO;$NL$
  $NL$
***************
*** 947,953 ****
  $END$
  $NL$
  
! $ CPU㳰ϥɥơ֥
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
--- 947,953 ----
  $END$
  $NL$
  
! $ CPU例外ハンドラ初期化テーブル
  $IF LENGTH(EXC.ORDER_LIST)$
  	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
  	$JOINEACH excno EXC.ORDER_LIST ",\n"$
***************
*** 960,966 ****
  $END$
  
  $ 
! $  󥿥ƥѤΥåΰ
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
--- 960,966 ----
  $END$
  
  $ 
! $  非タスクコンテキスト用のスタック領域
  $ 
  /*$NL$
  $SPC$*  Stack Area for Non-task Context$NL$
***************
*** 968,974 ****
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSʤΥǥեͤ
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
--- 968,974 ----
  $NL$
  
  $IF !LENGTH(ICS.ORDER_LIST)$
! $	// DEF_ICSがない場合のデフォルト値の設定
  	#ifdef DEFAULT_ISTK$NL$
  	$NL$
  	#define TOPPERS_ISTKSZ		DEFAULT_ISTKSZ$NL$
***************
*** 983,1008 ****
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// ŪAPIDEF_ICSפʣE_OBJ
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istksz0ʲåκǾ͡TARGET_MIN_ISTKSZˤ
! $	// E_PAR
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszåΰΥȤʤE_PAR
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// åΰμưդ
  		$istksz = ALLOC_STACK("_kernel_istack", ICS.ISTKSZ[1])$$NL$
  		#define TOPPERS_ISTKSZ		$istksz$$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
--- 983,1008 ----
  	#endif /* DEAULT_ISTK */$NL$
  $ELSE$
  
! $	// 静的API「DEF_ICS」が複数ある（E_OBJ）
  	$IF LENGTH(ICS.ORDER_LIST) > 1$
  		$ERROR$E_OBJ: $FORMAT(_("too many %1%"), "DEF_ICS")$$END$
  	$END$
  
! $	// istkszが0以下か，ターゲット定義の最小値（TARGET_MIN_ISTKSZ）よりも
! $	// 小さい場合（E_PAR）
  	$IF ICS.ISTKSZ[1] <= 0 || (TARGET_MIN_ISTKSZ
  									&& ICS.ISTKSZ[1] < TARGET_MIN_ISTKSZ)$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is too small"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
! $ 	// istkszがスタック領域のサイズとして正しくない場合（E_PAR）
  	$IF !EQ(ICS.ISTK[1], "NULL") && CHECK_STKSZ_ALIGN
  							&& (ICS.ISTKSZ[1] & (CHECK_STKSZ_ALIGN - 1))$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: $FORMAT(_("%1% `%2%\' in %3% is not aligned"), "istksz", ICS.ISTKSZ[1], "DEF_ICS")$$END$
  	$END$
  
  	$IF EQ(ICS.ISTK[1], "NULL")$
! $		// スタック領域の自動割付け
  		$istksz = ALLOC_STACK("_kernel_istack", ICS.ISTKSZ[1])$$NL$
  		#define TOPPERS_ISTKSZ		$istksz$$NL$
  		#define TOPPERS_ISTK		_kernel_istack$NL$
***************
*** 1013,1019 ****
  $END$
  $NL$
  
! $ 󥿥ƥѤΥåΰ
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
--- 1013,1019 ----
  $END$
  $NL$
  
! $ 非タスクコンテキスト用のスタック領域
  const SIZE		_kernel_istksz = TOPPERS_ISTKSZ;$NL$
  STK_T *const	_kernel_istk = TOPPERS_ISTK;$NL$
  $NL$
***************
*** 1023,1029 ****
  $NL$
  
  $ 
! $  ।٥ȴ
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
--- 1023,1029 ----
  $NL$
  
  $ 
! $  タイムイベント管理
  $ 
  /*$NL$
  $SPC$*  Time Event Management$NL$
***************
*** 1033,1039 ****
  $NL$
  
  $ 
! $  ƥ⥸塼νؿ
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
--- 1033,1039 ----
  $NL$
  
  $ 
! $  各モジュールの初期化関数
  $ 
  /*$NL$
  $SPC$*  Module Initialization Function$NL$
***************
*** 1057,1063 ****
  $NL$
  
  $ 
! $  롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
--- 1057,1063 ----
  $NL$
  
  $ 
! $  初期化ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Initialization Routine$NL$
***************
*** 1067,1073 ****
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrTA_NULLˤǤʤE_RSATR
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
--- 1067,1073 ----
  _kernel_call_inirtn(void)$NL$
  {$NL$
  $FOREACH order INI.ORDER_LIST$
! $ 	// iniatrが（TA_NULL）でない場合（E_RSATR）
  	$IF INI.INIATR[order] != 0$
  		$ERROR INI.TEXT_LINE[order]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "iniatr", INI.INIATR[order], "inirtn", INI.INIRTN[order], "ATT_INI")$$END$
  	$END$
***************
*** 1077,1083 ****
  $NL$
  
  $ 
! $  λ롼μ¹Դؿ
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
--- 1077,1083 ----
  $NL$
  
  $ 
! $  終了処理ルーチンの実行関数
  $ 
  /*$NL$
  $SPC$*  Termination Routine$NL$
***************
*** 1087,1093 ****
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrTA_NULLˤǤʤE_RSATR
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
--- 1087,1093 ----
  _kernel_call_terrtn(void)$NL$
  {$NL$
  $FOREACH rorder TER.RORDER_LIST$
! $ 	// teratrが（TA_NULL）でない場合（E_RSATR）
  	$IF TER.TERATR[rorder] != 0$
  		$ERROR TER.TEXT_LINE[rorder]$E_RSATR: $FORMAT(_("illegal %1% `%2%\' of %3% `%4%\' in %5%"), "teratr", TER.TERATR[rorder], "terrtn", TER.TERRTN[rorder], "ATT_TER")$$END$
  	$END$
diff -cr --new-file 1.9.1/asp/kernel/kernel_check.tf ASPs/asp/kernel/kernel_check.tf
*** 1.9.1/asp/kernel/kernel_check.tf	Mon Sep 16 10:32:44 2013
--- ASPs/asp/kernel/kernel_check.tf	Fri Dec  9 13:54:04 2022
***************
*** 7,47 ****
  $   Copyright (C) 2008-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! $   ܥեȥѤΤޤࡥʲƱˤѡʣ
! $   ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! $   (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! $       ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! $       ˴ޤޤƤ뤳ȡ
! $   (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! $       ѤǤǺۤˤϡۤȼɥȡ
! $       ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! $       ̵ݾڵǺܤ뤳ȡ
! $   (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! $       ѤǤʤǺۤˤϡΤ줫ξ
! $       ȡ
! $     (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! $         ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! $     (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! $         𤹤뤳ȡ
! $   (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! $       ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! $       ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! $       ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! $       դ뤳ȡ
  $  
! $   ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! $   TOPPERSץȤϡܥեȥ˴ؤơλŪ
! $   ФŬޤơʤݾڤԤʤޤܥեȥ
! $   ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! $   Ǥʤ
  $ 
  $   @(#) $Id: kernel_check.tf 2526 2013-09-16 01:32:30Z ertl-hiro $
  $  
  $ =====================================================================
  
  $
! $  ǡLMAVMAؤΥԡ
  $
  $FOREACH lma LMA.ORDER_LIST$
  	$start_data = SYMBOL(LMA.START_DATA[lma])$
--- 7,47 ----
  $   Copyright (C) 2008-2013 by Embedded and Real-Time Systems Laboratory
  $               Graduate School of Information Science, Nagoya Univ., JAPAN
  $  
! $   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! $   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! $   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! $   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! $       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! $       スコード中に含まれていること．
! $   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! $       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! $       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! $       の無保証規定を掲載すること．
! $   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! $       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! $       と．
! $     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! $         作権表示，この利用条件および下記の無保証規定を掲載すること．
! $     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! $         報告すること．
! $   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! $       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! $       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! $       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! $       免責すること．
  $  
! $   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! $   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! $   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! $   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! $   の責任を負わない．
  $ 
  $   @(#) $Id: kernel_check.tf 2526 2013-09-16 01:32:30Z ertl-hiro $
  $  
  $ =====================================================================
  
  $
! $  データセクションのLMAからVMAへのコピー
  $
  $FOREACH lma LMA.ORDER_LIST$
  	$start_data = SYMBOL(LMA.START_DATA[lma])$
***************
*** 59,68 ****
  $END$
  
  $ 
! $  ؿƬϤΥå
  $ 
  $IF CHECK_FUNC_ALIGN || CHECK_FUNC_NONNULL$
! $	// ȥ㳰롼ƬϤΥå
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$task = PEEK(tinib + offsetof_TINIB_task, sizeof_FP)$
--- 59,68 ----
  $END$
  
  $ 
! $  関数の先頭番地のチェック
  $ 
  $IF CHECK_FUNC_ALIGN || CHECK_FUNC_NONNULL$
! $	// タスクとタスク例外処理ルーチンの先頭番地のチェック
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$task = PEEK(tinib + offsetof_TINIB_task, sizeof_FP)$
***************
*** 85,91 ****
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// ϥɥƬϤΥå
  	$cycinib = SYMBOL("_kernel_cycinib_table")$
  	$FOREACH cycid CYC.ID_LIST$
  		$cychdr = PEEK(cycinib + offsetof_CYCINIB_cychdr, sizeof_FP)$
--- 85,91 ----
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// 周期ハンドラの先頭番地のチェック
  	$cycinib = SYMBOL("_kernel_cycinib_table")$
  	$FOREACH cycid CYC.ID_LIST$
  		$cychdr = PEEK(cycinib + offsetof_CYCINIB_cychdr, sizeof_FP)$
***************
*** 102,108 ****
  		$cycinib = cycinib + sizeof_CYCINIB$
  	$END$
  
! $	// 顼ϥɥƬϤΥå
  	$alminib = SYMBOL("_kernel_alminib_table")$
  	$FOREACH almid ALM.ID_LIST$
  		$almhdr = PEEK(alminib + offsetof_ALMINIB_almhdr, sizeof_FP)$
--- 102,108 ----
  		$cycinib = cycinib + sizeof_CYCINIB$
  	$END$
  
! $	// アラームハンドラの先頭番地のチェック
  	$alminib = SYMBOL("_kernel_alminib_table")$
  	$FOREACH almid ALM.ID_LIST$
  		$almhdr = PEEK(alminib + offsetof_ALMINIB_almhdr, sizeof_FP)$
***************
*** 121,130 ****
  $END$
  
  $ 
! $  åΰƬϤΥå
  $ 
  $IF CHECK_STACK_ALIGN || CHECK_STACK_NONNULL$
! $	// ΥåΰƬϤΥå
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$IF USE_TSKINICTXB$
--- 121,130 ----
  $END$
  
  $ 
! $  スタック領域の先頭番地のチェック
  $ 
  $IF CHECK_STACK_ALIGN || CHECK_STACK_NONNULL$
! $	// タスクのスタック領域の先頭番地のチェック
  	$tinib = SYMBOL("_kernel_tinib_table")$
  	$FOREACH tskid TSK.ID_LIST$
  		$IF USE_TSKINICTXB$
***************
*** 145,151 ****
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// 󥿥ƥѤΥåΰƬϤΥå
  	$istk = PEEK(SYMBOL("_kernel_istk"), sizeof_void_ptr)$
  	$IF CHECK_STACK_ALIGN && (istk & (CHECK_STACK_ALIGN - 1)) != 0$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: 
--- 145,151 ----
  		$tinib = tinib + sizeof_TINIB$
  	$END$
  
! $	// 非タスクコンテキスト用のスタック領域の先頭番地のチェック
  	$istk = PEEK(SYMBOL("_kernel_istk"), sizeof_void_ptr)$
  	$IF CHECK_STACK_ALIGN && (istk & (CHECK_STACK_ALIGN - 1)) != 0$
  		$ERROR ICS.TEXT_LINE[1]$E_PAR: 
***************
*** 160,169 ****
  $END$
  
  $ 
! $  ĹסΰƬϤΥå
  $ 
  $IF CHECK_MPF_ALIGN || CHECK_MPF_NONNULL$
! $	// ĹסΰƬϤΥå
  	$mpfinib = SYMBOL("_kernel_mpfinib_table")$
  	$FOREACH mpfid MPF.ID_LIST$
  		$mpf = PEEK(mpfinib + offsetof_MPFINIB_mpf, sizeof_void_ptr)$
--- 160,169 ----
  $END$
  
  $ 
! $  固定長メモリプール領域の先頭番地のチェック
  $ 
  $IF CHECK_MPF_ALIGN || CHECK_MPF_NONNULL$
! $	// 固定長メモリプール領域の先頭番地のチェック
  	$mpfinib = SYMBOL("_kernel_mpfinib_table")$
  	$FOREACH mpfid MPF.ID_LIST$
  		$mpf = PEEK(mpfinib + offsetof_MPFINIB_mpf, sizeof_void_ptr)$
diff -cr --new-file 1.9.1/asp/kernel/kernel_impl.h ASPs/asp/kernel/kernel_impl.h
*** 1.9.1/asp/kernel/kernel_impl.h	Wed Jan 27 22:24:12 2010
--- ASPs/asp/kernel/kernel_impl.h	Fri Dec  9 13:54:04 2022
***************
*** 8,178 ****
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: kernel_impl.h 1713 2010-01-27 13:23:29Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPͥɸإåե
   *
!  *  ΥإåեϡͥץΥե
!  *  ɬ󥯥롼ɤ٤ɸإåեǤ롥
   *
!  *  ֥Υե뤫餳Υե򥤥󥯥롼ɤ
!  *  ϡTOPPERS_MACRO_ONLYƤˤꡤޥʳ
!  *  褦ˤʤäƤ롥
   */
  
  #ifndef TOPPERS_KERNEL_IMPL_H
  #define TOPPERS_KERNEL_IMPL_H
  
  /*
!  *  ͥ̾Υ͡
   */
  #include "kernel_rename.h"
  
  /*
!  *  ץꥱȶ̤Υإåե
   */
  #include <kernel.h>
  
  /*
!  *  ƥǽΤ
   */
  #include <t_syslog.h>
  
  /*
!  *  㥹ȤԤޥ
   */
  #ifndef CAST
  #define CAST(type, val)		((type)(val))
  #endif /* CAST */
  
  /*
!  *  åȰ¸
   */
  #include "target_config.h"
  
  /*
!  *  ٤Ƥδؿ򥳥ѥ뤹뤿
   */
  #ifdef ALLFUNC
  #include "allfunc.h"
  #endif /* ALLFUNC */
  
  /*
!  *  ӥåȥեɤǤ̵
   *
!  *  8ӥåȰʲΥӥåȥեɤǡ̵ͤݻ
!  *  Ѥ٤ǡANSI CǤϡӥåȥեɤΥǡˤ
!  *  intunsigned intʤᡤǥեȤunsigned
!  *  intȤƤ뤬åȤӥġ¸ǡunsigned charޤ
!  *  unsigned shortΨɤ礬롥
   */
  #ifndef BIT_FIELD_UINT
  #define BIT_FIELD_UINT		unsigned int
  #endif /* BIT_FIELD_UINT */
  
  /*
!  *  ӥåȥեɤǤΥ֡뷿
   *
!  *  1ӥåΥӥåȥեɤǡ֡ͤݻѤ٤
!  *  ǡǥեȤǤBIT_FIELD_UINTƱƤ뤬֡
!  *  ͤݻ뤳Ȥ뤿̤̾ΤȤƤ롥
   */
  #ifndef BIT_FIELD_BOOL
  #define BIT_FIELD_BOOL		BIT_FIELD_UINT
  #endif /* BIT_FIELD_BOOL */
  
  /*
!  *  ֥IDκǾͤ
   */
! #define TMIN_TSKID		1		/* IDκǾ */
! #define TMIN_SEMID		1		/* ޥեIDκǾ */
! #define TMIN_FLGID		1		/* ե饰IDκǾ */
! #define TMIN_DTQID		1		/* ǡ塼IDκǾ */
! #define TMIN_PDQID		1		/* ͥ٥ǡ塼IDκǾ */
! #define TMIN_MBXID		1		/* ᡼ܥåIDκǾ */
! #define TMIN_MPFID		1		/* ĹסIDκǾ */
! #define TMIN_CYCID		1		/* ϥɥIDκǾ */
! #define TMIN_ALMID		1		/* 顼ϥɥIDκǾ */
  
  /*
!  *  ͥ٤ʳ
   */
  #define TNUM_TPRI		(TMAX_TPRI - TMIN_TPRI + 1)
  #define TNUM_MPRI		(TMAX_MPRI - TMIN_MPRI + 1)
  #define TNUM_INTPRI		(TMAX_INTPRI - TMIN_INTPRI + 1)
  
  /*
!  *  إåեʤ⥸塼δؿѿ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  ƥ⥸塼νkernel_cfg.c
   */
  extern void	initialize_object(void);
  
  /*
!  *  롼μ¹ԡkernel_cfg.c
   */
  extern void	call_inirtn(void);
  
  /*
!  *  λ롼μ¹ԡkernel_cfg.c
   */
  extern void	call_terrtn(void);
  
  /*
!  *  󥿥ƥѤΥåΰkernel_cfg.c
   */
! extern const SIZE	istksz;		/* åΰΥʴݤ᤿͡ */
! extern STK_T *const	istk;		/* åΰƬ */
  #ifdef TOPPERS_ISTKPT
! extern STK_T *const	istkpt;		/* åݥ󥿤ν */
  #endif /* TOPPERS_ISTKPT */
  
  /*
!  *  ͥư֥ե饰startup.c
   */
  extern bool_t	kerflg;
  
  /*
!  *  ͥεưstartup.c
   */
  extern void	sta_ker(void);
  
  /*
!  *  ͥνλstartup.c
   */
  extern void	exit_kernel(void);
  
--- 8,179 ----
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: kernel_impl.h 1713 2010-01-27 13:23:29Z ertl-hiro $
   */
  
  /*
!  *		TOPPERS/ASPカーネル内部向け標準ヘッダファイル
   *
!  *  このヘッダファイルは，カーネルを構成するプログラムのソースファイル
!  *  で必ずインクルードするべき標準ヘッダファイルである．
   *
!  *  アセンブリ言語のソースファイルからこのファイルをインクルードする時
!  *  は，TOPPERS_MACRO_ONLYを定義しておく．これにより，マクロ定義以外を
!  *  除くようになっている．
   */
  
  #ifndef TOPPERS_KERNEL_IMPL_H
  #define TOPPERS_KERNEL_IMPL_H
  
  /*
!  *  カーネルの内部識別名のリネーム
   */
  #include "kernel_rename.h"
  
  /*
!  *  アプリケーションと共通のヘッダファイル
   */
  #include <kernel.h>
  
  /*
!  *  システムログ機能のための定義
   */
  #include <t_syslog.h>
  
  /*
!  *  型キャストを行うマクロの定義
   */
  #ifndef CAST
  #define CAST(type, val)		((type)(val))
  #endif /* CAST */
  
  /*
!  *  ターゲット依存情報の定義
   */
  #include "target_config.h"
  
  /*
!  *  すべての関数をコンパイルするための定義
   */
  #ifdef ALLFUNC
  #include "allfunc.h"
  #endif /* ALLFUNC */
  
  /*
!  *  ビットフィールドでの符号無し整数型
   *
!  *  8ビット以下の幅のビットフィールドで，符号無し整数値を保持したい場合
!  *  に用いるべきデータ型．ANSI Cでは，ビットフィールドのデータ型には
!  *  intとunsigned intしか許されないため，デフォルトの定義はunsigned
!  *  intとしているが，ターゲットおよびツール依存で，unsigned charまたは
!  *  unsigned shortに定義した方が効率が良い場合がある．
   */
  #ifndef BIT_FIELD_UINT
  #define BIT_FIELD_UINT		unsigned int
  #endif /* BIT_FIELD_UINT */
  
  /*
!  *  ビットフィールドでのブール型
   *
!  *  1ビット幅のビットフィールドで，ブール値を保持したい場合に用いるべき
!  *  データ型．デフォルトではBIT_FIELD_UINTと同一に定義しているが，ブー
!  *  ル値を保持することを明示するために別の名称としている．
   */
  #ifndef BIT_FIELD_BOOL
  #define BIT_FIELD_BOOL		BIT_FIELD_UINT
  #endif /* BIT_FIELD_BOOL */
  
  /*
!  *  オブジェクトIDの最小値の定義
   */
! #define TMIN_TSKID		1		/* タスクIDの最小値 */
! #define TMIN_SEMID		1		/* セマフォIDの最小値 */
! #define TMIN_FLGID		1		/* フラグIDの最小値 */
! #define TMIN_DTQID		1		/* データキューIDの最小値 */
! #define TMIN_PDQID		1		/* 優先度データキューIDの最小値 */
! #define TMIN_MBXID		1		/* メールボックスIDの最小値 */
! #define TMIN_MPFID		1		/* 固定長メモリプールIDの最小値 */
! #define TMIN_CYCID		1		/* 周期ハンドラIDの最小値 */
! #define TMIN_ALMID		1		/* アラームハンドラIDの最小値 */
  
+ #define EXTERNAL_INIT
  /*
!  *  優先度の段階数の定義
   */
  #define TNUM_TPRI		(TMAX_TPRI - TMIN_TPRI + 1)
  #define TNUM_MPRI		(TMAX_MPRI - TMIN_MPRI + 1)
  #define TNUM_INTPRI		(TMAX_INTPRI - TMIN_INTPRI + 1)
  
  /*
!  *  ヘッダファイルを持たないモジュールの関数・変数の宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  /*
!  *  各モジュールの初期化（kernel_cfg.c）
   */
  extern void	initialize_object(void);
  
  /*
!  *  初期化ルーチンの実行（kernel_cfg.c）
   */
  extern void	call_inirtn(void);
  
  /*
!  *  終了処理ルーチンの実行（kernel_cfg.c）
   */
  extern void	call_terrtn(void);
  
  /*
!  *  非タスクコンテキスト用のスタック領域（kernel_cfg.c）
   */
! extern const SIZE	istksz;		/* スタック領域のサイズ（丸めた値） */
! extern STK_T *const	istk;		/* スタック領域の先頭番地 */
  #ifdef TOPPERS_ISTKPT
! extern STK_T *const	istkpt;		/* スタックポインタの初期値 */
  #endif /* TOPPERS_ISTKPT */
  
  /*
!  *  カーネル動作状態フラグ（startup.c）
   */
  extern bool_t	kerflg;
  
  /*
!  *  カーネルの起動（startup.c）
   */
  extern void	sta_ker(void);
  
  /*
!  *  カーネルの終了処理（startup.c）
   */
  extern void	exit_kernel(void);
  
diff -cr --new-file 1.9.1/asp/kernel/kernel_int.h ASPs/asp/kernel/kernel_int.h
*** 1.9.1/asp/kernel/kernel_int.h	Wed Jul 18 18:52:18 2012
--- ASPs/asp/kernel/kernel_int.h	Fri Dec  9 13:54:04 2022
***************
*** 8,59 ****
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: kernel_int.h 2394 2012-07-18 09:52:17Z ertl-hiro $
   */
  
  /*
!  *		kernel_cfg.cʤcfg1_out.cѥإåե
   */
  
  #ifndef TOPPERS_KERNEL_INT_H
  #define TOPPERS_KERNEL_INT_H
  
  /*
!  *  ͥɸإåե
   */
  #include "kernel_impl.h"
  
  /*
!  *  ͥγƥإåե
   */
  #include "task.h"
  #include "semaphore.h"
--- 8,59 ----
   *  Copyright (C) 2005-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: kernel_int.h 2394 2012-07-18 09:52:17Z ertl-hiro $
   */
  
  /*
!  *		kernel_cfg.c（およびcfg1_out.c）用ヘッダファイル
   */
  
  #ifndef TOPPERS_KERNEL_INT_H
  #define TOPPERS_KERNEL_INT_H
  
  /*
!  *  カーネル標準ヘッダファイル
   */
  #include "kernel_impl.h"
  
  /*
!  *  カーネルの各ヘッダファイル
   */
  #include "task.h"
  #include "semaphore.h"
***************
*** 69,80 ****
  #include "time_event.h"
  
  /*
!  *  ͡षܥ򸵤᤹Υإåե
   */
  #include "kernel_unrename.h"
  
  /*
!  *  Ƥ뤿Υޥ
   */
  #ifndef TOPPERS_EMPTY_LABEL
  #define TOPPERS_EMPTY_LABEL(type, var)		type var[0]
--- 69,80 ----
  #include "time_event.h"
  
  /*
!  *  リネームしたシンボルを元に戻すためのヘッダファイル
   */
  #include "kernel_unrename.h"
  
  /*
!  *  内容が空の配列を生成するためのマクロ
   */
  #ifndef TOPPERS_EMPTY_LABEL
  #define TOPPERS_EMPTY_LABEL(type, var)		type var[0]
diff -cr --new-file 1.9.1/asp/kernel/mailbox.c ASPs/asp/kernel/mailbox.c
*** 1.9.1/asp/kernel/mailbox.c	Sun Jun 26 12:14:58 2011
--- ASPs/asp/kernel/mailbox.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: mailbox.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		᡼ܥåǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: mailbox.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		メールボックス機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "mailbox.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SND_MBX_ENTER
  #define LOG_SND_MBX_ENTER(mbxid, pk_msg)
--- 51,57 ----
  #include "mailbox.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SND_MBX_ENTER
  #define LOG_SND_MBX_ENTER(mbxid, pk_msg)
***************
*** 102,119 ****
  #endif /* LOG_REF_MBX_LEAVE */
  
  /*
!  *  ᡼ܥåο
   */
  #define tnum_mbx	((uint_t)(tmax_mbxid - TMIN_MBXID + 1))
  
  /*
!  *  ᡼ܥåID᡼ܥå֥åФΥޥ
   */
  #define INDEX_MBX(mbxid)	((uint_t)((mbxid) - TMIN_MBXID))
  #define get_mbxcb(mbxid)	(&(mbxcb_table[INDEX_MBX(mbxid)]))
  
  /* 
!  *  ᡼ܥåǽν
   */
  #ifdef TOPPERS_mbxini
  
--- 102,119 ----
  #endif /* LOG_REF_MBX_LEAVE */
  
  /*
!  *  メールボックスの数
   */
  #define tnum_mbx	((uint_t)(tmax_mbxid - TMIN_MBXID + 1))
  
  /*
!  *  メールボックスIDからメールボックス管理ブロックを取り出すためのマクロ
   */
  #define INDEX_MBX(mbxid)	((uint_t)((mbxid) - TMIN_MBXID))
  #define get_mbxcb(mbxid)	(&(mbxcb_table[INDEX_MBX(mbxid)]))
  
  /* 
!  *  メールボックス機能の初期化
   */
  #ifdef TOPPERS_mbxini
  
***************
*** 134,145 ****
  #endif /* TOPPERS_mbxini */
  
  /*
!  *  åͥ٤μФ
   */
  #define	MSGPRI(pk_msg)	(((T_MSG_PRI *)(pk_msg))->msgpri)
  
  /*
!  *  ͥٽå塼ؤ
   */
  Inline void
  enqueue_msg_pri(T_MSG **ppk_prevmsg_next, T_MSG *pk_msg)
--- 134,145 ----
  #endif /* TOPPERS_mbxini */
  
  /*
!  *  メッセージ優先度の取出し
   */
  #define	MSGPRI(pk_msg)	(((T_MSG_PRI *)(pk_msg))->msgpri)
  
  /*
!  *  優先度順メッセージキューへの挿入
   */
  Inline void
  enqueue_msg_pri(T_MSG **ppk_prevmsg_next, T_MSG *pk_msg)
***************
*** 157,163 ****
  }
  
  /*
!  *  ᡼ܥåؤ
   */
  #ifdef TOPPERS_snd_mbx
  
--- 157,163 ----
  }
  
  /*
!  *  メールボックスへの送信
   */
  #ifdef TOPPERS_snd_mbx
  
***************
*** 210,216 ****
  #endif /* TOPPERS_snd_mbx */
  
  /*
!  *  ᡼ܥåμ
   */
  #ifdef TOPPERS_rcv_mbx
  
--- 210,216 ----
  #endif /* TOPPERS_snd_mbx */
  
  /*
!  *  メールボックスからの受信
   */
  #ifdef TOPPERS_rcv_mbx
  
***************
*** 251,257 ****
  #endif /* TOPPERS_rcv_mbx */
  
  /*
!  *  ᡼ܥåμʥݡ󥰡
   */
  #ifdef TOPPERS_prcv_mbx
  
--- 251,257 ----
  #endif /* TOPPERS_rcv_mbx */
  
  /*
!  *  メールボックスからの受信（ポーリング）
   */
  #ifdef TOPPERS_prcv_mbx
  
***************
*** 285,291 ****
  #endif /* TOPPERS_prcv_mbx */
  
  /*
!  *  ᡼ܥåμʥॢȤ
   */
  #ifdef TOPPERS_trcv_mbx
  
--- 285,291 ----
  #endif /* TOPPERS_prcv_mbx */
  
  /*
!  *  メールボックスからの受信（タイムアウトあり）
   */
  #ifdef TOPPERS_trcv_mbx
  
***************
*** 332,338 ****
  #endif /* TOPPERS_trcv_mbx */
  
  /*
!  *  ᡼ܥåκƽ
   */
  #ifdef TOPPERS_ini_mbx
  
--- 332,338 ----
  #endif /* TOPPERS_trcv_mbx */
  
  /*
!  *  メールボックスの再初期化
   */
  #ifdef TOPPERS_ini_mbx
  
***************
*** 365,371 ****
  #endif /* TOPPERS_ini_mbx */
  
  /*
!  *  ᡼ܥåξֻ
   */
  #ifdef TOPPERS_ref_mbx
  
--- 365,371 ----
  #endif /* TOPPERS_ini_mbx */
  
  /*
!  *  メールボックスの状態参照
   */
  #ifdef TOPPERS_ref_mbx
  
diff -cr --new-file 1.9.1/asp/kernel/mailbox.h ASPs/asp/kernel/mailbox.h
*** 1.9.1/asp/kernel/mailbox.h	Sun Aug 14 09:35:48 2011
--- ASPs/asp/kernel/mailbox.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: mailbox.h 2228 2011-08-14 00:35:44Z ertl-hiro $
   */
  
  /*
!  *		᡼ܥåǽ
   */
  
  #ifndef TOPPERS_MAILBOX_H
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: mailbox.h 2228 2011-08-14 00:35:44Z ertl-hiro $
   */
  
  /*
!  *		メールボックス機能
   */
  
  #ifndef TOPPERS_MAILBOX_H
***************
*** 50,119 ****
  #include "wait.h"
  
  /*
!  *  ᡼ܥå֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct mailbox_initialization_block {
! 	ATR			mbxatr;			/* ᡼ܥå° */
! 	PRI			maxmpri;		/* åͥ٤κ */
  } MBXINIB;
  
  /*
!  *  ᡼ܥå֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   *
!  *  å塼åͥٽξˤϡpk_lastϻȤ
!  *  ޤå塼ξpk_headNULLξˤˤ⡤
!  *  pk_last̵Ǥ롥
   */
  typedef struct mailbox_control_block {
! 	QUEUE		wait_queue;		/* ᡼ܥåԤ塼 */
! 	const MBXINIB *p_mbxinib;	/* ֥åؤΥݥ */
! 	T_MSG		*pk_head;		/* ƬΥå */
! 	T_MSG		*pk_last;		/* Υå */
  } MBXCB;
  
  /*
!  *  ᡼ܥåԤ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
   */
  typedef struct mailbox_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	MBXCB		*p_mbxcb;		/* ԤäƤ᡼ܥåδ֥å */
! 	T_MSG		*pk_msg;		/* å */
  } WINFO_MBX;
  
  /*
!  *  ᡼ܥåIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_mbxid;
  
  /*
!  *  ᡼ܥå֥åΥꥢkernel_cfg.c
   */
  extern const MBXINIB	mbxinib_table[];
  
  /*
!  *  ᡼ܥå֥åΥꥢkernel_cfg.c
   */
  extern MBXCB	mbxcb_table[];
  
  /*
!  *  ᡼ܥå֥å᡼ܥåIDФΥޥ
   */
  #define	MBXID(p_mbxcb)	((ID)(((p_mbxcb) - mbxcb_table) + TMIN_MBXID))
  
  /*
!  *  ᡼ܥåǽν
   */
  extern void	initialize_mailbox(void);
  
--- 50,119 ----
  #include "wait.h"
  
  /*
!  *  メールボックス初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct mailbox_initialization_block {
! 	ATR			mbxatr;			/* メールボックス属性 */
! 	PRI			maxmpri;		/* メッセージ優先度の最大値 */
  } MBXINIB;
  
  /*
!  *  メールボックス管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   *
!  *  メッセージキューがメッセージの優先度順の場合には，pk_lastは使わな
!  *  い．また，メッセージキューが空の場合（pk_headがNULLの場合）にも，
!  *  pk_lastは無効である．
   */
  typedef struct mailbox_control_block {
! 	QUEUE		wait_queue;		/* メールボックス待ちキュー */
! 	const MBXINIB *p_mbxinib;	/* 初期化ブロックへのポインタ */
! 	T_MSG		*pk_head;		/* 先頭のメッセージ */
! 	T_MSG		*pk_last;		/* 末尾のメッセージ */
  } MBXCB;
  
  /*
!  *  メールボックス待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
   */
  typedef struct mailbox_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	MBXCB		*p_mbxcb;		/* 待っているメールボックスの管理ブロック */
! 	T_MSG		*pk_msg;		/* 受信したメッセージ */
  } WINFO_MBX;
  
  /*
!  *  メールボックスIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_mbxid;
  
  /*
!  *  メールボックス初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const MBXINIB	mbxinib_table[];
  
  /*
!  *  メールボックス管理ブロックのエリア（kernel_cfg.c）
   */
  extern MBXCB	mbxcb_table[];
  
  /*
!  *  メールボックス管理ブロックからメールボックスIDを取り出すためのマクロ
   */
  #define	MBXID(p_mbxcb)	((ID)(((p_mbxcb) - mbxcb_table) + TMIN_MBXID))
  
  /*
!  *  メールボックス機能の初期化
   */
  extern void	initialize_mailbox(void);
  
diff -cr --new-file 1.9.1/asp/kernel/mempfix.c ASPs/asp/kernel/mempfix.c
*** 1.9.1/asp/kernel/mempfix.c	Sun Apr 13 20:30:45 2014
--- ASPs/asp/kernel/mempfix.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: mempfix.c 2632 2014-04-13 11:30:37Z ertl-hiro $
   */
  
  /*
!  *		Ĺס뵡ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: mempfix.c 2632 2014-04-13 11:30:37Z ertl-hiro $
   */
  
  /*
!  *		固定長メモリプール機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "mempfix.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_GET_MPF_ENTER
  #define LOG_GET_MPF_ENTER(mpfid, p_blk)
--- 51,57 ----
  #include "mempfix.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_GET_MPF_ENTER
  #define LOG_GET_MPF_ENTER(mpfid, p_blk)
***************
*** 102,126 ****
  #endif /* LOG_REF_MPF_LEAVE */
  
  /*
!  *  Ĺסο
   */
  #define tnum_mpf	((uint_t)(tmax_mpfid - TMIN_MPFID + 1))
  
  /*
!  *  ĹסIDĹס֥åФ
!  *  Υޥ
   */
  #define INDEX_MPF(mpfid)	((uint_t)((mpfid) - TMIN_MPFID))
  #define get_mpfcb(mpfid)	(&(mpfcb_table[INDEX_MPF(mpfid)]))
  
  /*
!  *  üʥǥåͤ
   */
! #define INDEX_NULL		(~0U)		/* ֥åꥹȤκǸ */
! #define INDEX_ALLOC		(~1U)		/* ƺѤߤΥ֥å */
  
  /*
!  *  Ĺס뵡ǽν
   */
  #ifdef TOPPERS_mpfini
  
--- 102,126 ----
  #endif /* LOG_REF_MPF_LEAVE */
  
  /*
!  *  固定長メモリプールの数
   */
  #define tnum_mpf	((uint_t)(tmax_mpfid - TMIN_MPFID + 1))
  
  /*
!  *  固定長メモリプールIDから固定長メモリプール管理ブロックを取り出すた
!  *  めのマクロ
   */
  #define INDEX_MPF(mpfid)	((uint_t)((mpfid) - TMIN_MPFID))
  #define get_mpfcb(mpfid)	(&(mpfcb_table[INDEX_MPF(mpfid)]))
  
  /*
!  *  特殊なインデックス値の定義
   */
! #define INDEX_NULL		(~0U)		/* 空きブロックリストの最後 */
! #define INDEX_ALLOC		(~1U)		/* 割当て済みのブロック */
  
  /*
!  *  固定長メモリプール機能の初期化
   */
  #ifdef TOPPERS_mpfini
  
***************
*** 143,149 ****
  #endif /* TOPPERS_mpfini */
  
  /*
!  *  Ĺס뤫֥å
   */
  #ifdef TOPPERS_mpfget
  
--- 143,149 ----
  #endif /* TOPPERS_mpfini */
  
  /*
!  *  固定長メモリプールからブロックを獲得
   */
  #ifdef TOPPERS_mpfget
  
***************
*** 169,175 ****
  #endif /* TOPPERS_mpfget */
  
  /*
!  *  Ĺ֥åγ
   */
  #ifdef TOPPERS_get_mpf
  
--- 169,175 ----
  #endif /* TOPPERS_mpfget */
  
  /*
!  *  固定長メモリブロックの獲得
   */
  #ifdef TOPPERS_get_mpf
  
***************
*** 209,215 ****
  #endif /* TOPPERS_get_mpf */
  
  /*
!  *  Ĺ֥åγʥݡ󥰡
   */
  #ifdef TOPPERS_pget_mpf
  
--- 209,215 ----
  #endif /* TOPPERS_get_mpf */
  
  /*
!  *  固定長メモリブロックの獲得（ポーリング）
   */
  #ifdef TOPPERS_pget_mpf
  
***************
*** 242,248 ****
  #endif /* TOPPERS_pget_mpf */
  
  /*
!  *  Ĺ֥åγʥॢȤ
   */
  #ifdef TOPPERS_tget_mpf
  
--- 242,248 ----
  #endif /* TOPPERS_pget_mpf */
  
  /*
!  *  固定長メモリブロックの獲得（タイムアウトあり）
   */
  #ifdef TOPPERS_tget_mpf
  
***************
*** 288,294 ****
  #endif /* TOPPERS_tget_mpf */
  
  /*
!  *  Ĺ֥åֵ
   */
  #ifdef TOPPERS_rel_mpf
  
--- 288,294 ----
  #endif /* TOPPERS_tget_mpf */
  
  /*
!  *  固定長メモリブロックの返却
   */
  #ifdef TOPPERS_rel_mpf
  
***************
*** 337,343 ****
  #endif /* TOPPERS_rel_mpf */
  
  /*
!  *  Ĺסκƽ
   */
  #ifdef TOPPERS_ini_mpf
  
--- 337,343 ----
  #endif /* TOPPERS_rel_mpf */
  
  /*
!  *  固定長メモリプールの再初期化
   */
  #ifdef TOPPERS_ini_mpf
  
***************
*** 372,378 ****
  #endif /* TOPPERS_ini_mpf */
  
  /*
!  *  Ĺסξֻ
   */
  #ifdef TOPPERS_ref_mpf
  
--- 372,378 ----
  #endif /* TOPPERS_ini_mpf */
  
  /*
!  *  固定長メモリプールの状態参照
   */
  #ifdef TOPPERS_ref_mpf
  
diff -cr --new-file 1.9.1/asp/kernel/mempfix.h ASPs/asp/kernel/mempfix.h
*** 1.9.1/asp/kernel/mempfix.h	Sun Aug 14 09:35:48 2011
--- ASPs/asp/kernel/mempfix.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: mempfix.h 2228 2011-08-14 00:35:44Z ertl-hiro $
   */
  
  /*
!  *		Ĺס뵡ǽ
   */
  
  #ifndef TOPPERS_MEMPFIX_H
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: mempfix.h 2228 2011-08-14 00:35:44Z ertl-hiro $
   */
  
  /*
!  *		固定長メモリプール機能
   */
  
  #ifndef TOPPERS_MEMPFIX_H
***************
*** 50,136 ****
  #include "wait.h"
  
  /*
!  *  Ĺ֥å֥å
   *
!  *  nextեɤˤϡ֥åƺѤߤξINDEX_ALLOC
!  *  ̤Ƥξϼ̤ƥ֥åΥǥåֹǼ롥
!  *  Ǹ̤ƥ֥åξˤϡINDEX_NULLǼ롥
   */
  typedef struct fixed_memoryblock_management_block {
! 	uint_t		next;			/* ̤ƥ֥å */
  } MPFMB;
  
  /*
!  *  Ĺס֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct fixed_memorypool_initialization_block {
! 	ATR			mpfatr;			/* Ĺס° */
! 	uint_t		blkcnt;			/* ֥å */
! 	uint_t		blksz;			/* ֥åΥʴݤ᤿͡ */
! 	void		*mpf;			/* ĹסΰƬ */
! 	MPFMB		*p_mpfmb;		/* ĹסΰƬ */
  } MPFINIB;
  
  /*
!  *  Ĺס֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct fixed_memorypool_control_block {
! 	QUEUE		wait_queue;		/* ĹסԤ塼 */
! 	const MPFINIB *p_mpfinib;	/* ֥åؤΥݥ */
! 	uint_t		fblkcnt;		/* ̤ƥ֥å */
! 	uint_t		unused;			/* ̤ѥ֥åƬ */
! 	uint_t		freelist;		/* ̤ƥ֥åΥꥹ */
  } MPFCB;
  
  /*
!  *  ĹסԤ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
   */
  typedef struct fixed_memorypool_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	MPFCB		*p_mpfcb;		/* ԤäƤĹסδ֥å*/
! 	void		*blk;			/* ֥å */
  } WINFO_MPF;
  
  /*
!  *  ĹסIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_mpfid;
  
  /*
!  *  Ĺס֥åΥꥢkernel_cfg.c
   */
  extern const MPFINIB	mpfinib_table[];
  
  /*
!  *  Ĺס֥åΥꥢkernel_cfg.c
   */
  extern MPFCB	mpfcb_table[];
  
  /*
!  *  Ĺס֥åĹסIDФ
!  *  Υޥ
   */
  #define	MPFID(p_mpfcb)	((ID)(((p_mpfcb) - mpfcb_table) + TMIN_MPFID))
  
  /*
!  *  Ĺס뵡ǽν
   */
  extern void	initialize_mempfix(void);
  
  /*
!  *  Ĺס뤫֥å
   */
  extern void	get_mpf_block(MPFCB *p_mpfcb, void **p_blk);
  
--- 50,136 ----
  #include "wait.h"
  
  /*
!  *  固定長メモリブロック管理ブロック
   *
!  *  nextフィールドには，メモリブロックが割当て済みの場合はINDEX_ALLOCを，
!  *  未割当ての場合は次の未割当てブロックのインデックス番号を格納する．
!  *  最後の未割当てブロックの場合には，INDEX_NULLを格納する．
   */
  typedef struct fixed_memoryblock_management_block {
! 	uint_t		next;			/* 次の未割当てブロック */
  } MPFMB;
  
  /*
!  *  固定長メモリプール初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct fixed_memorypool_initialization_block {
! 	ATR			mpfatr;			/* 固定長メモリプール属性 */
! 	uint_t		blkcnt;			/* メモリブロック数 */
! 	uint_t		blksz;			/* メモリブロックのサイズ（丸めた値） */
! 	void		*mpf;			/* 固定長メモリプール領域の先頭番地 */
! 	MPFMB		*p_mpfmb;		/* 固定長メモリプール管理領域の先頭番地 */
  } MPFINIB;
  
  /*
!  *  固定長メモリプール管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct fixed_memorypool_control_block {
! 	QUEUE		wait_queue;		/* 固定長メモリプール待ちキュー */
! 	const MPFINIB *p_mpfinib;	/* 初期化ブロックへのポインタ */
! 	uint_t		fblkcnt;		/* 未割当てブロック数 */
! 	uint_t		unused;			/* 未使用ブロックの先頭 */
! 	uint_t		freelist;		/* 未割当てブロックのリスト */
  } MPFCB;
  
  /*
!  *  固定長メモリプール待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
   */
  typedef struct fixed_memorypool_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	MPFCB		*p_mpfcb;		/* 待っている固定長メモリプールの管理ブロック*/
! 	void		*blk;			/* 獲得したメモリブロック */
  } WINFO_MPF;
  
  /*
!  *  固定長メモリプールIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_mpfid;
  
  /*
!  *  固定長メモリプール初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const MPFINIB	mpfinib_table[];
  
  /*
!  *  固定長メモリプール管理ブロックのエリア（kernel_cfg.c）
   */
  extern MPFCB	mpfcb_table[];
  
  /*
!  *  固定長メモリプール管理ブロックから固定長メモリプールIDを取り出すた
!  *  めのマクロ
   */
  #define	MPFID(p_mpfcb)	((ID)(((p_mpfcb) - mpfcb_table) + TMIN_MPFID))
  
  /*
!  *  固定長メモリプール機能の初期化
   */
  extern void	initialize_mempfix(void);
  
  /*
!  *  固定長メモリプールからブロックを獲得
   */
  extern void	get_mpf_block(MPFCB *p_mpfcb, void **p_blk);
  
diff -cr --new-file 1.9.1/asp/kernel/pridataq.c ASPs/asp/kernel/pridataq.c
*** 1.9.1/asp/kernel/pridataq.c	Wed Jun 12 20:57:00 2013
--- ASPs/asp/kernel/pridataq.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: pridataq.c 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		ͥ٥ǡ塼ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: pridataq.c 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		優先度データキュー機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "pridataq.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SND_PDQ_ENTER
  #define LOG_SND_PDQ_ENTER(pdqid, data, datapri)
--- 51,57 ----
  #include "pridataq.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SND_PDQ_ENTER
  #define LOG_SND_PDQ_ENTER(pdqid, data, datapri)
***************
*** 126,144 ****
  #endif /* LOG_REF_PDQ_LEAVE */
  
  /*
!  *  ͥ٥ǡ塼ο
   */
  #define tnum_pdq	((uint_t)(tmax_pdqid - TMIN_PDQID + 1))
  
  /*
!  *  ͥ٥ǡ塼IDͥ٥ǡ塼֥åФ
!  *  Υޥ
   */
  #define INDEX_PDQ(pdqid)	((uint_t)((pdqid) - TMIN_PDQID))
  #define get_pdqcb(pdqid)	(&(pdqcb_table[INDEX_PDQ(pdqid)]))
  
  /*
!  *  ͥ٥ǡ塼ǽν
   */
  #ifdef TOPPERS_pdqini
  
--- 126,144 ----
  #endif /* LOG_REF_PDQ_LEAVE */
  
  /*
!  *  優先度データキューの数
   */
  #define tnum_pdq	((uint_t)(tmax_pdqid - TMIN_PDQID + 1))
  
  /*
!  *  優先度データキューIDから優先度データキュー管理ブロックを取り出すた
!  *  めのマクロ
   */
  #define INDEX_PDQ(pdqid)	((uint_t)((pdqid) - TMIN_PDQID))
  #define get_pdqcb(pdqid)	(&(pdqcb_table[INDEX_PDQ(pdqid)]))
  
  /*
!  *  優先度データキュー機能の初期化
   */
  #ifdef TOPPERS_pdqini
  
***************
*** 163,169 ****
  #endif /* TOPPERS_pdqini */
  
  /*
!  *  ͥ٥ǡ塼ΰؤΥǡγǼ
   */
  #ifdef TOPPERS_pdqenq
  
--- 163,169 ----
  #endif /* TOPPERS_pdqini */
  
  /*
!  *  優先度データキュー管理領域へのデータの格納
   */
  #ifdef TOPPERS_pdqenq
  
***************
*** 200,206 ****
  #endif /* TOPPERS_pdqenq */
  
  /*
!  *  ͥ٥ǡ塼ΰ褫ΥǡμФ
   */
  #ifdef TOPPERS_pdqdeq
  
--- 200,206 ----
  #endif /* TOPPERS_pdqenq */
  
  /*
!  *  優先度データキュー管理領域からのデータの取出し
   */
  #ifdef TOPPERS_pdqdeq
  
***************
*** 223,229 ****
  #endif /* TOPPERS_pdqdeq */
  
  /*
!  *  ͥ٥ǡ塼ؤΥǡ
   */
  #ifdef TOPPERS_pdqsnd
  
--- 223,229 ----
  #endif /* TOPPERS_pdqdeq */
  
  /*
!  *  優先度データキューへのデータ送信
   */
  #ifdef TOPPERS_pdqsnd
  
***************
*** 252,258 ****
  #endif /* TOPPERS_pdqsnd */
  
  /*
!  *  ͥ٥ǡ塼Υǡ
   */
  #ifdef TOPPERS_pdqrcv
  
--- 252,258 ----
  #endif /* TOPPERS_pdqsnd */
  
  /*
!  *  優先度データキューからのデータ受信
   */
  #ifdef TOPPERS_pdqrcv
  
***************
*** 293,299 ****
  #endif /* TOPPERS_pdqrcv */
  
  /*
!  *  ͥ٥ǡ塼ؤ
   */
  #ifdef TOPPERS_snd_pdq
  
--- 293,299 ----
  #endif /* TOPPERS_pdqrcv */
  
  /*
!  *  優先度データキューへの送信
   */
  #ifdef TOPPERS_snd_pdq
  
***************
*** 336,342 ****
  #endif /* TOPPERS_snd_pdq */
  
  /*
!  *  ͥ٥ǡ塼ؤʥݡ󥰡
   */
  #ifdef TOPPERS_psnd_pdq
  
--- 336,342 ----
  #endif /* TOPPERS_snd_pdq */
  
  /*
!  *  優先度データキューへの送信（ポーリング）
   */
  #ifdef TOPPERS_psnd_pdq
  
***************
*** 373,379 ****
  #endif /* TOPPERS_psnd_pdq */
  
  /*
!  *  ͥ٥ǡ塼ؤʥݡ󥰡󥿥ƥѡ
   */
  #ifdef TOPPERS_ipsnd_pdq
  
--- 373,379 ----
  #endif /* TOPPERS_psnd_pdq */
  
  /*
!  *  優先度データキューへの送信（ポーリング，非タスクコンテキスト用）
   */
  #ifdef TOPPERS_ipsnd_pdq
  
***************
*** 410,416 ****
  #endif /* TOPPERS_ipsnd_pdq */
  
  /*
!  *  ͥ٥ǡ塼ؤʥॢȤ
   */
  #ifdef TOPPERS_tsnd_pdq
  
--- 410,416 ----
  #endif /* TOPPERS_ipsnd_pdq */
  
  /*
!  *  優先度データキューへの送信（タイムアウトあり）
   */
  #ifdef TOPPERS_tsnd_pdq
  
***************
*** 459,465 ****
  #endif /* TOPPERS_tsnd_pdq */
  
  /*
!  *  ͥ٥ǡ塼μ
   */
  #ifdef TOPPERS_rcv_pdq
  
--- 459,465 ----
  #endif /* TOPPERS_tsnd_pdq */
  
  /*
!  *  優先度データキューからの受信
   */
  #ifdef TOPPERS_rcv_pdq
  
***************
*** 506,512 ****
  #endif /* TOPPERS_rcv_pdq */
  
  /*
!  *  ͥ٥ǡ塼μʥݡ󥰡
   */
  #ifdef TOPPERS_prcv_pdq
  
--- 506,512 ----
  #endif /* TOPPERS_rcv_pdq */
  
  /*
!  *  優先度データキューからの受信（ポーリング）
   */
  #ifdef TOPPERS_prcv_pdq
  
***************
*** 542,548 ****
  #endif /* TOPPERS_prcv_pdq */
  
  /*
!  *  ͥ٥ǡ塼μʥॢȤ
   */
  #ifdef TOPPERS_trcv_pdq
  
--- 542,548 ----
  #endif /* TOPPERS_prcv_pdq */
  
  /*
!  *  優先度データキューからの受信（タイムアウトあり）
   */
  #ifdef TOPPERS_trcv_pdq
  
***************
*** 594,600 ****
  #endif /* TOPPERS_trcv_pdq */
  
  /*
!  *  ͥ٥ǡ塼κƽ
   */
  #ifdef TOPPERS_ini_pdq
  
--- 594,600 ----
  #endif /* TOPPERS_trcv_pdq */
  
  /*
!  *  優先度データキューの再初期化
   */
  #ifdef TOPPERS_ini_pdq
  
***************
*** 633,639 ****
  #endif /* TOPPERS_ini_pdq */
  
  /*
!  *  ͥ٥ǡ塼ξֻ
   */
  #ifdef TOPPERS_ref_pdq
  
--- 633,639 ----
  #endif /* TOPPERS_ini_pdq */
  
  /*
!  *  優先度データキューの状態参照
   */
  #ifdef TOPPERS_ref_pdq
  
diff -cr --new-file 1.9.1/asp/kernel/pridataq.h ASPs/asp/kernel/pridataq.h
*** 1.9.1/asp/kernel/pridataq.h	Wed Jun 12 20:57:00 2013
--- ASPs/asp/kernel/pridataq.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: pridataq.h 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		ͥ٥ǡ塼ǽ
   */
  
  #ifndef TOPPERS_PRIDATAQ_H
--- 8,47 ----
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: pridataq.h 2515 2013-06-12 11:56:59Z ertl-hiro $
   */
  
  /*
!  *		優先度データキュー機能
   */
  
  #ifndef TOPPERS_PRIDATAQ_H
***************
*** 50,156 ****
  #include "wait.h"
  
  /*
!  *  ͥ٥ǡ֥å
   */
  typedef struct pridata_management_block PDQMB;
  
  struct pridata_management_block {
! 	PDQMB		*p_next;		/* Υǡ */
! 	intptr_t	data;			/* ǡ */
! 	PRI			datapri;		/* ǡͥ */
  };
  
  /*
!  *  ͥ٥ǡ塼֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct pridataq_initialization_block {
! 	ATR			pdqatr;			/* ͥ٥ǡ塼° */
! 	uint_t		pdqcnt;			/* ͥ٥ǡ塼 */
! 	PRI			maxdpri;		/* ǡͥ٤κ */
! 	PDQMB		*p_pdqmb;		/* ͥ٥ǡ塼ΰƬ */
  } PDQINIB;
  
  /*
!  *  ͥ٥ǡ塼֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct pridataq_control_block {
! 	QUEUE		swait_queue;	/* ͥ٥ǡ塼Ԥ塼 */
! 	const PDQINIB *p_pdqinib;	/* ֥åؤΥݥ */
! 	QUEUE		rwait_queue;	/* ͥ٥ǡ塼Ԥ塼 */
! 	uint_t		count;			/* ͥ٥ǡ塼Υǡο */
! 	PDQMB		*p_head;		/* ǽΥǡ */
! 	uint_t		unused;			/* ̤ѥǡ֥åƬ */
! 	PDQMB		*p_freelist;	/* ̤ƥǡ֥åΥꥹ */
  } PDQCB;
  
  /*
!  *  ͥ٥ǡ塼Ԥ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽ2ĤΥեɤ̤ˤʤäƤ롥
!  *  ͥ٥ǡ塼ؤԤͥ٥ǡ塼μԤǡ
!  *  ƱԤ֥åȤ
   */
  typedef struct pridataq_waiting_information {
! 	WINFO		winfo;			/* ɸԤ֥å */
! 	PDQCB		*p_pdqcb;		/* ԤäƤͥ٥ǡ塼δ֥å*/
! 	intptr_t	data;			/* ǡ */
! 	PRI			datapri;		/* ǡͥ */
  } WINFO_PDQ;
  
  /*
!  *  ͥ٥ǡ塼IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_pdqid;
  
  /*
!  *  ͥ٥ǡ塼֥åΥꥢkernel_cfg.c
   */
  extern const PDQINIB	pdqinib_table[];
  
  /*
!  *  ͥ٥ǡ塼֥åΥꥢkernel_cfg.c
   */
  extern PDQCB	pdqcb_table[];
  
  /*
!  *  ͥ٥ǡ塼֥åͥ٥ǡ塼IDФ
!  *  Υޥ
   */
  #define	PDQID(p_pdqcb)	((ID)(((p_pdqcb) - pdqcb_table) + TMIN_PDQID))
  
  /*
!  *  ͥ٥ǡ塼ǽν
   */
  extern void	initialize_pridataq(void);
  
  /*
!  *  ͥ٥ǡ塼ΰؤΥǡγǼ
   */
  extern void	enqueue_pridata(PDQCB *p_pdqcb, intptr_t data, PRI datapri);
  
  /*
!  *  ͥ٥ǡ塼ΰ褫ΥǡμФ
   */
  extern void	dequeue_pridata(PDQCB *p_pdqcb, intptr_t *p_data, PRI *p_datapri);
  
  /*
!  *  ͥ٥ǡ塼ؤΥǡ
   */
  extern bool_t	send_pridata(PDQCB *p_pdqcb, intptr_t data,
  											PRI datapri, bool_t *p_dspreq);
  
  /*
!  *  ͥ٥ǡ塼Υǡ
   */
  extern bool_t	receive_pridata(PDQCB *p_pdqcb, intptr_t *p_data,
  											PRI *p_datapri, bool_t *p_dspreq);
--- 50,156 ----
  #include "wait.h"
  
  /*
!  *  優先度データ管理ブロック
   */
  typedef struct pridata_management_block PDQMB;
  
  struct pridata_management_block {
! 	PDQMB		*p_next;		/* 次のデータ */
! 	intptr_t	data;			/* データ本体 */
! 	PRI			datapri;		/* データ優先度 */
  };
  
  /*
!  *  優先度データキュー初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct pridataq_initialization_block {
! 	ATR			pdqatr;			/* 優先度データキュー属性 */
! 	uint_t		pdqcnt;			/* 優先度データキューの容量 */
! 	PRI			maxdpri;		/* データ優先度の最大値 */
! 	PDQMB		*p_pdqmb;		/* 優先度データキュー管理領域の先頭番地 */
  } PDQINIB;
  
  /*
!  *  優先度データキュー管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct pridataq_control_block {
! 	QUEUE		swait_queue;	/* 優先度データキュー送信待ちキュー */
! 	const PDQINIB *p_pdqinib;	/* 初期化ブロックへのポインタ */
! 	QUEUE		rwait_queue;	/* 優先度データキュー受信待ちキュー */
! 	uint_t		count;			/* 優先度データキュー中のデータの数 */
! 	PDQMB		*p_head;		/* 最初のデータ */
! 	uint_t		unused;			/* 未使用データ管理ブロックの先頭 */
! 	PDQMB		*p_freelist;	/* 未割当てデータ管理ブロックのリスト */
  } PDQCB;
  
  /*
!  *  優先度データキュー待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初の2つのフィールドが共通になっている．
!  *  優先度データキューへの送信待ちと優先度データキューからの受信待ちで，
!  *  同じ待ち情報ブロックを使う．
   */
  typedef struct pridataq_waiting_information {
! 	WINFO		winfo;			/* 標準の待ち情報ブロック */
! 	PDQCB		*p_pdqcb;		/* 待っている優先度データキューの管理ブロック*/
! 	intptr_t	data;			/* 送受信データ */
! 	PRI			datapri;		/* データ優先度 */
  } WINFO_PDQ;
  
  /*
!  *  優先度データキューIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_pdqid;
  
  /*
!  *  優先度データキュー初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const PDQINIB	pdqinib_table[];
  
  /*
!  *  優先度データキュー管理ブロックのエリア（kernel_cfg.c）
   */
  extern PDQCB	pdqcb_table[];
  
  /*
!  *  優先度データキュー管理ブロックから優先度データキューIDを取り出すた
!  *  めのマクロ
   */
  #define	PDQID(p_pdqcb)	((ID)(((p_pdqcb) - pdqcb_table) + TMIN_PDQID))
  
  /*
!  *  優先度データキュー機能の初期化
   */
  extern void	initialize_pridataq(void);
  
  /*
!  *  優先度データキュー管理領域へのデータの格納
   */
  extern void	enqueue_pridata(PDQCB *p_pdqcb, intptr_t data, PRI datapri);
  
  /*
!  *  優先度データキュー管理領域からのデータの取出し
   */
  extern void	dequeue_pridata(PDQCB *p_pdqcb, intptr_t *p_data, PRI *p_datapri);
  
  /*
!  *  優先度データキューへのデータ送信
   */
  extern bool_t	send_pridata(PDQCB *p_pdqcb, intptr_t data,
  											PRI datapri, bool_t *p_dspreq);
  
  /*
!  *  優先度データキューからのデータ受信
   */
  extern bool_t	receive_pridata(PDQCB *p_pdqcb, intptr_t *p_data,
  											PRI *p_datapri, bool_t *p_dspreq);
diff -cr --new-file 1.9.1/asp/kernel/semaphore.c ASPs/asp/kernel/semaphore.c
*** 1.9.1/asp/kernel/semaphore.c	Sun Jun 26 12:14:58 2011
--- ASPs/asp/kernel/semaphore.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: semaphore.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		ޥեǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: semaphore.c 2133 2011-06-26 03:14:51Z ertl-hiro $
   */
  
  /*
!  *		セマフォ機能
   */
  
  #include "kernel_impl.h"
***************
*** 51,57 ****
  #include "semaphore.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SIG_SEM_ENTER
  #define LOG_SIG_SEM_ENTER(semid)
--- 51,57 ----
  #include "semaphore.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SIG_SEM_ENTER
  #define LOG_SIG_SEM_ENTER(semid)
***************
*** 110,127 ****
  #endif /* LOG_REF_SEM_LEAVE */
  
  /*
!  *  ޥեο
   */
  #define tnum_sem	((uint_t)(tmax_semid - TMIN_SEMID + 1))
  
  /*
!  *  ޥեID饻ޥե֥åФΥޥ
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
  
  /* 
!  *  ޥեǽν
   */
  #ifdef TOPPERS_semini
  
--- 110,127 ----
  #endif /* LOG_REF_SEM_LEAVE */
  
  /*
!  *  セマフォの数
   */
  #define tnum_sem	((uint_t)(tmax_semid - TMIN_SEMID + 1))
  
  /*
!  *  セマフォIDからセマフォ管理ブロックを取り出すためのマクロ
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
  
  /* 
!  *  セマフォ機能の初期化
   */
  #ifdef TOPPERS_semini
  
***************
*** 142,148 ****
  #endif /* TOPPERS_semini */
  
  /*
!  *  ޥե񸻤ֵ
   */
  #ifdef TOPPERS_sig_sem
  
--- 142,148 ----
  #endif /* TOPPERS_semini */
  
  /*
!  *  セマフォ資源の返却
   */
  #ifdef TOPPERS_sig_sem
  
***************
*** 183,189 ****
  #endif /* TOPPERS_sig_sem */
  
  /*
!  *  ޥե񸻤ֵѡ󥿥ƥѡ
   */
  #ifdef TOPPERS_isig_sem
  
--- 183,189 ----
  #endif /* TOPPERS_sig_sem */
  
  /*
!  *  セマフォ資源の返却（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_isig_sem
  
***************
*** 224,230 ****
  #endif /* TOPPERS_isig_sem */
  
  /*
!  *  ޥե񸻤γ
   */
  #ifdef TOPPERS_wai_sem
  
--- 224,230 ----
  #endif /* TOPPERS_isig_sem */
  
  /*
!  *  セマフォ資源の獲得
   */
  #ifdef TOPPERS_wai_sem
  
***************
*** 261,267 ****
  #endif /* TOPPERS_wai_sem */
  
  /*
!  *  ޥե񸻤γʥݡ󥰡
   */
  #ifdef TOPPERS_pol_sem
  
--- 261,267 ----
  #endif /* TOPPERS_wai_sem */
  
  /*
!  *  セマフォ資源の獲得（ポーリング）
   */
  #ifdef TOPPERS_pol_sem
  
***************
*** 294,300 ****
  #endif /* TOPPERS_pol_sem */
  
  /*
!  *  ޥե񸻤γʥॢȤ
   */
  #ifdef TOPPERS_twai_sem
  
--- 294,300 ----
  #endif /* TOPPERS_pol_sem */
  
  /*
!  *  セマフォ資源の獲得（タイムアウトあり）
   */
  #ifdef TOPPERS_twai_sem
  
***************
*** 337,343 ****
  #endif /* TOPPERS_twai_sem */
  
  /*
!  *  ޥեκƽ
   */
  #ifdef TOPPERS_ini_sem
  
--- 337,343 ----
  #endif /* TOPPERS_twai_sem */
  
  /*
!  *  セマフォの再初期化
   */
  #ifdef TOPPERS_ini_sem
  
***************
*** 370,376 ****
  #endif /* TOPPERS_ini_sem */
  
  /*
!  *  ޥեξֻ
   */
  #ifdef TOPPERS_ref_sem
  
--- 370,376 ----
  #endif /* TOPPERS_ini_sem */
  
  /*
!  *  セマフォの状態参照
   */
  #ifdef TOPPERS_ref_sem
  
diff -cr --new-file 1.9.1/asp/kernel/semaphore.h ASPs/asp/kernel/semaphore.h
*** 1.9.1/asp/kernel/semaphore.h	Sun Aug 14 09:35:48 2011
--- ASPs/asp/kernel/semaphore.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: semaphore.h 2228 2011-08-14 00:35:44Z ertl-hiro $
   */
  
  /*
!  *		ޥեǽ
   */
  
  #ifndef TOPPERS_SEMAPHORE_H
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: semaphore.h 2228 2011-08-14 00:35:44Z ertl-hiro $
   */
  
  /*
!  *		セマフォ機能
   */
  
  #ifndef TOPPERS_SEMAPHORE_H
***************
*** 50,114 ****
  #include "wait.h"
  
  /*
!  *  ޥե֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥν֥åζʬ
!  *  WOBJINIBˤĥʥ֥ȻظηѾˤΤǡ
!  *  ǽΥեɤ̤ˤʤäƤ롥
   */
  typedef struct semaphore_initialization_block {
! 	ATR			sematr;			/* ޥե° */
! 	uint_t		isemcnt;		/* ޥեλ񸻿ν */
! 	uint_t		maxsem;			/* ޥեκ񸻿 */
  } SEMINIB;
  
  /*
!  *  ޥե֥å
   *
!  *  ι¤ΤϡƱ֥̿Ȥδ֥åζʬWOBJCB
!  *  ĥʥ֥ȻظηѾˤΤǡǽ2Ĥ
!  *  եɤ̤ˤʤäƤ롥
   */
  typedef struct semaphore_control_block {
! 	QUEUE		wait_queue;		/* ޥեԤ塼 */
! 	const SEMINIB *p_seminib;	/* ֥åؤΥݥ */
! 	uint_t		semcnt;			/* ޥեߥ */
  } SEMCB;
  
  /*
!  *  ޥեԤ֥å
   *
!  *  ι¤ΤϡƱ֥̿ȤԤ֥åζʬ
!  *  WINFO_WOBJˤĥʥ֥ȻظηѾˤΤǡ
!  *  ٤ƤΥեɤ̤ˤʤäƤ롥
   */
  typedef struct semaphore_waiting_information {
! 	WINFO	winfo;			/* ɸԤ֥å */
! 	SEMCB	*p_semcb;		/* ԤäƤ륻ޥեδ֥å */
  } WINFO_SEM;
  
  /*
!  *  ޥեIDκ͡kernel_cfg.c
   */
  extern const ID	tmax_semid;
  
  /*
!  *  ޥե֥åΥꥢkernel_cfg.c
   */
  extern const SEMINIB	seminib_table[];
  
  /*
!  *  ޥե֥åΥꥢkernel_cfg.c
   */
  extern SEMCB	semcb_table[];
  
  /*
!  *  ޥե֥å饻ޥեIDФΥޥ
   */
  #define	SEMID(p_semcb)	((ID)(((p_semcb) - semcb_table) + TMIN_SEMID))
  
  /*
!  *  ޥեǽν
   */
  extern void	initialize_semaphore(void);
  
--- 50,114 ----
  #include "wait.h"
  
  /*
!  *  セマフォ初期化ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの初期化ブロックの共通部分
!  *  （WOBJINIB）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  最初のフィールドが共通になっている．
   */
  typedef struct semaphore_initialization_block {
! 	ATR			sematr;			/* セマフォ属性 */
! 	uint_t		isemcnt;		/* セマフォの資源数の初期値 */
! 	uint_t		maxsem;			/* セマフォの最大資源数 */
  } SEMINIB;
  
  /*
!  *  セマフォ管理ブロック
   *
!  *  この構造体は，同期・通信オブジェクトの管理ブロックの共通部分（WOBJCB）
!  *  を拡張（オブジェクト指向言語の継承に相当）したもので，最初の2つの
!  *  フィールドが共通になっている．
   */
  typedef struct semaphore_control_block {
! 	QUEUE		wait_queue;		/* セマフォ待ちキュー */
! 	const SEMINIB *p_seminib;	/* 初期化ブロックへのポインタ */
! 	uint_t		semcnt;			/* セマフォ現在カウント値 */
  } SEMCB;
  
  /*
!  *  セマフォ待ち情報ブロックの定義
   *
!  *  この構造体は，同期・通信オブジェクトの待ち情報ブロックの共通部分
!  *  （WINFO_WOBJ）を拡張（オブジェクト指向言語の継承に相当）したもので，
!  *  すべてのフィールドが共通になっている．
   */
  typedef struct semaphore_waiting_information {
! 	WINFO	winfo;			/* 標準の待ち情報ブロック */
! 	SEMCB	*p_semcb;		/* 待っているセマフォの管理ブロック */
  } WINFO_SEM;
  
  /*
!  *  セマフォIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_semid;
  
  /*
!  *  セマフォ初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const SEMINIB	seminib_table[];
  
  /*
!  *  セマフォ管理ブロックのエリア（kernel_cfg.c）
   */
  extern SEMCB	semcb_table[];
  
  /*
!  *  セマフォ管理ブロックからセマフォIDを取り出すためのマクロ
   */
  #define	SEMID(p_semcb)	((ID)(((p_semcb) - semcb_table) + TMIN_SEMID))
  
  /*
!  *  セマフォ機能の初期化
   */
  extern void	initialize_semaphore(void);
  
diff -cr --new-file 1.9.1/asp/kernel/startup.c ASPs/asp/kernel/startup.c
*** 1.9.1/asp/kernel/startup.c	Thu May  5 09:46:29 2011
--- ASPs/asp/kernel/startup.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: startup.c 2067 2011-05-05 00:46:29Z ertl-hiro $
   */
  
  /*
!  *		ͥνȽλ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: startup.c 2067 2011-05-05 00:46:29Z ertl-hiro $
   */
  
  /*
!  *		カーネルの初期化と終了処理
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include <sil.h>
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_KER_ENTER
  #define LOG_KER_ENTER()
--- 49,55 ----
  #include <sil.h>
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_KER_ENTER
  #define LOG_KER_ENTER()
***************
*** 70,109 ****
  #ifdef TOPPERS_sta_ker
  
  /*
!  *  ͥư֥ե饰
   *
!  *  ȥåץ롼ǡfalseʡ0ˤ˽뤳ȤԤ
!  *  롥
   */
  bool_t	kerflg = false;
  
  /*
!  *  ͥεư
   */
  void
  sta_ker(void)
  {
  	/*
! 	 *  åȰ¸ν
  	 */
  	target_initialize();
! 
  	/*
! 	 *  ƥ⥸塼ν
  	 *
! 	 *  ।٥ȴ⥸塼¾Υ⥸塼˽
! 	 *  ɬפ롥
  	 */
  	initialize_tmevt();
  	initialize_object();
  
  	/*
! 	 *  롼μ¹
  	 */ 
  	call_inirtn();
  
  	/*
! 	 *  ͥưγ
  	 */
  	kerflg = true;
  	LOG_KER_ENTER();
--- 70,110 ----
  #ifdef TOPPERS_sta_ker
  
  /*
!  *  カーネル動作状態フラグ
   *
!  *  スタートアップルーチンで，false（＝0）に初期化されることを期待して
!  *  いる．
   */
  bool_t	kerflg = false;
  
  /*
!  *  カーネルの起動
   */
  void
  sta_ker(void)
  {
  	/*
! 	 *  ターゲット依存の初期化
  	 */
+ #ifndef EXTERNAL_INIT
  	target_initialize();
! #endif
  	/*
! 	 *  各モジュールの初期化
  	 *
! 	 *  タイムイベント管理モジュールは他のモジュールより先に初期化
! 	 *  する必要がある．
  	 */
  	initialize_tmevt();
  	initialize_object();
  
  	/*
! 	 *  初期化ルーチンの実行
  	 */ 
  	call_inirtn();
  
  	/*
! 	 *  カーネル動作の開始
  	 */
  	kerflg = true;
  	LOG_KER_ENTER();
***************
*** 114,120 ****
  #endif /* TOPPERS_sta_ker */
  
  /*
!  *  ͥνλ
   */
  #ifdef TOPPERS_ext_ker
  
--- 115,121 ----
  #endif /* TOPPERS_sta_ker */
  
  /*
!  *  カーネルの終了
   */
  #ifdef TOPPERS_ext_ker
  
***************
*** 126,150 ****
  	LOG_EXT_KER_ENTER();
  
  	/*
! 	 *  ߥå֤˰ܹ
  	 */
  	SIL_LOC_INT();
  
  	/*
! 	 *  ͥưνλ
  	 */
  	LOG_KER_LEAVE();
  	kerflg = false;
  
  	/*
! 	 *  ͥνλθƽФ
  	 *
! 	 *  󥿥ƥȤڤ괹ơexit_kernelƤӽФ
  	 */
  	call_exit_kernel();
  
  	/*
! 	 *  ѥηٹкʤ뤳ȤϤʤϤ
  	 */
  	SIL_UNL_INT();
  	LOG_EXT_KER_LEAVE(E_SYS);
--- 127,151 ----
  	LOG_EXT_KER_ENTER();
  
  	/*
! 	 *  割込みロック状態に移行
  	 */
  	SIL_LOC_INT();
  
  	/*
! 	 *  カーネル動作の終了
  	 */
  	LOG_KER_LEAVE();
  	kerflg = false;
  
  	/*
! 	 *  カーネルの終了処理の呼出し
  	 *
! 	 *  非タスクコンテキストに切り換えて，exit_kernelを呼び出す．
  	 */
  	call_exit_kernel();
  
  	/*
! 	 *  コンパイラの警告対策（ここへ来ることはないはず）
  	 */
  	SIL_UNL_INT();
  	LOG_EXT_KER_LEAVE(E_SYS);
***************
*** 152,169 ****
  }
  
  /*
!  *  ͥνλ
   */
  void
  exit_kernel(void)
  {
  	/*
! 	 *  λ롼μ¹
  	 */
  	call_terrtn();
  
  	/*
! 	 *  åȰ¸νλ
  	 */
  	target_exit();
  	assert(0);
--- 153,170 ----
  }
  
  /*
!  *  カーネルの終了処理
   */
  void
  exit_kernel(void)
  {
  	/*
! 	 *  終了処理ルーチンの実行
  	 */
  	call_terrtn();
  
  	/*
! 	 *  ターゲット依存の終了処理
  	 */
  	target_exit();
  	assert(0);
diff -cr --new-file 1.9.1/asp/kernel/sys_manage.c ASPs/asp/kernel/sys_manage.c
*** 1.9.1/asp/kernel/sys_manage.c	Fri Dec 31 21:41:43 2010
--- ASPs/asp/kernel/sys_manage.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: sys_manage.c 2008 2010-12-31 12:41:42Z ertl-hiro $
   */
  
  /*
!  *		ƥִǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: sys_manage.c 2008 2010-12-31 12:41:42Z ertl-hiro $
   */
  
  /*
!  *		システム状態管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ROT_RDQ_ENTER
  #define LOG_ROT_RDQ_ENTER(tskpri)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ROT_RDQ_ENTER
  #define LOG_ROT_RDQ_ENTER(tskpri)
***************
*** 172,178 ****
  #endif /* LOG_SNS_KER_LEAVE */
  
  /*
!  *  ̤ͥβž
   */
  #ifdef TOPPERS_rot_rdq
  
--- 172,178 ----
  #endif /* LOG_SNS_KER_LEAVE */
  
  /*
!  *  タスクの優先順位の回転
   */
  #ifdef TOPPERS_rot_rdq
  
***************
*** 202,208 ****
  #endif /* TOPPERS_rot_rdq */
  
  /*
!  *  ̤ͥβž󥿥ƥѡ
   */
  #ifdef TOPPERS_irot_rdq
  
--- 202,208 ----
  #endif /* TOPPERS_rot_rdq */
  
  /*
!  *  タスクの優先順位の回転（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_irot_rdq
  
***************
*** 230,236 ****
  #endif /* TOPPERS_irot_rdq */
  
  /*
!  *  ¹Ծ֤ΥIDλ
   */
  #ifdef TOPPERS_get_tid
  
--- 230,236 ----
  #endif /* TOPPERS_irot_rdq */
  
  /*
!  *  実行状態のタスクIDの参照
   */
  #ifdef TOPPERS_get_tid
  
***************
*** 255,261 ****
  #endif /* TOPPERS_get_tid */
  
  /*
!  *  ¹Ծ֤ΥIDλȡ󥿥ƥѡ
   */
  #ifdef TOPPERS_iget_tid
  
--- 255,261 ----
  #endif /* TOPPERS_get_tid */
  
  /*
!  *  実行状態のタスクIDの参照（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iget_tid
  
***************
*** 280,286 ****
  #endif /* TOPPERS_iget_tid */
  
  /*
!  *  CPUå֤ؤΰܹ
   */
  #ifdef TOPPERS_loc_cpu
  
--- 280,286 ----
  #endif /* TOPPERS_iget_tid */
  
  /*
!  *  CPUロック状態への移行
   */
  #ifdef TOPPERS_loc_cpu
  
***************
*** 305,311 ****
  #endif /* TOPPERS_loc_cpu */
  
  /*
!  *  CPUå֤ؤΰܹԡ󥿥ƥѡ
   */
  #ifdef TOPPERS_iloc_cpu
  
--- 305,311 ----
  #endif /* TOPPERS_loc_cpu */
  
  /*
!  *  CPUロック状態への移行（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iloc_cpu
  
***************
*** 330,340 ****
  #endif /* TOPPERS_iloc_cpu */
  
  /*
!  *  CPUå֤β
   *
!  *  CPUåϡǥѥåɬפȤʤ륵ӥƤӽФ
!  *  ȤϤǤʤᡤCPUå֤β˥ǥѥåư
!  *  ɬפϤʤ
   */
  #ifdef TOPPERS_unl_cpu
  
--- 330,340 ----
  #endif /* TOPPERS_iloc_cpu */
  
  /*
!  *  CPUロック状態の解除
   *
!  *  CPUロック中は，ディスパッチが必要となるサービスコールを呼び出すこ
!  *  とはできないため，CPUロック状態の解除時にディスパッチャを起動する
!  *  必要はない．
   */
  #ifdef TOPPERS_unl_cpu
  
***************
*** 359,369 ****
  #endif /* TOPPERS_unl_cpu */
  
  /*
!  *  CPUå֤β󥿥ƥѡ
   *
!  *  CPUåϡǥѥåɬפȤʤ륵ӥƤӽФ
!  *  ȤϤǤʤᡤCPUå֤β˥ǥѥåεư
!  *  ᤹ɬפϤʤ
   */
  #ifdef TOPPERS_iunl_cpu
  
--- 359,369 ----
  #endif /* TOPPERS_unl_cpu */
  
  /*
!  *  CPUロック状態の解除（非タスクコンテキスト用）
   *
!  *  CPUロック中は，ディスパッチが必要となるサービスコールを呼び出すこ
!  *  とはできないため，CPUロック状態の解除時にディスパッチャの起動を要
!  *  求する必要はない．
   */
  #ifdef TOPPERS_iunl_cpu
  
***************
*** 388,394 ****
  #endif /* TOPPERS_iunl_cpu */
  
  /*
!  *  ǥѥåζػ
   */
  #ifdef TOPPERS_dis_dsp
  
--- 388,394 ----
  #endif /* TOPPERS_iunl_cpu */
  
  /*
!  *  ディスパッチの禁止
   */
  #ifdef TOPPERS_dis_dsp
  
***************
*** 414,420 ****
  #endif /* TOPPERS_dis_dsp */
  
  /*
!  *  ǥѥåε
   */
  #ifdef TOPPERS_ena_dsp
  
--- 414,420 ----
  #endif /* TOPPERS_dis_dsp */
  
  /*
!  *  ディスパッチの許可
   */
  #ifdef TOPPERS_ena_dsp
  
***************
*** 445,451 ****
  #endif /* TOPPERS_ena_dsp */
  
  /*
!  *  ƥȤλ
   */
  #ifdef TOPPERS_sns_ctx
  
--- 445,451 ----
  #endif /* TOPPERS_ena_dsp */
  
  /*
!  *  コンテキストの参照
   */
  #ifdef TOPPERS_sns_ctx
  
***************
*** 463,469 ****
  #endif /* TOPPERS_sns_ctx */
  
  /*
!  *  CPUå֤λ
   */
  #ifdef TOPPERS_sns_loc
  
--- 463,469 ----
  #endif /* TOPPERS_sns_ctx */
  
  /*
!  *  CPUロック状態の参照
   */
  #ifdef TOPPERS_sns_loc
  
***************
*** 481,487 ****
  #endif /* TOPPERS_sns_loc */
  
  /*
!  *  ǥѥåػ߾֤λ
   */
  #ifdef TOPPERS_sns_dsp
  
--- 481,487 ----
  #endif /* TOPPERS_sns_loc */
  
  /*
!  *  ディスパッチ禁止状態の参照
   */
  #ifdef TOPPERS_sns_dsp
  
***************
*** 499,505 ****
  #endif /* TOPPERS_sns_dsp */
  
  /*
!  *  ǥѥåα֤λ
   */
  #ifdef TOPPERS_sns_dpn
  
--- 499,505 ----
  #endif /* TOPPERS_sns_dsp */
  
  /*
!  *  ディスパッチ保留状態の参照
   */
  #ifdef TOPPERS_sns_dpn
  
***************
*** 517,523 ****
  #endif /* TOPPERS_sns_dpn */
  
  /*
!  *  ͥư֤λ
   */
  #ifdef TOPPERS_sns_ker
  
--- 517,523 ----
  #endif /* TOPPERS_sns_dpn */
  
  /*
!  *  カーネル非動作状態の参照
   */
  #ifdef TOPPERS_sns_ker
  
diff -cr --new-file 1.9.1/asp/kernel/task.c ASPs/asp/kernel/task.c
*** 1.9.1/asp/kernel/task.c	Tue Aug 30 10:05:12 2011
--- ASPs/asp/kernel/task.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.c 2248 2011-08-30 01:05:11Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.c 2248 2011-08-30 01:05:11Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TEX_ENTER
  #define LOG_TEX_ENTER(p_tcb, texptn)
***************
*** 62,108 ****
  #ifdef TOPPERS_tskini
  
  /*
!  *  ¹Ծ֤Υ
   */
  TCB		*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   */
  TCB		*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   */
  bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   */
  bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   */
  bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   */
  bool_t	dspflg;
  
  /*
!  *  ǥ塼
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   */
  uint16_t	ready_primap;
  
  /*
!  *  ⥸塼ν
   */
  void
  initialize_task(void)
--- 62,108 ----
  #ifdef TOPPERS_tskini
  
  /*
!  *  実行状態のタスク
   */
  TCB		*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   */
  TCB		*p_schedtsk;
  
  /*
!  *  タスクディスパッチ／タスク例外処理ルーチン起動要求フラグ
   */
  bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   */
  bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   */
  bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   */
  bool_t	dspflg;
  
  /*
!  *  レディキュー
   */
  QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   */
  uint16_t	ready_primap;
  
  /*
!  *  タスク管理モジュールの初期化
   */
  void
  initialize_task(void)
***************
*** 137,158 ****
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ӥåȥޥåץؿ
   *
!  *  bitmap1ΥӥåȤ⡤ǤⲼ̡ʱˤΤΤ򥵡Υӥ
!  *  ֹ֤ӥåֹϡǲ̥ӥåȤ0Ȥ롥bitmap0
!  *  ƤϤʤʤδؿǤϡbitmap16ӥåȤǤ뤳Ȥꤷ
!  *  uint16_tȤƤ롥
   *
!  *  ӥåȥ̿ĥץåǤϡӥåȥ̿Ȥ褦
!  *  ľΨɤ礬롥Τ褦ʾˤϡå
!  *  ¸ǥӥåȥ̿Ȥäbitmap_search
!  *  OMIT_BITMAP_SEARCHޥФ褤ޤӥåȥ̿
!  *  դʤɤͳͥ٤ȥӥåȤȤбѹ
!  *  ϡPRIMAP_BITޥФ褤
   *
!  *  ޤ饤֥ffsʤ顤Τ褦ƥ饤֥ؿ
!  *  ȤäΨɤǽ⤢롥
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
--- 137,158 ----
  #endif /* TOPPERS_tskini */
  
  /*
!  *  ビットマップサーチ関数
   *
!  *  bitmap内の1のビットの内，最も下位（右）のものをサーチし，そのビッ
!  *  ト番号を返す．ビット番号は，最下位ビットを0とする．bitmapに0を指定
!  *  してはならない．この関数では，bitmapが16ビットであることを仮定し，
!  *  uint16_t型としている．
   *
!  *  ビットサーチ命令を持つプロセッサでは，ビットサーチ命令を使うように
!  *  書き直した方が効率が良い場合がある．このような場合には，ターゲット
!  *  依存部でビットサーチ命令を使ったbitmap_searchを定義し，
!  *  OMIT_BITMAP_SEARCHをマクロ定義すればよい．また，ビットサーチ命令の
!  *  サーチ方向が逆などの理由で優先度とビットとの対応を変更したい場合に
!  *  は，PRIMAP_BITをマクロ定義すればよい．
   *
!  *  また，ライブラリにffsがあるなら，次のように定義してライブラリ関数を
!  *  使った方が効率が良い可能性もある．
   *		#define	bitmap_search(bitmap) (ffs(bitmap) - 1)
   */
  #ifndef PRIMAP_BIT
***************
*** 184,190 ****
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline bool_t
  primap_empty(void)
--- 184,190 ----
  #endif /* OMIT_BITMAP_SEARCH */
  
  /*
!  *  優先度ビットマップが空かのチェック
   */
  Inline bool_t
  primap_empty(void)
***************
*** 193,199 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥ
   */
  Inline uint_t
  primap_search(void)
--- 193,199 ----
  }
  
  /*
!  *  優先度ビットマップのサーチ
   */
  Inline uint_t
  primap_search(void)
***************
*** 202,208 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥå
   */
  Inline void
  primap_set(uint_t pri)
--- 202,208 ----
  }
  
  /*
!  *  優先度ビットマップのセット
   */
  Inline void
  primap_set(uint_t pri)
***************
*** 211,217 ****
  }
  
  /*
!  *  ͥ٥ӥåȥޥåפΥꥢ
   */
  Inline void
  primap_clear(uint_t pri)
--- 211,217 ----
  }
  
  /*
!  *  優先度ビットマップのクリア
   */
  Inline void
  primap_clear(uint_t pri)
***************
*** 220,226 ****
  }
  
  /*
!  *  ǹ̥ͥΥ
   */
  #ifdef TOPPERS_tsksched
  
--- 220,226 ----
  }
  
  /*
!  *  最高優先順位タスクのサーチ
   */
  #ifdef TOPPERS_tsksched
  
***************
*** 236,246 ****
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡ¹ԤǤ륿ʤä
!  *  ȡp_tcbͥ٤ǹ̤ͥΥͥ٤⤤Ǥ
!  *  롥
   */
  #ifdef TOPPERS_tskrun
  
--- 236,246 ----
  #endif /* TOPPERS_tsksched */
  
  /*
!  *  実行できる状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，実行できるタスクがなかった場合
!  *  と，p_tcbの優先度が最高優先順位のタスクの優先度よりも高い場合であ
!  *  る．
   */
  #ifdef TOPPERS_tskrun
  
***************
*** 262,273 ****
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  ǹ̤ͥΥ򹹿Τϡp_tcbǹ̤ͥΥ
!  *  äǤ롥p_tcbƱͥ٤Υ¾ˤϡp_tcb
!  *  μΥǹ̤ͥˤʤ롥Ǥʤϡǥ塼
!  *  ɬפ롥
   */
  #ifdef TOPPERS_tsknrun
  
--- 262,273 ----
  #endif /* TOPPERS_tskrun */
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  最高優先順位のタスクを更新するのは，p_tcbが最高優先順位のタスクで
!  *  あった場合である．p_tcbと同じ優先度のタスクが他にある場合は，p_tcb
!  *  の次のタスクが最高優先順位になる．そうでない場合は，レディキューを
!  *  サーチする必要がある．
   */
  #ifdef TOPPERS_tsknrun
  
***************
*** 297,303 ****
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  ٻ߾֤ؤ
   */
  #ifdef TOPPERS_tskdmt
  
--- 297,303 ----
  #endif /* TOPPERS_tsknrun */
  
  /*
!  *  休止状態への遷移
   */
  #ifdef TOPPERS_tskdmt
  
***************
*** 315,321 ****
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   */
  #ifdef TOPPERS_tskact
  
--- 315,321 ----
  #endif /* TOPPERS_tskdmt */
  
  /*
!  *  休止状態から実行できる状態への遷移
   */
  #ifdef TOPPERS_tskact
  
***************
*** 331,346 ****
  #endif /* TOPPERS_tskact */
  
  /*
!  *  ͥ٤ѹ
   *
!  *  ¹ԤǤ֤ξˤϡǥ塼Ǥΰ֤ѹ
!  *  롥֥ȤԤ塼Ԥ֤ˤʤäƤˤϡ
!  *  塼Ǥΰ֤ѹ롥
   *
!  *  ǹ̤ͥΥ򹹿Τϡ(1) p_tcbǹ̤ͥΥ
!  *  Ǥäơͥ٤򲼤硤(2) p_tcbǹ̤ͥΥ
!  *  ǤϤʤѹͥ٤ǹ̤ͥΥͥ٤⤤
!  *  Ǥ롥(1)ξˤϡǥ塼򥵡ɬפ롥
   */
  #ifdef TOPPERS_tskpri
  
--- 331,346 ----
  #endif /* TOPPERS_tskact */
  
  /*
!  *  タスクの優先度の変更
   *
!  *  タスクが実行できる状態の場合には，レディキューの中での位置を変更す
!  *  る．オブジェクトの待ちキューの中で待ち状態になっている場合には，待
!  *  ちキューの中での位置を変更する．
   *
!  *  最高優先順位のタスクを更新するのは，(1) p_tcbが最高優先順位のタス
!  *  クであって，その優先度を下げた場合，(2) p_tcbが最高優先順位のタス
!  *  クではなく，変更後の優先度が最高優先順位のタスクの優先度よりも高い
!  *  場合である．(1)の場合には，レディキューをサーチする必要がある．
   */
  #ifdef TOPPERS_tskpri
  
***************
*** 354,360 ****
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤ξ
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
--- 354,360 ----
  
  	if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  タスクが実行できる状態の場合
  		 */
  		queue_delete(&(p_tcb->task_queue));
  		if (queue_empty(&(ready_queue[oldpri]))) {
***************
*** 379,386 ****
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  Ʊ֥̿Ȥδ֥åζ
! 			 *  ʬWOBJCBˤԤ塼ˤĤʤƤ
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
--- 379,386 ----
  	else {
  		if (TSTAT_WAIT_WOBJCB(p_tcb->tstat)) {
  			/*
! 			 *  タスクが，同期・通信オブジェクトの管理ブロックの共通部
! 			 *  分（WOBJCB）の待ちキューにつながれている場合
  			 */
  			wobj_change_priority(((WINFO_WOBJ *)(p_tcb->p_winfo))->p_wobjcb,
  																	p_tcb);
***************
*** 392,401 ****
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  ǥ塼βž
   *
!  *  ǹ̤ͥΥ򹹿Τϡǹ̤ͥΥ
!  *  塼˰ưǤ롥
   */
  #ifdef TOPPERS_tskrot
  
--- 392,401 ----
  #endif /* TOPPERS_tskpri */
  
  /*
!  *  レディキューの回転
   *
!  *  最高優先順位のタスクを更新するのは，最高優先順位のタスクがタスクキ
!  *  ューの末尾に移動した場合である．
   */
  #ifdef TOPPERS_tskrot
  
***************
*** 419,428 ****
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  㳰롼θƽФ
   *
!  *  ASPͥǤϡ㳰롼CPUå֤ܤ
!  *  ξ֤ᤵ˥꥿󤷤硤ͥ뤬ξ֤᤹
   */
  #ifdef TOPPERS_tsktex
  
--- 419,428 ----
  #endif /* TOPPERS_tskrot */
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  ASPカーネルでは，タスク例外処理ルーチン内でCPUロック状態に遷移し，
!  *  元の状態に戻さずにリターンした場合，カーネルが元の状態に戻す．
   */
  #ifdef TOPPERS_tsktex
  
***************
*** 455,464 ****
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  dispatchƤӽФϡߺƵƽФˤʤä
! 			 *  뤬dispatchƤp_runtsk->enatexfalseˤ
! 			 *  лپ㤬ʤͳˤĤƤϡTOPPERS/ASP 
! 			 *  ͥ ߷ץפ򻲾ȤΤȡ
  			 */
  			dispatch();
  		}
--- 455,464 ----
  		p_runtsk->enatex = false;
  		if (p_runtsk != p_schedtsk && dspflg) {
  			/*
! 			 *  ここでdispatchを呼び出す処理は，相互再帰呼出しになって
! 			 *  いるが，dispatchを呼ぶ前にp_runtsk->enatexをfalseにして
! 			 *  おけば支障がない．その理由については，「TOPPERS/ASP カー
! 			 *  ネル 設計メモ」を参照のこと．
  			 */
  			dispatch();
  		}
***************
*** 467,473 ****
  }
  
  /*
!  *  㳰롼εư
   */
  #ifndef OMIT_CALLTEX
  
--- 467,473 ----
  }
  
  /*
!  *  タスク例外処理ルーチンの起動
   */
  #ifndef OMIT_CALLTEX
  
diff -cr --new-file 1.9.1/asp/kernel/task.h ASPs/asp/kernel/task.h
*** 1.9.1/asp/kernel/task.h	Mon Jul  4 08:40:20 2011
--- ASPs/asp/kernel/task.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task.h 2146 2011-07-03 23:40:01Z ertl-hiro $
   */
  
  /*
!  *		⥸塼
   */
  
  #ifndef TOPPERS_TASK_H
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task.h 2146 2011-07-03 23:40:01Z ertl-hiro $
   */
  
  /*
!  *		タスク管理モジュール
   */
  
  #ifndef TOPPERS_TASK_H
***************
*** 51,99 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  ͥ٤ɽɽѴޥ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  ֤ɽ
   *
!  *  TCBΥ֤Ǥϡ¹Ծ֡RUNNINGˤȼ¹Բǽ֡READY
!  *  ϶̤ʤξ֤Τơ¹ԤǤ֡RUNNABLEˤȸƤ֡
!  *  Ԥ֤ϡ(TS_WAITING | TS_SUSPENDED)ɽTS_WAIT_???
!  *  װɽԤ֡Ԥ֤ޤˤξˤΤꤹ롥
!  */
! #define TS_DORMANT		0x00U			/* ٻ߾ */
! #define TS_RUNNABLE		0x01U			/* ¹ԤǤ */
! #define TS_WAITING		0x02U			/* Ԥ */
! #define TS_SUSPENDED	0x04U			/* Ԥ */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* ַвԤ */
! #define TS_WAIT_SLP		(0x01U << 3)	/* Ԥ */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* ǡ塼μԤ */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* ͥ٥ǡ塼μԤ */
! #define TS_WAIT_SEM		(0x04U << 3)	/* ޥե񸻤γԤ */
! #define TS_WAIT_FLG		(0x05U << 3)	/* ٥ȥե饰Ԥ */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* ǡ塼ؤԤ */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* ͥ٥ǡ塼ؤԤ */
! #define TS_WAIT_MBX		(0x08U << 3)	/* ᡼ܥåμԤ */
! #define TS_WAIT_MPF		(0x09U << 3)	/* Ĺ֥åγԤ */
! 
! /*
!  *  Ƚ̥ޥ
!  *
!  *  TSTAT_DORMANTϥٻ߾֤Ǥ뤫ɤTSTAT_RUNNABLE
!  *  ¹ԤǤ֤Ǥ뤫ɤȽ̤롥TSTAT_WAITING
!  *  ֤Ԥ֤Τ줫Ǥ뤫ɤTSTAT_SUSPENDED
!  *  Ԥ֤Ԥ֤Τ줫Ǥ뤫ɤȽ̤롥
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
--- 51,99 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_TSKSTAT
  #define LOG_TSKSTAT(p_tcb)
  #endif /* LOG_TSKSTAT */
  
  /*
!  *  タスク優先度の内部表現・外部表現変換マクロ
   */
  #define INT_PRIORITY(x)		((uint_t)((x) - TMIN_TPRI))
  #define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)
  
  /*
!  *  タスク状態の内部表現
   *
!  *  TCB中のタスク状態では，実行状態（RUNNING）と実行可能状態（READY）
!  *  は区別しない．両状態を総称して，実行できる状態（RUNNABLE）と呼ぶ．
!  *  二重待ち状態は，(TS_WAITING | TS_SUSPENDED)で表す．TS_WAIT_???は待
!  *  ち要因を表し，待ち状態（二重待ち状態を含む）の場合にのみ設定する．
!  */
! #define TS_DORMANT		0x00U			/* 休止状態 */
! #define TS_RUNNABLE		0x01U			/* 実行できる状態 */
! #define TS_WAITING		0x02U			/* 待ち状態 */
! #define TS_SUSPENDED	0x04U			/* 強制待ち状態 */
! 
! #define TS_WAIT_DLY		(0x00U << 3)	/* 時間経過待ち */
! #define TS_WAIT_SLP		(0x01U << 3)	/* 起床待ち */
! #define TS_WAIT_RDTQ	(0x02U << 3)	/* データキューからの受信待ち */
! #define TS_WAIT_RPDQ	(0x03U << 3)	/* 優先度データキューからの受信待ち */
! #define TS_WAIT_SEM		(0x04U << 3)	/* セマフォ資源の獲得待ち */
! #define TS_WAIT_FLG		(0x05U << 3)	/* イベントフラグ待ち */
! #define TS_WAIT_SDTQ	(0x06U << 3)	/* データキューへの送信待ち */
! #define TS_WAIT_SPDQ	(0x07U << 3)	/* 優先度データキューへの送信待ち */
! #define TS_WAIT_MBX		(0x08U << 3)	/* メールボックスからの受信待ち */
! #define TS_WAIT_MPF		(0x09U << 3)	/* 固定長メモリブロックの獲得待ち */
! 
! /*
!  *  タスク状態判別マクロ
!  *
!  *  TSTAT_DORMANTはタスクが休止状態であるかどうかを，TSTAT_RUNNABLEは
!  *  タスクが実行できる状態であるかどうかを判別する．TSTAT_WAITINGは待
!  *  ち状態と二重待ち状態のいずれかであるかどうかを，TSTAT_SUSPENDEDは
!  *  強制待ち状態と二重待ち状態のいずれかであるかどうかを判別する．
   */
  #define TSTAT_DORMANT(tstat)	((tstat) == TS_DORMANT)
  #define TSTAT_RUNNABLE(tstat)	(((tstat) & TS_RUNNABLE) != 0U)
***************
*** 101,479 ****
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  ԤװȽ̥ޥ
   *
!  *  TSTAT_WAIT_SLPϥԤǤ뤫ɤTSTAT_WAIT_WOBJ
!  *  ϥƱ֥̿ȤФԤǤ뤫ʸȡ
!  *  Ʊ֥̿ȤԤ塼ˤĤʤƤ뤫ˤɤȽ̤
!  *  롥ޤTSTAT_WAIT_WOBJCBϥƱ֥̿Ȥδ
!  *  ֥åζʬWOBJCBˤԤ塼ˤĤʤƤ뤫ɤ
!  *  Ƚ̤롥
!  *
!  *  TSTAT_WAIT_SLPϡǤդΥ֤椫顤ԤǤ
!  *  ȤȽ̤Ǥ롥ʤTSTAT_WAITINGˤԤ֤Ǥ뤳Ȥ
!  *  Ƚ̤ˡTSTAT_SLPѤƵԤ֤Ǥ뤳ȤȽ̤Ǥ롥
!  *  ΨŪ˼¸뤿ˡTS_WAIT_SLPͤ(0x00U << 3)ǤϤ
!  *  (0x01U << 3)ȤƤ롥ΤᡤַвԤ֤Ǥ
!  *  ȤȽ̤뤿TSTAT_WAIT_DLYTSTAT_WAIT_SLPƱͤˡ
!  *  ¸뤳ȤϤǤʤ
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* ԤװμФޥ */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  Ԥ֥åWINFOˤ
   *
!  *  Ԥ֤δ֤ϡTCBӤp_winfoǻؤWINFO򼡤
!  *  褦ꤷʤФʤʤ
   *
!  *  (a) TCBΥ֤Ԥ֡TS_WAITINGˤˤ롥κݤˡԤ
!  *  װTS_WAIT_???ˤꤹ롥
   *
!  *  (b) ॢȤƻ뤹뤿ˡ।٥ȥ֥åϿ롥
!  *  Ͽ륿।٥ȥ֥åϡԤ륵ӥؿ
!  *  ΥѿȤƳݤؤΥݥ󥿤WINFOp_tmevtb˵
!  *  롥ॢȤδƻ뤬ɬפʤʱʵԤξˤˤϡ
!  *  p_tmevtbNULLˤ롥
!  *
!  *  Ʊ֥̿ȤФԤ֤ξˤϡɸWINFO
!  *  p_wobjcbեɤɲä¤ΡWINFO_WOBJwait.hˤ
!  *  ޤʲ(c)(e)Ԥɬפ롥Ʊ֥̿
!  *  Ȥ˴طʤԤʵԤַвԤˤξˤϡ(c)(e)
!  *  ɬפʤ
!  *
!  *  (c) TCBԤоݤƱ֥̿ȤԤ塼ˤĤʤ
!  *  塼ˤĤʤˡtask_queueȤ
!  *
!  *  (d) ԤоݤƱ֥̿Ȥδ֥åؤΥݥ󥿤
!  *  WINFO_WOBJp_wobjcb˵롥
!  *
!  *  (e) ԤоݤƱ֥̿Ȥ˰¸Ƶ뤳Ȥɬפ
!  *  󤬤ˤϡWINFO_WOBJɬפʾΤΥեɤɲ
!  *  ¤ΤWINFO_WOBJѤ롥
!  *
!  *  Ԥ֤ݤˤϡԤФͤWINFO
!  *  wercdꤹ롥wercdɬפʤΤԤʹߤǤΤФơ
!  *  p_tmevtbԤɬפʤᡤΤ˶ΤȤ
!  *  Ƥ롥Τᡤwercdإ顼ɤꤹΤϡ।٥
!  *  ֥åϿˤʤФʤʤ
   */
  typedef union waiting_information {
! 	ER		wercd;			/* ԤΥ顼 */
! 	TMEVTB	*p_tmevtb;		/* ԤѤΥ।٥ȥ֥å */
  } WINFO;
  
  /*
!  *  ֥å
   *
!  *  ˴ؤͤѤʤROM֤ʬʥ
!  *  ֥åˤȡͤѲ뤿RAM֤ʤФʤʤ
!  *  ʬʥ֥åTCBˤʬΥTCBб륿
!  *  ֥åؤݥ󥿤롥֥åб
!  *  TCBؤݥ󥿤ˡRAMδ˾ޤ
!  *  ¹ԸΨʤ뤿˺ѤƤʤ¾Υ֥ȤˤĤ
!  *  ƤƱͤ˰
   *
!  *  ֥åˤϡDEF_TEX륿㳰롼
!  *  ˴ؤޤࡥ
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* ° */
! 	intptr_t	exinf;			/* γĥ */
! 	TASK		task;			/* εư */
! 	uint_t		ipriority;		/* εưͥ١ɽ */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* ƥȥ֥å */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* åΰΥʴݤ᤿͡ */
! 	void		*stk;			/* åΰƬ */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* 㳰롼° */
! 	TEXRTN		texrtn;			/* 㳰롼εư */
  } TINIB;
  
  /*
!  *  TCBΥեɤΥӥå
   *
!  *  ץåˤäƤϡTCBΥեɤΥӥåǥ̤
!  *  ǽȥ졼ɥդˤʤ뤿ᡤåȰ¸˥եɤΥӥå
!  *  ѹ뤳ȤƤ롥
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityեɤΥӥå */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  ֥åTCB
   *
!  *  ASPͥǤϡεư׵ᥭ塼󥰿κ͡TMAX_ACTCNT
!  *  ȵ׵ᥭ塼󥰿κ͡TMAX_WUPCNTˤ1˸ꤵƤ
!  *  ᡤ塼󥰤Ƥ뤫ɤοͤɽ뤳ȤǤ롥
!  *  ޤԤ׵ͥȿκ͡TMAX_SUSCNTˤ1˸ꤵƤ
!  *  ΤǡԤ׵ͥȿsuscntˤɬפʤ
!  *
!  *  TCBΤĤΥեɤϡΥ֤ǤΤͭͤݻ
!  *  ʳξͤݾڤʤʤäơȤƤϤʤʤˡ
!  *  եɤͭͤݻϼ̤ꡥ
!  *
!  *  Ͼͭ
!  *  		p_tinibtstatactque
!  *  ٻ߾ְʳͭʵٻ߾֤ǤϽͤˤʤäƤˡ
!  *  		prioritywupqueenatextexptn
!  *  Ԥ֡Ԥ֤ޤˤͭ
   *  		p_winfo
!  *  ¹ԤǤ֤Ʊ֥̿ȤФԤ֤ͭ
   *  		task_queue
!  *  ¹Բǽ֡Ԥ֡Ԥ֡Ԥ֤ͭ
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* 塼 */
! 	const TINIB		*p_tinib;		/* ֥åؤΥݥ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* ֡ɽ*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* ֡ɽ*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* ߤͥ١ɽ*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* ߤͥ١ɽ*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* ư׵ᥭ塼 */
! 	BIT_FIELD_BOOL	wupque : 1;		/* ׵ᥭ塼 */
! 	BIT_FIELD_BOOL	enatex : 1;		/* 㳰ľ */
! 
! 	TEXPTN			texptn;			/* α㳰װ */
! 	WINFO			*p_winfo;		/* Ԥ֥åؤΥݥ */
! 	TSKCTXB			tskctxb;		/* ƥȥ֥å */
  } TCB;
  
  /*
!  *  ¹Ծ֤Υ
   *
!  *  ¹Ծ֤ΥʡץåƥȤäƤ륿ˤ
!  *  TCBؤݥ󥿡¹Ծ֤ΥʤNULLˤ롥
   *
!  *  ӥνǡʥӥƤӽФ
!  *  ˤ˴ؤ򻲾Ȥp_runtskȤp_runtsk񤭴
!  *  ΤϡǥѥåʤȽˤΤߤǤ롥
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  ǹ̤ͥΥ
   *
!  *  ¹ԤǤ륿Ǻǹ̤ͥΥTCBؤݥ󥿡
!  *  ԤǤ륿ʤNULLˤ롥
   *
!  *  ǥѥåػ߾֤ʤɡǥѥåαƤ֤p_runtsk
!  *  ȰפƤȤϸ¤ʤ
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ǥѥå㳰롼ư׵ե饰
   *
!  *  ߥϥɥ顿CPU㳰ϥɥνиˡǥѥåޤ
!  *  㳰롼εư׵᤹뤳Ȥ򼨤ե饰
   */
  extern bool_t	reqflg;
  
  /*
!  *  ͥ٥ޥ
   *
!  *  ͥ٥ޥ֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ǥѥåػ߾
   *
!  *  ǥѥåػ߾֤Ǥ뤳Ȥ򼨤ե饰
   */
  extern bool_t	disdsp;
  
  /*
!  *  ǥѥåǽ
   *
!  *  ͥ٥ޥ֤Ǥꡤǥѥåľ֤Ǥʥǥ
!  *  ѥåػ߾֤ǤʤˤȤ򼨤ե饰
   */
  extern bool_t	dspflg;
  
  /*
!  *  ǥ塼
   *
!  *  ǥ塼ϡ¹ԤǤ֤Υ뤿Υ塼Ǥ롥
!  *  ¹Ծ֤ΥƤ뤿ᡤǥʼ¹Բǽ˥塼Ȥ
!  *  ̾ΤΤǤϤʤǥ塼Ȥ̾Τ夷Ƥ뤿ᡤ
!  *  ̾ΤǸƤ֤Ȥˤ롥
   *
!  *  ǥ塼ϡͥ٤ȤΥ塼ǹƤ롥
!  *  TCBϡͥ٤Υ塼Ͽ롥
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  ǥ塼ΤΥӥåȥޥå
   *
!  *  ǥ塼ΥΨ褯Ԥˡͥ٤ȤΥ塼
!  *  ˥äƤ뤫ɤ򼨤ӥåȥޥåפѰդƤ롥ӥ
!  *  ȥޥåפȤȤǡꥢβ򸺤餹ȤǤ뤬
!  *  ӥå̿᤬¤Ƥʤץåǡͥ٤ʳʤ
!  *  ˤϡӥåȥޥåΥСإåɤΤˡդ˸Ψ
!  *  ǽ⤢롥
   *
!  *  ͥ٤16ʳǤ뤳ȤꤷƤ뤿ᡤuint16_tȤƤ롥
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  IDκ͡kernel_cfg.c
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  ֥åΥꥢkernel_cfg.c
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  ơ֥kernel_cfg.c
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBΥꥢkernel_cfg.c
   */
  extern TCB	tcb_table[];
  
  /*
!  *  ο
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  IDTCBФΥޥ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCB饿IDФΥޥ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  ⥸塼ν
   */
  extern void	initialize_task(void);
  
  /*
!  *  ǹ̥ͥΥ
   *
!  *  ǥ塼κǹ̤ͥΥ򥵡TCBؤΥݥ
!  *  ֤ǥ塼ξˤϡδؿƤӽФƤϤʤʤ
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  ¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥ǥ塼
!  *  ͥ٤ǹ̤ͥΥͥ٤⤤ϡ
!  *  ǹ̤ͥΥ򹹿ǥѥåľ֤Ǥtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  ¹ԤǤ֤¾ξ֤ؤ
   *
!  *  p_tcbǻꤵ륿ǥ塼롥p_tcbǻꤷ
!  *  ǹ̤ͥΥǤäˤϡǹ̤ͥΥ
!  *  ꤷʤǥѥåľ֤Ǥtrue֤Ǥʤ
!  *  false֤ξ֤Ϲʤ
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤Ȥ롥ޤεư
!  *  ˽٤ѿνȡưΤΥƥȤ
!  *  ꤹ롥
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  ٻ߾֤¹ԤǤ֤ؤ
   *
!  *  p_tcbǻꤵ륿ξ֤ٻ߾֤¹ԤǤ֤Ȥ롥
!  *  ¹ԤǤ֤ܤؤΥǥѥåɬפʾtrue
!  *  Ǥʤfalse֤
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  ͥ٤ѹ
   *
!  *  p_tcbǻꤵ륿ͥ٤newpriɽˤѹ롥ޤ
!  *  ɬפʾˤϺǹ̤ͥΥ򹹿ǥѥåľ֤
!  *  true֤Ǥʤfalse֤
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  ǥ塼βž
   *
!  *  ǥ塼Ρpriǻꤵͥ٤Υ塼ž롥
!  *  ޤɬפʾˤϺǹ̤ͥΥѹǥѥå
!  *  αƤʤtrue֤Ǥʤfalse֤
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  㳰롼θƽФ
   *
!  *  㳰롼ƤӽФƤӽФˡ¹Ծ֤Υ
!  *  α㳰װ򥯥ꥢ㳰ػ߾֤ˤCPUå
!  *  롥
!  *
!  *  㳰롼󤫤ȡޤCPUå֤ᤷδ
!  *  α㳰װ0ǤʤʤäƤСƤӥ㳰롼
!  *  ƤӽФα㳰װ0ξˤϡ㳰ľ֤ˤƴؿ
!  *  ꥿󤹤롥
!  *
!  *  δؿϡ¹Ծ֤Υ㳰ľ֡enatex
!  *  trueˤǡα㳰װ0Ǥʤtexptn0Ǥʤ˾˸ƤӽФ
!  *  ȤꤷƤ롥δؿϡCPUå֤ǸƤӽФʤФʤ
!  *  ʤ
   */
  extern void	call_texrtn(void);
  
  /*
!  *  㳰롼εư
   *
!  *  ¹Ծ֤Υ㳰롼εưƤС
!  *  㳰롼ƤӽФCPU㳰롼ƤӽФ
!  *  ϡŪCPUå롥
!  *
!  *  δؿϡǥѥåߥϥɥ顿CPU㳰ϥɥνи
!  *  ƤӽФ뤳ȤꤷƤ롥δؿϡCPUå
!  *  ǸƤӽФʤФʤʤ
   *
!  *  ¹ԸΨ夲뤿ˡδؿ򥿡åȰ¸ǵҤƤ褤
!  *  ξˤϡOMIT_CALLTEXޥ롥
   */
  extern void	calltex(void);
  
--- 101,479 ----
  #define TSTAT_SUSPENDED(tstat)	(((tstat) & TS_SUSPENDED) != 0U)
  
  /*
!  *  タスク待ち要因判別マクロ
   *
!  *  TSTAT_WAIT_SLPはタスクが起床待ちであるかどうかを，TSTAT_WAIT_WOBJ
!  *  はタスクが同期・通信オブジェクトに対する待ちであるか（言い換えると，
!  *  同期通信オブジェクトの待ちキューにつながれているか）どうかを判別す
!  *  る．また，TSTAT_WAIT_WOBJCBはタスクが同期・通信オブジェクトの管理
!  *  ブロックの共通部分（WOBJCB）の待ちキューにつながれているかどうかを
!  *  判別する．
!  *
!  *  TSTAT_WAIT_SLPは，任意のタスク状態の中から，タスクが起床待ちである
!  *  ことを判別できる．すなわち，TSTAT_WAITINGにより待ち状態であることを
!  *  判別せずに，TSTAT_SLPだけを用いて起床待ち状態であることを判別できる．
!  *  これを効率的に実現するために，TS_WAIT_SLPの値を，(0x00U << 3)ではな
!  *  く(0x01U << 3)としている．そのため，タスクが時間経過待ち状態である
!  *  ことを判別するためのTSTAT_WAIT_DLYを，TSTAT_WAIT_SLPと同様の方法で
!  *  実現することはできない．
   */
! #define TS_WAIT_MASK	(0x0fU << 3)	/* 待ち要因の取出しマスク */
  
  #define TSTAT_WAIT_SLP(tstat)		(((tstat) & TS_WAIT_MASK) == TS_WAIT_SLP)
  #define TSTAT_WAIT_WOBJ(tstat)		(((tstat) & TS_WAIT_MASK) >= TS_WAIT_RDTQ)
  #define TSTAT_WAIT_WOBJCB(tstat)	(((tstat) & TS_WAIT_MASK) >= TS_WAIT_SEM)
  
  /*
!  *  待ち情報ブロック（WINFO）の定義
   *
!  *  タスクが待ち状態の間は，TCBおよびそのp_winfoで指されるWINFOを次の
!  *  ように設定しなければならない．
   *
!  *  (a) TCBのタスク状態を待ち状態（TS_WAITING）にする．その際に，待ち
!  *  要因（TS_WAIT_???）も設定する．
   *
!  *  (b) タイムアウトを監視するために，タイムイベントブロックを登録する．
!  *  登録するタイムイベントブロックは，待ちに入るサービスコール処理関数
!  *  のローカル変数として確保し，それへのポインタをWINFOのp_tmevtbに記
!  *  憶する．タイムアウトの監視が必要ない場合（永久待ちの場合）には，
!  *  p_tmevtbをNULLにする．
!  *
!  *  同期・通信オブジェクトに対する待ち状態の場合には，標準のWINFOに
!  *  p_wobjcbフィールドを追加した構造体（WINFO_WOBJ，wait.hで定義）を使
!  *  う．また，以下の(c)〜(e)の設定を行う必要がある．同期・通信オブジェ
!  *  クトに関係しない待ち（起床待ち，時間経過待ち）の場合には，(c)〜(e)
!  *  は必要ない．
!  *
!  *  (c) TCBを待ち対象の同期・通信オブジェクトの待ちキューにつなぐ．待
!  *  ちキューにつなぐために，task_queueを使う．
!  *
!  *  (d) 待ち対象の同期・通信オブジェクトの管理ブロックへのポインタを，
!  *  WINFO_WOBJのp_wobjcbに記憶する．
!  *
!  *  (e) 待ち対象の同期・通信オブジェクトに依存して記憶することが必要な
!  *  情報がある場合には，WINFO_WOBJに必要な情報のためのフィールドを追加
!  *  した構造体を定義し，WINFO_WOBJの代わりに用いる．
!  *
!  *  待ち状態を解除する際には，待ち解除したタスクに対する返値をWINFOの
!  *  wercdに設定する．wercdが必要なのは待ち解除以降であるのに対して，
!  *  p_tmevtbは待ち解除後は必要ないため，メモリ節約のために共用体を使っ
!  *  ている．そのため，wercdへエラーコードを設定するのは，タイムイベント
!  *  ブロックを登録解除した後にしなければならない．
   */
  typedef union waiting_information {
! 	ER		wercd;			/* 待ち解除時のエラーコード */
! 	TMEVTB	*p_tmevtb;		/* 待ち状態用のタイムイベントブロック */
  } WINFO;
  
  /*
!  *  タスク初期化ブロック
   *
!  *  タスクに関する情報を，値が変わらないためにROMに置ける部分（タスク
!  *  初期化ブロック）と，値が変化するためにRAMに置かなければならない部
!  *  分（タスク管理ブロック，TCB）に分離し，TCB内に対応するタスク初期化
!  *  ブロックを指すポインタを入れる．タスク初期化ブロック内に対応する
!  *  TCBを指すポインタを入れる方法の方が，RAMの節約の観点からは望ましい
!  *  が，実行効率が悪くなるために採用していない．他のオブジェクトについ
!  *  ても同様に扱う．
   *
!  *  タスク初期化ブロックには，DEF_TEXで定義されるタスク例外処理ルーチ
!  *  ンに関する情報も含む．
   */
  typedef struct task_initialization_block {
! 	ATR			tskatr;			/* タスク属性 */
! 	intptr_t	exinf;			/* タスクの拡張情報 */
! 	TASK		task;			/* タスクの起動番地 */
! 	uint_t		ipriority;		/* タスクの起動時優先度（内部表現） */
  
  #ifdef USE_TSKINICTXB
! 	TSKINICTXB	tskinictxb;		/* タスク初期化コンテキストブロック */
  #else /* USE_TSKINICTXB */
! 	SIZE		stksz;			/* スタック領域のサイズ（丸めた値） */
! 	void		*stk;			/* スタック領域の先頭番地 */
  #endif /* USE_TSKINICTXB */
  
! 	ATR			texatr;			/* タスク例外処理ルーチン属性 */
! 	TEXRTN		texrtn;			/* タスク例外処理ルーチンの起動番地 */
  } TINIB;
  
  /*
!  *  TCB中のフィールドのビット幅の定義
   *
!  *  プロセッサによっては，TCB中のフィールドのビット幅でメモリ使用量と
!  *  性能がトレードオフになるため，ターゲット依存にフィールドのビット幅
!  *  を変更することを許している．
   */
  #ifndef TBIT_TCB_PRIORITY
! #define	TBIT_TCB_PRIORITY		8		/* priorityフィールドのビット幅 */
  #endif /* TBIT_TCB_PRIORITY */
  
  /*
!  *  タスク管理ブロック（TCB）
   *
!  *  ASPカーネルでは，タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）
!  *  と起床要求キューイング数の最大値（TMAX_WUPCNT）は1に固定されている
!  *  ため，キューイングされているかどうかの真偽値で表現することができる．
!  *  また，強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が1に固定されてい
!  *  るので，強制待ち要求ネスト数（suscnt）は必要ない．
!  *
!  *  TCBのいくつかのフィールドは，特定のタスク状態でのみ有効な値を保持し，
!  *  それ以外の場合は値が保証されない（よって，参照してはならない）．各
!  *  フィールドが有効な値を保持する条件は次の通り．
!  *
!  *  ・初期化後は常に有効：
!  *  		p_tinib，tstat，actque
!  *  ・休止状態以外で有効（休止状態では初期値になっている）：
!  *  		priority，wupque，enatex，texptn
!  *  ・待ち状態（二重待ち状態を含む）で有効：
   *  		p_winfo
!  *  ・実行できる状態と同期・通信オブジェクトに対する待ち状態で有効：
   *  		task_queue
!  *  ・実行可能状態，待ち状態，強制待ち状態，二重待ち状態で有効：
   *  		tskctxb
   */
  typedef struct task_control_block {
! 	QUEUE			task_queue;		/* タスクキュー */
! 	const TINIB		*p_tinib;		/* 初期化ブロックへのポインタ */
  
  #ifdef UINT8_MAX
! 	uint8_t			tstat;			/* タスク状態（内部表現）*/
  #else /* UINT8_MAX */
! 	BIT_FIELD_UINT	tstat : 8;		/* タスク状態（内部表現）*/
  #endif /* UINT8_MAX */
  #if defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8)
! 	uint8_t			priority;		/* 現在の優先度（内部表現）*/
  #else /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
  	BIT_FIELD_UINT	priority : TBIT_TCB_PRIORITY;
! 									/* 現在の優先度（内部表現）*/
  #endif /* defined(UINT8_MAX) && (TBIT_TCB_PRIORITY == 8) */
! 	BIT_FIELD_BOOL	actque : 1;		/* 起動要求キューイング */
! 	BIT_FIELD_BOOL	wupque : 1;		/* 起床要求キューイング */
! 	BIT_FIELD_BOOL	enatex : 1;		/* タスク例外処理許可状態 */
! 
! 	TEXPTN			texptn;			/* 保留例外要因 */
! 	WINFO			*p_winfo;		/* 待ち情報ブロックへのポインタ */
! 	TSKCTXB			tskctxb;		/* タスクコンテキストブロック */
  } TCB;
  
  /*
!  *  実行状態のタスク
   *
!  *  実行状態のタスク（＝プロセッサがコンテキストを持っているタスク）の
!  *  TCBを指すポインタ．実行状態のタスクがない場合はNULLにする．
   *
!  *  サービスコールの処理中で，自タスク（サービスコールを呼び出したタス
!  *  ク）に関する情報を参照する場合はp_runtskを使う．p_runtskを書き換え
!  *  るのは，ディスパッチャ（と初期化処理）のみである．
   */
  extern TCB	*p_runtsk;
  
  /*
!  *  最高優先順位のタスク
   *
!  *  実行できるタスクの中で最高優先順位のタスクのTCBを指すポインタ．実
!  *  行できるタスクがない場合はNULLにする．
   *
!  *  ディスパッチ禁止状態など，ディスパッチが保留されている間はp_runtsk
!  *  と一致しているとは限らない．
   */
  extern TCB	*p_schedtsk;
  
  /*
!  *  ディスパッチ／タスク例外処理ルーチン起動要求フラグ
   *
!  *  割込みハンドラ／CPU例外ハンドラの出口処理に，ディスパッチまたは
!  *  タスク例外処理ルーチンの起動を要求することを示すフラグ．
   */
  extern bool_t	reqflg;
  
  /*
!  *  割込み優先度マスク全解除状態
   *
!  *  割込み優先度マスク全解除状態であることを示すフラグ．
   */
  extern bool_t	ipmflg;
  
  /*
!  *  ディスパッチ禁止状態
   *
!  *  ディスパッチ禁止状態であることを示すフラグ．
   */
  extern bool_t	disdsp;
  
  /*
!  *  タスクディスパッチ可能状態
   *
!  *  割込み優先度マスク全解除状態であり，ディスパッチ許可状態である（ディ
!  *  スパッチ禁止状態でない）ことを示すフラグ．
   */
  extern bool_t	dspflg;
  
  /*
!  *  レディキュー
   *
!  *  レディキューは，実行できる状態のタスクを管理するためのキューである．
!  *  実行状態のタスクも管理しているため，レディ（実行可能）キューという
!  *  名称は正確ではないが，レディキューという名称が定着しているため，こ
!  *  の名称で呼ぶことにする．
   *
!  *  レディキューは，優先度ごとのタスクキューで構成されている．タスクの
!  *  TCBは，該当する優先度のキューに登録される．
   */
  extern QUEUE	ready_queue[TNUM_TPRI];
  
  /*
!  *  レディキューサーチのためのビットマップ
   *
!  *  レディキューのサーチを効率よく行うために，優先度ごとのタスクキュー
!  *  にタスクが入っているかどうかを示すビットマップを用意している．ビッ
!  *  トマップを使うことで，メモリアクセスの回数を減らすことができるが，
!  *  ビット操作命令が充実していないプロセッサで，優先度の段階数が少ない
!  *  場合には，ビットマップ操作のオーバーヘッドのために，逆に効率が落ち
!  *  る可能性もある．
   *
!  *  優先度が16段階であることを仮定しているため，uint16_t型としている．
   */
  extern uint16_t	ready_primap;
  
  /*
!  *  タスクIDの最大値（kernel_cfg.c）
   */
  extern const ID	tmax_tskid;
  
  /*
!  *  タスク初期化ブロックのエリア（kernel_cfg.c）
   */
  extern const TINIB	tinib_table[];
  
  /*
!  *  タスク生成順序テーブル（kernel_cfg.c）
   */
  extern const ID	torder_table[];
  
  /*
!  *  TCBのエリア（kernel_cfg.c）
   */
  extern TCB	tcb_table[];
  
  /*
!  *  タスクの数
   */
  #define tnum_tsk	((uint_t)(tmax_tskid - TMIN_TSKID + 1))
  
  /*
!  *  タスクIDからTCBを取り出すためのマクロ
   */
  #define INDEX_TSK(tskid)	((uint_t)((tskid) - TMIN_TSKID))
  #define get_tcb(tskid)		(&(tcb_table[INDEX_TSK(tskid)]))
  #define get_tcb_self(tskid)	((tskid) == TSK_SELF ? p_runtsk : get_tcb(tskid))
  
  /*
!  *  TCBからタスクIDを取り出すためのマクロ
   */
  #define	TSKID(p_tcb)	((ID)(((p_tcb) - tcb_table) + TMIN_TSKID))
  
  /*
!  *  タスク管理モジュールの初期化
   */
  extern void	initialize_task(void);
  
  /*
!  *  最高優先順位タスクのサーチ
   *
!  *  レディキュー中の最高優先順位のタスクをサーチし，そのTCBへのポインタ
!  *  を返す．レディキューが空の場合には，この関数を呼び出してはならない．
   */
  extern TCB	*search_schedtsk(void);
  
  /*
!  *  実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューに挿入する．レディキューに挿入
!  *  したタスクの優先度が，最高優先順位のタスクの優先度よりも高い場合は，
!  *  最高優先順位のタスクを更新し，ディスパッチ許可状態であればtrueを返
!  *  す．そうでない場合はfalseを返す．
   */
  extern bool_t	make_runnable(TCB *p_tcb);
  
  /*
!  *  実行できる状態から他の状態への遷移
   *
!  *  p_tcbで指定されるタスクをレディキューから削除する．p_tcbで指定した
!  *  タスクが最高優先順位のタスクであった場合には，最高優先順位のタスク
!  *  を設定しなおし，ディスパッチ許可状態であればtrueを返す．そうでない
!  *  場合はfalseを返す．タスクの状態は更新しない．
   */
  extern bool_t	make_non_runnable(TCB *p_tcb);
  
  /*
!  *  休止状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態とする．また，タスクの起動
!  *  時に初期化すべき変数の初期化と，タスク起動のためのコンテキストを設
!  *  定する．
   */
  extern void	make_dormant(TCB *p_tcb);
  
  /*
!  *  休止状態から実行できる状態への遷移
   *
!  *  p_tcbで指定されるタスクの状態を休止状態から実行できる状態とする．
!  *  実行できる状態に遷移したタスクへのディスパッチが必要な場合はtrue，
!  *  そうでない場合はfalseを返す．
   */
  extern bool_t	make_active(TCB *p_tcb);
  
  /*
!  *  タスクの優先度の変更
   *
!  *  p_tcbで指定されるタスクの優先度をnewpri（内部表現）に変更する．また，
!  *  必要な場合には最高優先順位のタスクを更新し，ディスパッチ許可状態で
!  *  あればtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	change_priority(TCB *p_tcb, uint_t newpri);
  
  /*
!  *  レディキューの回転
   *
!  *  レディキュー中の，priで指定される優先度のタスクキューを回転させる．
!  *  また，必要な場合には最高優先順位のタスクを変更し，ディスパッチが保
!  *  留されていなければtrueを返す．そうでない場合はfalseを返す．
   */
  extern bool_t	rotate_ready_queue(uint_t pri);
  
  /*
!  *  タスク例外処理ルーチンの呼出し
   *
!  *  タスク例外処理ルーチンを呼び出す．呼び出す前に，実行状態のタスクの
!  *  保留例外要因をクリアし，タスク例外処理禁止状態にし，CPUロックを解
!  *  除する．
!  *
!  *  タスク例外処理ルーチンから戻ると，まずCPUロック状態に戻し，その間
!  *  に保留例外要因が0でなくなっていれば，再びタスク例外処理ルーチンを
!  *  呼び出す．保留例外要因が0の場合には，例外処理許可状態にして関数か
!  *  らリターンする．
!  *
!  *  この関数は，実行状態のタスクが，タスク例外処理許可状態（enatexが
!  *  true）で，保留例外要因が0でない（texptnが0でない）場合に呼び出すこ
!  *  とを想定している．この関数は，CPUロック状態で呼び出さなければなら
!  *  ない．
   */
  extern void	call_texrtn(void);
  
  /*
!  *  タスク例外処理ルーチンの起動
   *
!  *  実行状態のタスクがタスク例外処理ルーチンの起動条件を満たしていれば，
!  *  タスク例外処理ルーチンを呼び出す．CPU例外処理ルーチンを呼び出す時
!  *  は，一時的にCPUロックを解除する．
!  *
!  *  この関数は，ディスパッチャや割込みハンドラ／CPU例外ハンドラの出口
!  *  処理から呼び出されることを想定している．この関数は，CPUロック状態
!  *  で呼び出さなければならない．
   *
!  *  実行効率を上げるために，この関数をターゲット依存部で記述してもよい．
!  *  その場合には，OMIT_CALLTEXをマクロ定義する．
   */
  extern void	calltex(void);
  
diff -cr --new-file 1.9.1/asp/kernel/task_except.c ASPs/asp/kernel/task_except.c
*** 1.9.1/asp/kernel/task_except.c	Sun Jan  2 17:59:06 2011
--- ASPs/asp/kernel/task_except.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: task_except.c 2023 2011-01-02 08:59:06Z ertl-hiro $
   */
  
  /*
!  *		㳰ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: task_except.c 2023 2011-01-02 08:59:06Z ertl-hiro $
   */
  
  /*
!  *		タスク例外処理機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "task.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_RAS_TEX_ENTER
  #define LOG_RAS_TEX_ENTER(tskid, rasptn)
--- 49,55 ----
  #include "task.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_RAS_TEX_ENTER
  #define LOG_RAS_TEX_ENTER(tskid, rasptn)
***************
*** 100,106 ****
  #endif /* LOG_REF_TEX_LEAVE */
  
  /*
!  *  㳰׵
   */
  #ifdef TOPPERS_ras_tex
  
--- 100,106 ----
  #endif /* LOG_REF_TEX_LEAVE */
  
  /*
!  *  タスク例外処理の要求
   */
  #ifdef TOPPERS_ras_tex
  
***************
*** 137,143 ****
  #endif /* TOPPERS_ras_tex */
  
  /*
!  *  㳰׵󥿥ƥѡ
   */
  #ifdef TOPPERS_iras_tex
  
--- 137,143 ----
  #endif /* TOPPERS_ras_tex */
  
  /*
!  *  タスク例外処理の要求（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iras_tex
  
***************
*** 174,180 ****
  #endif /* TOPPERS_iras_tex */
  
  /*
!  *  㳰ζػ
   */
  #ifdef TOPPERS_dis_tex
  
--- 174,180 ----
  #endif /* TOPPERS_iras_tex */
  
  /*
!  *  タスク例外処理の禁止
   */
  #ifdef TOPPERS_dis_tex
  
***************
*** 204,210 ****
  #endif /* TOPPERS_dis_tex */
  
  /*
!  *  㳰ε
   */
  #ifdef TOPPERS_ena_tex
  
--- 204,210 ----
  #endif /* TOPPERS_dis_tex */
  
  /*
!  *  タスク例外処理の許可
   */
  #ifdef TOPPERS_ena_tex
  
***************
*** 237,243 ****
  #endif /* TOPPERS_ena_tex */
  
  /*
!  *  㳰ػ߾֤λ
   */
  #ifdef TOPPERS_sns_tex
  
--- 237,243 ----
  #endif /* TOPPERS_ena_tex */
  
  /*
!  *  タスク例外処理禁止状態の参照
   */
  #ifdef TOPPERS_sns_tex
  
***************
*** 255,261 ****
  #endif /* TOPPERS_sns_tex */
  
  /*
!  *  㳰ξֻ
   */
  #ifdef TOPPERS_ref_tex
  
--- 255,261 ----
  #endif /* TOPPERS_sns_tex */
  
  /*
!  *  タスク例外処理の状態参照
   */
  #ifdef TOPPERS_ref_tex
  
diff -cr --new-file 1.9.1/asp/kernel/task_manage.c ASPs/asp/kernel/task_manage.c
*** 1.9.1/asp/kernel/task_manage.c	Fri Dec 31 21:41:43 2010
--- ASPs/asp/kernel/task_manage.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: task_manage.c 2008 2010-12-31 12:41:42Z ertl-hiro $
   */
  
  /*
!  *		ǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: task_manage.c 2008 2010-12-31 12:41:42Z ertl-hiro $
   */
  
  /*
!  *		タスク管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 50,56 ****
  #include "wait.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
--- 50,56 ----
  #include "wait.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_ACT_TSK_ENTER
  #define LOG_ACT_TSK_ENTER(tskid)
***************
*** 117,123 ****
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  εư
   */
  #ifdef TOPPERS_act_tsk
  
--- 117,123 ----
  #endif /* LOG_GET_INF_LEAVE */
  
  /*
!  *  タスクの起動
   */
  #ifdef TOPPERS_act_tsk
  
***************
*** 156,162 ****
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  εư󥿥ƥѡ
   */
  #ifdef TOPPERS_iact_tsk
  
--- 156,162 ----
  #endif /* TOPPERS_act_tsk */
  
  /*
!  *  タスクの起動（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iact_tsk
  
***************
*** 195,201 ****
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  ư׵Υ󥻥
   */
  #ifdef TOPPERS_can_act
  
--- 195,201 ----
  #endif /* TOPPERS_iact_tsk */
  
  /*
!  *  タスク起動要求のキャンセル
   */
  #ifdef TOPPERS_can_act
  
***************
*** 223,229 ****
  #endif /* TOPPERS_can_act */
  
  /*
!  *  νλ
   */
  #ifdef TOPPERS_ext_tsk
  
--- 223,229 ----
  #endif /* TOPPERS_can_act */
  
  /*
!  *  自タスクの終了
   */
  #ifdef TOPPERS_ext_tsk
  
***************
*** 237,245 ****
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUå֤ext_tskƤФ줿ϡCPUå
! 		 *  Ƥ饿λ롥ϡӥǤCPU
! 		 *  åάФ褤
  		 */
  	}
  	else {
--- 237,245 ----
  
  	if (t_sense_lock()) {
  		/*
! 		 *  CPUロック状態でext_tskが呼ばれた場合は，CPUロックを解除し
! 		 *  てからタスクを終了する．実装上は，サービスコール内でのCPU
! 		 *  ロックを省略すればよいだけ．
  		 */
  	}
  	else {
***************
*** 247,262 ****
  	}
  	if (disdsp) {
  		/*
! 		 *  ǥѥåػ߾֤ext_tskƤФ줿ϡǥѥ
! 		 *  ľ֤ˤƤ饿λ롥
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  ͥ٥ޥIPMˤTIPM_ENAALLʳξ֤ext_tsk
! 		 *  ƤФ줿ϡIPMTIPM_ENAALLˤƤ饿λ
! 		 *  롥
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
--- 247,262 ----
  	}
  	if (disdsp) {
  		/*
! 		 *  ディスパッチ禁止状態でext_tskが呼ばれた場合は，ディスパッ
! 		 *  チ許可状態にしてからタスクを終了する．
  		 */
  		disdsp = false;
  	}
  	if (!ipmflg) {
  		/*
! 		 *  割込み優先度マスク（IPM）がTIPM_ENAALL以外の状態でext_tsk
! 		 *  が呼ばれた場合は，IPMをTIPM_ENAALLにしてからタスクを終了す
! 		 *  る．
  		 */
  		t_set_ipm(TIPM_ENAALL);
  		ipmflg = true;
***************
*** 280,286 ****
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  ζλ
   */
  #ifdef TOPPERS_ter_tsk
  
--- 280,286 ----
  #endif /* TOPPERS_ext_tsk */
  
  /*
!  *  タスクの強制終了
   */
  #ifdef TOPPERS_ter_tsk
  
***************
*** 303,311 ****
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbϼǤʤᡤʥ󥰥ץåǤϡ˼
! 			 *  Ծ֤Ǥʤmake_non_runnable(p_tcb)ǥǥѥ
! 			 *  ɬפˤʤ뤳ȤϤʤ
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
--- 303,311 ----
  	else {
  		if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  			/*
! 			 *  p_tcbは自タスクでないため，（シングルプロセッサでは）実
! 			 *  行状態でなく，make_non_runnable(p_tcb)でタスクディスパッ
! 			 *  チが必要になることはない．
  			 */
  			(void) make_non_runnable(p_tcb);
  		}
***************
*** 332,338 ****
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  Υ١ͥ٤ѹ
   */
  #ifdef TOPPERS_chg_pri
  
--- 332,338 ----
  #endif /* TOPPERS_ter_tsk */
  
  /*
!  *  タスクのベース優先度の変更
   */
  #ifdef TOPPERS_chg_pri
  
***************
*** 371,377 ****
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  ͥ٤λ
   */
  #ifdef TOPPERS_get_pri
  
--- 371,377 ----
  #endif /* TOPPERS_chg_pri */
  
  /*
!  *  タスク優先度の参照
   */
  #ifdef TOPPERS_get_pri
  
***************
*** 404,410 ****
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  γĥλ
   */
  #ifdef TOPPERS_get_inf
  
--- 404,410 ----
  #endif /* TOPPERS_get_pri */
  
  /*
!  *  自タスクの拡張情報の参照
   */
  #ifdef TOPPERS_get_inf
  
diff -cr --new-file 1.9.1/asp/kernel/task_refer.c ASPs/asp/kernel/task_refer.c
*** 1.9.1/asp/kernel/task_refer.c	Sat May 10 17:42:22 2008
--- ASPs/asp/kernel/task_refer.c	Fri Dec  9 13:54:04 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: task_refer.c 1016 2008-05-10 08:42:16Z ertl-hiro $
   */
  
  /*
!  *		ξֻȵǽ
   */
  
  #include "kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: task_refer.c 1016 2008-05-10 08:42:16Z ertl-hiro $
   */
  
  /*
!  *		タスクの状態参照機能
   */
  
  #include "kernel_impl.h"
***************
*** 55,61 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_REF_TSK_ENTER
  #define LOG_REF_TSK_ENTER(tskid, pk_rtsk)
--- 55,61 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_REF_TSK_ENTER
  #define LOG_REF_TSK_ENTER(tskid, pk_rtsk)
***************
*** 66,72 ****
  #endif /* LOG_REF_TSK_LEAVE */
  
  /*
!  *  ξֻ
   */
  #ifdef TOPPERS_ref_tsk
  
--- 66,72 ----
  #endif /* LOG_REF_TSK_LEAVE */
  
  /*
!  *  タスクの状態参照
   */
  #ifdef TOPPERS_ref_tsk
  
***************
*** 86,98 ****
  	tstat = p_tcb->tstat;
  	if (TSTAT_DORMANT(tstat)) {
  		/*
!  		 *  оݥٻ߾֤ξ
  		 */
  		pk_rtsk->tskstat = TTS_DMT;
  	}
  	else {
  		/*
!  		 *  ֤μФ
  		 */
  		if (TSTAT_SUSPENDED(tstat)) {
  			if (TSTAT_WAITING(tstat)) {
--- 86,98 ----
  	tstat = p_tcb->tstat;
  	if (TSTAT_DORMANT(tstat)) {
  		/*
!  		 *  対象タスクが休止状態の場合
  		 */
  		pk_rtsk->tskstat = TTS_DMT;
  	}
  	else {
  		/*
!  		 *  タスク状態の取出し
  		 */
  		if (TSTAT_SUSPENDED(tstat)) {
  			if (TSTAT_WAITING(tstat)) {
***************
*** 113,126 ****
  		}
  
  		/*
!  		 *  ͥ٤ȥ١ͥ٤μФ
  		 */
  		pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
  		pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->priority);
  
  		if (TSTAT_WAITING(tstat)) {
  			/*
! 	 		 *  ԤװԤоݤΥ֥ȤIDμФ
  			 */
  			switch (tstat & TS_WAIT_MASK) {
  			case TS_WAIT_SLP:
--- 113,126 ----
  		}
  
  		/*
!  		 *  現在優先度とベース優先度の取出し
  		 */
  		pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
  		pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->priority);
  
  		if (TSTAT_WAITING(tstat)) {
  			/*
! 	 		 *  待ち要因と待ち対象のオブジェクトのIDの取出し
  			 */
  			switch (tstat & TS_WAIT_MASK) {
  			case TS_WAIT_SLP:
***************
*** 172,178 ****
  			}
  
  			/*
! 	 		 *  ॢȤޤǤλ֤μФ
  			 */
  			if (p_tcb->p_winfo->p_tmevtb != NULL) {
  				pk_rtsk->lefttmo
--- 172,178 ----
  			}
  
  			/*
! 	 		 *  タイムアウトするまでの時間の取出し
  			 */
  			if (p_tcb->p_winfo->p_tmevtb != NULL) {
  				pk_rtsk->lefttmo
***************
*** 184,196 ****
  		}
  
  		/*
!  		 *  ׵ᥭ塼󥰿μФ
  		 */
  		pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
  	}
  
  	/*
! 	 *  ư׵ᥭ塼󥰿μФ
  	 */
  	pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
  	ercd = E_OK;
--- 184,196 ----
  		}
  
  		/*
!  		 *  起床要求キューイング数の取出し
  		 */
  		pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
  	}
  
  	/*
! 	 *  起動要求キューイング数の取出し
  	 */
  	pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
  	ercd = E_OK;
diff -cr --new-file 1.9.1/asp/kernel/task_sync.c ASPs/asp/kernel/task_sync.c
*** 1.9.1/asp/kernel/task_sync.c	Thu Aug  5 21:33:21 2010
--- ASPs/asp/kernel/task_sync.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: task_sync.c 1453 2009-02-18 09:09:34Z ertl-hiro $
   */
  
  /*
!  *		°Ʊǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: task_sync.c 1453 2009-02-18 09:09:34Z ertl-hiro $
   */
  
  /*
!  *		タスク付属同期機能
   */
  
  #include "kernel_impl.h"
***************
*** 50,56 ****
  #include "wait.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SLP_TSK_ENTER
  #define LOG_SLP_TSK_ENTER()
--- 50,56 ----
  #include "wait.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SLP_TSK_ENTER
  #define LOG_SLP_TSK_ENTER()
***************
*** 133,139 ****
  #endif /* LOG_DLY_TSK_LEAVE */
  
  /*
!  *  Ԥ
   */
  #ifdef TOPPERS_slp_tsk
  
--- 133,139 ----
  #endif /* LOG_DLY_TSK_LEAVE */
  
  /*
!  *  起床待ち
   */
  #ifdef TOPPERS_slp_tsk
  
***************
*** 168,174 ****
  #endif /* TOPPERS_slp_tsk */
  
  /*
!  *  ԤʥॢȤ
   */
  #ifdef TOPPERS_tslp_tsk
  
--- 168,174 ----
  #endif /* TOPPERS_slp_tsk */
  
  /*
!  *  起床待ち（タイムアウトあり）
   */
  #ifdef TOPPERS_tslp_tsk
  
***************
*** 208,214 ****
  #endif /* TOPPERS_tslp_tsk */
  
  /*
!  *  ε
   */
  #ifdef TOPPERS_wup_tsk
  
--- 208,214 ----
  #endif /* TOPPERS_tslp_tsk */
  
  /*
!  *  タスクの起床
   */
  #ifdef TOPPERS_wup_tsk
  
***************
*** 250,256 ****
  #endif /* TOPPERS_wup_tsk */
  
  /*
!  *  ε󥿥ƥѡ
   */
  #ifdef TOPPERS_iwup_tsk
  
--- 250,256 ----
  #endif /* TOPPERS_wup_tsk */
  
  /*
!  *  タスクの起床（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_iwup_tsk
  
***************
*** 292,298 ****
  #endif /* TOPPERS_iwup_tsk */
  
  /*
!  *  ׵Υ󥻥
   */
  #ifdef TOPPERS_can_wup
  
--- 292,298 ----
  #endif /* TOPPERS_iwup_tsk */
  
  /*
!  *  タスク起床要求のキャンセル
   */
  #ifdef TOPPERS_can_wup
  
***************
*** 325,331 ****
  #endif /* TOPPERS_can_wup */
  
  /*
!  *  Ԥ֤ζ
   */
  #ifdef TOPPERS_rel_wai
  
--- 325,331 ----
  #endif /* TOPPERS_can_wup */
  
  /*
!  *  待ち状態の強制解除
   */
  #ifdef TOPPERS_rel_wai
  
***************
*** 360,366 ****
  #endif /* TOPPERS_rel_wai */
  
  /*
!  *  Ԥ֤ζ󥿥ƥѡ
   */
  #ifdef TOPPERS_irel_wai
  
--- 360,366 ----
  #endif /* TOPPERS_rel_wai */
  
  /*
!  *  待ち状態の強制解除（非タスクコンテキスト用）
   */
  #ifdef TOPPERS_irel_wai
  
***************
*** 395,401 ****
  #endif /* TOPPERS_irel_wai */
  
  /*
!  *  Ԥ֤ؤΰܹ
   */
  #ifdef TOPPERS_sus_tsk
  
--- 395,401 ----
  #endif /* TOPPERS_irel_wai */
  
  /*
!  *  強制待ち状態への移行
   */
  #ifdef TOPPERS_sus_tsk
  
***************
*** 419,425 ****
  	}
  	else if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  ¹ԤǤ֤鶯Ԥ֤ؤ
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 419,425 ----
  	}
  	else if (TSTAT_RUNNABLE(p_tcb->tstat)) {
  		/*
! 		 *  実行できる状態から強制待ち状態への遷移
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 433,439 ****
  	}
  	else {
  		/*
! 		 *  Ԥ֤Ԥ֤ؤ
  		 */
  		p_tcb->tstat |= TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 433,439 ----
  	}
  	else {
  		/*
! 		 *  待ち状態から二重待ち状態への遷移
  		 */
  		p_tcb->tstat |= TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 449,455 ****
  #endif /* TOPPERS_sus_tsk */
  
  /*
!  *  Ԥ֤κƳ
   */
  #ifdef TOPPERS_rsm_tsk
  
--- 449,455 ----
  #endif /* TOPPERS_sus_tsk */
  
  /*
!  *  強制待ち状態からの再開
   */
  #ifdef TOPPERS_rsm_tsk
  
***************
*** 470,476 ****
  	}
  	else if (!TSTAT_WAITING(p_tcb->tstat)) {
  		/*
! 		 *  Ԥ֤¹ԤǤ֤ؤ
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
--- 470,476 ----
  	}
  	else if (!TSTAT_WAITING(p_tcb->tstat)) {
  		/*
! 		 *  強制待ち状態から実行できる状態への遷移
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
***************
*** 481,487 ****
  	}
  	else {
  		/*
! 		 *  Ԥ֤Ԥ֤ؤ
  		 */
  		p_tcb->tstat &= ~TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 481,487 ----
  	}
  	else {
  		/*
! 		 *  二重待ち状態から待ち状態への遷移
  		 */
  		p_tcb->tstat &= ~TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 497,503 ****
  #endif /* TOPPERS_rsm_tsk */
  
  /*
!  *  ٱ
   */
  #ifdef TOPPERS_dly_tsk
  
--- 497,503 ----
  #endif /* TOPPERS_rsm_tsk */
  
  /*
!  *  自タスクの遅延
   */
  #ifdef TOPPERS_dly_tsk
  
diff -cr --new-file 1.9.1/asp/kernel/time_event.c ASPs/asp/kernel/time_event.c
*** 1.9.1/asp/kernel/time_event.c	Sat Oct 19 15:53:31 2013
--- ASPs/asp/kernel/time_event.c	Fri Dec  9 13:54:04 2022
***************
*** 8,65 ****
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: time_event.c 2559 2013-10-19 06:53:19Z ertl-hiro $
   */
  
  /*
!  *		।٥ȴ⥸塼
   */
  
  #include "kernel_impl.h"
  #include "time_event.h"
  
  /*
!  *  ।٥ȥҡޥ
   */
! #define	PARENT(index)		((index) >> 1)		/* ƥΡɤ */
! #define	LCHILD(index)		((index) << 1)		/* λҥΡɤ */
  #define	TMEVT_NODE(index)	(tmevt_heap[(index) - 1])
  
  /*
!  *  ٥ȯӥޥ
   *
!  *  ٥ȯϡmin_timeͤӤ롥ʤ
!  *  min_timeǾ͡ʺǤᤤˡmit_time-1͡ʺǤ󤤻
!  *  ȤߤʤӤ롥
   */
  #define	EVTTIM_LT(t1, t2) (((t1) - min_time) < ((t2) - min_time))
  #define	EVTTIM_LE(t1, t2) (((t1) - min_time) <= ((t2) - min_time))
--- 8,65 ----
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: time_event.c 2559 2013-10-19 06:53:19Z ertl-hiro $
   */
  
  /*
!  *		タイムイベント管理モジュール
   */
  
  #include "kernel_impl.h"
  #include "time_event.h"
  
  /*
!  *  タイムイベントヒープ操作マクロ
   */
! #define	PARENT(index)		((index) >> 1)		/* 親ノードを求める */
! #define	LCHILD(index)		((index) << 1)		/* 左の子ノードを求める */
  #define	TMEVT_NODE(index)	(tmevt_heap[(index) - 1])
  
  /*
!  *  イベント発生時刻比較マクロ
   *
!  *  イベント発生時刻は，min_timeからの相対値で比較する．すなわち，
!  *  min_timeを最小値（最も近い時刻），mit_time-1が最大値（最も遠い時刻）
!  *  とみなして比較する．
   */
  #define	EVTTIM_LT(t1, t2) (((t1) - min_time) < ((t2) - min_time))
  #define	EVTTIM_LE(t1, t2) (((t1) - min_time) <= ((t2) - min_time))
***************
*** 67,102 ****
  #ifdef TOPPERS_tmeini
  
  /*
!  *  ߤΥƥñ: 1ߥá
   *
!  *  ̩ˤϡΥƥåΥƥ
   */
  EVTTIM	current_time;
  
  /*
!  *  ।٥ȥҡͭʺǾΥƥñ: 1ߥá
   */
  EVTTIM	min_time;
  
  /*
!  *  ΥƥåΥƥñ: 1ߥá
   */
  EVTTIM	next_time;
  
  /*
!  *  ƥѻѿñ: 1/TIC_DENOߥá
   */
  #if TIC_DENO != 1U
  uint_t	next_subtime;
  #endif /* TIC_DENO != 1U */
  
  /*
!  *  ।٥ȥҡפκǸλΰΥǥå
   */
  uint_t	last_index;
  
  /*
!  *  ޥ⥸塼ν
   */
  void
  initialize_tmevt(void)
--- 67,102 ----
  #ifdef TOPPERS_tmeini
  
  /*
!  *  現在のシステム時刻（単位: 1ミリ秒）
   *
!  *  厳密には，前のタイムティックのシステム時刻．
   */
  EVTTIM	current_time;
  
  /*
!  *  タイムイベントヒープ中で有効な最小のシステム時刻（単位: 1ミリ秒）
   */
  EVTTIM	min_time;
  
  /*
!  *  次のタイムティックのシステム時刻（単位: 1ミリ秒）
   */
  EVTTIM	next_time;
  
  /*
!  *  システム時刻積算用変数（単位: 1/TIC_DENOミリ秒）
   */
  #if TIC_DENO != 1U
  uint_t	next_subtime;
  #endif /* TIC_DENO != 1U */
  
  /*
!  *  タイムイベントヒープの最後の使用領域のインデックス
   */
  uint_t	last_index;
  
  /*
!  *  タイマモジュールの初期化
   */
  void
  initialize_tmevt(void)
***************
*** 113,123 ****
  #endif /* TOPPERS_tmeini */
  
  /*
!  *  ।٥Ȥ֤õ
   *
!  *  timeȯ륿।٥ȤΡɤ뤿ˡ
!  *  ҡפξ˸äƶΡɤư롥ưζΡɤΰ֤
!  *  indexϤȡưζΡɤΰ֡ʤʤ֡ˤ֤
   */
  #ifdef TOPPERS_tmeup
  
--- 113,123 ----
  #endif /* TOPPERS_tmeini */
  
  /*
!  *  タイムイベントの挿入位置を上向きに探索
   *
!  *  時刻timeに発生するタイムイベントを挿入するノードを空けるために，
!  *  ヒープの上に向かって空ノードを移動させる．移動前の空ノードの位置を
!  *  indexに渡すと，移動後の空ノードの位置（すなわち挿入位置）を返す．
   */
  #ifdef TOPPERS_tmeup
  
***************
*** 128,135 ****
  
  	while (index > 1) {
  		/*
! 		 *  ƥΡɤΥ٥ȯᤤʤޤƱˤʤС
! 		 *  index֤ʤΤǥ롼פȴ롥
  		 */
  		parent = PARENT(index);
  		if (EVTTIM_LE(TMEVT_NODE(parent).time, time)) {
--- 128,135 ----
  
  	while (index > 1) {
  		/*
! 		 *  親ノードのイベント発生時刻の方が早い（または同じ）ならば，
! 		 *  indexが挿入位置なのでループを抜ける．
  		 */
  		parent = PARENT(index);
  		if (EVTTIM_LE(TMEVT_NODE(parent).time, time)) {
***************
*** 137,149 ****
  		}
  
  		/*
! 		 *  ƥΡɤindexΰ֤˰ư롥
  		 */
  		TMEVT_NODE(index) = TMEVT_NODE(parent);
  		TMEVT_NODE(index).p_tmevtb->index = index;
  
  		/*
! 		 *  indexƥΡɤΰ֤˹
  		 */
  		index = parent;
  	}
--- 137,149 ----
  		}
  
  		/*
! 		 *  親ノードをindexの位置に移動させる．
  		 */
  		TMEVT_NODE(index) = TMEVT_NODE(parent);
  		TMEVT_NODE(index).p_tmevtb->index = index;
  
  		/*
! 		 *  indexを親ノードの位置に更新．
  		 */
  		index = parent;
  	}
***************
*** 153,163 ****
  #endif /* TOPPERS_tmeup */
  
  /*
!  *  ।٥Ȥ֤򲼸õ
   *
!  *  timeȯ륿।٥ȤΡɤ뤿ˡ
!  *  ҡפβ˸äƶΡɤư롥ưζΡɤΰ֤ 
!  *  indexϤȡưζΡɤΰ֡ʤʤ֡ˤ֤
   */
  #ifdef TOPPERS_tmedown
  
--- 153,163 ----
  #endif /* TOPPERS_tmeup */
  
  /*
!  *  タイムイベントの挿入位置を下向きに探索
   *
!  *  時刻timeに発生するタイムイベントを挿入するノードを空けるために，
!  *  ヒープの下に向かって空ノードを移動させる．移動前の空ノードの位置を 
!  *  indexに渡すと，移動後の空ノードの位置（すなわち挿入位置）を返す．
   */
  #ifdef TOPPERS_tmedown
  
***************
*** 168,176 ****
  
  	while ((child = LCHILD(index)) <= last_index) {
  		/*
! 		 *  λҥΡɤΥ٥ȯӤᤤλҥΡ
! 		 *  ΰ֤childꤹ롥ʲλҥΡɤϡФ줿
! 		 *  λҥΡɤΤȡ
  		 */
  		if (child + 1 <= last_index
  						&& EVTTIM_LT(TMEVT_NODE(child + 1).time,
--- 168,176 ----
  
  	while ((child = LCHILD(index)) <= last_index) {
  		/*
! 		 *  左右の子ノードのイベント発生時刻を比較し，早い方の子ノード
! 		 *  の位置をchildに設定する．以下の子ノードは，ここで選ばれた方
! 		 *  の子ノードのこと．
  		 */
  		if (child + 1 <= last_index
  						&& EVTTIM_LT(TMEVT_NODE(child + 1).time,
***************
*** 179,199 ****
  		}
  
  		/*
! 		 *  ҥΡɤΥ٥ȯ٤ʤޤƱˤʤС
! 		 *  index֤ʤΤǥ롼פȴ롥
  		 */
  		if (EVTTIM_LE(time, TMEVT_NODE(child).time)) {
  			break;
  		}
  
  		/*
! 		 *  ҥΡɤindexΰ֤˰ư롥
  		 */
  		TMEVT_NODE(index) = TMEVT_NODE(child);
  		TMEVT_NODE(index).p_tmevtb->index = index;
  
  		/*
! 		 *  indexҥΡɤΰ֤˹
  		 */
  		index = child;
  	}
--- 179,199 ----
  		}
  
  		/*
! 		 *  子ノードのイベント発生時刻の方が遅い（または同じ）ならば，
! 		 *  indexが挿入位置なのでループを抜ける．
  		 */
  		if (EVTTIM_LE(time, TMEVT_NODE(child).time)) {
  			break;
  		}
  
  		/*
! 		 *  子ノードをindexの位置に移動させる．
  		 */
  		TMEVT_NODE(index) = TMEVT_NODE(child);
  		TMEVT_NODE(index).p_tmevtb->index = index;
  
  		/*
! 		 *  indexを子ノードの位置に更新．
  		 */
  		index = child;
  	}
***************
*** 203,212 ****
  #endif /* TOPPERS_tmedown */
  
  /*
!  *  ।٥ȥҡפؤϿ
   *
!  *  p_tmevtbǻꤷ।٥ȥ֥åtimeǻꤷ֤
!  *  ˥٥Ȥȯ褦ˡ।٥ȥҡפϿ롥
   */
  #ifdef TOPPERS_tmeins
  
--- 203,212 ----
  #endif /* TOPPERS_tmedown */
  
  /*
!  *  タイムイベントヒープへの登録
   *
!  *  p_tmevtbで指定したタイムイベントブロックを，timeで指定した時間が経
!  *  過後にイベントが発生するように，タイムイベントヒープに登録する．
   */
  #ifdef TOPPERS_tmeins
  
***************
*** 216,227 ****
  	uint_t	index;
  
  	/*
! 	 *  last_index򥤥󥯥Ȥ֤õ
  	 */
  	index = tmevt_up(++last_index, time);
  
  	/*
! 	 *  ।٥Ȥindexΰ֤롥
  	 */ 
  	TMEVT_NODE(index).time = time;
  	TMEVT_NODE(index).p_tmevtb = p_tmevtb;
--- 216,227 ----
  	uint_t	index;
  
  	/*
! 	 *  last_indexをインクリメントし，そこから上に挿入位置を探す．
  	 */
  	index = tmevt_up(++last_index, time);
  
  	/*
! 	 *  タイムイベントをindexの位置に挿入する．
  	 */ 
  	TMEVT_NODE(index).time = time;
  	TMEVT_NODE(index).p_tmevtb = p_tmevtb;
***************
*** 231,237 ****
  #endif /* TOPPERS_tmeins */
  
  /*
!  *  ।٥ȥҡפκ
   */
  #ifdef TOPPERS_tmedel
  
--- 231,237 ----
  #endif /* TOPPERS_tmeins */
  
  /*
!  *  タイムイベントヒープからの削除
   */
  #ifdef TOPPERS_tmedel
  
***************
*** 243,286 ****
  	EVTTIM	event_time = TMEVT_NODE(last_index).time;
  
  	/*
! 	 *  ˤ꥿।٥ȥҡפˤʤϲ⤷ʤ
  	 */
  	if (--last_index == 0) {
  		return;
  	}
  
  	/*
! 	 *  Ρɤΰ֤˺ǸΥΡɡlast_index+1ΰ֤ΥΡɡ
! 	 *  Ŭڤʰ֤ذư롥ºݤˤϡǸΥΡ
! 	 *  ºݤΤǤϤʤΡɤΰ֤Ρɤˤ
! 	 *  ΤǡǸΥΡɤ٤֤ظƶΡɤư
! 	 *  롥
! 	 *  ǸΥΡɤΥ٥ȯ郎ΡɤοƥΡɤΥ
! 	 *  ٥ȯξˤϡ˸ä֤õ
! 	 *  Ǥʤˤϡ˸äõ
  	 */
  	if (index > 1 && EVTTIM_LT(event_time,
  								TMEVT_NODE(parent = PARENT(index)).time)) {
  		/*
! 		 *  ƥΡɤindexΰ֤˰ư롥
  		 */
  		TMEVT_NODE(index) = TMEVT_NODE(parent);
  		TMEVT_NODE(index).p_tmevtb->index = index;
  
  		/*
! 		 *  ΡɤοƥΡɤ˸ä֤õ
  		 */
  		index = tmevt_up(parent, event_time);
  	}
  	else {
  		/*
! 		 *  Ρɤ鲼˸ä֤õ
  		 */
  		index = tmevt_down(index, event_time);
  	}
  
  	/*
! 	 *  ǸΥΡɤindexΰ֤롥
  	 */ 
  	TMEVT_NODE(index) = TMEVT_NODE(last_index + 1);
  	TMEVT_NODE(index).p_tmevtb->index = index;
--- 243,286 ----
  	EVTTIM	event_time = TMEVT_NODE(last_index).time;
  
  	/*
! 	 *  削除によりタイムイベントヒープが空になる場合は何もしない．
  	 */
  	if (--last_index == 0) {
  		return;
  	}
  
  	/*
! 	 *  削除したノードの位置に最後のノード（last_index+1の位置のノード）
! 	 *  を挿入し，それを適切な位置へ移動させる．実際には，最後のノード
! 	 *  を実際に挿入するのではなく，削除したノードの位置が空ノードにな
! 	 *  るので，最後のノードを挿入すべき位置へ向けて空ノードを移動させ
! 	 *  る．
! 	 *  最後のノードのイベント発生時刻が，削除したノードの親ノードのイ
! 	 *  ベント発生時刻より前の場合には，上に向かって挿入位置を探す．そ
! 	 *  うでない場合には，下に向かって探す．
  	 */
  	if (index > 1 && EVTTIM_LT(event_time,
  								TMEVT_NODE(parent = PARENT(index)).time)) {
  		/*
! 		 *  親ノードをindexの位置に移動させる．
  		 */
  		TMEVT_NODE(index) = TMEVT_NODE(parent);
  		TMEVT_NODE(index).p_tmevtb->index = index;
  
  		/*
! 		 *  削除したノードの親ノードから上に向かって挿入位置を探す．
  		 */
  		index = tmevt_up(parent, event_time);
  	}
  	else {
  		/*
! 		 *  削除したノードから下に向かって挿入位置を探す．
  		 */
  		index = tmevt_down(index, event_time);
  	}
  
  	/*
! 	 *  最後のノードをindexの位置に挿入する．
  	 */ 
  	TMEVT_NODE(index) = TMEVT_NODE(last_index + 1);
  	TMEVT_NODE(index).p_tmevtb->index = index;
***************
*** 289,295 ****
  #endif /* TOPPERS_tmedel */
  
  /*
!  *  ।٥ȥҡפƬΥΡɤκ
   */
  Inline void
  tmevtb_delete_top(void)
--- 289,295 ----
  #endif /* TOPPERS_tmedel */
  
  /*
!  *  タイムイベントヒープの先頭のノードの削除
   */
  Inline void
  tmevtb_delete_top(void)
***************
*** 298,326 ****
  	EVTTIM	event_time = TMEVT_NODE(last_index).time;
  
  	/*
! 	 *  ˤ꥿।٥ȥҡפˤʤϲ⤷ʤ
  	 */
  	if (--last_index == 0) {
  		return;
  	}
  
  	/*
! 	 *  롼ȥΡɤ˺ǸΥΡɡlast_index + 1 ΰ֤ΥΡɡˤ
! 	 *  Ŭڤʰ֤ذư롥ºݤˤϡǸΥΡɤ
! 	 *  ºݤΤǤϤʤ롼ȥΡɤΡɤˤʤΤǡ
! 	 *  ΥΡɤ٤֤ظƶΡɤư롥
  	 */
  	index = tmevt_down(1, event_time);
  
  	/*
! 	 *  ǸΥΡɤindexΰ֤롥
  	 */ 
  	TMEVT_NODE(index) = TMEVT_NODE(last_index + 1);
  	TMEVT_NODE(index).p_tmevtb->index = index;
  }
  
  /*
!  *  ।٥ȤޤǤλĤ֤η׻
   */
  #ifdef TOPPERS_tmeltim
  
--- 298,326 ----
  	EVTTIM	event_time = TMEVT_NODE(last_index).time;
  
  	/*
! 	 *  削除によりタイムイベントヒープが空になる場合は何もしない．
  	 */
  	if (--last_index == 0) {
  		return;
  	}
  
  	/*
! 	 *  ルートノードに最後のノード（last_index + 1 の位置のノード）を
! 	 *  挿入し，それを適切な位置へ移動させる．実際には，最後のノードを
! 	 *  実際に挿入するのではなく，ルートノードが空ノードになるので，最
! 	 *  後のノードを挿入すべき位置へ向けて空ノードを移動させる．
  	 */
  	index = tmevt_down(1, event_time);
  
  	/*
! 	 *  最後のノードをindexの位置に挿入する．
  	 */ 
  	TMEVT_NODE(index) = TMEVT_NODE(last_index + 1);
  	TMEVT_NODE(index).p_tmevtb->index = index;
  }
  
  /*
!  *  タイムイベントまでの残り時間の計算
   */
  #ifdef TOPPERS_tmeltim
  
***************
*** 332,338 ****
  	time = TMEVT_NODE(p_tmevtb->index).time;
  	if (EVTTIM_LE(time, next_time)) {
  		/*
! 		 *  Υƥåǽˤ0֤
  		 */
  		return(0U);
  	}
--- 332,338 ----
  	time = TMEVT_NODE(p_tmevtb->index).time;
  	if (EVTTIM_LE(time, next_time)) {
  		/*
! 		 *  次のタイムティックで処理される場合には0を返す．
  		 */
  		return(0U);
  	}
***************
*** 344,350 ****
  #endif /* TOPPERS_tmeltim */
  
  /*
!  *  ƥåζ
   */
  #ifdef TOPPERS_sigtim
  
--- 344,350 ----
  #endif /* TOPPERS_tmeltim */
  
  /*
!  *  タイムティックの供給
   */
  #ifdef TOPPERS_sigtim
  
***************
*** 359,370 ****
  	i_lock_cpu();
  
  	/*
! 	 *  current_time򹹿롥
  	 */
  	current_time = next_time;
  
  	/*
! 	 *  next_timenext_subtime򹹿롥
  	 */
  #if TIC_DENO == 1U
  	next_time = current_time + TIC_NUME;
--- 359,370 ----
  	i_lock_cpu();
  
  	/*
! 	 *  current_timeを更新する．
  	 */
  	current_time = next_time;
  
  	/*
! 	 *  next_time，next_subtimeを更新する．
  	 */
  #if TIC_DENO == 1U
  	next_time = current_time + TIC_NUME;
***************
*** 378,386 ****
  #endif /* TIC_DENO == 1U */
  
  	/*
! 	 *  current_timeꥤ٥ȯᤤʤޤƱ˥।
! 	 *  Ȥ򡤥।٥ȥҡפХåؿƤ
! 	 *  Ф
  	 */
  	while (last_index > 0 && EVTTIM_LE(TMEVT_NODE(1).time, current_time)) {
  		p_tmevtb = TMEVT_NODE(1).p_tmevtb;
--- 378,386 ----
  #endif /* TIC_DENO == 1U */
  
  	/*
! 	 *  current_timeよりイベント発生時刻の早い（または同じ）タイムイベ
! 	 *  ントを，タイムイベントヒープから削除し，コールバック関数を呼び
! 	 *  出す．
  	 */
  	while (last_index > 0 && EVTTIM_LE(TMEVT_NODE(1).time, current_time)) {
  		p_tmevtb = TMEVT_NODE(1).p_tmevtb;
***************
*** 389,395 ****
  	}
  
  	/*
! 	 *  min_time򹹿롥
  	 */
  	min_time = current_time;
  
--- 389,395 ----
  	}
  
  	/*
! 	 *  min_timeを更新する．
  	 */
  	min_time = current_time;
  
diff -cr --new-file 1.9.1/asp/kernel/time_event.h ASPs/asp/kernel/time_event.h
*** 1.9.1/asp/kernel/time_event.h	Fri Mar 19 21:46:08 2010
--- ASPs/asp/kernel/time_event.h	Fri Dec  9 13:54:04 2022
***************
*** 8,120 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: time_event.h 1774 2010-03-19 12:45:46Z ertl-hiro $
   */
  
  /*
!  *		।٥ȴ⥸塼
   */
  
  #ifndef TOPPERS_TIME_EVENT_H
  #define TOPPERS_TIME_EVENT_H
  
  /*
!  *  ٥ȯΥǡ
   *
!  *  EVTTIMϡRELTIMȤƻǤϰϤ⹭ϰϤɽǤɬ
!  *  롥ITRON4.0ͤΥɥץեǤϡRELTIM16ӥ
!  *  ȰʾǤʤФʤʤᡤEVTTIM17ӥåȰʾǤ뤳Ȥɬ
!  *  Ǥ롥Τᡤ16ӥåȤˤʤ礬uint_tǤϤʤulong_t
!  *  Ƥ롥
   */
  typedef ulong_t	EVTTIM;
  
  /* 
!  *  ।٥ȥ֥åΥǡ
   */
! typedef void	(*CBACK)(void *);	/* Хåؿη */
  
  typedef struct time_event_block {
! 	uint_t	index;			/* ।٥ȥҡǤΰ */
! 	CBACK	callback;		/* Хåؿ */
! 	void	*arg;			/* ХåؿϤ */
  } TMEVTB;
  
  /*
!  *  ।٥ȥҡΥΡɤΥǡ
   */
  typedef struct time_event_node {
! 	EVTTIM	time;			/* ٥ȯ */
! 	TMEVTB	*p_tmevtb;		/* б륿।٥ȥ֥å */
  } TMEVTN;
  
  /*
!  *  ।٥ȥҡסkernel_cfg.c
   */
  extern TMEVTN	tmevt_heap[];
  
  /*
!  *  ߤΥƥñ: 1ߥá
   *
!  *  ƥ൯ư0˽졤ʹߡƥå뤵٤
!  *  ñĴä롥
   */
  extern EVTTIM	current_time;
  
  /*
!  *  ।٥ȥҡͭʺǾΥƥñ: 1ߥá
   */
  extern EVTTIM	min_time;
  
  /*
!  *  ΥƥåΥƥñ: 1ߥá
   */
  extern EVTTIM	next_time;
  
  /*
!  *  ƥѻѿñ: 1/TIC_DENOߥá
   *
!  *  ΥƥåΥƥβ̷򼨤ʾ̷next_timeˡ
!  *  TIC_DENO1λϡ̷Ͼ0Ǥ뤿ᡤѿɬפʤ
   */
  #if TIC_DENO != 1U
  extern uint_t	next_subtime;
  #endif /* TIC_DENO != 1U */
  
  /*
!  *  л֤δñ: 1ߥá
   *
!  *  ΥƥåΥƥڤ夲TIC_DENO1λ
!  *  ϡnext_time˰פ롥
   */
  #if TIC_DENO == 1U
  #define	base_time	(next_time)
--- 8,120 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: time_event.h 1774 2010-03-19 12:45:46Z ertl-hiro $
   */
  
  /*
!  *		タイムイベント管理モジュール
   */
  
  #ifndef TOPPERS_TIME_EVENT_H
  #define TOPPERS_TIME_EVENT_H
  
  /*
!  *  イベント発生時刻のデータ型の定義
   *
!  *  EVTTIMは，RELTIMとして指定できる範囲よりも広い範囲を表現できる必要
!  *  がある．μITRON4.0仕様のスタンダードプロファイルでは，RELTIMが16ビッ
!  *  ト以上でなければならないため，EVTTIMは17ビット以上であることが必要
!  *  である．そのため，16ビットになる場合があるuint_tではなく，ulong_tに
!  *  定義している．
   */
  typedef ulong_t	EVTTIM;
  
  /* 
!  *  タイムイベントブロックのデータ型の定義
   */
! typedef void	(*CBACK)(void *);	/* コールバック関数の型 */
  
  typedef struct time_event_block {
! 	uint_t	index;			/* タイムイベントヒープ中での位置 */
! 	CBACK	callback;		/* コールバック関数 */
! 	void	*arg;			/* コールバック関数へ渡す引数 */
  } TMEVTB;
  
  /*
!  *  タイムイベントヒープ中のノードのデータ型の定義
   */
  typedef struct time_event_node {
! 	EVTTIM	time;			/* イベント発生時刻 */
! 	TMEVTB	*p_tmevtb;		/* 対応するタイムイベントブロック */
  } TMEVTN;
  
  /*
!  *  タイムイベントヒープ（kernel_cfg.c）
   */
  extern TMEVTN	tmevt_heap[];
  
  /*
!  *  現在のシステム時刻（単位: 1ミリ秒）
   *
!  *  システム起動時に0に初期化され，以降，タイムティックが供給される度に
!  *  単調に増加する．
   */
  extern EVTTIM	current_time;
  
  /*
!  *  タイムイベントヒープ中で有効な最小のシステム時刻（単位: 1ミリ秒）
   */
  extern EVTTIM	min_time;
  
  /*
!  *  次のタイムティックのシステム時刻（単位: 1ミリ秒）
   */
  extern EVTTIM	next_time;
  
  /*
!  *  システム時刻積算用変数（単位: 1/TIC_DENOミリ秒）
   *
!  *  次のタイムティックのシステム時刻の下位桁を示す（上位桁はnext_time）．
!  *  TIC_DENOが1の時は，下位桁は常に0であるため，この変数は必要ない．
   */
  #if TIC_DENO != 1U
  extern uint_t	next_subtime;
  #endif /* TIC_DENO != 1U */
  
  /*
!  *  相対時間の基準時刻（単位: 1ミリ秒）
   *
!  *  次のタイムティックのシステム時刻を切り上げた時刻．TIC_DENOが1の時
!  *  は，next_timeに一致する．
   */
  #if TIC_DENO == 1U
  #define	base_time	(next_time)
***************
*** 123,157 ****
  #endif /* TIC_DENO == 1U */
  
  /*
!  *  ।٥ȥҡפκǸλΰΥǥå
   *
!  *  ।٥ȥҡפϿƤ륿।٥Ȥο˰פ롥
   */
  extern uint_t	last_index;
  
  /*
!  *  ।٥ȴ⥸塼ν
   */
  extern void	initialize_tmevt(void);
  
  /*
!  *  ।٥Ȥ֤õ
   */
  extern uint_t	tmevt_up(uint_t index, EVTTIM time);
  extern uint_t	tmevt_down(uint_t index, EVTTIM time);
  
  /*
!  *  ।٥ȥҡפؤϿȺ
   */
  extern void	tmevtb_insert(TMEVTB *p_tmevtb, EVTTIM time);
  extern void	tmevtb_delete(TMEVTB *p_tmevtb);
  
  /*
!  *  ।٥ȥ֥åϿлֻ
   *
!  *  timeǻꤷл֤вᤷˡargȤcallback
!  *  ӽФ褦ˡp_tmevtbǻꤷ।٥ȥ֥åϿ
!  *  롥
   *  
   */
  Inline void
--- 123,157 ----
  #endif /* TIC_DENO == 1U */
  
  /*
!  *  タイムイベントヒープの最後の使用領域のインデックス
   *
!  *  タイムイベントヒープに登録されているタイムイベントの数に一致する．
   */
  extern uint_t	last_index;
  
  /*
!  *  タイムイベント管理モジュールの初期化
   */
  extern void	initialize_tmevt(void);
  
  /*
!  *  タイムイベントの挿入位置の探索
   */
  extern uint_t	tmevt_up(uint_t index, EVTTIM time);
  extern uint_t	tmevt_down(uint_t index, EVTTIM time);
  
  /*
!  *  タイムイベントヒープへの登録と削除
   */
  extern void	tmevtb_insert(TMEVTB *p_tmevtb, EVTTIM time);
  extern void	tmevtb_delete(TMEVTB *p_tmevtb);
  
  /*
!  *  タイムイベントブロックの登録（相対時間指定）
   *
!  *  timeで指定した相対時間が経過した後に，argを引数としてcallbackが呼
!  *  び出されるように，p_tmevtbで指定したタイムイベントブロックを登録す
!  *  る．
   *  
   */
  Inline void
***************
*** 165,174 ****
  }
  
  /*
!  *  ।٥ȥ֥åϿʥ٥ȯ
   *
!  *  timeǻꤷ٥ȯˡargȤcallbackƤӽ
!  *  褦ˡp_tmevtbǻꤷ।٥ȥ֥åϿ롥
   */
  Inline void
  tmevtb_enqueue_evttim(TMEVTB *p_tmevtb, EVTTIM time, CBACK callback, void *arg)
--- 165,174 ----
  }
  
  /*
!  *  タイムイベントブロックの登録（イベント発生時刻指定）
   *
!  *  timeで指定したイベント発生時刻に，argを引数としてcallbackが呼び出
!  *  されるように，p_tmevtbで指定したタイムイベントブロックを登録する．
   */
  Inline void
  tmevtb_enqueue_evttim(TMEVTB *p_tmevtb, EVTTIM time, CBACK callback, void *arg)
***************
*** 179,185 ****
  }
  
  /*
!  *  ।٥ȥ֥åϿ
   */
  Inline void
  tmevtb_dequeue(TMEVTB *p_tmevtb)
--- 179,185 ----
  }
  
  /*
!  *  タイムイベントブロックの登録解除
   */
  Inline void
  tmevtb_dequeue(TMEVTB *p_tmevtb)
***************
*** 188,199 ****
  }
  
  /*
!  *  ।٥ȤޤǤλĤ֤η׻
   */
  extern RELTIM	tmevt_lefttim(TMEVTB *p_tmevtb);
  
  /*
!  *  ƥåζ
   */
  extern void	signal_time(void);
  
--- 188,199 ----
  }
  
  /*
!  *  タイムイベントまでの残り時間の計算
   */
  extern RELTIM	tmevt_lefttim(TMEVTB *p_tmevtb);
  
  /*
!  *  タイムティックの供給
   */
  extern void	signal_time(void);
  
diff -cr --new-file 1.9.1/asp/kernel/time_manage.c ASPs/asp/kernel/time_manage.c
*** 1.9.1/asp/kernel/time_manage.c	Fri Feb 12 03:25:11 2010
--- ASPs/asp/kernel/time_manage.c	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: time_manage.c 1747 2010-02-11 18:24:19Z ertl-hiro $
   */
  
  /*
!  *		ƥǽ
   */
  
  #include "kernel_impl.h"
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: time_manage.c 1747 2010-02-11 18:24:19Z ertl-hiro $
   */
  
  /*
!  *		システム時刻管理機能
   */
  
  #include "kernel_impl.h"
***************
*** 49,55 ****
  #include "time_event.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_GET_TIM_ENTER
  #define LOG_GET_TIM_ENTER(p_systim)
--- 49,55 ----
  #include "time_event.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_GET_TIM_ENTER
  #define LOG_GET_TIM_ENTER(p_systim)
***************
*** 68,74 ****
  #endif /* LOG_GET_UTM_LEAVE */
  
  /*
!  *  ƥλ
   */
  #ifdef TOPPERS_get_tim
  
--- 68,74 ----
  #endif /* LOG_GET_UTM_LEAVE */
  
  /*
!  *  システム時刻の参照
   */
  #ifdef TOPPERS_get_tim
  
***************
*** 93,99 ****
  #endif /* TOPPERS_get_tim */
  
  /*
!  *  ǽɾѥƥλ
   */
  #ifdef TOPPERS_get_utm
  #ifdef TOPPERS_SUPPORT_GET_UTM
--- 93,99 ----
  #endif /* TOPPERS_get_tim */
  
  /*
!  *  性能評価用システム時刻の参照
   */
  #ifdef TOPPERS_get_utm
  #ifdef TOPPERS_SUPPORT_GET_UTM
diff -cr --new-file 1.9.1/asp/kernel/wait.c ASPs/asp/kernel/wait.c
*** 1.9.1/asp/kernel/wait.c	Thu Jan  2 10:54:04 2014
--- ASPs/asp/kernel/wait.c	Fri Dec  9 13:54:04 2022
***************
*** 8,54 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: wait.c 2587 2014-01-02 01:54:03Z ertl-hiro $
   */
  
  /*
!  *		Ԥִ⥸塼
   */
  
  #include "kernel_impl.h"
  #include "wait.h"
  
  /*
!  *  Ԥ֤ؤܡʥॢȻ
   */
  #ifdef TOPPERS_waimake
  
--- 8,54 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: wait.c 2587 2014-01-02 01:54:03Z ertl-hiro $
   */
  
  /*
!  *		待ち状態管理モジュール
   */
  
  #include "kernel_impl.h"
  #include "wait.h"
  
  /*
!  *  待ち状態への遷移（タイムアウト指定）
   */
  #ifdef TOPPERS_waimake
  
***************
*** 71,77 ****
  #endif /* TOPPERS_waimake */
  
  /*
!  *  Ԥ
   */
  #ifdef TOPPERS_waicmp
  
--- 71,77 ----
  #endif /* TOPPERS_waimake */
  
  /*
!  *  待ち解除
   */
  #ifdef TOPPERS_waicmp
  
***************
*** 86,92 ****
  #endif /* TOPPERS_waicmp */
  
  /*
!  *  ॢȤȼԤ
   */
  #ifdef TOPPERS_waitmo
  
--- 86,92 ----
  #endif /* TOPPERS_waicmp */
  
  /*
!  *  タイムアウトに伴う待ち解除
   */
  #ifdef TOPPERS_waitmo
  
***************
*** 100,106 ****
  	}
  
  	/*
! 	 *  ͥ٤ι⤤ߤդ롥
  	 */
  	i_unlock_cpu();
  	i_lock_cpu();
--- 100,106 ----
  	}
  
  	/*
! 	 *  ここで優先度の高い割込みを受け付ける．
  	 */
  	i_unlock_cpu();
  	i_lock_cpu();
***************
*** 118,124 ****
  	}
  
  	/*
! 	 *  ͥ٤ι⤤ߤդ롥
  	 */
  	i_unlock_cpu();
  	i_lock_cpu();
--- 118,124 ----
  	}
  
  	/*
! 	 *  ここで優先度の高い割込みを受け付ける．
  	 */
  	i_unlock_cpu();
  	i_lock_cpu();
***************
*** 127,133 ****
  #endif /* TOPPERS_waitmook */
  
  /*
!  *  Ԥ֤ζ
   */
  #ifdef TOPPERS_wairel
  
--- 127,133 ----
  #endif /* TOPPERS_waitmook */
  
  /*
!  *  待ち状態の強制解除
   */
  #ifdef TOPPERS_wairel
  
***************
*** 143,152 ****
  #endif /* TOPPERS_wairel */
  
  /*
!  *  ¹ΥƱ֥̿ȤԤ塼ؤ
   *
!  *  ¹ΥƱ֥̿ȤԤ塼롥
!  *  ֥Ȥ°˱ơFIFOޤϥͥٽ롥
   */
  Inline void
  wobj_queue_insert(WOBJCB *p_wobjcb)
--- 143,152 ----
  #endif /* TOPPERS_wairel */
  
  /*
!  *  実行中のタスクの同期・通信オブジェクトの待ちキューへの挿入
   *
!  *  実行中のタスクを，同期・通信オブジェクトの待ちキューへ挿入する．オ
!  *  ブジェクトの属性に応じて，FIFO順またはタスク優先度順で挿入する．
   */
  Inline void
  wobj_queue_insert(WOBJCB *p_wobjcb)
***************
*** 160,166 ****
  }
  
  /*
!  *  Ʊ֥̿ȤФԤ֤ؤ
   */
  #ifdef TOPPERS_wobjwai
  
--- 160,166 ----
  }
  
  /*
!  *  同期・通信オブジェクトに対する待ち状態への遷移
   */
  #ifdef TOPPERS_wobjwai
  
***************
*** 189,195 ****
  #endif /* TOPPERS_wobjwaitmo */
  
  /*
!  *  Ԥ塼ν
   */
  #ifdef TOPPERS_iniwque
  
--- 189,195 ----
  #endif /* TOPPERS_wobjwaitmo */
  
  /*
!  *  待ちキューの初期化
   */
  #ifdef TOPPERS_iniwque
  
diff -cr --new-file 1.9.1/asp/kernel/wait.h ASPs/asp/kernel/wait.h
*** 1.9.1/asp/kernel/wait.h	Sun Jun 26 10:21:12 2011
--- ASPs/asp/kernel/wait.h	Fri Dec  9 13:54:04 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: wait.h 2128 2011-06-26 01:21:05Z ertl-hiro $
   */
  
  /*
!  *		Ԥִ⥸塼
   */
  
  #ifndef TOPPERS_WAIT_H
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: wait.h 2128 2011-06-26 01:21:05Z ertl-hiro $
   */
  
  /*
!  *		待ち状態管理モジュール
   */
  
  #ifndef TOPPERS_WAIT_H
***************
*** 51,60 ****
  #include "time_event.h"
  
  /*
!  *  ͥٽԤ塼ؤ
   *
!  *  p_tcbǻꤵ륿򡤥ͥٽΥ塼p_queue롥
!  *  塼Ʊͥ٤ΥˤϡκǸ롥
   */
  Inline void
  queue_insert_tpri(QUEUE *p_queue, TCB *p_tcb)
--- 51,60 ----
  #include "time_event.h"
  
  /*
!  *  タスクの優先度順の待ちキューへの挿入
   *
!  *  p_tcbで指定されるタスクを，タスク優先度順のキューp_queueに挿入する．
!  *  キューの中に同じ優先度のタスクがある場合には，その最後に挿入する．
   */
  Inline void
  queue_insert_tpri(QUEUE *p_queue, TCB *p_tcb)
***************
*** 72,82 ****
  }
  
  /*
!  *  Ԥ֤ؤ
   *
!  *  ¹ΥԤ֤ܤ롥Ūˤϡ¹Υ
!  *  ǥ塼TCBp_winfoեɡWINFOp_tmevtbե
!  *  ɤꤹ롥
   */
  Inline void
  make_wait(WINFO *p_winfo)
--- 72,82 ----
  }
  
  /*
!  *  待ち状態への遷移
   *
!  *  実行中のタスクを待ち状態に遷移させる．具体的には，実行中のタスクを
!  *  レディキューから削除し，TCBのp_winfoフィールド，WINFOのp_tmevtbフィー
!  *  ルドを設定する．
   */
  Inline void
  make_wait(WINFO *p_winfo)
***************
*** 87,107 ****
  }
  
  /*
!  *  Ԥ֤ؤܡʥॢȻ
   *
!  *  ¹Υ򡤥ॢȻդԤ֤ܤ롥
!  *  Ūˤϡ¹Υǥ塼TCBp_winfoե
!  *  ɡWINFOp_tmevtbեɤꤹ롥ޤ।٥ȥ
!  *  åϿ롥
   */
  extern void	make_wait_tmout(WINFO *p_winfo, TMEVTB *p_tmevtb, TMO tmout);
  
  /*
!  *  ԤΤΥ֤ι
   *
!  *  p_tcbǻꤵ륿Ԥ褦֤򹹿롥
!  *  Ԥ륿¹ԤǤ֤ˤʤϡǥ塼ˤĤ
!  *  ޤǥѥåɬפʾˤtrue֤
   */
  Inline bool_t
  make_non_wait(TCB *p_tcb)
--- 87,107 ----
  }
  
  /*
!  *  待ち状態への遷移（タイムアウト指定）
   *
!  *  実行中のタスクを，タイムアウト指定付きで待ち状態に遷移させる．具体
!  *  的には，実行中のタスクをレディキューから削除し，TCBのp_winfoフィー
!  *  ルド，WINFOのp_tmevtbフィールドを設定する．また，タイムイベントブ
!  *  ロックを登録する．
   */
  extern void	make_wait_tmout(WINFO *p_winfo, TMEVTB *p_tmevtb, TMO tmout);
  
  /*
!  *  待ち解除のためのタスク状態の更新
   *
!  *  p_tcbで指定されるタスクを，待ち解除するようタスク状態を更新する．
!  *  待ち解除するタスクが実行できる状態になる場合は，レディキューにつな
!  *  ぐ．また，ディスパッチが必要な場合にはtrueを返す．
   */
  Inline bool_t
  make_non_wait(TCB *p_tcb)
***************
*** 110,116 ****
  
  	if (!TSTAT_SUSPENDED(p_tcb->tstat)) {
  		/*
! 		 *  Ԥ֤¹ԤǤ֤ؤ
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
--- 110,116 ----
  
  	if (!TSTAT_SUSPENDED(p_tcb->tstat)) {
  		/*
! 		 *  待ち状態から実行できる状態への遷移
  		 */
  		p_tcb->tstat = TS_RUNNABLE;
  		LOG_TSKSTAT(p_tcb);
***************
*** 118,124 ****
  	}
  	else {
  		/*
! 		 *  Ԥ֤鶯Ԥ֤ؤ
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
--- 118,124 ----
  	}
  	else {
  		/*
! 		 *  二重待ち状態から強制待ち状態への遷移
  		 */
  		p_tcb->tstat = TS_SUSPENDED;
  		LOG_TSKSTAT(p_tcb);
***************
*** 127,136 ****
  }
  
  /*
!  *  ֥Ԥ塼κ
   *
!  *  p_tcbǻꤵ륿Ʊ֥̿ȤԤ塼ˤ
!  *  ʤƤСԤ塼롥
   */
  Inline void
  wait_dequeue_wobj(TCB *p_tcb)
--- 127,136 ----
  }
  
  /*
!  *  オブジェクト待ちキューからの削除
   *
!  *  p_tcbで指定されるタスクが，同期・通信オブジェクトの待ちキューにつ
!  *  ながれていれば，待ちキューから削除する．
   */
  Inline void
  wait_dequeue_wobj(TCB *p_tcb)
***************
*** 141,150 ****
  }
  
  /*
!  *  ԤΤΥ।٥ȥ֥åϿ
   *
!  *  p_tcbǻꤵ륿ФơԤΤΥ।٥ȥ
!  *  åϿƤСϿ롥
   */
  Inline void
  wait_dequeue_tmevtb(TCB *p_tcb)
--- 141,150 ----
  }
  
  /*
!  *  時間待ちのためのタイムイベントブロックの登録解除
   *
!  *  p_tcbで指定されるタスクに対して，時間待ちのためのタイムイベントブ
!  *  ロックが登録されていれば，それを登録解除する．
   */
  Inline void
  wait_dequeue_tmevtb(TCB *p_tcb)
***************
*** 155,203 ****
  }
  
  /*
!  *  Ԥ
   *
!  *  p_tcbǻꤵ륿Ԥ֤롥Ūˤϡ।
!  *  ٥ȥ֥åϿƤСϿ롥ޤ
!  *  ֤򹹿ԤͤE_OKȤ롥Ԥ塼
!  *  κϹԤʤԤؤΥǥѥåɬפʾ
!  *  ˤtrue֤
   */
  extern bool_t	wait_complete(TCB *p_tcb);
  
  /*
!  *  ॢȤȼԤ
   *
!  *  p_tcbǻꤵ륿Ԥ塼ˤĤʤƤԤ塼
!  *  ֤򹹿롥ޤԤ
!  *  ͤwait_tmoutǤE_TMOUTwait_tmout_okǤE_OKȤ롥Ԥ
!  *  ؤΥǥѥåɬפʻϡreqflgtrueˤ롥
   *
!  *  wait_tmout_okϡdly_tskǻȤΤΤǡԤ塼
!  *  Ԥʤ
   *
!  *  δؿ⡤।٥ȤΥХåؿȤѤ뤿
!  *  Τǡߥϥɥ餫ƤӽФ뤳ȤꤷƤ롥
   */
  extern void	wait_tmout(TCB *p_tcb);
  extern void	wait_tmout_ok(TCB *p_tcb);
  
  /*
!  *  Ԥ֤ζ
   *
!  *  p_tcbǻꤵ륿Ԥ֤Ū˲롥Ūˤϡ
!  *  Ԥ塼ˤĤʤƤԤ塼।
!  *  ٥ȥ֥åϿƤФϿ롥ޤ
!  *  ֤򹹿ԤͤE_RLWAIȤ롥ޤ
!  *  ԤؤΥǥѥåɬפʾˤtrue֤
   */
  extern bool_t	wait_release(TCB *p_tcb);
  
  /*
!  *  Ԥ塼ƬΥID
   *
!  *  p_wait_queueǻꤷԤ塼ƬΥID֤Ԥ塼
!  *  ξˤϡTSK_NONE֤
   */
  Inline ID
  wait_tskid(QUEUE *p_wait_queue)
--- 155,203 ----
  }
  
  /*
!  *  待ち解除
   *
!  *  p_tcbで指定されるタスクの待ち状態を解除する．具体的には，タイムイ
!  *  ベントブロックが登録されていれば，それを登録解除する．また，タスク
!  *  状態を更新し，待ち解除したタスクからの返値をE_OKとする．待ちキュー
!  *  からの削除は行わない．待ち解除したタスクへのディスパッチが必要な場
!  *  合にはtrueを返す．
   */
  extern bool_t	wait_complete(TCB *p_tcb);
  
  /*
!  *  タイムアウトに伴う待ち解除
   *
!  *  p_tcbで指定されるタスクが，待ちキューにつながれていれば待ちキュー
!  *  から削除し，タスク状態を更新する．また，待ち解除したタスクからの返
!  *  値を，wait_tmoutではE_TMOUT，wait_tmout_okではE_OKとする．待ち解除
!  *  したタスクへのディスパッチが必要な時は，reqflgをtrueにする．
   *
!  *  wait_tmout_okは，dly_tskで使うためのもので，待ちキューから削除する
!  *  処理を行わない．
   *
!  *  いずれの関数も，タイムイベントのコールバック関数として用いるための
!  *  もので，割込みハンドラから呼び出されることを想定している．
   */
  extern void	wait_tmout(TCB *p_tcb);
  extern void	wait_tmout_ok(TCB *p_tcb);
  
  /*
!  *  待ち状態の強制解除
   *
!  *  p_tcbで指定されるタスクの待ち状態を強制的に解除する．具体的には，
!  *  タスクが待ちキューにつながれていれば待ちキューから削除し，タイムイ
!  *  ベントブロックが登録されていればそれを登録解除する．また，タスクの
!  *  状態を更新し，待ち解除したタスクからの返値をE_RLWAIとする．また，
!  *  待ち解除したタスクへのディスパッチが必要な場合にはtrueを返す．
   */
  extern bool_t	wait_release(TCB *p_tcb);
  
  /*
!  *  待ちキューの先頭のタスクID
   *
!  *  p_wait_queueで指定した待ちキューの先頭のタスクIDを返す．待ちキュー
!  *  が空の場合には，TSK_NONEを返す．
   */
  Inline ID
  wait_tskid(QUEUE *p_wait_queue)
***************
*** 211,271 ****
  }
  
  /*
!  *  Ʊ֥̿Ȥδ֥åζʬ롼
   *
!  *  Ʊ֥̿Ȥν֥åȴ֥åƬʬ϶
!  *  ̤ˤʤäƤ롥ʲϡζʬ򰷤ηӥ롼
!  *  Ǥ롥
   *
!  *  ʣԤ塼Ʊ֥̿Ȥξ硤ƬʳԤ
!  *  塼ˤϡΥ롼ϻȤʤޤ֥
!  *  °TA_TPRIӥåȤ򻲾ȤΤǡΥӥåȤ¾Ū˻Ȥä
!  *  ⡤Υ롼ϻȤʤ
   */
  
  /*
!  *  Ʊ֥̿Ȥν֥åζʬ
   */
  typedef struct wait_object_initialization_block {
! 	ATR			wobjatr;		/* ֥° */
  } WOBJINIB;
  
  /*
!  *  Ʊ֥̿Ȥδ֥åζʬ
   */
  typedef struct wait_object_control_block {
! 	QUEUE		wait_queue;		/* Ԥ塼 */
! 	const WOBJINIB *p_wobjinib;	/* ֥åؤΥݥ */
  } WOBJCB;
  
  /*
!  *  Ʊ֥̿ȤԤ֥åζʬ
   *
!  *  ι¤ΤϡԤ֥åWINFOˤĥʥ֥Ȼظ
!  *  ηѾˤΤǤ뤬WINFOΤƤ뤿
!  *  ˡ1ĤΥեɤȤƴޤƤ롥
   */
  typedef struct wait_object_waiting_information {
! 	WINFO	winfo;			/* ɸԤ֥å */
! 	WOBJCB	*p_wobjcb;		/* Ԥ֥Ȥδ֥å */
  } WINFO_WOBJ;
  
  /*
!  *  Ʊ֥̿ȤФԤ֤ؤ
   *  
!  *  ¹ΥԤ֤ܤƱ֥̿ȤԤ塼
!  *  ˤĤʤޤԤ֥åWINFOˤp_wobjcbꤹ롥
!  *  wobj_make_wait_tmoutϡ।٥ȥ֥åϿԤ
   */
  extern void	wobj_make_wait(WOBJCB *p_wobjcb, WINFO_WOBJ *p_winfo);
  extern void	wobj_make_wait_tmout(WOBJCB *p_wobjcb, WINFO_WOBJ *p_winfo,
  											TMEVTB *p_tmevtb, TMO tmout);
  
  /*
!  *  ͥѹν
   *
!  *  Ʊ֥̿ȤФԤ֤ˤ륿ͥ٤ѹ
!  *  줿ˡԤ塼ǤΥΰ֤롥
   */
  Inline void
  wobj_change_priority(WOBJCB *p_wobjcb, TCB *p_tcb)
--- 211,271 ----
  }
  
  /*
!  *  同期・通信オブジェクトの管理ブロックの共通部分操作ルーチン
   *
!  *  同期・通信オブジェクトの初期化ブロックと管理ブロックの先頭部分は共
!  *  通になっている．以下は，その共通部分を扱うための型およびルーチン群
!  *  である．
   *
!  *  複数の待ちキューを持つ同期・通信オブジェクトの場合，先頭以外の待ち
!  *  キューを操作する場合には，これらのルーチンは使えない．また，オブジェ
!  *  クト属性のTA_TPRIビットを参照するので，このビットを他の目的に使って
!  *  いる場合も，これらのルーチンは使えない．
   */
  
  /*
!  *  同期・通信オブジェクトの初期化ブロックの共通部分
   */
  typedef struct wait_object_initialization_block {
! 	ATR			wobjatr;		/* オブジェクト属性 */
  } WOBJINIB;
  
  /*
!  *  同期・通信オブジェクトの管理ブロックの共通部分
   */
  typedef struct wait_object_control_block {
! 	QUEUE		wait_queue;		/* 待ちキュー */
! 	const WOBJINIB *p_wobjinib;	/* 初期化ブロックへのポインタ */
  } WOBJCB;
  
  /*
!  *  同期・通信オブジェクトの待ち情報ブロックの共通部分
   *
!  *  この構造体は，待ち情報ブロック（WINFO）を拡張（オブジェクト指向言
!  *  語の継承に相当）したものであるが，WINFOが共用体で定義されているた
!  *  めに，1つのフィールドとして含めている．
   */
  typedef struct wait_object_waiting_information {
! 	WINFO	winfo;			/* 標準の待ち情報ブロック */
! 	WOBJCB	*p_wobjcb;		/* 待ちオブジェクトの管理ブロック */
  } WINFO_WOBJ;
  
  /*
!  *  同期・通信オブジェクトに対する待ち状態への遷移
   *  
!  *  実行中のタスクを待ち状態に遷移させ，同期・通信オブジェクトの待ちキュー
!  *  につなぐ．また，待ち情報ブロック（WINFO）のp_wobjcbを設定する．
!  *  wobj_make_wait_tmoutは，タイムイベントブロックの登録も行う．
   */
  extern void	wobj_make_wait(WOBJCB *p_wobjcb, WINFO_WOBJ *p_winfo);
  extern void	wobj_make_wait_tmout(WOBJCB *p_wobjcb, WINFO_WOBJ *p_winfo,
  											TMEVTB *p_tmevtb, TMO tmout);
  
  /*
!  *  タスク優先度変更時の処理
   *
!  *  同期・通信オブジェクトに対する待ち状態にあるタスクの優先度が変更さ
!  *  れた場合に，待ちキューの中でのタスクの位置を修正する．
   */
  Inline void
  wobj_change_priority(WOBJCB *p_wobjcb, TCB *p_tcb)
***************
*** 277,287 ****
  }
  
  /*
!  *  Ԥ塼ν
   *
!  *  Ԥ塼ˤĤʤƤ륿򤹤٤Ԥ롥Ԥ
!  *  ͤϡE_DLTȤ롥ԤؤΥǥѥå
!  *  ɬפʾtrueǤʤfalse֤
   */
  extern bool_t	init_wait_queue(QUEUE *p_wait_queue);
  
--- 277,287 ----
  }
  
  /*
!  *  待ちキューの初期化
   *
!  *  待ちキューにつながれているタスクをすべて待ち解除する．待ち解除した
!  *  タスクからの返値は，E_DLTとする．待ち解除したタスクへのディスパッチ
!  *  が必要な場合はtrue，そうでない場合はfalseを返す．
   */
  extern bool_t	init_wait_queue(QUEUE *p_wait_queue);
  
diff -cr --new-file 1.9.1/asp/library/histogram.c ASPs/asp/library/histogram.c
*** 1.9.1/asp/library/histogram.c	Wed Jun 22 15:34:21 2011
--- ASPs/asp/library/histogram.c	Fri Dec  9 13:54:04 2022
***************
*** 5,44 ****
   *  Copyright (C) 2006-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: histogram.c 2119 2011-06-22 06:34:20Z ertl-hiro $
   */
  
  /*
!  *		¹Իʬ۽ץ⥸塼
   */
  
  #include <kernel.h>
--- 5,44 ----
   *  Copyright (C) 2006-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: histogram.c 2119 2011-06-22 06:34:20Z ertl-hiro $
   */
  
  /*
!  *		実行時間分布集計モジュール
   */
  
  #include <kernel.h>
***************
*** 48,105 ****
  #include "target_test.h"
  
  /*
!  *  ¹Իʬ۷¬ο
   */
  #ifndef TNUM_HIST
  #define TNUM_HIST		10
  #endif /* TNUM_HIST */
  
  /*
!  *  åȰ¸ѹ뤿Υޥ
   */
! #ifndef HISTTIM						/* ¹Իַ¬ѤλΥǡ */
  #define HISTTIM			SYSUTM
  #endif /* HISTTIM */
  
! #ifndef HIST_GET_TIM				/* ¹Իַ¬Ѥθ߻μ */
  #ifndef TOPPERS_SUPPORT_GET_UTM
  #error get_utm is not supported.
  #endif /* TOPPERS_SUPPORT_GET_UTM */
  #define HIST_GET_TIM(p_time)	((void) get_utm(p_time))
  #endif /* HIST_GET_TIM */
  
! #ifndef HIST_CONV_TIM				/* κ¹Ի֤ؤѴ */
  #define HIST_CONV_TIM(time)		((uint_t)(time))
  #endif /* HIST_CONV_TIM */
  
! #ifndef HIST_BM_HOOK				/* ¹Իַ¬ľ˹Ԥ٤ */
  #define HIST_BM_HOOK()			((void) 0)
  #endif
  
  /*
!  *  ¹Իʬ۷¬֥å
   */
  typedef struct histogram_control_block {
! 	HISTTIM		begin_time;			/* ¬ϻ */
! 	uint_t		maxval;				/* ʬۤϿ */
! 	uint_t		*histarea;			/* ʬۤϿΰ */
! 	uint_t		over;				/* ֤Ķٿ */
! 	uint_t		under;				/* ֤εžٿ */
  } HISTCB;
  
  /*
!  *  ¹Իʬ۷¬֥åΥꥢ
   */
  static HISTCB	histcb_table[TNUM_HIST];
  
  /*
!  *  ¹Իʬ۷¬IDκǾͤȺ
   */
  #define TMIN_HISTID		1
  #define TMAX_HISTID		(TMIN_HISTID + TNUM_HIST - 1)
  
  /*
!  *  ¹Իʬ۷¬ν
   */
  void
  init_hist(ID histid, uint_t maxval, uint_t histarea[])
--- 48,105 ----
  #include "target_test.h"
  
  /*
!  *  実行時間分布計測の数
   */
  #ifndef TNUM_HIST
  #define TNUM_HIST		10
  #endif /* TNUM_HIST */
  
  /*
!  *  ターゲット依存部で設定変更するためのマクロ
   */
! #ifndef HISTTIM						/* 実行時間計測用の時刻のデータ型 */
  #define HISTTIM			SYSUTM
  #endif /* HISTTIM */
  
! #ifndef HIST_GET_TIM				/* 実行時間計測用の現在時刻の取得 */
  #ifndef TOPPERS_SUPPORT_GET_UTM
  #error get_utm is not supported.
  #endif /* TOPPERS_SUPPORT_GET_UTM */
  #define HIST_GET_TIM(p_time)	((void) get_utm(p_time))
  #endif /* HIST_GET_TIM */
  
! #ifndef HIST_CONV_TIM				/* 時刻の差から実行時間への変換 */
  #define HIST_CONV_TIM(time)		((uint_t)(time))
  #endif /* HIST_CONV_TIM */
  
! #ifndef HIST_BM_HOOK				/* 実行時間計測直前に行うべき処理 */
  #define HIST_BM_HOOK()			((void) 0)
  #endif
  
  /*
!  *  実行時間分布計測管理ブロック
   */
  typedef struct histogram_control_block {
! 	HISTTIM		begin_time;			/* 計測開始時刻 */
! 	uint_t		maxval;				/* 分布を記録する最大時間 */
! 	uint_t		*histarea;			/* 分布を記録するメモリ領域 */
! 	uint_t		over;				/* 最大時間を超えた度数 */
! 	uint_t		under;				/* 時間の逆転が疑われる度数 */
  } HISTCB;
  
  /*
!  *  実行時間分布計測管理ブロックのエリア
   */
  static HISTCB	histcb_table[TNUM_HIST];
  
  /*
!  *  実行時間分布計測IDの最小値と最大値
   */
  #define TMIN_HISTID		1
  #define TMAX_HISTID		(TMIN_HISTID + TNUM_HIST - 1)
  
  /*
!  *  実行時間分布計測の初期化
   */
  void
  init_hist(ID histid, uint_t maxval, uint_t histarea[])
***************
*** 120,126 ****
  }
  
  /*
!  *  ¹Իַ¬γ
   */
  void
  begin_measure(ID histid)
--- 120,126 ----
  }
  
  /*
!  *  実行時間計測の開始
   */
  void
  begin_measure(ID histid)
***************
*** 135,141 ****
  }
  
  /*
!  *  ¹Իַ¬νλ
   */
  void
  end_measure(ID histid)
--- 135,141 ----
  }
  
  /*
!  *  実行時間計測の終了
   */
  void
  end_measure(ID histid)
***************
*** 162,168 ****
  }
  
  /*
!  *  ¹Իʬ۷¬ɽ
   */
  void
  print_hist(ID histid)
--- 162,168 ----
  }
  
  /*
!  *  実行時間分布計測の表示
   */
  void
  print_hist(ID histid)
diff -cr --new-file 1.9.1/asp/library/log_output.c ASPs/asp/library/log_output.c
*** 1.9.1/asp/library/log_output.c	Sat Aug 27 07:39:16 2011
--- ASPs/asp/library/log_output.c	Fri Dec  9 13:54:04 2022
***************
*** 7,46 ****
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: log_output.c 2246 2011-08-26 22:39:15Z ertl-hiro $
   */
  
  /*
!  *		ƥΥեޥåȽ
   */
  
  #include <t_stddef.h>
--- 7,46 ----
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: log_output.c 2246 2011-08-26 22:39:15Z ertl-hiro $
   */
  
  /*
!  *		システムログのフォーマット出力
   */
  
  #include <t_stddef.h>
***************
*** 48,57 ****
  #include <log_output.h>
  
  /*
!  *  ͤʸѴ
   */
  #define CONVERT_BUFLEN	((sizeof(uintptr_t) * CHAR_BIT + 2) / 3)
! 										/* uintptr_tοͤκʸ */
  static void
  convert(uintptr_t val, uint_t radix, const char *radchar,
  			uint_t width, bool_t minus, bool_t padzero, void (*putc)(char))
--- 48,57 ----
  #include <log_output.h>
  
  /*
!  *  数値を文字列に変換
   */
  #define CONVERT_BUFLEN	((sizeof(uintptr_t) * CHAR_BIT + 2) / 3)
! 										/* uintptr_t型の数値の最大文字数 */
  static void
  convert(uintptr_t val, uint_t radix, const char *radchar,
  			uint_t width, bool_t minus, bool_t padzero, void (*putc)(char))
***************
*** 83,89 ****
  }
  
  /*
!  *  ʸ
   */
  static const char raddec[] = "0123456789";
  static const char radhex[] = "0123456789abcdef";
--- 83,89 ----
  }
  
  /*
!  *  文字列整形出力
   */
  static const char raddec[] = "0123456789";
  static const char radhex[] = "0123456789abcdef";
***************
*** 164,170 ****
  }
  
  /*
!  *  ν
   */
  void
  syslog_print(const SYSLOG *p_syslog, void (*putc)(char))
--- 164,170 ----
  }
  
  /*
!  *  ログ情報の出力
   */
  void
  syslog_print(const SYSLOG *p_syslog, void (*putc)(char))
***************
*** 180,193 ****
  		break;
  	default:
  		/*
! 		 *  ¾μ̤ΥˤбƤʤ
  		 */
  		break;
  	}
  }
  
  /*
!  *  Ӽåν
   */
  void
  syslog_lostmsg(uint_t lostlog, void (*putc)(char))
--- 180,193 ----
  		break;
  	default:
  		/*
! 		 *  他の種別のログ情報には対応していない．
  		 */
  		break;
  	}
  }
  
  /*
!  *  ログ情報喪失メッセージの出力
   */
  void
  syslog_lostmsg(uint_t lostlog, void (*putc)(char))
diff -cr --new-file 1.9.1/asp/library/strerror.c ASPs/asp/library/strerror.c
*** 1.9.1/asp/library/strerror.c	Wed Feb  3 12:16:38 2010
--- ASPs/asp/library/strerror.c	Fri Dec  9 13:54:04 2022
***************
*** 7,46 ****
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: strerror.c 1732 2010-02-03 03:15:52Z ertl-hiro $
   */
  
  /*
!  *		顼åʸ֤ؿ
   */
  
  #include <t_stddef.h>
--- 7,46 ----
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: strerror.c 1732 2010-02-03 03:15:52Z ertl-hiro $
   */
  
  /*
!  *		エラーメッセージ文字列を返す関数
   */
  
  #include <t_stddef.h>
diff -cr --new-file 1.9.1/asp/library/t_perror.c ASPs/asp/library/t_perror.c
*** 1.9.1/asp/library/t_perror.c	Sat Apr 12 10:31:21 2008
--- ASPs/asp/library/t_perror.c	Fri Dec  9 13:54:04 2022
***************
*** 7,46 ****
   *  Copyright (C) 2004-2006 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: t_perror.c 264 2007-07-12 08:23:10Z hiro $
   */
  
  /*
!  *		顼åν
   */
  
  #include <t_stddef.h>
--- 7,46 ----
   *  Copyright (C) 2004-2006 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: t_perror.c 264 2007-07-12 08:23:10Z hiro $
   */
  
  /*
!  *		エラーメッセージの出力
   */
  
  #include <t_stddef.h>
diff -cr --new-file 1.9.1/asp/library/test_lib.c ASPs/asp/library/test_lib.c
*** 1.9.1/asp/library/test_lib.c	Fri Oct 18 23:59:01 2013
--- ASPs/asp/library/test_lib.c	Fri Dec  9 13:54:04 2022
***************
*** 5,44 ****
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_lib.c 2542 2013-10-13 15:37:27Z ertl-hiro $
   */
  
  /* 
!  *		ƥȥץѥ饤֥
   */
  
  #include <kernel.h>
--- 5,44 ----
   *  Copyright (C) 2005-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_lib.c 2542 2013-10-13 15:37:27Z ertl-hiro $
   */
  
  /* 
!  *		テストプログラム用ライブラリ
   */
  
  #include <kernel.h>
***************
*** 51,67 ****
  #include <test_lib.h>
  
  /*
!  *	åݥ
   */
  static uint_t	check_count = 0u;
  
  /*
!  *	ʿǴؿ
   */
  static BIT_FUNC	check_bit_func = NULL;
  
  /*
!  *	ʿǴؿ
   */
  void
  set_bit_func(BIT_FUNC bit_func)
--- 51,67 ----
  #include <test_lib.h>
  
  /*
!  *	チェックポイント
   */
  static uint_t	check_count = 0u;
  
  /*
!  *	自己診断関数
   */
  static BIT_FUNC	check_bit_func = NULL;
  
  /*
!  *	自己診断関数の設定
   */
  void
  set_bit_func(BIT_FUNC bit_func)
***************
*** 70,76 ****
  }
  
  /*
!  *  ƥȥץγ
   */
  void
  test_start(char *progname)
--- 70,76 ----
  }
  
  /*
!  *  テストプログラムの開始
   */
  void
  test_start(char *progname)
***************
*** 79,85 ****
  }
  
  /*
!  *  ƥνϽ
   */
  void
  syslog_flush(void)
--- 79,85 ----
  }
  
  /*
!  *  システムログの出力処理
   */
  void
  syslog_flush(void)
***************
*** 88,95 ****
  	ER_UINT	rercd;
  
  	/*
! 	 *  Хåե˵Ͽ줿٥ϵǽѤƽ
! 	 *  Ϥ롥
  	 */
  	while ((rercd = syslog_rea_log(&logbuf)) >= 0) {
  		if (rercd > 0) {
--- 88,95 ----
  	ER_UINT	rercd;
  
  	/*
! 	 *  ログバッファに記録されたログ情報を，低レベル出力機能を用いて出
! 	 *  力する．
  	 */
  	while ((rercd = syslog_rea_log(&logbuf)) >= 0) {
  		if (rercd > 0) {
***************
*** 103,109 ****
  }
  
  /*
!  *	ƥȥץνλ
   */
  void
  test_finish(void)
--- 103,109 ----
  }
  
  /*
!  *	テストプログラムの終了
   */
  void
  test_finish(void)
***************
*** 114,125 ****
  	syslog_flush();
  	(void) ext_ker();
  
! 	/* 뤳ȤϤʤϤ */
  	SIL_UNL_INT();
  }
  
  /*
!  *	åݥ
   */
  void
  check_point(uint_t count)
--- 114,125 ----
  	syslog_flush();
  	(void) ext_ker();
  
! 	/* ここへ来ることはないはず */
  	SIL_UNL_INT();
  }
  
  /*
!  *	チェックポイント
   */
  void
  check_point(uint_t count)
***************
*** 129,140 ****
  	SIL_PRE_LOC;
  
  	/*
! 	 *  ߥå֤
  	 */
  	SIL_LOC_INT();
  
  	/*
! 	 *  󥹥å
  	 */
  	if (++check_count == count) {
  		syslog_1(LOG_NOTICE, "Check point %d passed.", count);
--- 129,140 ----
  	SIL_PRE_LOC;
  
  	/*
! 	 *  割込みロック状態に
  	 */
  	SIL_LOC_INT();
  
  	/*
! 	 *  シーケンスチェック
  	 */
  	if (++check_count == count) {
  		syslog_1(LOG_NOTICE, "Check point %d passed.", count);
***************
*** 145,151 ****
  	}
  
  	/*
! 	 *  ֤ͥθ
  	 */
  	if (check_bit_func != NULL) {
  		rercd = (*check_bit_func)();
--- 145,151 ----
  	}
  
  	/*
! 	 *  カーネルの内部状態の検査
  	 */
  	if (check_bit_func != NULL) {
  		rercd = (*check_bit_func)();
***************
*** 157,176 ****
  	}
  
  	/*
! 	 *  顼Ф줿ϡƥȥץλ롥
  	 */
  	if (errorflag) {
  		test_finish();
  	}
  
  	/*
! 	 *  ߥå֤
  	 */
  	SIL_UNL_INT();
  }
  
  /*
!  *	λåݥ
   */
  void
  check_finish(uint_t count)
--- 157,176 ----
  	}
  
  	/*
! 	 *  エラーが検出された場合は，テストプログラムを終了する．
  	 */
  	if (errorflag) {
  		test_finish();
  	}
  
  	/*
! 	 *  割込みロック状態を解除
  	 */
  	SIL_UNL_INT();
  }
  
  /*
!  *	完了チェックポイント
   */
  void
  check_finish(uint_t count)
***************
*** 181,187 ****
  }
  
  /*
!  *	åΥ顼
   */
  void
  _check_assert(const char *expr, const char *file, int_t line)
--- 181,187 ----
  }
  
  /*
!  *	条件チェックのエラー処理
   */
  void
  _check_assert(const char *expr, const char *file, int_t line)
***************
*** 192,198 ****
  }
  
  /*
!  *	顼ɥåΥ顼
   */
  void
  _check_ercd(ER ercd, const char *file, int_t line)
--- 192,198 ----
  }
  
  /*
!  *	エラーコードチェックのエラー処理
   */
  void
  _check_ercd(ER ercd, const char *file, int_t line)
diff -cr --new-file 1.9.1/asp/library/vasyslog.c ASPs/asp/library/vasyslog.c
*** 1.9.1/asp/library/vasyslog.c	Sun Nov 11 16:26:48 2012
--- ASPs/asp/library/vasyslog.c	Fri Dec  9 13:54:04 2022
***************
*** 7,46 ****
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: vasyslog.c 2422 2012-11-11 07:26:42Z ertl-hiro $
   */
  
  /*
!  *		ѿΥƥ饤֥
   */
  
  #include <t_stddef.h>
--- 7,46 ----
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: vasyslog.c 2422 2012-11-11 07:26:42Z ertl-hiro $
   */
  
  /*
!  *		可変数引数のシステムログライブラリ
   */
  
  #include <t_stddef.h>
diff -cr --new-file 1.9.1/asp/pdic/renesas/MANIFEST ASPs/asp/pdic/renesas/MANIFEST
*** 1.9.1/asp/pdic/renesas/MANIFEST	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/renesas/MANIFEST	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,6 ----
+ PACKAGE pdic_rx600
+ VERSION 1.6.0
+ 
+ MANIFEST
+ rx600_uart.c
+ rx600_uart.h
diff -cr --new-file 1.9.1/asp/pdic/renesas/scic.c~ ASPs/asp/pdic/renesas/scic.c~
*** 1.9.1/asp/pdic/renesas/scic.c~	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/renesas/scic.c~	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,543 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  L쌠҂́Cȉ(1)`(4)̏𖞂ꍇɌC{\tgEF
+  *  Ai{\tgEFAς̂܂ށDȉjgpEE
+  *  ρEĔzziȉCpƌĂԁj邱Ƃ𖳏ŋD
+  *  (1) {\tgEFA\[XR[ȟ`ŗpꍇɂ́CL̒
+  *      \C̗pщL̖ۏ؋K肪Ĉ܂܂̌`Ń\[
+  *      XR[hɊ܂܂Ă邱ƁD
+  *  (2) {\tgEFACCu`ȂǁC̃\tgEFAJɎg
+  *      pł`ōĔzzꍇɂ́CĔzzɔhLgip
+  *      ҃}jAȂǁjɁCL̒쌠\C̗pщL
+  *      ̖ۏ؋Kfڂ邱ƁD
+  *  (3) {\tgEFAC@ɑgݍނȂǁC̃\tgEFAJɎg
+  *      płȂ`ōĔzzꍇɂ́Ĉꂩ̏𖞂
+  *      ƁD
+  *    (a) ĔzzɔhLgip҃}jAȂǁjɁCL̒
+  *        쌠\C̗pщL̖ۏ؋Kfڂ邱ƁD
+  *    (b) Ĕzž`ԂCʂɒ߂@ɂāCTOPPERSvWFNg
+  *        񍐂邱ƁD
+  *  (4) {\tgEFA̗pɂ蒼ړI܂͊ԐړIɐ邢Ȃ鑹
+  *      QCL쌠҂TOPPERSvWFNgƐӂ邱ƁD
+  *      ܂C{\tgEFÃ[U܂̓Gh[ÛȂ闝
+  *      RɊÂCL쌠҂TOPPERSvWFNg
+  *      Ɛӂ邱ƁD
+  * 
+  *  {\tgEFÁCۏ؂Œ񋟂Ă̂łDL쌠҂
+  *  TOPPERSvWFNǵC{\tgEFAɊւāC̎gpړI
+  *  ɑ΂K܂߂āCȂۏ؂sȂD܂C{\tgEF
+  *  A̗pɂ蒼ړI܂͊ԐړIɐȂ鑹QɊւĂC
+  *  ̐ӔC𕉂ȂD
+  * 
+  */
+ 
+ 
+ /*
+  *   rx610 UARTp ȈSIOhCo
+  */
+ 
+ #include <sil.h>
+ #include <kernel.h>
+ #include <t_syslog.h>
+ #include "target_syssvc.h"
+ #include "rx600_uart.h"
+ 
+ /* VA[hWX^iSMR) */
+ #define CKS			UINT_C(0x03)
+ #define STOP		UINT_C(0x08)
+ #define PM			UINT_C(0x10)
+ #define PE			UINT_C(0x20)
+ #define CHR			UINT_C(0x40)
+ #define CM			UINT_C(0x80)
+ #define ASYNC_7BIT	UINT_C(0x00)
+ #define ASYNC_8BIT	UINT_C(0x40)
+ 
+ /* VARg[WX^iSCR) */
+ #define CKE			UINT_C(0x03)
+ #define TEIE		UINT_C(0x04)
+ #define RE			UINT_C(0x10)
+ #define TE			UINT_C(0x20)
+ #define RIE			UINT_C(0x40)
+ #define TIE			UINT_C(0x80)
+ 
+ /* VAXe[^XWX^iSSRj */
+ #define TEND		UINT_C(0x04)
+ #define PER			UINT_C(0x08)
+ #define FER			UINT_C(0x10)
+ #define ORER		UINT_C(0x20)
+ 
+ /* VAg[hWX^iSEMR) */
+ #define ACS0		UINT_C(0x01)
+ #define ABCS		UINT_C(0x10)
+ 
+ #define SCI_SCR_FLG_ENABLE	(RE | TE)
+ #define SCI_SMR_FLG_ENABLE	(STOP | PM | PE | CHR | CM)
+ 
+ /*
+  *  VAI/O|[gubN̒`
+  */
+ typedef struct sio_port_initialization_block {
+ 	volatile uint8_t	*ctlreg;		/* VARg[WX^iSCR) */
+ 	volatile uint8_t	*modereg;		/* VA[hWX^iSMR) */
+ 	volatile uint8_t	*extmodereg;	/* VAg[hWX^iSEMR) */	
+ 	volatile uint8_t	*statusreg;		/* VAXe[^XWX^iSSRj */
+ 	volatile uint8_t	*tdreg;			/* gX~bgf[^WX^iTDR)*/
+ 	volatile uint8_t	*rdreg;			/* V[uf[^WX^iRDR) */
+ 	volatile uint8_t	*bitratereg;	/* rbg[gWX^iBRR) */
+ 	volatile uint8_t	*porticrreg;	/* ̓obt@Rg[WX^iICR) */
+ 	volatile uint32_t	*mstpcrreg;		/* W[XgbvRg[WX^iMSTPCRj */
+ 	volatile uint8_t	*ssrreg;		/* Xe[^XWX^ */
+ 	volatile uint8_t	*rxiirreg;		/* RXIpݗvWX^ */
+ 	uint8_t				tx_intno;		/* Mif[^GveBj荞ݔԍ */
+ 	uint8_t				rx_intno;		/* Mif[^tj荞ݔԍ */
+ 	uint8_t				er_intno;		/* MiG[j荞ݔԍ */
+ 	uint8_t				te_intno;		/* MiIj荞ݔԍ */
+ 	uint8_t				sci_no;			/* SCI̔ԍ(SCI0`SCI6) */
+ 	uint32_t			mstpcr_offset;	/* MSTPCȒΉrbgItZbg */
+ } SIOPINIB;
+ 
+ /*
+  *  VAI/O|[gǗubN̒`
+  */
+ struct sio_port_control_block {
+ 	const SIOPINIB	*p_siopinib; 				/* VAI/O|[gubN */
+ 	intptr_t 	exinf;			 				/* g */
+ 	bool_t		openflag;						/* I[vς݃tO */
+ 	bool_t		sendflag;						/* M݃Cl[utO */
+ 	bool_t		getready;						/* M */
+ 	bool_t		putready;						/* 𑗐Mł */
+ 	bool_t		is_initialized; 				/* foCXς݃tO */
+ };
+ 
+ /*
+  *  VAI/O|[gǗubÑGA
+  */
+ static SIOPCB	siopcb_table[TNUM_SIOP];
+ 
+ /* WX^e[u */
+ static const SIOPINIB siopinib_table[TNUM_SIOP] =
+ {
+ 	{
+ 		(volatile uint8_t *)SCI0_SCR_ADDR,
+ 		(volatile uint8_t *)SCI0_SMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		(volatile uint8_t *)SCI0_TDR_ADDR,
+ 		(volatile uint8_t *)SCI0_RDR_ADDR,
+ 		(volatile uint8_t *)SCI0_BRR_ADDR,
+ 		(volatile uint8_t *)PORT2_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR215_ADDR,
+ 		INT_SCI0_TXI0,
+ 		INT_SCI0_RXI0,
+ 		INT_SCI0_ERI0,
+ 		INT_SCI0_TEI0,
+ 		0,
+ 		SYSTEM_MSTPCRB_MSTPB31_BIT,
+ 	} ,			/* UART0 */
+ #if TNUM_SIOP > 1
+ 	{
+ 		(volatile uint8_t *)SCI1_SCR_ADDR,
+ 		(volatile uint8_t *)SCI1_SMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		(volatile uint8_t *)SCI1_TDR_ADDR,
+ 		(volatile uint8_t *)SCI1_RDR_ADDR,
+ 		(volatile uint8_t *)SCI1_BRR_ADDR,
+ 		(volatile uint8_t *)PORT2_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR219_ADDR,
+ 		INT_SCI1_TXI1,
+ 		INT_SCI1_RXI1,
+ 		INT_SCI1_ERI1,
+ 		INT_SCI1_TEI1,
+ 		1,
+ 		SYSTEM_MSTPCRB_MSTPB30_BIT,
+ 	} ,			/* UART1 */
+ #endif
+ #if TNUM_SIOP > 2
+ 	{
+ 		(volatile uint8_t *)SCI2_SCR_ADDR,
+ 		(volatile uint8_t *)SCI2_SMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		(volatile uint8_t *)SCI2_TDR_ADDR,
+ 		(volatile uint8_t *)SCI2_RDR_ADDR,
+ 		(volatile uint8_t *)SCI2_BRR_ADDR,
+ 		(volatile uint8_t *)PORT1_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR223_ADDR,
+ 		INT_SCI2_TXI2,
+ 		INT_SCI2_RXI2,
+ 		INT_SCI2_ERI2 ,
+ 		INT_SCI2_TEI2,
+ 		2,
+ 		SYSTEM_MSTPCRB_MSTPB29_BIT,
+ 	} ,			/* UART2 */
+ #endif
+ #if TNUM_SIOP > 3
+ 	{
+ 		(volatile uint8_t *)SCI3_SCR_ADDR,
+ 		(volatile uint8_t *)SCI3_SMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		(volatile uint8_t *)SCI3_TDR_ADDR,
+ 		(volatile uint8_t *)SCI3_RDR_ADDR,
+ 		(volatile uint8_t *)SCI3_BRR_ADDR,
+ 		(volatile uint8_t *)PORT1_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR227_ADDR,
+ 		INT_SCI3_TXI3,
+ 		INT_SCI3_RXI3,
+ 		INT_SCI3_ERI3,
+ 		INT_SCI3_TEI3,
+ 		3,
+ 		SYSTEM_MSTPCRB_MSTPB28_BIT,
+ 	} ,			/* UART3 */
+ #endif
+ #if TNUM_SIOP > 4
+ 	{
+ 		(volatile uint8_t *)SCI4_SCR_ADDR,
+ 		(volatile uint8_t *)SCI4_SMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		(volatile uint8_t *)SCI4_TDR_ADDR,
+ 		(volatile uint8_t *)SCI4_RDR_ADDR,
+ 		(volatile uint8_t *)SCI4_BRR_ADDR,
+ 		(volatile uint8_t *)PORT0_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR231_ADDR,
+ 		INT_SCI4_TXI4,
+ 		INT_SCI4_RXI4,
+ 		INT_SCI4_ERI4,
+ 		INT_SCI4_TEI4,
+ 		4,
+ 		SYSTEM_MSTPCRB_MSTPB27_BIT,
+ 	} ,		/* UART4 */
+ #endif
+ #if TNUM_SIOP > 5
+ 	{
+ 		(volatile uint8_t *)SCI5_SCR_ADDR,
+ 		(volatile uint8_t *)SCI5_SMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		(volatile uint8_t *)SCI5_TDR_ADDR,
+ 		(volatile uint8_t *)SCI5_RDR_ADDR,
+ 		(volatile uint8_t *)SCI5_BRR_ADDR,
+ 		(volatile uint8_t *)PORTC_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR235_ADDR,
+ 		INT_SCI5_TXI5,
+ 		INT_SCI5_RXI5,
+ 		INT_SCI5_ERI5,
+ 		INT_SCI5_TEI5,
+ 		5,
+ 		SYSTEM_MSTPCRB_MSTPB26_BIT,
+ 	} ,		/* UART5 */
+ #endif
+ #if TNUM_SIOP > 6
+ 	{
+ 		(volatile uint8_t *)SCI6_SCR_ADDR,
+ 		(volatile uint8_t *)SCI6_SMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		(volatile uint8_t *)SCI6_TDR_ADDR,
+ 		(volatile uint8_t *)SCI6_RDR_ADDR,
+ 		(volatile uint8_t *)SCI6_BRR_ADDR,
+ 		(volatile uint8_t *)PORT0_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR239_ADDR,
+ 		INT_SCI6_TXI6,
+ 		INT_SCI6_RXI6,
+ 		INT_SCI6_ERI6,
+ 		INT_SCI6_TEI6,
+ 		6,
+ 		SYSTEM_MSTPCRB_MSTPB25_BIT,
+ 	} ,		/* UART6 */
+ #endif
+ };
+ 
+ /*
+  *  VAI/O|[gIDǗubNo߂̃}N
+  */
+ #define INDEX_SIOP(siopid)	 ((uint_t)((siopid) - 1))
+ #define get_siopcb(siopid)	 (&(siopcb_table[INDEX_SIOP(siopid)]))
+ #define get_siopinib(siopid) (&(siopinib_table[INDEX_SIOP(siopid)]))
+ 
+ 
+ /*
+  *  SIOhCõVA[hWX^(SMR)
+  */
+ static void
+ rx600_uart_setmode(const SIOPINIB *p_siopinib, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	uint8_t i;
+ 
+ 	/*
+ 	 *  SCIhCȍ[`
+ 	 */
+ 
+ 	/*
+ 	 *  荞ݗv惌WX^̐ݒ(ISELRi)
+ 	 *
+ 	 *  ZbglƓlݒ肷邱ƂɂȂ邽,
+ 	 *  ͏ȗ.
+ 	 */
+ 
+ 	/*
+ 	 *  W[Xgbv@\̐ݒ(SCI1)
+ 	 */
+ 	sil_wrw_mem((void *)p_siopinib->mstpcrreg, (~p_siopinib->mstpcr_offset));
+ 
+ 	/* M֎~, SCKn[q͓o̓|[gƂĎgp */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 0x00U);
+ 
+ 	/* NbNIrbg(SMR.CKS[1:0]rbgݒ) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 					sil_reb_mem((void *)p_siopinib->modereg) | clksrc);
+ 
+ 	/* SMRɑM^ MtH[}bgݒ) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 			sil_reb_mem((void *)p_siopinib->modereg) & (~SCI_SMR_FLG_ENABLE));
+ 
+ 	/* rbg[gݒ */
+ 	sil_wrb_mem((void *)p_siopinib->bitratereg, bitrate);
+ 
+ 	/* rbg({NbN16TCN̊Ԃ1rbgԂƂȂ) */
+ 	while(i < 16){
+ 		i++;
+ 	}
+ 
+ 	/* M */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 			(sil_reb_mem((void *)p_siopinib->ctlreg) | SCI_SCR_FLG_ENABLE));
+ }
+ 
+ 
+ /*
+  *  SIOhCȍ[`
+  */
+ void
+ rx600_uart_initialize(void)
+ {
+ 	SIOPCB	*p_siopcb;
+ 	uint_t	i;
+ 
+ 	/*
+ 	 *  VAI/O|[gǗubN̏
+ 	 */
+ 	for (p_siopcb = siopcb_table, i = 0; i < TNUM_SIOP; p_siopcb++, i++){
+ 		p_siopcb->p_siopinib = &(siopinib_table[i]);
+ 		p_siopcb->openflag = false;
+ 		p_siopcb->sendflag = false;
+ 	}
+ }
+ 
+ /*
+  *  J[lÑoi[o͗p̏
+  */
+ void
+ rx600_uart_init(ID siopid, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb   = get_siopcb(siopid);
+ 	const SIOPINIB  *p_siopinib = get_siopinib(siopid);
+ 	/*  ̎_ł́Ap_siopcb->p_siopinib͏ĂȂ  */
+ 
+ 	/*  d̖h~  */
+ 	p_siopcb->is_initialized = true;
+ 
+ 	/*  n[hEFȀƑM  */
+ 	rx600_uart_setmode(p_siopinib , bitrate, clksrc);
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 					(uint8_t)(sil_reb_mem((void *)p_siopinib->ctlreg) | TE));
+ }
+ 
+ 
+ /*
+  *  VAI/O|[gւ̃|[Oł̏o
+  */
+ void
+ rx600_uart_pol_putc(char c, ID siopid)
+ {
+ 	const SIOPINIB *p_siopinib;
+ 
+ 	p_siopinib = get_siopinib(siopid);
+ 
+ 	/*
+ 	 *  MWX^ɂȂ܂ő҂
+ 	 */
+ 	while((sil_reb_mem(
+ 			(void *)p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) == 0U);
+ 
+ 	sil_wrb_mem((void *)p_siopinib->tdreg, (uint8_t)c);
+ }
+ 
+ /*
+  *  VAI/O|[g̃I[v
+  */
+ SIOPCB *
+ rx600_uart_opn_por
+ 	(ID siopid, intptr_t exinf, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb;
+ 	const SIOPINIB  *p_siopinib;
+ 
+ 	p_siopcb = get_siopcb(siopid);
+ 	p_siopinib = p_siopcb->p_siopinib;
+ 
+ 	/*
+ 	 *  n[hEFȀ
+ 	 *
+ 	 *  ɏĂꍇ, dɏȂ.
+ 	 */
+ 	if(!(p_siopcb->is_initialized)){
+ 		rx600_uart_setmode(p_siopinib, bitrate, clksrc);
+ 		p_siopcb->is_initialized = true;
+ 	}
+ 
+ 	p_siopcb->exinf = exinf;
+ 	p_siopcb->getready = p_siopcb->putready = false;
+ 	p_siopcb->openflag = true;
+ 
+     return (p_siopcb);
+ }
+ 
+ /*
+  *  VAI/O|[g̃N[Y
+  */
+ void
+ rx600_uart_cls_por(SIOPCB *p_siopcb)
+ {
+ 	/*
+ 	 *  UART~
+ 	 */
+ 	sil_wrh_mem((void *)p_siopcb->p_siopinib->ctlreg, 0x00U);
+ 	p_siopcb->openflag = false;
+ 	p_siopcb->is_initialized = false;
+ }
+ 
+ /*
+  *  VAI/O|[gւ̕M
+  */
+ bool_t
+ rx600_uart_snd_chr(SIOPCB *p_siopcb, char c)
+ {
+ 	bool_t ercd = false;
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0){
+ 		sil_wrb_mem((void *)p_siopcb->p_siopinib->tdreg, (uint8_t)c);
+ 		ercd = true;
+ 	}
+ 
+ 	return ercd;
+ }
+ 
+ /*
+  *  VAI/O|[g̕M
+  */
+ int_t
+ rx600_uart_rcv_chr(SIOPCB *p_siopcb)
+ {
+ 	int_t c = -1;
+ 
+ 	/*
+ 	 *  MtOON̂Ƃ̂ݎMobt@當擾.
+ 	 *  , |[OMɑΉ邽߂ł.
+ 	 *  , RX600V[Ył͎MtOȂ, VXeT[rX
+ 	 *  ł͎M݂̒炵f[^MɗȂƂ, 
+ 	 *  Mobt@當擾.
+ 	 */
+ 	c = (int)(sil_reb_mem((void *)p_siopcb->p_siopinib->rdreg));
+ 
+ 	return c;
+ }
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋
+  */
+ void
+ rx600_uart_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_TEIE_BIT));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_RIE_BIT));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋֎~
+  */
+ void
+ rx600_uart_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_TEIE_BIT)));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_RIE_BIT)));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  SIO̊݃T[rX[`
+  */
+ void
+ rx600_uart_tx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0U){
+ 		/*
+ 		 *  M\R[obN[`ĂяoD
+ 		 */
+ 		rx600_uart_irdy_snd(p_siopcb->exinf);
+ 	}
+ }
+ 
+ void
+ rx600_uart_rx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	/*
+ 	 *  MtOON̂Ƃ̂ݎMʒmR[obN[`Ăяo.
+ 	 *  , RX600V[Ył͎MtOȂ, ɎMʒm
+ 	 *  R[obN[`Ăяo.
+ 	 *  ł͎M݂̔M.
+ 	 */
+ 	/*
+ 	 *  MʒmR[obN[`ĂяoD
+ 	 */
+ 	rx600_uart_irdy_rcv(p_siopcb->exinf);
+ }
+ 
diff -cr --new-file 1.9.1/asp/pdic/renesas/scic.h~ ASPs/asp/pdic/renesas/scic.h~
*** 1.9.1/asp/pdic/renesas/scic.h~	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/renesas/scic.h~	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,129 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  L쌠҂́Cȉ(1)`(4)̏𖞂ꍇɌC{\tgEF
+  *  Ai{\tgEFAς̂܂ށDȉjgpEE
+  *  ρEĔzziȉCpƌĂԁj邱Ƃ𖳏ŋD
+  *  (1) {\tgEFA\[XR[ȟ`ŗpꍇɂ́CL̒
+  *      \C̗pщL̖ۏ؋K肪Ĉ܂܂̌`Ń\[
+  *      XR[hɊ܂܂Ă邱ƁD
+  *  (2) {\tgEFACCu`ȂǁC̃\tgEFAJɎg
+  *      pł`ōĔzzꍇɂ́CĔzzɔhLgip
+  *      ҃}jAȂǁjɁCL̒쌠\C̗pщL
+  *      ̖ۏ؋Kfڂ邱ƁD
+  *  (3) {\tgEFAC@ɑgݍނȂǁC̃\tgEFAJɎg
+  *      płȂ`ōĔzzꍇɂ́Ĉꂩ̏𖞂
+  *      ƁD
+  *    (a) ĔzzɔhLgip҃}jAȂǁjɁCL̒
+  *        쌠\C̗pщL̖ۏ؋Kfڂ邱ƁD
+  *    (b) Ĕzž`ԂCʂɒ߂@ɂāCTOPPERSvWFNg
+  *        񍐂邱ƁD
+  *  (4) {\tgEFA̗pɂ蒼ړI܂͊ԐړIɐ邢Ȃ鑹
+  *      QCL쌠҂TOPPERSvWFNgƐӂ邱ƁD
+  *      ܂C{\tgEFÃ[U܂̓Gh[ÛȂ闝
+  *      RɊÂCL쌠҂TOPPERSvWFNg
+  *      Ɛӂ邱ƁD
+  * 
+  *  {\tgEFÁCۏ؂Œ񋟂Ă̂łDL쌠҂
+  *  TOPPERSvWFNǵC{\tgEFAɊւāC̎gpړI
+  *  ɑ΂K܂߂āCȂۏ؂sȂD܂C{\tgEF
+  *  A̗pɂ蒼ړI܂͊ԐړIɐȂ鑹QɊւĂC
+  *  ̐ӔC𕉂ȂD
+  * 
+  */
+ 
+ /*
+  *  RX610 UARTp ȈSIOhCo
+  */
+ 
+ #ifndef TOPPERS_RX610_UART_H
+ #define TOPPERS_RX610_UART_H
+ 
+ /* w\ȃNbN\[X */
+ #define CLK_F1	UINT_C(0x00)
+ #define CLK_F4	UINT_C(0x01)
+ #define CLK_F16	UINT_C(0x02)
+ #define CLK_F64	UINT_C(0x03)
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  VAI/O|[gǗubN̒`
+  */
+ typedef struct sio_port_control_block	SIOPCB;
+ 
+ /*
+  *  R[obN[`̎ʔԍ
+  */
+ #define SIO_RDY_SND    (1U)        /* M\R[obN */
+ #define SIO_RDY_RCV    (2U)        /* MʒmR[obN */
+ 
+ /*
+  *  SIOhCȍ[`
+  */
+ extern void rx600_uart_initialize(void);
+ 
+ /*
+  * J[lÑoi[o͗p̏
+  */
+ extern void rx600_uart_init(ID siopid , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  VAI/O|[gւ̃|[Oł̏o
+  */
+ extern void rx600_uart_pol_putc(char c, ID siopid);
+ 
+ /*
+  *  VAI/O|[g̃I[v
+  */
+ extern SIOPCB *rx600_uart_opn_por
+ 	(ID siopid, intptr_t exinf , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  VAI/O|[g̃N[Y
+  */
+ extern void rx600_uart_cls_por(SIOPCB *p_siopcb);
+ 
+ /*
+  *  VAI/O|[gւ̕M
+  */
+ extern bool_t rx600_uart_snd_chr(SIOPCB *p_siopcb, char c);
+ 
+ /*
+  *  VAI/O|[g̕M
+  */
+ extern int_t rx600_uart_rcv_chr(SIOPCB *p_siopcb);
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋
+  */
+ extern void  rx600_uart_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋֎~
+  */
+ extern void rx600_uart_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  SIO̊݃T[rX[`
+  */
+ extern void rx600_uart_tx_isr(ID siopid);
+ extern void rx600_uart_rx_isr(ID siopid);
+ 
+ /*
+  *  VAI/O|[g̑M\R[obN
+  */
+ extern void rx600_uart_irdy_snd(intptr_t exinf);
+ 
+ /*
+  *  VAI/O|[g̎MʒmR[obN
+  */
+ extern void rx600_uart_irdy_rcv(intptr_t exinf);
+ 
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ #endif /* TOPPERS_RX610_UART_H */
diff -cr --new-file 1.9.1/asp/pdic/renesas/scic_uart.c ASPs/asp/pdic/renesas/scic_uart.c
*** 1.9.1/asp/pdic/renesas/scic_uart.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/renesas/scic_uart.c	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,519 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ 
+ /*
+  *   Renesas SCIc(UART)用 簡易SIOドライバ
+  */
+ 
+ #include <sil.h>
+ #include <kernel.h>
+ #include <t_syslog.h>
+ #include "target_syssvc.h"
+ #include "scic_uart.h"
+ 
+ /* シリアルモードレジスタ（SMR) */
+ #define CKS			UINT_C(0x03)
+ #define STOP		UINT_C(0x08)
+ #define PM			UINT_C(0x10)
+ #define PE			UINT_C(0x20)
+ #define CHR			UINT_C(0x40)
+ #define CM			UINT_C(0x80)
+ #define ASYNC_7BIT	UINT_C(0x00)
+ #define ASYNC_8BIT	UINT_C(0x40)
+ 
+ /* シリアルコントロールレジスタ（SCR) */
+ #define CKE			UINT_C(0x03)
+ #define TEIE		UINT_C(0x04)
+ #define RE			UINT_C(0x10)
+ #define TE			UINT_C(0x20)
+ #define RIE			UINT_C(0x40)
+ #define TIE			UINT_C(0x80)
+ 
+ /* シリアルステータスレジスタ（SSR） */
+ #define TEND		UINT_C(0x04)
+ #define PER			UINT_C(0x08)
+ #define FER			UINT_C(0x10)
+ #define ORER		UINT_C(0x20)
+ 
+ /* シリアル拡張モードレジスタ（SEMR) */
+ #define ACS0		UINT_C(0x01)
+ #define ABCS		UINT_C(0x10)
+ 
+ #define SCI_SCR_FLG_ENABLE	(RE | TE)
+ #define SCI_SMR_FLG_ENABLE	(STOP | PM | PE | CHR | CM)
+ 
+ /*
+  *  シリアルI/Oポート初期化ブロックの定義
+  */
+ typedef struct sio_port_initialization_block {
+ 	volatile uint8_t	*ctlreg;		/* シリアルコントロールレジスタ（SCR) */
+ 	volatile uint8_t	*modereg;		/* シリアルモードレジスタ（SMR) */
+ 	volatile uint8_t	*extmodereg;	/* シリアル拡張モードレジスタ（SEMR) */	
+ 	volatile uint8_t	*statusreg;		/* シリアルステータスレジスタ（SSR） */
+ 	volatile uint8_t	*tdreg;			/* トランスミットデータレジスタ（TDR)*/
+ 	volatile uint8_t	*rdreg;			/* レシーブデータレジスタ（RDR) */
+ 	volatile uint8_t	*bitratereg;	/* ビットレートレジスタ（BRR) */
+ 	volatile uint32_t	*mstpcrreg;		/* モジュールストップコントロールレジスタ（MSTPCR） */
+ 	volatile uint8_t	*ssrreg;		/* ステータスレジスタ */
+ 	uint8_t				tx_intno;		/* 送信（データエンプティ）割り込み番号 */
+ 	uint8_t				rx_intno;		/* 受信（データフル）割り込み番号 */
+ 	uint8_t				te_intno;		/* 送信（終了）割り込み番号 */
+ 	uint8_t				sci_no;			/* SCIの番号(SCI0〜SCI6) */
+ 	uint32_t			mstpcr_offset;	/* MSTPCRの対応するビットオフセット */
+ } SIOPINIB;
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックの定義
+  */
+ struct sio_port_control_block {
+ 	const SIOPINIB	*p_siopinib; 				/* シリアルI/Oポート初期化ブロック */
+ 	intptr_t 	exinf;			 				/* 拡張情報 */
+ 	bool_t		openflag;						/* オープン済みフラグ */
+ 	bool_t		sendflag;						/* 送信割込みイネーブルフラグ */
+ 	bool_t		getready;						/* 文字を受信した状態 */
+ 	bool_t		putready;						/* 文字を送信できる状態 */
+ 	bool_t		is_initialized; 				/* デバイス初期化済みフラグ */
+ };
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックのエリア
+  */
+ static SIOPCB	siopcb_table[TNUM_SIOP];
+ 
+ /* レジスタテーブル */
+ static const SIOPINIB siopinib_table[TNUM_SIOP] =
+ {
+ 	{
+ 		(volatile uint8_t *)SCI0_SCR_ADDR,
+ 		(volatile uint8_t *)SCI0_SMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		(volatile uint8_t *)SCI0_TDR_ADDR,
+ 		(volatile uint8_t *)SCI0_RDR_ADDR,
+ 		(volatile uint8_t *)SCI0_BRR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		INT_SCI0_TXI0,
+ 		INT_SCI0_RXI0,
+ 		INT_SCI0_TEI0,
+ 		0,
+ 		SYSTEM_MSTPCRB_MSTPB31_BIT,
+ 	} ,			/* UART0 */
+ #if TNUM_SIOP > 1
+ 	{
+ 		(volatile uint8_t *)SCI1_SCR_ADDR,
+ 		(volatile uint8_t *)SCI1_SMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		(volatile uint8_t *)SCI1_TDR_ADDR,
+ 		(volatile uint8_t *)SCI1_RDR_ADDR,
+ 		(volatile uint8_t *)SCI1_BRR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		INT_SCI1_TXI1,
+ 		INT_SCI1_RXI1,
+ 		INT_SCI1_TEI1,
+ 		1,
+ 		SYSTEM_MSTPCRB_MSTPB30_BIT,
+ 	} ,			/* UART1 */
+ #endif
+ #if TNUM_SIOP > 2
+ 	{
+ 		(volatile uint8_t *)SCI2_SCR_ADDR,
+ 		(volatile uint8_t *)SCI2_SMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		(volatile uint8_t *)SCI2_TDR_ADDR,
+ 		(volatile uint8_t *)SCI2_RDR_ADDR,
+ 		(volatile uint8_t *)SCI2_BRR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		INT_SCI2_TXI2,
+ 		INT_SCI2_RXI2,
+ 		INT_SCI2_TEI2,
+ 		2,
+ 		SYSTEM_MSTPCRB_MSTPB29_BIT,
+ 	} ,			/* UART2 */
+ #endif
+ #if TNUM_SIOP > 3
+ 	{
+ 		(volatile uint8_t *)SCI3_SCR_ADDR,
+ 		(volatile uint8_t *)SCI3_SMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		(volatile uint8_t *)SCI3_TDR_ADDR,
+ 		(volatile uint8_t *)SCI3_RDR_ADDR,
+ 		(volatile uint8_t *)SCI3_BRR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		INT_SCI3_TXI3,
+ 		INT_SCI3_RXI3,
+ 		INT_SCI3_TEI3,
+ 		3,
+ 		SYSTEM_MSTPCRB_MSTPB28_BIT,
+ 	} ,			/* UART3 */
+ #endif
+ #if TNUM_SIOP > 4
+ 	{
+ 		(volatile uint8_t *)SCI4_SCR_ADDR,
+ 		(volatile uint8_t *)SCI4_SMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		(volatile uint8_t *)SCI4_TDR_ADDR,
+ 		(volatile uint8_t *)SCI4_RDR_ADDR,
+ 		(volatile uint8_t *)SCI4_BRR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		INT_SCI4_TXI4,
+ 		INT_SCI4_RXI4,
+ 		INT_SCI4_TEI4,
+ 		4,
+ 		SYSTEM_MSTPCRB_MSTPB27_BIT,
+ 	} ,		/* UART4 */
+ #endif
+ #if TNUM_SIOP > 5
+ 	{
+ 		(volatile uint8_t *)SCI5_SCR_ADDR,
+ 		(volatile uint8_t *)SCI5_SMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		(volatile uint8_t *)SCI5_TDR_ADDR,
+ 		(volatile uint8_t *)SCI5_RDR_ADDR,
+ 		(volatile uint8_t *)SCI5_BRR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		INT_SCI5_TXI5,
+ 		INT_SCI5_RXI5,
+ 		INT_SCI5_TEI5,
+ 		5,
+ 		SYSTEM_MSTPCRB_MSTPB26_BIT,
+ 	} ,		/* UART5 */
+ #endif
+ #if TNUM_SIOP > 6
+ 	{
+ 		(volatile uint8_t *)SCI6_SCR_ADDR,
+ 		(volatile uint8_t *)SCI6_SMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		(volatile uint8_t *)SCI6_TDR_ADDR,
+ 		(volatile uint8_t *)SCI6_RDR_ADDR,
+ 		(volatile uint8_t *)SCI6_BRR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		INT_SCI6_TXI6,
+ 		INT_SCI6_RXI6,
+ 		INT_SCI6_TEI6,
+ 		6,
+ 		SYSTEM_MSTPCRB_MSTPB25_BIT,
+ 	} ,		/* UART6 */
+ #endif
+ };
+ 
+ /*
+  *  シリアルI/OポートIDから管理ブロックを取り出すためのマクロ
+  */
+ #define INDEX_SIOP(siopid)	 ((uint_t)((siopid) - 1))
+ #define get_siopcb(siopid)	 (&(siopcb_table[INDEX_SIOP(siopid)]))
+ #define get_siopinib(siopid) (&(siopinib_table[INDEX_SIOP(siopid)]))
+ 
+ 
+ /*
+  *  SIOドライバのシリアルモードレジスタ(SMR)
+  */
+ static void
+ scic_uart_setmode(const SIOPINIB *p_siopinib, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	uint8_t i;
+ 
+ 	/*
+ 	 *  SCIドライバの初期化ルーチン
+ 	 */
+ 
+ 	/*
+ 	 *  割り込み要求先レジスタの設定(ISELRi)
+ 	 *
+ 	 *  リセット値と同じ値を設定することになるため,
+ 	 *  処理は省略する.
+ 	 */
+ 
+ 	/*
+ 	 *  モジュールストップ機能の設定(SCI1)
+ 	 */
+ 	sil_wrw_mem((void *)p_siopinib->mstpcrreg, (~p_siopinib->mstpcr_offset));
+ 
+ 	/* 送受信禁止, SCKn端子は入出力ポートとして使用 */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 0x00U);
+ 
+ 	/* クロック選択ビット(SMR.CKS[1:0]ビットを設定) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 					sil_reb_mem((void *)p_siopinib->modereg) | clksrc);
+ 
+ 	/* SMRに送信／ 受信フォーマットを設定) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 			sil_reb_mem((void *)p_siopinib->modereg) & (~SCI_SMR_FLG_ENABLE));
+ 
+ 	/* ビットレートを設定 */
+ 	sil_wrb_mem((void *)p_siopinib->bitratereg, bitrate);
+ 
+ 	/* ビット期間(基本クロック16サイクルの期間が1ビット期間となる) */
+ 	while(i < 16){
+ 		i++;
+ 	}
+ 
+ 	/* 送受信許可 */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 			(sil_reb_mem((void *)p_siopinib->ctlreg) | SCI_SCR_FLG_ENABLE));
+ }
+ 
+ 
+ /*
+  *  SIOドライバの初期化ルーチン
+  */
+ void
+ scic_uart_initialize(void)
+ {
+ 	SIOPCB	*p_siopcb;
+ 	uint_t	i;
+ 
+ 	/*
+ 	 *  シリアルI/Oポート管理ブロックの初期化
+ 	 */
+ 	for (p_siopcb = siopcb_table, i = 0; i < TNUM_SIOP; p_siopcb++, i++){
+ 		p_siopcb->p_siopinib = &(siopinib_table[i]);
+ 		p_siopcb->openflag = false;
+ 		p_siopcb->sendflag = false;
+ 	}
+ }
+ 
+ /*
+  *  カーネル起動時のバナー出力用の初期化
+  */
+ void
+ scic_uart_init(ID siopid, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb   = get_siopcb(siopid);
+ 	const SIOPINIB  *p_siopinib = get_siopinib(siopid);
+ 	/*  この時点では、p_siopcb->p_siopinibは初期化されていない  */
+ 
+ 	/*  二重初期化の防止  */
+ 	p_siopcb->is_initialized = true;
+ 
+ 	/*  ハードウェアの初期化処理と送信許可  */
+ 	scic_uart_setmode(p_siopinib , bitrate, clksrc);
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 					(uint8_t)(sil_reb_mem((void *)p_siopinib->ctlreg) | TE));
+ }
+ 
+ 
+ /*
+  *  シリアルI/Oポートへのポーリングでの出力
+  */
+ void
+ scic_uart_pol_putc(char c, ID siopid)
+ {
+ 	const SIOPINIB *p_siopinib;
+ 
+ 	p_siopinib = get_siopinib(siopid);
+ 
+ 	/*
+ 	 *  送信レジスタが空になるまで待つ
+ 	 */
+ 	while((sil_reb_mem(
+ 			(void *)p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) == 0U);
+ 
+ 	sil_wrb_mem((void *)p_siopinib->tdreg, (uint8_t)c);
+ }
+ 
+ /*
+  *  シリアルI/Oポートのオープン
+  */
+ SIOPCB *
+ scic_uart_opn_por
+ 	(ID siopid, intptr_t exinf, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb;
+ 	const SIOPINIB  *p_siopinib;
+ 
+ 	p_siopcb = get_siopcb(siopid);
+ 	p_siopinib = p_siopcb->p_siopinib;
+ 
+ 	/*
+ 	 *  ハードウェアの初期化
+ 	 *
+ 	 *  既に初期化している場合は, 二重に初期化しない.
+ 	 */
+ 	if(!(p_siopcb->is_initialized)){
+ 		scic_uart_setmode(p_siopinib, bitrate, clksrc);
+ 		p_siopcb->is_initialized = true;
+ 	}
+ 
+ 	p_siopcb->exinf = exinf;
+ 	p_siopcb->getready = p_siopcb->putready = false;
+ 	p_siopcb->openflag = true;
+ 
+     return (p_siopcb);
+ }
+ 
+ /*
+  *  シリアルI/Oポートのクローズ
+  */
+ void
+ scic_uart_cls_por(SIOPCB *p_siopcb)
+ {
+ 	/*
+ 	 *  UART停止
+ 	 */
+ 	sil_wrh_mem((void *)p_siopcb->p_siopinib->ctlreg, 0x00U);
+ 	p_siopcb->openflag = false;
+ 	p_siopcb->is_initialized = false;
+ }
+ 
+ /*
+  *  シリアルI/Oポートへの文字送信
+  */
+ bool_t
+ scic_uart_snd_chr(SIOPCB *p_siopcb, char c)
+ {
+ 	bool_t ercd = false;
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0){
+ 		sil_wrb_mem((void *)p_siopcb->p_siopinib->tdreg, (uint8_t)c);
+ 		ercd = true;
+ 	}
+ 
+ 	return ercd;
+ }
+ 
+ /*
+  *  シリアルI/Oポートからの文字受信
+  */
+ int_t
+ scic_uart_rcv_chr(SIOPCB *p_siopcb)
+ {
+ 	int_t c = -1;
+ 
+ 	/*
+ 	 *  受信フラグがONのときのみ受信バッファから文字を取得する.
+ 	 *  これは, ポーリング受信に対応するためである.
+ 	 *  しかし, SCICでは受信フラグがないこと, システムサービス
+ 	 *  では受信割込みの中からしかデータを受信しに来ないことから, 常に
+ 	 *  受信バッファから文字を取得する.
+ 	 */
+ 	c = (int)(sil_reb_mem((void *)p_siopcb->p_siopinib->rdreg));
+ 
+ 	return c;
+ }
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの許可
+  */
+ void
+ scic_uart_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_TEIE_BIT));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_RIE_BIT));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの禁止
+  */
+ void
+ scic_uart_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_TEIE_BIT)));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_RIE_BIT)));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  SIOの割込みサービスルーチン
+  */
+ void
+ scic_uart_tx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0U){
+ 		/*
+ 		 *  送信可能コールバックルーチンを呼び出す．
+ 		 */
+ 		scic_uart_irdy_snd(p_siopcb->exinf);
+ 	}
+ }
+ 
+ void
+ scic_uart_rx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	/*
+ 	 *  受信フラグがONのときのみ受信通知コールバックルーチンを呼び出す.
+ 	 *  しかし, SCICでは受信フラグがないため, 常に受信通知
+ 	 *  コールバックルーチンを呼び出す.
+ 	 *  ここでは受信割込みの発生を信じる.
+ 	 */
+ 	/*
+ 	 *  受信通知コールバックルーチンを呼び出す．
+ 	 */
+ 	scic_uart_irdy_rcv(p_siopcb->exinf);
+ }
+ 
diff -cr --new-file 1.9.1/asp/pdic/renesas/scic_uart.c~ ASPs/asp/pdic/renesas/scic_uart.c~
*** 1.9.1/asp/pdic/renesas/scic_uart.c~	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/renesas/scic_uart.c~	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,535 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  L쌠҂́Cȉ(1)`(4)̏𖞂ꍇɌC{\tgEF
+  *  Ai{\tgEFAς̂܂ށDȉjgpEE
+  *  ρEĔzziȉCpƌĂԁj邱Ƃ𖳏ŋD
+  *  (1) {\tgEFA\[XR[ȟ`ŗpꍇɂ́CL̒
+  *      \C̗pщL̖ۏ؋K肪Ĉ܂܂̌`Ń\[
+  *      XR[hɊ܂܂Ă邱ƁD
+  *  (2) {\tgEFACCu`ȂǁC̃\tgEFAJɎg
+  *      pł`ōĔzzꍇɂ́CĔzzɔhLgip
+  *      ҃}jAȂǁjɁCL̒쌠\C̗pщL
+  *      ̖ۏ؋Kfڂ邱ƁD
+  *  (3) {\tgEFAC@ɑgݍނȂǁC̃\tgEFAJɎg
+  *      płȂ`ōĔzzꍇɂ́Ĉꂩ̏𖞂
+  *      ƁD
+  *    (a) ĔzzɔhLgip҃}jAȂǁjɁCL̒
+  *        쌠\C̗pщL̖ۏ؋Kfڂ邱ƁD
+  *    (b) Ĕzž`ԂCʂɒ߂@ɂāCTOPPERSvWFNg
+  *        񍐂邱ƁD
+  *  (4) {\tgEFA̗pɂ蒼ړI܂͊ԐړIɐ邢Ȃ鑹
+  *      QCL쌠҂TOPPERSvWFNgƐӂ邱ƁD
+  *      ܂C{\tgEFÃ[U܂̓Gh[ÛȂ闝
+  *      RɊÂCL쌠҂TOPPERSvWFNg
+  *      Ɛӂ邱ƁD
+  * 
+  *  {\tgEFÁCۏ؂Œ񋟂Ă̂łDL쌠҂
+  *  TOPPERSvWFNǵC{\tgEFAɊւāC̎gpړI
+  *  ɑ΂K܂߂āCȂۏ؂sȂD܂C{\tgEF
+  *  A̗pɂ蒼ړI܂͊ԐړIɐȂ鑹QɊւĂC
+  *  ̐ӔC𕉂ȂD
+  * 
+  */
+ 
+ 
+ /*
+  *   Renesas SCIc(UART)p ȈSIOhCo
+  */
+ 
+ #include <sil.h>
+ #include <kernel.h>
+ #include <t_syslog.h>
+ #include "target_syssvc.h"
+ #include "scic_uart.h"
+ 
+ /* VA[hWX^iSMR) */
+ #define CKS			UINT_C(0x03)
+ #define STOP		UINT_C(0x08)
+ #define PM			UINT_C(0x10)
+ #define PE			UINT_C(0x20)
+ #define CHR			UINT_C(0x40)
+ #define CM			UINT_C(0x80)
+ #define ASYNC_7BIT	UINT_C(0x00)
+ #define ASYNC_8BIT	UINT_C(0x40)
+ 
+ /* VARg[WX^iSCR) */
+ #define CKE			UINT_C(0x03)
+ #define TEIE		UINT_C(0x04)
+ #define RE			UINT_C(0x10)
+ #define TE			UINT_C(0x20)
+ #define RIE			UINT_C(0x40)
+ #define TIE			UINT_C(0x80)
+ 
+ /* VAXe[^XWX^iSSRj */
+ #define TEND		UINT_C(0x04)
+ #define PER			UINT_C(0x08)
+ #define FER			UINT_C(0x10)
+ #define ORER		UINT_C(0x20)
+ 
+ /* VAg[hWX^iSEMR) */
+ #define ACS0		UINT_C(0x01)
+ #define ABCS		UINT_C(0x10)
+ 
+ #define SCI_SCR_FLG_ENABLE	(RE | TE)
+ #define SCI_SMR_FLG_ENABLE	(STOP | PM | PE | CHR | CM)
+ 
+ /*
+  *  VAI/O|[gubN̒`
+  */
+ typedef struct sio_port_initialization_block {
+ 	volatile uint8_t	*ctlreg;		/* VARg[WX^iSCR) */
+ 	volatile uint8_t	*modereg;		/* VA[hWX^iSMR) */
+ 	volatile uint8_t	*extmodereg;	/* VAg[hWX^iSEMR) */	
+ 	volatile uint8_t	*statusreg;		/* VAXe[^XWX^iSSRj */
+ 	volatile uint8_t	*tdreg;			/* gX~bgf[^WX^iTDR)*/
+ 	volatile uint8_t	*rdreg;			/* V[uf[^WX^iRDR) */
+ 	volatile uint8_t	*bitratereg;	/* rbg[gWX^iBRR) */
+ 	volatile uint8_t	*porticrreg;	/* ̓obt@Rg[WX^iICR) */
+ 	volatile uint32_t	*mstpcrreg;		/* W[XgbvRg[WX^iMSTPCRj */
+ 	volatile uint8_t	*ssrreg;		/* Xe[^XWX^ */
+ 	volatile uint8_t	*rxiirreg;		/* RXIpݗvWX^ */
+ 	uint8_t				tx_intno;		/* Mif[^GveBj荞ݔԍ */
+ 	uint8_t				rx_intno;		/* Mif[^tj荞ݔԍ */
+ 	uint8_t				te_intno;		/* MiIj荞ݔԍ */
+ 	uint8_t				sci_no;			/* SCI̔ԍ(SCI0`SCI6) */
+ 	uint32_t			mstpcr_offset;	/* MSTPCȒΉrbgItZbg */
+ } SIOPINIB;
+ 
+ /*
+  *  VAI/O|[gǗubN̒`
+  */
+ struct sio_port_control_block {
+ 	const SIOPINIB	*p_siopinib; 				/* VAI/O|[gubN */
+ 	intptr_t 	exinf;			 				/* g */
+ 	bool_t		openflag;						/* I[vς݃tO */
+ 	bool_t		sendflag;						/* M݃Cl[utO */
+ 	bool_t		getready;						/* M */
+ 	bool_t		putready;						/* 𑗐Mł */
+ 	bool_t		is_initialized; 				/* foCXς݃tO */
+ };
+ 
+ /*
+  *  VAI/O|[gǗubÑGA
+  */
+ static SIOPCB	siopcb_table[TNUM_SIOP];
+ 
+ /* WX^e[u */
+ static const SIOPINIB siopinib_table[TNUM_SIOP] =
+ {
+ 	{
+ 		(volatile uint8_t *)SCI0_SCR_ADDR,
+ 		(volatile uint8_t *)SCI0_SMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		(volatile uint8_t *)SCI0_TDR_ADDR,
+ 		(volatile uint8_t *)SCI0_RDR_ADDR,
+ 		(volatile uint8_t *)SCI0_BRR_ADDR,
+ 		(volatile uint8_t *)PORT2_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR215_ADDR,
+ 		INT_SCI0_TXI0,
+ 		INT_SCI0_RXI0,
+ 		INT_SCI0_TEI0,
+ 		0,
+ 		SYSTEM_MSTPCRB_MSTPB31_BIT,
+ 	} ,			/* UART0 */
+ #if TNUM_SIOP > 1
+ 	{
+ 		(volatile uint8_t *)SCI1_SCR_ADDR,
+ 		(volatile uint8_t *)SCI1_SMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		(volatile uint8_t *)SCI1_TDR_ADDR,
+ 		(volatile uint8_t *)SCI1_RDR_ADDR,
+ 		(volatile uint8_t *)SCI1_BRR_ADDR,
+ 		(volatile uint8_t *)PORT2_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR219_ADDR,
+ 		INT_SCI1_TXI1,
+ 		INT_SCI1_RXI1,
+ 		INT_SCI1_TEI1,
+ 		1,
+ 		SYSTEM_MSTPCRB_MSTPB30_BIT,
+ 	} ,			/* UART1 */
+ #endif
+ #if TNUM_SIOP > 2
+ 	{
+ 		(volatile uint8_t *)SCI2_SCR_ADDR,
+ 		(volatile uint8_t *)SCI2_SMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		(volatile uint8_t *)SCI2_TDR_ADDR,
+ 		(volatile uint8_t *)SCI2_RDR_ADDR,
+ 		(volatile uint8_t *)SCI2_BRR_ADDR,
+ 		(volatile uint8_t *)PORT1_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR223_ADDR,
+ 		INT_SCI2_TXI2,
+ 		INT_SCI2_RXI2,
+ 		INT_SCI2_TEI2,
+ 		2,
+ 		SYSTEM_MSTPCRB_MSTPB29_BIT,
+ 	} ,			/* UART2 */
+ #endif
+ #if TNUM_SIOP > 3
+ 	{
+ 		(volatile uint8_t *)SCI3_SCR_ADDR,
+ 		(volatile uint8_t *)SCI3_SMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		(volatile uint8_t *)SCI3_TDR_ADDR,
+ 		(volatile uint8_t *)SCI3_RDR_ADDR,
+ 		(volatile uint8_t *)SCI3_BRR_ADDR,
+ 		(volatile uint8_t *)PORT1_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR227_ADDR,
+ 		INT_SCI3_TXI3,
+ 		INT_SCI3_RXI3,
+ 		INT_SCI3_TEI3,
+ 		3,
+ 		SYSTEM_MSTPCRB_MSTPB28_BIT,
+ 	} ,			/* UART3 */
+ #endif
+ #if TNUM_SIOP > 4
+ 	{
+ 		(volatile uint8_t *)SCI4_SCR_ADDR,
+ 		(volatile uint8_t *)SCI4_SMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		(volatile uint8_t *)SCI4_TDR_ADDR,
+ 		(volatile uint8_t *)SCI4_RDR_ADDR,
+ 		(volatile uint8_t *)SCI4_BRR_ADDR,
+ 		(volatile uint8_t *)PORT0_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR231_ADDR,
+ 		INT_SCI4_TXI4,
+ 		INT_SCI4_RXI4,
+ 		INT_SCI4_TEI4,
+ 		4,
+ 		SYSTEM_MSTPCRB_MSTPB27_BIT,
+ 	} ,		/* UART4 */
+ #endif
+ #if TNUM_SIOP > 5
+ 	{
+ 		(volatile uint8_t *)SCI5_SCR_ADDR,
+ 		(volatile uint8_t *)SCI5_SMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		(volatile uint8_t *)SCI5_TDR_ADDR,
+ 		(volatile uint8_t *)SCI5_RDR_ADDR,
+ 		(volatile uint8_t *)SCI5_BRR_ADDR,
+ 		(volatile uint8_t *)PORTC_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR235_ADDR,
+ 		INT_SCI5_TXI5,
+ 		INT_SCI5_RXI5,
+ 		INT_SCI5_TEI5,
+ 		5,
+ 		SYSTEM_MSTPCRB_MSTPB26_BIT,
+ 	} ,		/* UART5 */
+ #endif
+ #if TNUM_SIOP > 6
+ 	{
+ 		(volatile uint8_t *)SCI6_SCR_ADDR,
+ 		(volatile uint8_t *)SCI6_SMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		(volatile uint8_t *)SCI6_TDR_ADDR,
+ 		(volatile uint8_t *)SCI6_RDR_ADDR,
+ 		(volatile uint8_t *)SCI6_BRR_ADDR,
+ 		(volatile uint8_t *)PORT0_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR239_ADDR,
+ 		INT_SCI6_TXI6,
+ 		INT_SCI6_RXI6,
+ 		INT_SCI6_TEI6,
+ 		6,
+ 		SYSTEM_MSTPCRB_MSTPB25_BIT,
+ 	} ,		/* UART6 */
+ #endif
+ };
+ 
+ /*
+  *  VAI/O|[gIDǗubNo߂̃}N
+  */
+ #define INDEX_SIOP(siopid)	 ((uint_t)((siopid) - 1))
+ #define get_siopcb(siopid)	 (&(siopcb_table[INDEX_SIOP(siopid)]))
+ #define get_siopinib(siopid) (&(siopinib_table[INDEX_SIOP(siopid)]))
+ 
+ 
+ /*
+  *  SIOhCõVA[hWX^(SMR)
+  */
+ static void
+ scic_uart_setmode(const SIOPINIB *p_siopinib, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	uint8_t i;
+ 
+ 	/*
+ 	 *  SCIhCȍ[`
+ 	 */
+ 
+ 	/*
+ 	 *  荞ݗv惌WX^̐ݒ(ISELRi)
+ 	 *
+ 	 *  ZbglƓlݒ肷邱ƂɂȂ邽,
+ 	 *  ͏ȗ.
+ 	 */
+ 
+ 	/*
+ 	 *  W[Xgbv@\̐ݒ(SCI1)
+ 	 */
+ 	sil_wrw_mem((void *)p_siopinib->mstpcrreg, (~p_siopinib->mstpcr_offset));
+ 
+ 	/* M֎~, SCKn[q͓o̓|[gƂĎgp */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 0x00U);
+ 
+ 	/* NbNIrbg(SMR.CKS[1:0]rbgݒ) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 					sil_reb_mem((void *)p_siopinib->modereg) | clksrc);
+ 
+ 	/* SMRɑM^ MtH[}bgݒ) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 			sil_reb_mem((void *)p_siopinib->modereg) & (~SCI_SMR_FLG_ENABLE));
+ 
+ 	/* rbg[gݒ */
+ 	sil_wrb_mem((void *)p_siopinib->bitratereg, bitrate);
+ 
+ 	/* rbg({NbN16TCN̊Ԃ1rbgԂƂȂ) */
+ 	while(i < 16){
+ 		i++;
+ 	}
+ 
+ 	/* M */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 			(sil_reb_mem((void *)p_siopinib->ctlreg) | SCI_SCR_FLG_ENABLE));
+ }
+ 
+ 
+ /*
+  *  SIOhCȍ[`
+  */
+ void
+ scic_uart_initialize(void)
+ {
+ 	SIOPCB	*p_siopcb;
+ 	uint_t	i;
+ 
+ 	/*
+ 	 *  VAI/O|[gǗubN̏
+ 	 */
+ 	for (p_siopcb = siopcb_table, i = 0; i < TNUM_SIOP; p_siopcb++, i++){
+ 		p_siopcb->p_siopinib = &(siopinib_table[i]);
+ 		p_siopcb->openflag = false;
+ 		p_siopcb->sendflag = false;
+ 	}
+ }
+ 
+ /*
+  *  J[lÑoi[o͗p̏
+  */
+ void
+ scic_uart_init(ID siopid, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb   = get_siopcb(siopid);
+ 	const SIOPINIB  *p_siopinib = get_siopinib(siopid);
+ 	/*  ̎_ł́Ap_siopcb->p_siopinib͏ĂȂ  */
+ 
+ 	/*  d̖h~  */
+ 	p_siopcb->is_initialized = true;
+ 
+ 	/*  n[hEFȀƑM  */
+ 	scic_uart_setmode(p_siopinib , bitrate, clksrc);
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 					(uint8_t)(sil_reb_mem((void *)p_siopinib->ctlreg) | TE));
+ }
+ 
+ 
+ /*
+  *  VAI/O|[gւ̃|[Oł̏o
+  */
+ void
+ scic_uart_pol_putc(char c, ID siopid)
+ {
+ 	const SIOPINIB *p_siopinib;
+ 
+ 	p_siopinib = get_siopinib(siopid);
+ 
+ 	/*
+ 	 *  MWX^ɂȂ܂ő҂
+ 	 */
+ 	while((sil_reb_mem(
+ 			(void *)p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) == 0U);
+ 
+ 	sil_wrb_mem((void *)p_siopinib->tdreg, (uint8_t)c);
+ }
+ 
+ /*
+  *  VAI/O|[g̃I[v
+  */
+ SIOPCB *
+ scic_uart_opn_por
+ 	(ID siopid, intptr_t exinf, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb;
+ 	const SIOPINIB  *p_siopinib;
+ 
+ 	p_siopcb = get_siopcb(siopid);
+ 	p_siopinib = p_siopcb->p_siopinib;
+ 
+ 	/*
+ 	 *  n[hEFȀ
+ 	 *
+ 	 *  ɏĂꍇ, dɏȂ.
+ 	 */
+ 	if(!(p_siopcb->is_initialized)){
+ 		scic_uart_setmode(p_siopinib, bitrate, clksrc);
+ 		p_siopcb->is_initialized = true;
+ 	}
+ 
+ 	p_siopcb->exinf = exinf;
+ 	p_siopcb->getready = p_siopcb->putready = false;
+ 	p_siopcb->openflag = true;
+ 
+     return (p_siopcb);
+ }
+ 
+ /*
+  *  VAI/O|[g̃N[Y
+  */
+ void
+ scic_uart_cls_por(SIOPCB *p_siopcb)
+ {
+ 	/*
+ 	 *  UART~
+ 	 */
+ 	sil_wrh_mem((void *)p_siopcb->p_siopinib->ctlreg, 0x00U);
+ 	p_siopcb->openflag = false;
+ 	p_siopcb->is_initialized = false;
+ }
+ 
+ /*
+  *  VAI/O|[gւ̕M
+  */
+ bool_t
+ scic_uart_snd_chr(SIOPCB *p_siopcb, char c)
+ {
+ 	bool_t ercd = false;
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0){
+ 		sil_wrb_mem((void *)p_siopcb->p_siopinib->tdreg, (uint8_t)c);
+ 		ercd = true;
+ 	}
+ 
+ 	return ercd;
+ }
+ 
+ /*
+  *  VAI/O|[g̕M
+  */
+ int_t
+ scic_uart_rcv_chr(SIOPCB *p_siopcb)
+ {
+ 	int_t c = -1;
+ 
+ 	/*
+ 	 *  MtOON̂Ƃ̂ݎMobt@當擾.
+ 	 *  , |[OMɑΉ邽߂ł.
+ 	 *  , SCICł͎MtOȂ, VXeT[rX
+ 	 *  ł͎M݂̒炵f[^MɗȂƂ, 
+ 	 *  Mobt@當擾.
+ 	 */
+ 	c = (int)(sil_reb_mem((void *)p_siopcb->p_siopinib->rdreg));
+ 
+ 	return c;
+ }
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋
+  */
+ void
+ scic_uart_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_TEIE_BIT));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_RIE_BIT));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋֎~
+  */
+ void
+ scic_uart_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_TEIE_BIT)));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_RIE_BIT)));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  SIO̊݃T[rX[`
+  */
+ void
+ scic_uart_tx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0U){
+ 		/*
+ 		 *  M\R[obN[`ĂяoD
+ 		 */
+ 		scic_uart_irdy_snd(p_siopcb->exinf);
+ 	}
+ }
+ 
+ void
+ scic_uart_rx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	/*
+ 	 *  MtOON̂Ƃ̂ݎMʒmR[obN[`Ăяo.
+ 	 *  , SCICł͎MtOȂ, ɎMʒm
+ 	 *  R[obN[`Ăяo.
+ 	 *  ł͎M݂̔M.
+ 	 */
+ 	/*
+ 	 *  MʒmR[obN[`ĂяoD
+ 	 */
+ 	scic_uart_irdy_rcv(p_siopcb->exinf);
+ }
+ 
diff -cr --new-file 1.9.1/asp/pdic/renesas/scic_uart.h ASPs/asp/pdic/renesas/scic_uart.h
*** 1.9.1/asp/pdic/renesas/scic_uart.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/renesas/scic_uart.h	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,129 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *  RX610 UART用 簡易SIOドライバ
+  */
+ 
+ #ifndef TOPPERS_RX610_UART_H
+ #define TOPPERS_RX610_UART_H
+ 
+ /* 指定可能なクロックソース */
+ #define CLK_F1	UINT_C(0x00)
+ #define CLK_F4	UINT_C(0x01)
+ #define CLK_F16	UINT_C(0x02)
+ #define CLK_F64	UINT_C(0x03)
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックの定義
+  */
+ typedef struct sio_port_control_block	SIOPCB;
+ 
+ /*
+  *  コールバックルーチンの識別番号
+  */
+ #define SIO_RDY_SND    (1U)        /* 送信可能コールバック */
+ #define SIO_RDY_RCV    (2U)        /* 受信通知コールバック */
+ 
+ /*
+  *  SIOドライバの初期化ルーチン
+  */
+ extern void scic_uart_initialize(void);
+ 
+ /*
+  * カーネル起動時のバナー出力用の初期化
+  */
+ extern void scic_uart_init(ID siopid , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  シリアルI/Oポートへのポーリングでの出力
+  */
+ extern void scic_uart_pol_putc(char c, ID siopid);
+ 
+ /*
+  *  シリアルI/Oポートのオープン
+  */
+ extern SIOPCB *scic_uart_opn_por
+ 	(ID siopid, intptr_t exinf , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  シリアルI/Oポートのクローズ
+  */
+ extern void scic_uart_cls_por(SIOPCB *p_siopcb);
+ 
+ /*
+  *  シリアルI/Oポートへの文字送信
+  */
+ extern bool_t scic_uart_snd_chr(SIOPCB *p_siopcb, char c);
+ 
+ /*
+  *  シリアルI/Oポートからの文字受信
+  */
+ extern int_t scic_uart_rcv_chr(SIOPCB *p_siopcb);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの許可
+  */
+ extern void  scic_uart_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの禁止
+  */
+ extern void scic_uart_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  SIOの割込みサービスルーチン
+  */
+ extern void scic_uart_tx_isr(ID siopid);
+ extern void scic_uart_rx_isr(ID siopid);
+ 
+ /*
+  *  シリアルI/Oポートからの送信可能コールバック
+  */
+ extern void scic_uart_irdy_snd(intptr_t exinf);
+ 
+ /*
+  *  シリアルI/Oポートからの受信通知コールバック
+  */
+ extern void scic_uart_irdy_rcv(intptr_t exinf);
+ 
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ #endif /* TOPPERS_RX610_UART_H */
diff -cr --new-file 1.9.1/asp/pdic/rx600/MANIFEST ASPs/asp/pdic/rx600/MANIFEST
*** 1.9.1/asp/pdic/rx600/MANIFEST	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/rx600/MANIFEST	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,6 ----
+ PACKAGE pdic_rx600
+ VERSION 1.6.0
+ 
+ MANIFEST
+ rx600_uart.c
+ rx600_uart.h
diff -cr --new-file 1.9.1/asp/pdic/rx600/rx600_uart.c ASPs/asp/pdic/rx600/rx600_uart.c
*** 1.9.1/asp/pdic/rx600/rx600_uart.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/rx600/rx600_uart.c	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,543 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ 
+ /*
+  *   rx610 UART用 簡易SIOドライバ
+  */
+ 
+ #include <sil.h>
+ #include <kernel.h>
+ #include <t_syslog.h>
+ #include "target_syssvc.h"
+ #include "rx600_uart.h"
+ 
+ /* シリアルモードレジスタ（SMR) */
+ #define CKS			UINT_C(0x03)
+ #define STOP		UINT_C(0x08)
+ #define PM			UINT_C(0x10)
+ #define PE			UINT_C(0x20)
+ #define CHR			UINT_C(0x40)
+ #define CM			UINT_C(0x80)
+ #define ASYNC_7BIT	UINT_C(0x00)
+ #define ASYNC_8BIT	UINT_C(0x40)
+ 
+ /* シリアルコントロールレジスタ（SCR) */
+ #define CKE			UINT_C(0x03)
+ #define TEIE		UINT_C(0x04)
+ #define RE			UINT_C(0x10)
+ #define TE			UINT_C(0x20)
+ #define RIE			UINT_C(0x40)
+ #define TIE			UINT_C(0x80)
+ 
+ /* シリアルステータスレジスタ（SSR） */
+ #define TEND		UINT_C(0x04)
+ #define PER			UINT_C(0x08)
+ #define FER			UINT_C(0x10)
+ #define ORER		UINT_C(0x20)
+ 
+ /* シリアル拡張モードレジスタ（SEMR) */
+ #define ACS0		UINT_C(0x01)
+ #define ABCS		UINT_C(0x10)
+ 
+ #define SCI_SCR_FLG_ENABLE	(RE | TE)
+ #define SCI_SMR_FLG_ENABLE	(STOP | PM | PE | CHR | CM)
+ 
+ /*
+  *  シリアルI/Oポート初期化ブロックの定義
+  */
+ typedef struct sio_port_initialization_block {
+ 	volatile uint8_t	*ctlreg;		/* シリアルコントロールレジスタ（SCR) */
+ 	volatile uint8_t	*modereg;		/* シリアルモードレジスタ（SMR) */
+ 	volatile uint8_t	*extmodereg;	/* シリアル拡張モードレジスタ（SEMR) */	
+ 	volatile uint8_t	*statusreg;		/* シリアルステータスレジスタ（SSR） */
+ 	volatile uint8_t	*tdreg;			/* トランスミットデータレジスタ（TDR)*/
+ 	volatile uint8_t	*rdreg;			/* レシーブデータレジスタ（RDR) */
+ 	volatile uint8_t	*bitratereg;	/* ビットレートレジスタ（BRR) */
+ 	volatile uint8_t	*porticrreg;	/* 入力バッファコントロールレジスタ（ICR) */
+ 	volatile uint32_t	*mstpcrreg;		/* モジュールストップコントロールレジスタ（MSTPCR） */
+ 	volatile uint8_t	*ssrreg;		/* ステータスレジスタ */
+ 	volatile uint8_t	*rxiirreg;		/* RXI用割込み要求レジスタ */
+ 	uint8_t				tx_intno;		/* 送信（データエンプティ）割り込み番号 */
+ 	uint8_t				rx_intno;		/* 受信（データフル）割り込み番号 */
+ 	uint8_t				er_intno;		/* 受信（エラー）割り込み番号 */
+ 	uint8_t				te_intno;		/* 送信（終了）割り込み番号 */
+ 	uint8_t				sci_no;			/* SCIの番号(SCI0〜SCI6) */
+ 	uint32_t			mstpcr_offset;	/* MSTPCRの対応するビットオフセット */
+ } SIOPINIB;
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックの定義
+  */
+ struct sio_port_control_block {
+ 	const SIOPINIB	*p_siopinib; 				/* シリアルI/Oポート初期化ブロック */
+ 	intptr_t 	exinf;			 				/* 拡張情報 */
+ 	bool_t		openflag;						/* オープン済みフラグ */
+ 	bool_t		sendflag;						/* 送信割込みイネーブルフラグ */
+ 	bool_t		getready;						/* 文字を受信した状態 */
+ 	bool_t		putready;						/* 文字を送信できる状態 */
+ 	bool_t		is_initialized; 				/* デバイス初期化済みフラグ */
+ };
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックのエリア
+  */
+ static SIOPCB	siopcb_table[TNUM_SIOP];
+ 
+ /* レジスタテーブル */
+ static const SIOPINIB siopinib_table[TNUM_SIOP] =
+ {
+ 	{
+ 		(volatile uint8_t *)SCI0_SCR_ADDR,
+ 		(volatile uint8_t *)SCI0_SMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		(volatile uint8_t *)SCI0_TDR_ADDR,
+ 		(volatile uint8_t *)SCI0_RDR_ADDR,
+ 		(volatile uint8_t *)SCI0_BRR_ADDR,
+ 		(volatile uint8_t *)PORT2_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR215_ADDR,
+ 		INT_SCI0_TXI0,
+ 		INT_SCI0_RXI0,
+ 		INT_SCI0_ERI0,
+ 		INT_SCI0_TEI0,
+ 		0,
+ 		SYSTEM_MSTPCRB_MSTPB31_BIT,
+ 	} ,			/* UART0 */
+ #if TNUM_SIOP > 1
+ 	{
+ 		(volatile uint8_t *)SCI1_SCR_ADDR,
+ 		(volatile uint8_t *)SCI1_SMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		(volatile uint8_t *)SCI1_TDR_ADDR,
+ 		(volatile uint8_t *)SCI1_RDR_ADDR,
+ 		(volatile uint8_t *)SCI1_BRR_ADDR,
+ 		(volatile uint8_t *)PORT2_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR219_ADDR,
+ 		INT_SCI1_TXI1,
+ 		INT_SCI1_RXI1,
+ 		INT_SCI1_ERI1,
+ 		INT_SCI1_TEI1,
+ 		1,
+ 		SYSTEM_MSTPCRB_MSTPB30_BIT,
+ 	} ,			/* UART1 */
+ #endif
+ #if TNUM_SIOP > 2
+ 	{
+ 		(volatile uint8_t *)SCI2_SCR_ADDR,
+ 		(volatile uint8_t *)SCI2_SMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		(volatile uint8_t *)SCI2_TDR_ADDR,
+ 		(volatile uint8_t *)SCI2_RDR_ADDR,
+ 		(volatile uint8_t *)SCI2_BRR_ADDR,
+ 		(volatile uint8_t *)PORT1_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR223_ADDR,
+ 		INT_SCI2_TXI2,
+ 		INT_SCI2_RXI2,
+ 		INT_SCI2_ERI2 ,
+ 		INT_SCI2_TEI2,
+ 		2,
+ 		SYSTEM_MSTPCRB_MSTPB29_BIT,
+ 	} ,			/* UART2 */
+ #endif
+ #if TNUM_SIOP > 3
+ 	{
+ 		(volatile uint8_t *)SCI3_SCR_ADDR,
+ 		(volatile uint8_t *)SCI3_SMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		(volatile uint8_t *)SCI3_TDR_ADDR,
+ 		(volatile uint8_t *)SCI3_RDR_ADDR,
+ 		(volatile uint8_t *)SCI3_BRR_ADDR,
+ 		(volatile uint8_t *)PORT1_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR227_ADDR,
+ 		INT_SCI3_TXI3,
+ 		INT_SCI3_RXI3,
+ 		INT_SCI3_ERI3,
+ 		INT_SCI3_TEI3,
+ 		3,
+ 		SYSTEM_MSTPCRB_MSTPB28_BIT,
+ 	} ,			/* UART3 */
+ #endif
+ #if TNUM_SIOP > 4
+ 	{
+ 		(volatile uint8_t *)SCI4_SCR_ADDR,
+ 		(volatile uint8_t *)SCI4_SMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		(volatile uint8_t *)SCI4_TDR_ADDR,
+ 		(volatile uint8_t *)SCI4_RDR_ADDR,
+ 		(volatile uint8_t *)SCI4_BRR_ADDR,
+ 		(volatile uint8_t *)PORT0_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR231_ADDR,
+ 		INT_SCI4_TXI4,
+ 		INT_SCI4_RXI4,
+ 		INT_SCI4_ERI4,
+ 		INT_SCI4_TEI4,
+ 		4,
+ 		SYSTEM_MSTPCRB_MSTPB27_BIT,
+ 	} ,		/* UART4 */
+ #endif
+ #if TNUM_SIOP > 5
+ 	{
+ 		(volatile uint8_t *)SCI5_SCR_ADDR,
+ 		(volatile uint8_t *)SCI5_SMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		(volatile uint8_t *)SCI5_TDR_ADDR,
+ 		(volatile uint8_t *)SCI5_RDR_ADDR,
+ 		(volatile uint8_t *)SCI5_BRR_ADDR,
+ 		(volatile uint8_t *)PORTC_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR235_ADDR,
+ 		INT_SCI5_TXI5,
+ 		INT_SCI5_RXI5,
+ 		INT_SCI5_ERI5,
+ 		INT_SCI5_TEI5,
+ 		5,
+ 		SYSTEM_MSTPCRB_MSTPB26_BIT,
+ 	} ,		/* UART5 */
+ #endif
+ #if TNUM_SIOP > 6
+ 	{
+ 		(volatile uint8_t *)SCI6_SCR_ADDR,
+ 		(volatile uint8_t *)SCI6_SMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		(volatile uint8_t *)SCI6_TDR_ADDR,
+ 		(volatile uint8_t *)SCI6_RDR_ADDR,
+ 		(volatile uint8_t *)SCI6_BRR_ADDR,
+ 		(volatile uint8_t *)PORT0_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR239_ADDR,
+ 		INT_SCI6_TXI6,
+ 		INT_SCI6_RXI6,
+ 		INT_SCI6_ERI6,
+ 		INT_SCI6_TEI6,
+ 		6,
+ 		SYSTEM_MSTPCRB_MSTPB25_BIT,
+ 	} ,		/* UART6 */
+ #endif
+ };
+ 
+ /*
+  *  シリアルI/OポートIDから管理ブロックを取り出すためのマクロ
+  */
+ #define INDEX_SIOP(siopid)	 ((uint_t)((siopid) - 1))
+ #define get_siopcb(siopid)	 (&(siopcb_table[INDEX_SIOP(siopid)]))
+ #define get_siopinib(siopid) (&(siopinib_table[INDEX_SIOP(siopid)]))
+ 
+ 
+ /*
+  *  SIOドライバのシリアルモードレジスタ(SMR)
+  */
+ static void
+ rx600_uart_setmode(const SIOPINIB *p_siopinib, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	uint8_t i;
+ 
+ 	/*
+ 	 *  SCIドライバの初期化ルーチン
+ 	 */
+ 
+ 	/*
+ 	 *  割り込み要求先レジスタの設定(ISELRi)
+ 	 *
+ 	 *  リセット値と同じ値を設定することになるため,
+ 	 *  処理は省略する.
+ 	 */
+ 
+ 	/*
+ 	 *  モジュールストップ機能の設定(SCI1)
+ 	 */
+ 	sil_wrw_mem((void *)p_siopinib->mstpcrreg, (~p_siopinib->mstpcr_offset));
+ 
+ 	/* 送受信禁止, SCKn端子は入出力ポートとして使用 */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 0x00U);
+ 
+ 	/* クロック選択ビット(SMR.CKS[1:0]ビットを設定) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 					sil_reb_mem((void *)p_siopinib->modereg) | clksrc);
+ 
+ 	/* SMRに送信／ 受信フォーマットを設定) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 			sil_reb_mem((void *)p_siopinib->modereg) & (~SCI_SMR_FLG_ENABLE));
+ 
+ 	/* ビットレートを設定 */
+ 	sil_wrb_mem((void *)p_siopinib->bitratereg, bitrate);
+ 
+ 	/* ビット期間(基本クロック16サイクルの期間が1ビット期間となる) */
+ 	while(i < 16){
+ 		i++;
+ 	}
+ 
+ 	/* 送受信許可 */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 			(sil_reb_mem((void *)p_siopinib->ctlreg) | SCI_SCR_FLG_ENABLE));
+ }
+ 
+ 
+ /*
+  *  SIOドライバの初期化ルーチン
+  */
+ void
+ rx600_uart_initialize(void)
+ {
+ 	SIOPCB	*p_siopcb;
+ 	uint_t	i;
+ 
+ 	/*
+ 	 *  シリアルI/Oポート管理ブロックの初期化
+ 	 */
+ 	for (p_siopcb = siopcb_table, i = 0; i < TNUM_SIOP; p_siopcb++, i++){
+ 		p_siopcb->p_siopinib = &(siopinib_table[i]);
+ 		p_siopcb->openflag = false;
+ 		p_siopcb->sendflag = false;
+ 	}
+ }
+ 
+ /*
+  *  カーネル起動時のバナー出力用の初期化
+  */
+ void
+ rx600_uart_init(ID siopid, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb   = get_siopcb(siopid);
+ 	const SIOPINIB  *p_siopinib = get_siopinib(siopid);
+ 	/*  この時点では、p_siopcb->p_siopinibは初期化されていない  */
+ 
+ 	/*  二重初期化の防止  */
+ 	p_siopcb->is_initialized = true;
+ 
+ 	/*  ハードウェアの初期化処理と送信許可  */
+ 	rx600_uart_setmode(p_siopinib , bitrate, clksrc);
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 					(uint8_t)(sil_reb_mem((void *)p_siopinib->ctlreg) | TE));
+ }
+ 
+ 
+ /*
+  *  シリアルI/Oポートへのポーリングでの出力
+  */
+ void
+ rx600_uart_pol_putc(char c, ID siopid)
+ {
+ 	const SIOPINIB *p_siopinib;
+ 
+ 	p_siopinib = get_siopinib(siopid);
+ 
+ 	/*
+ 	 *  送信レジスタが空になるまで待つ
+ 	 */
+ 	while((sil_reb_mem(
+ 			(void *)p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) == 0U);
+ 
+ 	sil_wrb_mem((void *)p_siopinib->tdreg, (uint8_t)c);
+ }
+ 
+ /*
+  *  シリアルI/Oポートのオープン
+  */
+ SIOPCB *
+ rx600_uart_opn_por
+ 	(ID siopid, intptr_t exinf, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb;
+ 	const SIOPINIB  *p_siopinib;
+ 
+ 	p_siopcb = get_siopcb(siopid);
+ 	p_siopinib = p_siopcb->p_siopinib;
+ 
+ 	/*
+ 	 *  ハードウェアの初期化
+ 	 *
+ 	 *  既に初期化している場合は, 二重に初期化しない.
+ 	 */
+ 	if(!(p_siopcb->is_initialized)){
+ 		rx600_uart_setmode(p_siopinib, bitrate, clksrc);
+ 		p_siopcb->is_initialized = true;
+ 	}
+ 
+ 	p_siopcb->exinf = exinf;
+ 	p_siopcb->getready = p_siopcb->putready = false;
+ 	p_siopcb->openflag = true;
+ 
+     return (p_siopcb);
+ }
+ 
+ /*
+  *  シリアルI/Oポートのクローズ
+  */
+ void
+ rx600_uart_cls_por(SIOPCB *p_siopcb)
+ {
+ 	/*
+ 	 *  UART停止
+ 	 */
+ 	sil_wrh_mem((void *)p_siopcb->p_siopinib->ctlreg, 0x00U);
+ 	p_siopcb->openflag = false;
+ 	p_siopcb->is_initialized = false;
+ }
+ 
+ /*
+  *  シリアルI/Oポートへの文字送信
+  */
+ bool_t
+ rx600_uart_snd_chr(SIOPCB *p_siopcb, char c)
+ {
+ 	bool_t ercd = false;
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0){
+ 		sil_wrb_mem((void *)p_siopcb->p_siopinib->tdreg, (uint8_t)c);
+ 		ercd = true;
+ 	}
+ 
+ 	return ercd;
+ }
+ 
+ /*
+  *  シリアルI/Oポートからの文字受信
+  */
+ int_t
+ rx600_uart_rcv_chr(SIOPCB *p_siopcb)
+ {
+ 	int_t c = -1;
+ 
+ 	/*
+ 	 *  受信フラグがONのときのみ受信バッファから文字を取得する.
+ 	 *  これは, ポーリング受信に対応するためである.
+ 	 *  しかし, RX600シリーズでは受信フラグがないこと, システムサービス
+ 	 *  では受信割込みの中からしかデータを受信しに来ないことから, 常に
+ 	 *  受信バッファから文字を取得する.
+ 	 */
+ 	c = (int)(sil_reb_mem((void *)p_siopcb->p_siopinib->rdreg));
+ 
+ 	return c;
+ }
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの許可
+  */
+ void
+ rx600_uart_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_TEIE_BIT));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_RIE_BIT));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの禁止
+  */
+ void
+ rx600_uart_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_TEIE_BIT)));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_RIE_BIT)));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  SIOの割込みサービスルーチン
+  */
+ void
+ rx600_uart_tx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0U){
+ 		/*
+ 		 *  送信可能コールバックルーチンを呼び出す．
+ 		 */
+ 		rx600_uart_irdy_snd(p_siopcb->exinf);
+ 	}
+ }
+ 
+ void
+ rx600_uart_rx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	/*
+ 	 *  受信フラグがONのときのみ受信通知コールバックルーチンを呼び出す.
+ 	 *  しかし, RX600シリーズでは受信フラグがないため, 常に受信通知
+ 	 *  コールバックルーチンを呼び出す.
+ 	 *  ここでは受信割込みの発生を信じる.
+ 	 */
+ 	/*
+ 	 *  受信通知コールバックルーチンを呼び出す．
+ 	 */
+ 	rx600_uart_irdy_rcv(p_siopcb->exinf);
+ }
+ 
diff -cr --new-file 1.9.1/asp/pdic/rx600/rx600_uart.c~ ASPs/asp/pdic/rx600/rx600_uart.c~
*** 1.9.1/asp/pdic/rx600/rx600_uart.c~	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/rx600/rx600_uart.c~	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,543 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  L쌠҂́Cȉ(1)`(4)̏𖞂ꍇɌC{\tgEF
+  *  Ai{\tgEFAς̂܂ށDȉjgpEE
+  *  ρEĔzziȉCpƌĂԁj邱Ƃ𖳏ŋD
+  *  (1) {\tgEFA\[XR[ȟ`ŗpꍇɂ́CL̒
+  *      \C̗pщL̖ۏ؋K肪Ĉ܂܂̌`Ń\[
+  *      XR[hɊ܂܂Ă邱ƁD
+  *  (2) {\tgEFACCu`ȂǁC̃\tgEFAJɎg
+  *      pł`ōĔzzꍇɂ́CĔzzɔhLgip
+  *      ҃}jAȂǁjɁCL̒쌠\C̗pщL
+  *      ̖ۏ؋Kfڂ邱ƁD
+  *  (3) {\tgEFAC@ɑgݍނȂǁC̃\tgEFAJɎg
+  *      płȂ`ōĔzzꍇɂ́Ĉꂩ̏𖞂
+  *      ƁD
+  *    (a) ĔzzɔhLgip҃}jAȂǁjɁCL̒
+  *        쌠\C̗pщL̖ۏ؋Kfڂ邱ƁD
+  *    (b) Ĕzž`ԂCʂɒ߂@ɂāCTOPPERSvWFNg
+  *        񍐂邱ƁD
+  *  (4) {\tgEFA̗pɂ蒼ړI܂͊ԐړIɐ邢Ȃ鑹
+  *      QCL쌠҂TOPPERSvWFNgƐӂ邱ƁD
+  *      ܂C{\tgEFÃ[U܂̓Gh[ÛȂ闝
+  *      RɊÂCL쌠҂TOPPERSvWFNg
+  *      Ɛӂ邱ƁD
+  * 
+  *  {\tgEFÁCۏ؂Œ񋟂Ă̂łDL쌠҂
+  *  TOPPERSvWFNǵC{\tgEFAɊւāC̎gpړI
+  *  ɑ΂K܂߂āCȂۏ؂sȂD܂C{\tgEF
+  *  A̗pɂ蒼ړI܂͊ԐړIɐȂ鑹QɊւĂC
+  *  ̐ӔC𕉂ȂD
+  * 
+  */
+ 
+ 
+ /*
+  *   rx610 UARTp ȈSIOhCo
+  */
+ 
+ #include <sil.h>
+ #include <kernel.h>
+ #include <t_syslog.h>
+ #include "target_syssvc.h"
+ #include "rx600_uart.h"
+ 
+ /* VA[hWX^iSMR) */
+ #define CKS			UINT_C(0x03)
+ #define STOP		UINT_C(0x08)
+ #define PM			UINT_C(0x10)
+ #define PE			UINT_C(0x20)
+ #define CHR			UINT_C(0x40)
+ #define CM			UINT_C(0x80)
+ #define ASYNC_7BIT	UINT_C(0x00)
+ #define ASYNC_8BIT	UINT_C(0x40)
+ 
+ /* VARg[WX^iSCR) */
+ #define CKE			UINT_C(0x03)
+ #define TEIE		UINT_C(0x04)
+ #define RE			UINT_C(0x10)
+ #define TE			UINT_C(0x20)
+ #define RIE			UINT_C(0x40)
+ #define TIE			UINT_C(0x80)
+ 
+ /* VAXe[^XWX^iSSRj */
+ #define TEND		UINT_C(0x04)
+ #define PER			UINT_C(0x08)
+ #define FER			UINT_C(0x10)
+ #define ORER		UINT_C(0x20)
+ 
+ /* VAg[hWX^iSEMR) */
+ #define ACS0		UINT_C(0x01)
+ #define ABCS		UINT_C(0x10)
+ 
+ #define SCI_SCR_FLG_ENABLE	(RE | TE)
+ #define SCI_SMR_FLG_ENABLE	(STOP | PM | PE | CHR | CM)
+ 
+ /*
+  *  VAI/O|[gubN̒`
+  */
+ typedef struct sio_port_initialization_block {
+ 	volatile uint8_t	*ctlreg;		/* VARg[WX^iSCR) */
+ 	volatile uint8_t	*modereg;		/* VA[hWX^iSMR) */
+ 	volatile uint8_t	*extmodereg;	/* VAg[hWX^iSEMR) */	
+ 	volatile uint8_t	*statusreg;		/* VAXe[^XWX^iSSRj */
+ 	volatile uint8_t	*tdreg;			/* gX~bgf[^WX^iTDR)*/
+ 	volatile uint8_t	*rdreg;			/* V[uf[^WX^iRDR) */
+ 	volatile uint8_t	*bitratereg;	/* rbg[gWX^iBRR) */
+ 	volatile uint8_t	*porticrreg;	/* ̓obt@Rg[WX^iICR) */
+ 	volatile uint32_t	*mstpcrreg;		/* W[XgbvRg[WX^iMSTPCRj */
+ 	volatile uint8_t	*ssrreg;		/* Xe[^XWX^ */
+ 	volatile uint8_t	*rxiirreg;		/* RXIpݗvWX^ */
+ 	uint8_t				tx_intno;		/* Mif[^GveBj荞ݔԍ */
+ 	uint8_t				rx_intno;		/* Mif[^tj荞ݔԍ */
+ 	uint8_t				er_intno;		/* MiG[j荞ݔԍ */
+ 	uint8_t				te_intno;		/* MiIj荞ݔԍ */
+ 	uint8_t				sci_no;			/* SCI̔ԍ(SCI0`SCI6) */
+ 	uint32_t			mstpcr_offset;	/* MSTPCȒΉrbgItZbg */
+ } SIOPINIB;
+ 
+ /*
+  *  VAI/O|[gǗubN̒`
+  */
+ struct sio_port_control_block {
+ 	const SIOPINIB	*p_siopinib; 				/* VAI/O|[gubN */
+ 	intptr_t 	exinf;			 				/* g */
+ 	bool_t		openflag;						/* I[vς݃tO */
+ 	bool_t		sendflag;						/* M݃Cl[utO */
+ 	bool_t		getready;						/* M */
+ 	bool_t		putready;						/* 𑗐Mł */
+ 	bool_t		is_initialized; 				/* foCXς݃tO */
+ };
+ 
+ /*
+  *  VAI/O|[gǗubÑGA
+  */
+ static SIOPCB	siopcb_table[TNUM_SIOP];
+ 
+ /* WX^e[u */
+ static const SIOPINIB siopinib_table[TNUM_SIOP] =
+ {
+ 	{
+ 		(volatile uint8_t *)SCI0_SCR_ADDR,
+ 		(volatile uint8_t *)SCI0_SMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		(volatile uint8_t *)SCI0_TDR_ADDR,
+ 		(volatile uint8_t *)SCI0_RDR_ADDR,
+ 		(volatile uint8_t *)SCI0_BRR_ADDR,
+ 		(volatile uint8_t *)PORT2_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI0_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR215_ADDR,
+ 		INT_SCI0_TXI0,
+ 		INT_SCI0_RXI0,
+ 		INT_SCI0_ERI0,
+ 		INT_SCI0_TEI0,
+ 		0,
+ 		SYSTEM_MSTPCRB_MSTPB31_BIT,
+ 	} ,			/* UART0 */
+ #if TNUM_SIOP > 1
+ 	{
+ 		(volatile uint8_t *)SCI1_SCR_ADDR,
+ 		(volatile uint8_t *)SCI1_SMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		(volatile uint8_t *)SCI1_TDR_ADDR,
+ 		(volatile uint8_t *)SCI1_RDR_ADDR,
+ 		(volatile uint8_t *)SCI1_BRR_ADDR,
+ 		(volatile uint8_t *)PORT2_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI1_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR219_ADDR,
+ 		INT_SCI1_TXI1,
+ 		INT_SCI1_RXI1,
+ 		INT_SCI1_ERI1,
+ 		INT_SCI1_TEI1,
+ 		1,
+ 		SYSTEM_MSTPCRB_MSTPB30_BIT,
+ 	} ,			/* UART1 */
+ #endif
+ #if TNUM_SIOP > 2
+ 	{
+ 		(volatile uint8_t *)SCI2_SCR_ADDR,
+ 		(volatile uint8_t *)SCI2_SMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		(volatile uint8_t *)SCI2_TDR_ADDR,
+ 		(volatile uint8_t *)SCI2_RDR_ADDR,
+ 		(volatile uint8_t *)SCI2_BRR_ADDR,
+ 		(volatile uint8_t *)PORT1_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI2_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR223_ADDR,
+ 		INT_SCI2_TXI2,
+ 		INT_SCI2_RXI2,
+ 		INT_SCI2_ERI2 ,
+ 		INT_SCI2_TEI2,
+ 		2,
+ 		SYSTEM_MSTPCRB_MSTPB29_BIT,
+ 	} ,			/* UART2 */
+ #endif
+ #if TNUM_SIOP > 3
+ 	{
+ 		(volatile uint8_t *)SCI3_SCR_ADDR,
+ 		(volatile uint8_t *)SCI3_SMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		(volatile uint8_t *)SCI3_TDR_ADDR,
+ 		(volatile uint8_t *)SCI3_RDR_ADDR,
+ 		(volatile uint8_t *)SCI3_BRR_ADDR,
+ 		(volatile uint8_t *)PORT1_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI3_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR227_ADDR,
+ 		INT_SCI3_TXI3,
+ 		INT_SCI3_RXI3,
+ 		INT_SCI3_ERI3,
+ 		INT_SCI3_TEI3,
+ 		3,
+ 		SYSTEM_MSTPCRB_MSTPB28_BIT,
+ 	} ,			/* UART3 */
+ #endif
+ #if TNUM_SIOP > 4
+ 	{
+ 		(volatile uint8_t *)SCI4_SCR_ADDR,
+ 		(volatile uint8_t *)SCI4_SMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		(volatile uint8_t *)SCI4_TDR_ADDR,
+ 		(volatile uint8_t *)SCI4_RDR_ADDR,
+ 		(volatile uint8_t *)SCI4_BRR_ADDR,
+ 		(volatile uint8_t *)PORT0_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI4_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR231_ADDR,
+ 		INT_SCI4_TXI4,
+ 		INT_SCI4_RXI4,
+ 		INT_SCI4_ERI4,
+ 		INT_SCI4_TEI4,
+ 		4,
+ 		SYSTEM_MSTPCRB_MSTPB27_BIT,
+ 	} ,		/* UART4 */
+ #endif
+ #if TNUM_SIOP > 5
+ 	{
+ 		(volatile uint8_t *)SCI5_SCR_ADDR,
+ 		(volatile uint8_t *)SCI5_SMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		(volatile uint8_t *)SCI5_TDR_ADDR,
+ 		(volatile uint8_t *)SCI5_RDR_ADDR,
+ 		(volatile uint8_t *)SCI5_BRR_ADDR,
+ 		(volatile uint8_t *)PORTC_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI5_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR235_ADDR,
+ 		INT_SCI5_TXI5,
+ 		INT_SCI5_RXI5,
+ 		INT_SCI5_ERI5,
+ 		INT_SCI5_TEI5,
+ 		5,
+ 		SYSTEM_MSTPCRB_MSTPB26_BIT,
+ 	} ,		/* UART5 */
+ #endif
+ #if TNUM_SIOP > 6
+ 	{
+ 		(volatile uint8_t *)SCI6_SCR_ADDR,
+ 		(volatile uint8_t *)SCI6_SMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SEMR_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		(volatile uint8_t *)SCI6_TDR_ADDR,
+ 		(volatile uint8_t *)SCI6_RDR_ADDR,
+ 		(volatile uint8_t *)SCI6_BRR_ADDR,
+ 		(volatile uint8_t *)PORT0_ICR_ADDR,
+ 		(volatile uint32_t *)SYSTEM_MSTPCRB_ADDR,
+ 		(volatile uint8_t *)SCI6_SSR_ADDR,
+ 		(volatile uint8_t *)ICU_IR239_ADDR,
+ 		INT_SCI6_TXI6,
+ 		INT_SCI6_RXI6,
+ 		INT_SCI6_ERI6,
+ 		INT_SCI6_TEI6,
+ 		6,
+ 		SYSTEM_MSTPCRB_MSTPB25_BIT,
+ 	} ,		/* UART6 */
+ #endif
+ };
+ 
+ /*
+  *  VAI/O|[gIDǗubNo߂̃}N
+  */
+ #define INDEX_SIOP(siopid)	 ((uint_t)((siopid) - 1))
+ #define get_siopcb(siopid)	 (&(siopcb_table[INDEX_SIOP(siopid)]))
+ #define get_siopinib(siopid) (&(siopinib_table[INDEX_SIOP(siopid)]))
+ 
+ 
+ /*
+  *  SIOhCõVA[hWX^(SMR)
+  */
+ static void
+ rx600_uart_setmode(const SIOPINIB *p_siopinib, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	uint8_t i;
+ 
+ 	/*
+ 	 *  SCIhCȍ[`
+ 	 */
+ 
+ 	/*
+ 	 *  荞ݗv惌WX^̐ݒ(ISELRi)
+ 	 *
+ 	 *  ZbglƓlݒ肷邱ƂɂȂ邽,
+ 	 *  ͏ȗ.
+ 	 */
+ 
+ 	/*
+ 	 *  W[Xgbv@\̐ݒ(SCI1)
+ 	 */
+ 	sil_wrw_mem((void *)p_siopinib->mstpcrreg, (~p_siopinib->mstpcr_offset));
+ 
+ 	/* M֎~, SCKn[q͓o̓|[gƂĎgp */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 0x00U);
+ 
+ 	/* NbNIrbg(SMR.CKS[1:0]rbgݒ) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 					sil_reb_mem((void *)p_siopinib->modereg) | clksrc);
+ 
+ 	/* SMRɑM^ MtH[}bgݒ) */
+ 	sil_wrb_mem((void *)p_siopinib->modereg, 
+ 			sil_reb_mem((void *)p_siopinib->modereg) & (~SCI_SMR_FLG_ENABLE));
+ 
+ 	/* rbg[gݒ */
+ 	sil_wrb_mem((void *)p_siopinib->bitratereg, bitrate);
+ 
+ 	/* rbg({NbN16TCN̊Ԃ1rbgԂƂȂ) */
+ 	while(i < 16){
+ 		i++;
+ 	}
+ 
+ 	/* M */
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 			(sil_reb_mem((void *)p_siopinib->ctlreg) | SCI_SCR_FLG_ENABLE));
+ }
+ 
+ 
+ /*
+  *  SIOhCȍ[`
+  */
+ void
+ rx600_uart_initialize(void)
+ {
+ 	SIOPCB	*p_siopcb;
+ 	uint_t	i;
+ 
+ 	/*
+ 	 *  VAI/O|[gǗubN̏
+ 	 */
+ 	for (p_siopcb = siopcb_table, i = 0; i < TNUM_SIOP; p_siopcb++, i++){
+ 		p_siopcb->p_siopinib = &(siopinib_table[i]);
+ 		p_siopcb->openflag = false;
+ 		p_siopcb->sendflag = false;
+ 	}
+ }
+ 
+ /*
+  *  J[lÑoi[o͗p̏
+  */
+ void
+ rx600_uart_init(ID siopid, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb   = get_siopcb(siopid);
+ 	const SIOPINIB  *p_siopinib = get_siopinib(siopid);
+ 	/*  ̎_ł́Ap_siopcb->p_siopinib͏ĂȂ  */
+ 
+ 	/*  d̖h~  */
+ 	p_siopcb->is_initialized = true;
+ 
+ 	/*  n[hEFȀƑM  */
+ 	rx600_uart_setmode(p_siopinib , bitrate, clksrc);
+ 	sil_wrb_mem((void *)p_siopinib->ctlreg, 
+ 					(uint8_t)(sil_reb_mem((void *)p_siopinib->ctlreg) | TE));
+ }
+ 
+ 
+ /*
+  *  VAI/O|[gւ̃|[Oł̏o
+  */
+ void
+ rx600_uart_pol_putc(char_t c, ID siopid)
+ {
+ 	const SIOPINIB *p_siopinib;
+ 
+ 	p_siopinib = get_siopinib(siopid);
+ 
+ 	/*
+ 	 *  MWX^ɂȂ܂ő҂
+ 	 */
+ 	while((sil_reb_mem(
+ 			(void *)p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) == 0U);
+ 
+ 	sil_wrb_mem((void *)p_siopinib->tdreg, (uint8_t)c);
+ }
+ 
+ /*
+  *  VAI/O|[g̃I[v
+  */
+ SIOPCB *
+ rx600_uart_opn_por
+ 	(ID siopid, intptr_t exinf, uint8_t bitrate, uint8_t clksrc)
+ {
+ 	SIOPCB          *p_siopcb;
+ 	const SIOPINIB  *p_siopinib;
+ 
+ 	p_siopcb = get_siopcb(siopid);
+ 	p_siopinib = p_siopcb->p_siopinib;
+ 
+ 	/*
+ 	 *  n[hEFȀ
+ 	 *
+ 	 *  ɏĂꍇ, dɏȂ.
+ 	 */
+ 	if(!(p_siopcb->is_initialized)){
+ 		rx600_uart_setmode(p_siopinib, bitrate, clksrc);
+ 		p_siopcb->is_initialized = true;
+ 	}
+ 
+ 	p_siopcb->exinf = exinf;
+ 	p_siopcb->getready = p_siopcb->putready = false;
+ 	p_siopcb->openflag = true;
+ 
+     return (p_siopcb);
+ }
+ 
+ /*
+  *  VAI/O|[g̃N[Y
+  */
+ void
+ rx600_uart_cls_por(SIOPCB *p_siopcb)
+ {
+ 	/*
+ 	 *  UART~
+ 	 */
+ 	sil_wrh_mem((void *)p_siopcb->p_siopinib->ctlreg, 0x00U);
+ 	p_siopcb->openflag = false;
+ 	p_siopcb->is_initialized = false;
+ }
+ 
+ /*
+  *  VAI/O|[gւ̕M
+  */
+ bool_t
+ rx600_uart_snd_chr(SIOPCB *p_siopcb, char_t c)
+ {
+ 	bool_t ercd = false;
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0){
+ 		sil_wrb_mem((void *)p_siopcb->p_siopinib->tdreg, (uint8_t)c);
+ 		ercd = true;
+ 	}
+ 
+ 	return ercd;
+ }
+ 
+ /*
+  *  VAI/O|[g̕M
+  */
+ int_t
+ rx600_uart_rcv_chr(SIOPCB *p_siopcb)
+ {
+ 	int_t c = -1;
+ 
+ 	/*
+ 	 *  MtOON̂Ƃ̂ݎMobt@當擾.
+ 	 *  , |[OMɑΉ邽߂ł.
+ 	 *  , RX600V[Ył͎MtOȂ, VXeT[rX
+ 	 *  ł͎M݂̒炵f[^MɗȂƂ, 
+ 	 *  Mobt@當擾.
+ 	 */
+ 	c = (int)(sil_reb_mem((void *)p_siopcb->p_siopinib->rdreg));
+ 
+ 	return c;
+ }
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋
+  */
+ void
+ rx600_uart_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_TEIE_BIT));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) | SCI_SCR_RIE_BIT));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋֎~
+  */
+ void
+ rx600_uart_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
+ {
+ 	switch (cbrtn) {
+ 		case SIO_RDY_SND:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_TEIE_BIT)));
+ 			break;
+ 		case SIO_RDY_RCV:
+ 			sil_wrb_mem((void *)p_siopcb->p_siopinib->ctlreg, 
+ 				(sil_reb_mem((void *)p_siopcb->p_siopinib->ctlreg) & (~SCI_SCR_RIE_BIT)));
+ 			break;
+ 		default:
+ 			assert(1);
+ 			break;
+ 	}
+ }
+ 
+ /*
+  *  SIO̊݃T[rX[`
+  */
+ void
+ rx600_uart_tx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	if((sil_reb_mem(
+ 		(void *)p_siopcb->p_siopinib->ssrreg) & SCI_SSR_TEND_BIT) != 0U){
+ 		/*
+ 		 *  M\R[obN[`ĂяoD
+ 		 */
+ 		rx600_uart_irdy_snd(p_siopcb->exinf);
+ 	}
+ }
+ 
+ void
+ rx600_uart_rx_isr(ID siopid)
+ {
+ 	SIOPCB	*p_siopcb = get_siopcb(siopid);
+ 
+ 	/*
+ 	 *  MtOON̂Ƃ̂ݎMʒmR[obN[`Ăяo.
+ 	 *  , RX600V[Ył͎MtOȂ, ɎMʒm
+ 	 *  R[obN[`Ăяo.
+ 	 *  ł͎M݂̔M.
+ 	 */
+ 	/*
+ 	 *  MʒmR[obN[`ĂяoD
+ 	 */
+ 	rx600_uart_irdy_rcv(p_siopcb->exinf);
+ }
+ 
diff -cr --new-file 1.9.1/asp/pdic/rx600/rx600_uart.h ASPs/asp/pdic/rx600/rx600_uart.h
*** 1.9.1/asp/pdic/rx600/rx600_uart.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/rx600/rx600_uart.h	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,129 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *  RX610 UART用 簡易SIOドライバ
+  */
+ 
+ #ifndef TOPPERS_RX610_UART_H
+ #define TOPPERS_RX610_UART_H
+ 
+ /* 指定可能なクロックソース */
+ #define CLK_F1	UINT_C(0x00)
+ #define CLK_F4	UINT_C(0x01)
+ #define CLK_F16	UINT_C(0x02)
+ #define CLK_F64	UINT_C(0x03)
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  シリアルI/Oポート管理ブロックの定義
+  */
+ typedef struct sio_port_control_block	SIOPCB;
+ 
+ /*
+  *  コールバックルーチンの識別番号
+  */
+ #define SIO_RDY_SND    (1U)        /* 送信可能コールバック */
+ #define SIO_RDY_RCV    (2U)        /* 受信通知コールバック */
+ 
+ /*
+  *  SIOドライバの初期化ルーチン
+  */
+ extern void rx600_uart_initialize(void);
+ 
+ /*
+  * カーネル起動時のバナー出力用の初期化
+  */
+ extern void rx600_uart_init(ID siopid , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  シリアルI/Oポートへのポーリングでの出力
+  */
+ extern void rx600_uart_pol_putc(char c, ID siopid);
+ 
+ /*
+  *  シリアルI/Oポートのオープン
+  */
+ extern SIOPCB *rx600_uart_opn_por
+ 	(ID siopid, intptr_t exinf , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  シリアルI/Oポートのクローズ
+  */
+ extern void rx600_uart_cls_por(SIOPCB *p_siopcb);
+ 
+ /*
+  *  シリアルI/Oポートへの文字送信
+  */
+ extern bool_t rx600_uart_snd_chr(SIOPCB *p_siopcb, char c);
+ 
+ /*
+  *  シリアルI/Oポートからの文字受信
+  */
+ extern int_t rx600_uart_rcv_chr(SIOPCB *p_siopcb);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの許可
+  */
+ extern void  rx600_uart_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの禁止
+  */
+ extern void rx600_uart_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  SIOの割込みサービスルーチン
+  */
+ extern void rx600_uart_tx_isr(ID siopid);
+ extern void rx600_uart_rx_isr(ID siopid);
+ 
+ /*
+  *  シリアルI/Oポートからの送信可能コールバック
+  */
+ extern void rx600_uart_irdy_snd(intptr_t exinf);
+ 
+ /*
+  *  シリアルI/Oポートからの受信通知コールバック
+  */
+ extern void rx600_uart_irdy_rcv(intptr_t exinf);
+ 
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ #endif /* TOPPERS_RX610_UART_H */
diff -cr --new-file 1.9.1/asp/pdic/rx600/rx600_uart.h~ ASPs/asp/pdic/rx600/rx600_uart.h~
*** 1.9.1/asp/pdic/rx600/rx600_uart.h~	Thu Jan  1 09:00:00 1970
--- ASPs/asp/pdic/rx600/rx600_uart.h~	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,129 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  L쌠҂́Cȉ(1)`(4)̏𖞂ꍇɌC{\tgEF
+  *  Ai{\tgEFAς̂܂ށDȉjgpEE
+  *  ρEĔzziȉCpƌĂԁj邱Ƃ𖳏ŋD
+  *  (1) {\tgEFA\[XR[ȟ`ŗpꍇɂ́CL̒
+  *      \C̗pщL̖ۏ؋K肪Ĉ܂܂̌`Ń\[
+  *      XR[hɊ܂܂Ă邱ƁD
+  *  (2) {\tgEFACCu`ȂǁC̃\tgEFAJɎg
+  *      pł`ōĔzzꍇɂ́CĔzzɔhLgip
+  *      ҃}jAȂǁjɁCL̒쌠\C̗pщL
+  *      ̖ۏ؋Kfڂ邱ƁD
+  *  (3) {\tgEFAC@ɑgݍނȂǁC̃\tgEFAJɎg
+  *      płȂ`ōĔzzꍇɂ́Ĉꂩ̏𖞂
+  *      ƁD
+  *    (a) ĔzzɔhLgip҃}jAȂǁjɁCL̒
+  *        쌠\C̗pщL̖ۏ؋Kfڂ邱ƁD
+  *    (b) Ĕzž`ԂCʂɒ߂@ɂāCTOPPERSvWFNg
+  *        񍐂邱ƁD
+  *  (4) {\tgEFA̗pɂ蒼ړI܂͊ԐړIɐ邢Ȃ鑹
+  *      QCL쌠҂TOPPERSvWFNgƐӂ邱ƁD
+  *      ܂C{\tgEFÃ[U܂̓Gh[ÛȂ闝
+  *      RɊÂCL쌠҂TOPPERSvWFNg
+  *      Ɛӂ邱ƁD
+  * 
+  *  {\tgEFÁCۏ؂Œ񋟂Ă̂łDL쌠҂
+  *  TOPPERSvWFNǵC{\tgEFAɊւāC̎gpړI
+  *  ɑ΂K܂߂āCȂۏ؂sȂD܂C{\tgEF
+  *  A̗pɂ蒼ړI܂͊ԐړIɐȂ鑹QɊւĂC
+  *  ̐ӔC𕉂ȂD
+  * 
+  */
+ 
+ /*
+  *  RX610 UARTp ȈSIOhCo
+  */
+ 
+ #ifndef TOPPERS_RX610_UART_H
+ #define TOPPERS_RX610_UART_H
+ 
+ /* w\ȃNbN\[X */
+ #define CLK_F1	UINT_C(0x00)
+ #define CLK_F4	UINT_C(0x01)
+ #define CLK_F16	UINT_C(0x02)
+ #define CLK_F64	UINT_C(0x03)
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  VAI/O|[gǗubN̒`
+  */
+ typedef struct sio_port_control_block	SIOPCB;
+ 
+ /*
+  *  R[obN[`̎ʔԍ
+  */
+ #define SIO_RDY_SND    (1U)        /* M\R[obN */
+ #define SIO_RDY_RCV    (2U)        /* MʒmR[obN */
+ 
+ /*
+  *  SIOhCȍ[`
+  */
+ extern void rx600_uart_initialize(void);
+ 
+ /*
+  * J[lÑoi[o͗p̏
+  */
+ extern void rx600_uart_init(ID siopid , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  VAI/O|[gւ̃|[Oł̏o
+  */
+ extern void rx600_uart_pol_putc(char_t c, ID siopid);
+ 
+ /*
+  *  VAI/O|[g̃I[v
+  */
+ extern SIOPCB *rx600_uart_opn_por
+ 	(ID siopid, intptr_t exinf , uint8_t baud , uint8_t clksrc);
+ 
+ /*
+  *  VAI/O|[g̃N[Y
+  */
+ extern void rx600_uart_cls_por(SIOPCB *p_siopcb);
+ 
+ /*
+  *  VAI/O|[gւ̕M
+  */
+ extern bool_t rx600_uart_snd_chr(SIOPCB *p_siopcb, char_t c);
+ 
+ /*
+  *  VAI/O|[g̕M
+  */
+ extern int_t rx600_uart_rcv_chr(SIOPCB *p_siopcb);
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋
+  */
+ extern void  rx600_uart_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  VAI/O|[g̃R[obN̋֎~
+  */
+ extern void rx600_uart_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
+ 
+ /*
+  *  SIO̊݃T[rX[`
+  */
+ extern void rx600_uart_tx_isr(ID siopid);
+ extern void rx600_uart_rx_isr(ID siopid);
+ 
+ /*
+  *  VAI/O|[g̑M\R[obN
+  */
+ extern void rx600_uart_irdy_snd(intptr_t exinf);
+ 
+ /*
+  *  VAI/O|[g̎MʒmR[obN
+  */
+ extern void rx600_uart_irdy_rcv(intptr_t exinf);
+ 
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ #endif /* TOPPERS_RX610_UART_H */
diff -cr --new-file 1.9.1/asp/pdic/upd72001/MANIFEST ASPs/asp/pdic/upd72001/MANIFEST
*** 1.9.1/asp/pdic/upd72001/MANIFEST	Sat Apr 12 10:30:56 2008
--- ASPs/asp/pdic/upd72001/MANIFEST	Thu Jan  1 09:00:00 1970
***************
*** 1,5 ****
- PACKAGE asp
- 
- MANIFEST
- upd72001.c
- upd72001.h
--- 0 ----
diff -cr --new-file 1.9.1/asp/pdic/upd72001/upd72001.c ASPs/asp/pdic/upd72001/upd72001.c
*** 1.9.1/asp/pdic/upd72001/upd72001.c	Fri Oct  7 17:28:12 2011
--- ASPs/asp/pdic/upd72001/upd72001.c	Thu Jan  1 09:00:00 1970
***************
*** 1,445 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2006-2011 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: upd72001.c 2254 2011-10-07 08:28:12Z ertl-hiro $
-  */
- 
- /*
-  *		PD72001 ʰSIOɥ饤
-  */
- 
- #include <sil.h>
- #include "target_syssvc.h"
- #include "upd72001.h"
- 
- /*
-  *  ǥХ쥸Υֳֻ֡nsecñ̡
-  *
-  *  200Ȥͤˤޤ꺬Ϥʤ
-  */
- #define	UPD72001_DELAY	200U
- 
- /*
-  *  PD72001Υ쥸ֹ
-  */
- #define	UPD72001_CR0	0x00U		/* ȥ쥸 */
- #define	UPD72001_CR1	0x01U
- #define	UPD72001_CR2	0x02U
- #define	UPD72001_CR3	0x03U
- #define	UPD72001_CR4	0x04U
- #define	UPD72001_CR5	0x05U
- #define	UPD72001_CR10	0x0aU
- #define	UPD72001_CR12	0x0cU
- #define	UPD72001_CR14	0x0eU
- #define	UPD72001_CR15	0x0fU
- 
- #define	UPD72001_SR0	0x00U		/* ơ쥸 */
- 
- /*
-  *  ȥ쥸
-  */
- #define CR_RESET	0x18U		/* ݡȥꥻåȥޥ */
- 
- #define CR0_EOI		0x38U		/* EOIEnd of Interrupt*/
- 
- #define CR1_DOWN	0x00U		/* ߤػ */
- #define CR1_RECV	0x10U		/* ߵĥӥå */
- #define CR1_SEND	0x02U		/* ߵĥӥå */
- 
- #define CR3_DEF		0xc1U		/* ǡ 8bit֥͡ */
- #define CR4_DEF		0x44U		/* ȥåץӥå 1bitѥƥʤ */
- #define CR5_DEF		0xeaU		/* ǡ 8bit֥͡ */
- 
- #define CR10_DEF	0x00U		/* NRZ */
- #define CR14_DEF	0x07U		/* ܡ졼ȥͥ졼֥͡ */
- #define CR15_DEF	0x56U		/* ܡ졼ȥͥ졼 */
- 
- #define SR0_RECV	0x01U		/* Υӥå */
- #define SR0_SEND	0x04U		/* ǽӥå */
- 
- /*
-  *  ꥢI/OݡȽ֥å
-  */
- typedef struct sio_port_initialization_block {
- 	void		*data;			/* ǡ쥸 */
- 	void		*ctrl;			/* ȥ쥸 */
- 
- 	uint8_t		cr3_def;		/* CR3͡ʼӥåȿ*/
- 	uint8_t		cr4_def;		/* CR4͡ʥȥåץӥåȡѥƥ*/
- 	uint8_t		cr5_def;		/* CR5͡ӥåȿ*/
- 	uint8_t		brg1_def;		/* ܡ졼Ⱦ̤ */
- 	uint8_t		brg2_def;		/* ܡ졼Ȳ̤ */
- } SIOPINIB;
- 
- /*
-  *  ꥢI/Oݡȴ֥å
-  */
- struct sio_port_control_block {
- 	const SIOPINIB *p_siopinib;	/* ꥢI/OݡȽ֥å */
- 	intptr_t	exinf;			/* ĥ */
- 	bool_t		openflag;		/* ץѤߥե饰 */
- 	uint8_t		cr1;			/* CR1͡ʳߵġ*/
- 	bool_t		getready;		/* ʸ */
- 	bool_t		putready;		/* ʸǤ */
- };
- 
- /*
-  *  ꥢI/OݡȽ֥å
-  */
- const SIOPINIB siopinib_table[TNUM_SIOP] = {
- 	{ (void *) TADR_UPD72001_DATAA, (void *) TADR_UPD72001_CTRLA,
- 					CR3_DEF, CR4_DEF, CR5_DEF, BRG1_DEF, BRG2_DEF },
- 	{ (void *) TADR_UPD72001_DATAB, (void *) TADR_UPD72001_CTRLB,
- 					CR3_DEF, CR4_DEF, CR5_DEF, BRG1_DEF, BRG2_DEF }
- };
- 
- /*
-  *  ꥢI/Oݡȴ֥åΥꥢ
-  */
- SIOPCB	siopcb_table[TNUM_SIOP];
- 
- /*
-  *  ꥢI/OݡID֥åФΥޥ
-  */
- #define INDEX_SIOP(siopid)	((uint_t)((siopid) - 1))
- #define get_siopcb(siopid)	(&(siopcb_table[INDEX_SIOP(siopid)]))
- 
- /*
-  *  ǥХ쥸ؤΥؿ
-  */
- Inline uint8_t
- upd72001_read_reg(void *addr)
- {
- 	uint8_t	val;
- 
- 	val = upd72001_reb_reg(addr);
- 	sil_dly_nse(UPD72001_DELAY);
- 	return(val);
- }
- 
- Inline void
- upd72001_write_reg(void *addr, uint8_t val)
- {
- 	upd72001_wrb_reg(addr, val);
- 	sil_dly_nse(UPD72001_DELAY);
- }
- 
- Inline uint8_t
- upd72001_read_ctrl(void *addr, uint8_t reg)
- {
- 	upd72001_write_reg(addr, reg);
- 	return(upd72001_read_reg(addr));
- }
- 
- Inline void
- upd72001_write_ctrl(void *addr, uint8_t reg, uint8_t val)
- {
- 	upd72001_write_reg(addr, reg);
- 	upd72001_write_reg(addr, val);
- }
- 
- Inline void
- upd72001_write_brg(void *addr, uint8_t reg, uint8_t val,
- 									uint8_t brg2, uint8_t brg1)
- {
- 	upd72001_write_reg(addr, reg);
- 	upd72001_write_reg(addr, val);
- 	upd72001_write_reg(addr, brg2);
- 	upd72001_write_reg(addr, brg1);
- 	(void) upd72001_read_reg(addr);		/* ߡ꡼ */
- }
- 
- /*
-  *  ֤ɽФSR0ɽФ
-  *
-  *  PD72001ϡ֡SR0ˤɤȼΥӥåȤƤޤ
-  *  ᡤ֤ɤ߽ФؿߤꥢI/Oݡȴ֥å
-  *  getready˼ξ֡putreadyǽ֤¸Ƥ
-  *  ǽ֤¸פ⤷ʤˡ
-  *  ֥쥸ɤǤΥӥåȤʤǥХʤ餬
-  *  ̤ȻפˤǤϡδؿɬפʤ
-  */
- static void
- upd72001_get_stat(SIOPCB *p_siopcb)
- {
- 	uint8_t	sr0;
- 
- 	sr0 = upd72001_read_ctrl(p_siopcb->p_siopinib->ctrl, UPD72001_SR0);
- 	if ((sr0 & SR0_RECV) != 0) {
- 		p_siopcb->getready = true;
- 	}
- 	if ((sr0 & SR0_SEND) != 0) {
- 		p_siopcb->putready = true;
- 	}
- }
- 
- /*
-  *  ʸǤ뤫
-  */
- Inline bool_t
- upd72001_getready(SIOPCB *p_siopcb)
- {
- 	upd72001_get_stat(p_siopcb);
- 	return(p_siopcb->getready);
- }
- 
- /*
-  *  ʸǤ뤫
-  */
- Inline bool_t
- upd72001_putready(SIOPCB *p_siopcb)
- {
- 	upd72001_get_stat(p_siopcb);
- 	return(p_siopcb->putready);
- }
- 
- /*
-  *  ʸμФ
-  */
- Inline char
- upd72001_getchar(SIOPCB *p_siopcb)
- {
- 	p_siopcb->getready = false;
- 	return((char) upd72001_read_reg(p_siopcb->p_siopinib->data));
- }
- 
- /*
-  *  ʸν
-  */
- Inline void
- upd72001_putchar(SIOPCB *p_siopcb, char c)
- {
- 	p_siopcb->putready = false;
- 	upd72001_write_reg(p_siopcb->p_siopinib->data, (uint8_t) c);
- }
- 
- /*
-  *  EOIEnd Of Interruptȯ
-  */
- Inline void
- upd72001_eoi(void)
- {
- 	upd72001_write_ctrl((void *) TADR_UPD72001_CTRLA, UPD72001_CR0, CR0_EOI);
- }
- 
- /*
-  *  SIOɥ饤Фν
-  */
- void
- upd72001_initialize(void)
- {
- 	SIOPCB	*p_siopcb;
- 	uint_t	i;
- 
- 	/*
- 	 *  ꥢI/Oݡȴ֥åν
- 	 */
- 	for (i = 0; i < TNUM_SIOP; i++) {
- 		p_siopcb = &(siopcb_table[i]);
- 		p_siopcb->p_siopinib = &(siopinib_table[i]);
- 		p_siopcb->openflag = false;
- 	}
- }
- 
- /*
-  *  ץ󤷤ƤݡȤ뤫
-  */
- bool_t
- upd72001_openflag(void)
- {
- 	return(siopcb_table[0].openflag || siopcb_table[1].openflag);
- }
- 
- /*
-  *  ꥢI/OݡȤΥץ
-  */
- SIOPCB *
- upd72001_opn_por(ID siopid, intptr_t exinf)
- {
- 	SIOPCB		*p_siopcb;
- 	const SIOPINIB	*p_siopinib;
- 
- 	p_siopcb = get_siopcb(siopid);
- 	p_siopinib = p_siopcb->p_siopinib;
- 
- 	upd72001_write_reg(p_siopinib->ctrl, CR_RESET);
- 	if (!upd72001_openflag()) {
- 		upd72001_write_ctrl((void *) TADR_UPD72001_CTRLA, UPD72001_CR2, 0x18);
- 		upd72001_write_ctrl((void *) TADR_UPD72001_CTRLB, UPD72001_CR2, 0x00);
- 	}
- 	p_siopcb->cr1 = CR1_DOWN;
- 	upd72001_write_ctrl(p_siopinib->ctrl, UPD72001_CR1, p_siopcb->cr1);
- 	upd72001_write_ctrl(p_siopinib->ctrl, UPD72001_CR4, p_siopinib->cr4_def);
- 	upd72001_write_brg(p_siopinib->ctrl, UPD72001_CR12, 0x01U,
- 							p_siopinib->brg2_def, p_siopinib->brg1_def);
- 	upd72001_write_brg(p_siopinib->ctrl, UPD72001_CR12, 0x02U,
- 							p_siopinib->brg2_def, p_siopinib->brg1_def);
- 	upd72001_write_ctrl(p_siopinib->ctrl, UPD72001_CR15, CR15_DEF);
- 	upd72001_write_ctrl(p_siopinib->ctrl, UPD72001_CR14, CR14_DEF);
- 	upd72001_write_ctrl(p_siopinib->ctrl, UPD72001_CR10, CR10_DEF);
- 	upd72001_write_ctrl(p_siopinib->ctrl, UPD72001_CR3, p_siopinib->cr3_def);
- 	upd72001_write_ctrl(p_siopinib->ctrl, UPD72001_CR5, p_siopinib->cr5_def);
- 	p_siopcb->exinf = exinf;
- 	p_siopcb->getready = false;
- 	p_siopcb->putready = false;
- 	p_siopcb->openflag = true;
- 	return(p_siopcb);
- }
- 
- /*
-  *  ꥢI/OݡȤΥ
-  */
- void
- upd72001_cls_por(SIOPCB *p_siopcb)
- {
- 	upd72001_write_ctrl(p_siopcb->p_siopinib->ctrl, UPD72001_CR1, CR1_DOWN);
- 	p_siopcb->openflag = false;
- }
- 
- /*
-  *  ꥢI/OݡȤؤʸ
-  */
- bool_t
- upd72001_snd_chr(SIOPCB *p_siopcb, char c)
- {
- 	if (upd72001_putready(p_siopcb)) {
- 		upd72001_putchar(p_siopcb, c);
- 		return(true);
- 	}
- 	return(false);
- }
- 
- /*
-  *  ꥢI/OݡȤʸ
-  */
- int_t
- upd72001_rcv_chr(SIOPCB *p_siopcb)
- {
- 	if (upd72001_getready(p_siopcb)) {
- 		return((int_t)(uint8_t) upd72001_getchar(p_siopcb));
- 	}
- 	return(-1);
- }
- 
- /*
-  *  ꥢI/OݡȤΥХåε
-  */
- void
- upd72001_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
- {
- 	uint8_t	cr1_bit;
- 
- 	switch (cbrtn) {
- 	case SIO_RDY_SND:
- 		cr1_bit = CR1_SEND;
- 		break;
- 	case SIO_RDY_RCV:
- 		cr1_bit = CR1_RECV;
- 		break;
- 	default:
- 		cr1_bit = 0U;
- 		break;
- 	}
- 	p_siopcb->cr1 |= cr1_bit;
- 	upd72001_write_ctrl(p_siopcb->p_siopinib->ctrl,
- 									UPD72001_CR1, p_siopcb->cr1);
- }
- 
- /*
-  *  ꥢI/OݡȤΥХåζػ
-  */
- void
- upd72001_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn)
- {
- 	uint8_t	cr1_bit;
- 
- 	switch (cbrtn) {
- 	case SIO_RDY_SND:
- 		cr1_bit = CR1_SEND;
- 		break;
- 	case SIO_RDY_RCV:
- 		cr1_bit = CR1_RECV;
- 		break;
- 	default:
- 		cr1_bit = 0U;
- 		break;
- 	}
- 	p_siopcb->cr1 &= ~cr1_bit;
- 	upd72001_write_ctrl(p_siopcb->p_siopinib->ctrl,
- 									UPD72001_CR1, p_siopcb->cr1);
- }
- 
- /*
-  *  ꥢI/OݡȤФ߽
-  */
- static void
- upd72001_isr_siop(SIOPCB *p_siopcb)
- {
- 	if ((p_siopcb->cr1 & CR1_RECV) != 0U) {
- 		if (upd72001_getready(p_siopcb)) {
- 			/*
- 			 *  ΥХå롼ƤӽФ
- 			 */
- 			upd72001_irdy_rcv(p_siopcb->exinf);
- 		}
- 	}
- 	if ((p_siopcb->cr1 & CR1_SEND) != 0U) {
- 		if (upd72001_putready(p_siopcb)) {
- 			/*
- 			 *  ǽХå롼ƤӽФ
- 			 */
- 			upd72001_irdy_snd(p_siopcb->exinf);
- 		}
- 	}
- }
- 
- /*
-  *  SIOγߥӥ롼
-  */
- void
- upd72001_isr(void)
- {
- 	if (siopcb_table[0].openflag) {
- 		upd72001_isr_siop(&(siopcb_table[0]));
- 	}
- 	if (siopcb_table[1].openflag) {
- 		upd72001_isr_siop(&(siopcb_table[1]));
- 	}
- 	upd72001_eoi();
- }
--- 0 ----
diff -cr --new-file 1.9.1/asp/pdic/upd72001/upd72001.h ASPs/asp/pdic/upd72001/upd72001.h
*** 1.9.1/asp/pdic/upd72001/upd72001.h	Sat Aug 27 07:39:16 2011
--- ASPs/asp/pdic/upd72001/upd72001.h	Thu Jan  1 09:00:00 1970
***************
*** 1,124 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2006-2011 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: upd72001.h 2246 2011-08-26 22:39:15Z ertl-hiro $
-  */
- 
- /*
-  *		PD72001 ʰSIOɥ饤
-  */
- 
- #ifndef TOPPERS_UPD72001_H
- #define TOPPERS_UPD72001_H
- 
- /*
-  *  ꥢI/Oݡȿ
-  */
- #define TNUM_SIOP		2		/* ݡȤ륷ꥢI/OݡȤο */
- 
- #ifndef TOPPERS_MACRO_ONLY
- 
- /*
-  *  ꥢI/Oݡȴ֥å
-  */
- typedef struct sio_port_control_block	SIOPCB;
- 
- /*
-  *  Хå롼μֹ
-  */
- #define SIO_RDY_SND		1U		/* ǽХå */
- #define SIO_RDY_RCV		2U		/* ΥХå */
- 
- /*
-  *  SIOɥ饤Фν롼
-  */
- extern void		upd72001_initialize(void);
- 
- /*
-  *  ץ󤷤ƤݡȤ뤫
-  */
- extern bool_t	upd72001_openflag(void);
- 
- /*
-  *  ꥢI/OݡȤΥץ
-  */
- extern SIOPCB	*upd72001_opn_por(ID siopid, intptr_t exinf);
- 
- /*
-  *  ꥢI/OݡȤΥ
-  */
- extern void		upd72001_cls_por(SIOPCB *p_siopcb);
- 
- /*
-  *  ꥢI/OݡȤؤʸ
-  */
- extern bool_t	upd72001_snd_chr(SIOPCB *p_siopcb, char c);
- 
- /*
-  *  ꥢI/OݡȤʸ
-  */
- extern int_t	upd72001_rcv_chr(SIOPCB *p_siopcb);
- 
- /*
-  *  ꥢI/OݡȤΥХåε
-  */
- extern void		upd72001_ena_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
- 
- /*
-  *  ꥢI/OݡȤΥХåζػ
-  */
- extern void		upd72001_dis_cbr(SIOPCB *p_siopcb, uint_t cbrtn);
- 
- /*
-  *  SIOγߥӥ롼
-  */
- extern void		upd72001_isr(void);
- 
- /*
-  *  ꥢI/OݡȤǽХå
-  */
- extern void		upd72001_irdy_snd(intptr_t exinf);
- 
- /*
-  *  ꥢI/OݡȤμΥХå
-  */
- extern void		upd72001_irdy_rcv(intptr_t exinf);
- 
- #endif /* TOPPERS_MACRO_ONLY */
- #endif /* TOPPERS_UPD72001_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/sample/Makefile ASPs/asp/sample/Makefile
*** 1.9.1/asp/sample/Makefile	Thu Jan  2 16:08:55 2014
--- ASPs/asp/sample/Makefile	Fri Dec  9 13:54:10 2022
***************
*** 8,57 ****
  #  Copyright (C) 2006-2014 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
! #  ܥեȥѤΤޤࡥʲƱˤѡʣ
! #  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
! #  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
! #      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
! #      ˴ޤޤƤ뤳ȡ
! #  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
! #      ѤǤǺۤˤϡۤȼɥȡ
! #      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
! #      ̵ݾڵǺܤ뤳ȡ
! #  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
! #      ѤǤʤǺۤˤϡΤ줫ξ
! #      ȡ
! #    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
! #        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
! #    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
! #        𤹤뤳ȡ
! #  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
! #      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
! #      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
! #      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
! #      դ뤳ȡ
  # 
! #  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
! #  TOPPERSץȤϡܥեȥ˴ؤơλŪ
! #  ФŬޤơʤݾڤԤʤޤܥեȥ
! #  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
! #  Ǥʤ
  # 
  #  $Id: Makefile 2594 2014-01-02 07:08:54Z ertl-hiro $
  # 
  
  #
! #  åȤλMakefile.targetǾ񤭤Τɤ
  #
  all:
  
  #
! #  åάΤ
  #
  TARGET = @(TARGET)
  
  #
! #  ץߥ󥰸
  #
  SRCLANG = @(SRCLANG)
  ifeq ($(SRCLANG),c)
--- 8,57 ----
  #  Copyright (C) 2006-2014 by Embedded and Real-Time Systems Laboratory
  #              Graduate School of Information Science, Nagoya Univ., JAPAN
  # 
! #  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
! #  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
! #  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
! #  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
! #      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
! #      スコード中に含まれていること．
! #  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
! #      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
! #      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
! #      の無保証規定を掲載すること．
! #  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
! #      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
! #      と．
! #    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
! #        作権表示，この利用条件および下記の無保証規定を掲載すること．
! #    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
! #        報告すること．
! #  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
! #      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
! #      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
! #      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
! #      免責すること．
  # 
! #  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
! #  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
! #  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
! #  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
! #  の責任を負わない．
  # 
  #  $Id: Makefile 2594 2014-01-02 07:08:54Z ertl-hiro $
  # 
  
  #
! #  ターゲットの指定（Makefile.targetで上書きされるのを防ぐため）
  #
  all:
  
  #
! #  ターゲット略称の定義
  #
  TARGET = @(TARGET)
  
  #
! #  プログラミング言語の定義
  #
  SRCLANG = @(SRCLANG)
  ifeq ($(SRCLANG),c)
***************
*** 64,107 ****
  endif
  
  #
! #  եΥǥ쥯ȥ
  #
  SRCDIR = @(SRCDIR)
  
  #
! #  ֥ȥե̾γĥҤ
  #
  OBJEXT = @(OBJEXT)
  
  #
! #  ¹ԴĶʥåȰ¸˾񤭤礬
  #
  DBGENV := @(DBGENV)
  
  #
! #  ͥ饤֥libkernel.aˤΥǥ쥯ȥ̾
! #  ʥͥ饤֥makeоݤˤϡ
  #
  KERNEL_LIB = @(KERNEL_LIB)
  
  #
! #  ͥؿñ̤ǥѥ뤹뤫ɤ
  #
  KERNEL_FUNCOBJS = @(KERNEL_FUNCOBJS)
  
  #
! #  ȥ졼뤫ɤ
  #
  ENABLE_TRACE = @(ENABLE_TRACE)
  
  #
! #  桼ƥƥץ̾
  #
  PERL = @(PERL)
  CFG = @(CFG)
  
  #
! #  ֥ȥե̾
  #
  OBJNAME = asp
  ifdef OBJEXT
--- 64,107 ----
  endif
  
  #
! #  ソースファイルのディレクトリの定義
  #
  SRCDIR = @(SRCDIR)
  
  #
! #  オブジェクトファイル名の拡張子の設定
  #
  OBJEXT = @(OBJEXT)
  
  #
! #  実行環境の定義（ターゲット依存に上書きされる場合がある）
  #
  DBGENV := @(DBGENV)
  
  #
! #  カーネルライブラリ（libkernel.a）のディレクトリ名
! #  （カーネルライブラリもmake対象にする時は，空に定義する）
  #
  KERNEL_LIB = @(KERNEL_LIB)
  
  #
! #  カーネルを関数単位でコンパイルするかどうかの定義
  #
  KERNEL_FUNCOBJS = @(KERNEL_FUNCOBJS)
  
  #
! #  トレースログを取得するかどうかの定義
  #
  ENABLE_TRACE = @(ENABLE_TRACE)
  
  #
! #  ユーティリティプログラムの名称
  #
  PERL = @(PERL)
  CFG = @(CFG)
  
  #
! #  オブジェクトファイル名の定義
  #
  OBJNAME = asp
  ifdef OBJEXT
***************
*** 113,129 ****
  endif
  
  #
! #  åȰ¸Υǥ쥯ȥ
  #
  TARGETDIR = $(SRCDIR)/target/$(TARGET)
  
  #
! #  åȰ¸Υ󥯥롼
  #
  include $(TARGETDIR)/Makefile.target
  
  #
! #  ե졼طѿ
  #
  CFG_TABS := --api-table $(SRCDIR)/kernel/kernel_api.csv \
  			--cfg1-def-table $(SRCDIR)/kernel/kernel_def.csv $(CFG_TABS)
--- 113,129 ----
  endif
  
  #
! #  ターゲット依存部のディレクトリの定義
  #
  TARGETDIR = $(SRCDIR)/target/$(TARGET)
  
  #
! #  ターゲット依存の定義のインクルード
  #
  include $(TARGETDIR)/Makefile.target
  
  #
! #  コンフィギュレータ関係の変数の定義
  #
  CFG_TABS := --api-table $(SRCDIR)/kernel/kernel_api.csv \
  			--cfg1-def-table $(SRCDIR)/kernel/kernel_def.csv $(CFG_TABS)
***************
*** 134,142 ****
  CFG2_OUT_SRCS := kernel_cfg.h kernel_cfg.c $(CFG2_OUT_SRCS)
  
  #
! #  ̥ѥ륪ץ
  #
! COPTS := $(COPTS) -g @(COPTS)
  ifndef OMIT_WARNING_ALL
    COPTS := $(COPTS) -Wall
  endif
--- 134,142 ----
  CFG2_OUT_SRCS := kernel_cfg.h kernel_cfg.c $(CFG2_OUT_SRCS)
  
  #
! #  共通コンパイルオプションの定義
  #
! COPTS := $(COPTS)  -g @(COPTS)
  ifndef OMIT_WARNING_ALL
    COPTS := $(COPTS) -Wall
  endif
***************
*** 151,157 ****
  CFLAGS = $(COPTS) $(CDEFS) $(INCLUDES)
  
  #
! #  ץꥱץ˴ؤ
  #
  APPLNAME = @(APPLNAME)
  APPLDIR = @(APPLDIR)
--- 151,157 ----
  CFLAGS = $(COPTS) $(CDEFS) $(INCLUDES)
  
  #
! #  アプリケーションプログラムに関する定義
  #
  APPLNAME = @(APPLNAME)
  APPLDIR = @(APPLDIR)
***************
*** 173,202 ****
  endif
  
  #
! #  ƥॵӥ˴ؤ
  #
  SYSSVC_DIR := $(SYSSVC_DIR) $(SRCDIR)/syssvc $(SRCDIR)/library
  SYSSVC_ASMOBJS := $(SYSSVC_ASMOBJS)
! SYSSVC_COBJS := $(SYSSVC_COBJS) banner.o syslog.o serial.o logtask.o \
  				@(SYSSVCOBJS) $(CXXRTS)
  SYSSVC_CFLAGS := $(SYSSVC_CFLAGS)
  SYSSVC_LIBS := $(SYSSVC_LIBS)
  INCLUDES := $(INCLUDES)
  
  #
! #  ͥ˴ؤ
  #
! #  KERNEL_ASMOBJS: ͥ饤֥˴ޤ롤֥
! #				   ֥ȥե롥
! #  KERNEL_COBJS: ͥΥ饤֥˴ޤ롤Cǡ
! #				 ե11б륪֥ȥե롥
! #  KERNEL_LCSRCS: ͥΥ饤֥˴ޤCΥեǡ
! #				  1ĤΥե뤫ʣΥ֥ȥե
! #				  Ρ
! #  KERNEL_LCOBJS: Υե뤫륪֥ȥե롥
! #  KERNEL_AUX_COBJS: ɥ⥸塼˴ޤʤͥΥե
! #					 ƱץŬѤƥѥ뤹٤
! #					 CΥ֥ȥե롥
  #
  KERNEL_DIR := $(KERNEL_DIR) $(SRCDIR)/kernel
  KERNEL_ASMOBJS := $(KERNEL_ASMOBJS)
--- 173,202 ----
  endif
  
  #
! #  システムサービスに関する定義
  #
  SYSSVC_DIR := $(SYSSVC_DIR) $(SRCDIR)/syssvc $(SRCDIR)/library
  SYSSVC_ASMOBJS := $(SYSSVC_ASMOBJS)
! SYSSVC_COBJS := $(SYSSVC_COBJS) banner.o syslog.o logtask.o \
  				@(SYSSVCOBJS) $(CXXRTS)
  SYSSVC_CFLAGS := $(SYSSVC_CFLAGS)
  SYSSVC_LIBS := $(SYSSVC_LIBS)
  INCLUDES := $(INCLUDES)
  
  #
! #  カーネルに関する定義
  #
! #  KERNEL_ASMOBJS: カーネルライブラリに含める，ソースがアセンブリ言語の
! #				   オブジェクトファイル．
! #  KERNEL_COBJS: カーネルのライブラリに含める，ソースがC言語で，ソース
! #				 ファイルと1対1に対応するオブジェクトファイル．
! #  KERNEL_LCSRCS: カーネルのライブラリに含めるC言語のソースファイルで，
! #				  1つのソースファイルから複数のオブジェクトファイルを生
! #				  成するもの．
! #  KERNEL_LCOBJS: 上のソースファイルから生成されるオブジェクトファイル．
! #  KERNEL_AUX_COBJS: ロードモジュールに含めないが，カーネルのソースファ
! #					 イルと同じオプションを適用してコンパイルすべき，ソー
! #					 スがC言語のオブジェクトファイル．
  #
  KERNEL_DIR := $(KERNEL_DIR) $(SRCDIR)/kernel
  KERNEL_ASMOBJS := $(KERNEL_ASMOBJS)
***************
*** 212,234 ****
  endif
  
  #
! #  åȥեʣƱ򤷤ƤϤʤʤ
  #
  all: $(OBJFILE)
  #all: $(OBJNAME).bin
  #all: $(OBJNAME).srec
  
! ##### ʲԽʤ #####
  
  #
! #  Ķ˰¸륳ѥ륪ץ
  #
  ifdef DBGENV
    CDEFS := $(CDEFS) -D$(DBGENV)
  endif
  
  #
! #  ͥΥե빽
  #
  include $(SRCDIR)/kernel/Makefile.kernel
  ifdef KERNEL_FUNCOBJS
--- 212,234 ----
  endif
  
  #
! #  ターゲットファイル（複数を同時に選択してはならない）
  #
  all: $(OBJFILE)
  #all: $(OBJNAME).bin
  #all: $(OBJNAME).srec
  
! ##### 以下は編集しないこと #####
  
  #
! #  環境に依存するコンパイルオプションの定義
  #
  ifdef DBGENV
    CDEFS := $(CDEFS) -D$(DBGENV)
  endif
  
  #
! #  カーネルのファイル構成の定義
  #
  include $(SRCDIR)/kernel/Makefile.kernel
  ifdef KERNEL_FUNCOBJS
***************
*** 241,254 ****
  endif
  
  #
! #  եΤǥ쥯ȥ˴ؤ
  #
  vpath %.c $(KERNEL_DIR) $(SYSSVC_DIR) $(APPL_DIR)
  vpath %.S $(KERNEL_DIR) $(SYSSVC_DIR) $(APPL_DIR)
  vpath %.cfg $(APPL_DIR)
  
  #
! #  ѥΤѿ
  #
  KERNEL_LIB_OBJS = $(KERNEL_ASMOBJS) $(KERNEL_COBJS) $(KERNEL_LCOBJS)
  SYSSVC_OBJS = $(SYSSVC_ASMOBJS) $(SYSSVC_COBJS)
--- 241,254 ----
  endif
  
  #
! #  ソースファイルのあるディレクトリに関する定義
  #
  vpath %.c $(KERNEL_DIR) $(SYSSVC_DIR) $(APPL_DIR)
  vpath %.S $(KERNEL_DIR) $(SYSSVC_DIR) $(APPL_DIR)
  vpath %.cfg $(APPL_DIR)
  
  #
! #  コンパイルのための変数の定義
  #
  KERNEL_LIB_OBJS = $(KERNEL_ASMOBJS) $(KERNEL_COBJS) $(KERNEL_LCOBJS)
  SYSSVC_OBJS = $(SYSSVC_ASMOBJS) $(SYSSVC_COBJS)
***************
*** 279,285 ****
  endif
  
  #
! #  եåȥեoffset.hˤ§
  #
  ifdef OFFSET_TF
  offset.h: $(APPL_CFG) kernel_cfg.timestamp
--- 279,285 ----
  endif
  
  #
! #  オフセットファイル（offset.h）の生成規則
  #
  ifdef OFFSET_TF
  offset.h: $(APPL_CFG) kernel_cfg.timestamp
***************
*** 292,298 ****
  endif
  
  #
! #  ͥΥե졼ե
  #
  cfg1_out.c: $(APPL_CFG)
  	$(CFG) --pass 1 --kernel asp $(INCLUDES) $(CFG_TABS) $<
--- 292,298 ----
  endif
  
  #
! #  カーネルのコンフィギュレーションファイルの生成
  #
  cfg1_out.c: $(APPL_CFG)
  	$(CFG) --pass 1 --kernel asp $(INCLUDES) $(CFG_TABS) $<
***************
*** 309,315 ****
  	touch -r kernel_cfg.c kernel_cfg.timestamp
  
  #
! #  ͥ饤֥ե
  #
  libkernel.a: $(OFFSET_H) $(KERNEL_LIB_OBJS)
  	rm -f libkernel.a
--- 309,315 ----
  	touch -r kernel_cfg.c kernel_cfg.timestamp
  
  #
! #  カーネルライブラリファイルの生成
  #
  libkernel.a: $(OFFSET_H) $(KERNEL_LIB_OBJS)
  	rm -f libkernel.a
***************
*** 317,358 ****
  	$(RANLIB) libkernel.a
  
  #
! #  ̤ʰ¸ط
  #
  banner.o: kernel_cfg.timestamp $(filter-out banner.o,$(ALL_OBJS)) $(LIBS_DEP)
  
  #
! #  ΤΥ
  #
! $(OBJFILE): $(APPL_CFG) kernel_cfg.timestamp $(ALL_OBJS) $(LIBS_DEP)
! 	$(LINK) $(CFLAGS) $(LDFLAGS) -o $(OBJFILE) $(START_OBJS) \
  			$(APPL_OBJS) $(SYSSVC_OBJS) $(CFG_OBJS) $(ALL_LIBS) $(END_OBJS)
! 	$(NM) -n $(OBJFILE) > $(OBJNAME).syms
! 	$(OBJCOPY) -O srec -S $(OBJFILE) $(OBJNAME).srec
  	$(CFG) --pass 3 --kernel asp $(INCLUDES) \
  				--rom-image $(OBJNAME).srec --symbol-table $(OBJNAME).syms \
  				-T $(TARGETDIR)/target_check.tf $(CFG_TABS) $<
  
  #
! #  Хʥե
  #
  $(OBJNAME).bin: $(OBJFILE)
! 	$(OBJCOPY) -O binary -S $(OBJFILE) $(OBJNAME).bin
  
  #
! #  S쥳ɥե
  #
  $(OBJNAME).srec: $(OBJFILE)
! 	$(OBJCOPY) -O srec -S $(OBJFILE) $(OBJNAME).srec
  
  #
! #  ѥ̤ξõ
  #
  .PHONY: clean
  clean:
! 	rm -f \#* *~ *.o $(CLEAN_FILES)
! 	rm -f $(OBJFILE) $(OBJNAME).syms $(OBJNAME).srec $(OBJNAME).bin
  	rm -f kernel_cfg.timestamp $(CFG2_OUT_SRCS)
  	rm -f cfg1_out.c $(CFG1_OUT) cfg1_out.syms cfg1_out.srec
  ifndef KERNEL_LIB
  	rm -f libkernel.a
--- 317,367 ----
  	$(RANLIB) libkernel.a
  
  #
! #  特別な依存関係の定義
  #
  banner.o: kernel_cfg.timestamp $(filter-out banner.o,$(ALL_OBJS)) $(LIBS_DEP)
  
  #
! #  全体のリンク
  #
! $(OBJFILE): $(APPL_CFG) kernel_cfg.timestamp $(ALL_OBJS) $(LIBS_DEP) 
! 	
! 	$(LINK) $(CFLAGS) $(LDFLAGS) -o '${C_PROJECT}'/toppers_rx/$(OBJFILE) $(START_OBJS) \
  			$(APPL_OBJS) $(SYSSVC_OBJS) $(CFG_OBJS) $(ALL_LIBS) $(END_OBJS)
! 	
! 		rm -f '${C_PROJECT}'/toppers_rx/libasp.a
! 		
! 	$(AR) -rcs '${C_PROJECT}'/toppers_rx/libasp.a $(ALL_OBJS) $(KERNEL_LIB_OBJS)
! 	$(AR) -d  '${C_PROJECT}'/toppers_rx/libasp.a dummy.o 				
! 	$(NM) -n '${C_PROJECT}'/toppers_rx/$(OBJFILE) > $(OBJNAME).syms
! 	
! 	$(OBJCOPY) -O srec -S '${C_PROJECT}'/toppers_rx/$(OBJFILE) $(OBJNAME).srec
! 	
  	$(CFG) --pass 3 --kernel asp $(INCLUDES) \
  				--rom-image $(OBJNAME).srec --symbol-table $(OBJNAME).syms \
  				-T $(TARGETDIR)/target_check.tf $(CFG_TABS) $<
  
  #
! #  バイナリファイルの生成
  #
  $(OBJNAME).bin: $(OBJFILE)
! 	$(OBJCOPY) -O binary -S '${C_PROJECT}'/toppers_rx/$(OBJFILE) $(OBJNAME).bin
  
  #
! #  Sレコードファイルの生成
  #
  $(OBJNAME).srec: $(OBJFILE)
! 	$(OBJCOPY) -O srec -S '${C_PROJECT}'/toppers_rx/$(OBJFILE) $(OBJNAME).srec
  
  #
! #  コンパイル結果の消去
  #
  .PHONY: clean
  clean:
! 	rm -f \#* *~ *.o ../*.o $(CLEAN_FILES)
! 	rm -f '${C_PROJECT}'/toppers_rx/$(OBJFILE) $(OBJNAME).syms $(OBJNAME).srec $(OBJNAME).bin
  	rm -f kernel_cfg.timestamp $(CFG2_OUT_SRCS)
+ 	rm -f ${C_PROJECT}'/toppers_rx/$(OBJFILE)/libasp.a
  	rm -f cfg1_out.c $(CFG1_OUT) cfg1_out.syms cfg1_out.srec
  ifndef KERNEL_LIB
  	rm -f libkernel.a
***************
*** 378,389 ****
  	rm -f $(REALCLEAN_FILES)
  
  #
! #  ե졼եΥѥ롼Ȱ¸ط
! #  롼
  #
! #  ե졼եϡץꥱץѡ
! #  ƥॵӥѡͥѤΤ٤ƤΥץդƥѥ
! #  롥
  #
  ALL_CFG_COBJS = $(CFG_COBJS) cfg1_out.o
  ALL_CFG_ASMOBJS = $(CFG_ASMOBJS)
--- 387,398 ----
  	rm -f $(REALCLEAN_FILES)
  
  #
! #  コンフィギュレータが生成したファイルのコンパイルルールと依存関係作成
! #  ルールの定義
  #
! #  コンフィギュレータが生成したファイルは，アプリケーションプログラム用，
! #  システムサービス用，カーネル用のすべてのオプションを付けてコンパイル
! #  する．
  #
  ALL_CFG_COBJS = $(CFG_COBJS) cfg1_out.o
  ALL_CFG_ASMOBJS = $(CFG_ASMOBJS)
***************
*** 407,413 ****
  		-O "$(CFLAGS) $(CFG_CFLAGS)" $< >> Makefile.depend
  
  #
! #  üʰ¸ط롼
  #
  cfg1_out.depend: $(APPL_CFG)
  	@$(CFG) -M cfg1_out.c $(INCLUDES) $< >> Makefile.depend
--- 416,422 ----
  		-O "$(CFLAGS) $(CFG_CFLAGS)" $< >> Makefile.depend
  
  #
! #  特殊な依存関係作成ルールの定義
  #
  cfg1_out.depend: $(APPL_CFG)
  	@$(CFG) -M cfg1_out.c $(INCLUDES) $< >> Makefile.depend
***************
*** 417,423 ****
  		-T "makeoffset.s" -O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend
  
  #
! #  ¸طե
  #
  .PHONY: gendepend
  gendepend:
--- 426,432 ----
  		-T "makeoffset.s" -O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend
  
  #
! #  依存関係ファイルの生成
  #
  .PHONY: gendepend
  gendepend:
***************
*** 436,451 ****
  endif
  
  #
! #  ¸طե򥤥󥯥롼
  #
  -include Makefile.depend
  
  #
! #  ȯġΥޥ̾
  #
  ifeq ($(TOOL),gcc)
    #
!   #  GNUȯĶ
    #
    ifdef GCC_TARGET
      GCC_TARGET_PREFIX = $(GCC_TARGET)-
--- 445,460 ----
  endif
  
  #
! #  依存関係ファイルをインクルード
  #
  -include Makefile.depend
  
  #
! #  開発ツールのコマンド名の定義
  #
  ifeq ($(TOOL),gcc)
    #
!   #  GNU開発環境用
    #
    ifdef GCC_TARGET
      GCC_TARGET_PREFIX = $(GCC_TARGET)-
***************
*** 470,476 ****
  endif
  
  #
! #  ѥ롼
  #
  KERNEL_ALL_COBJS = $(KERNEL_COBJS) $(KERNEL_AUX_COBJS)
  
--- 479,485 ----
  endif
  
  #
! #  コンパイルルールの定義
  #
  KERNEL_ALL_COBJS = $(KERNEL_COBJS) $(KERNEL_AUX_COBJS)
  
***************
*** 514,520 ****
  	$(CC) -c $(CFLAGS) $(APPL_CFLAGS) $<
  
  #
! #  ¸ط롼
  #
  $(KERNEL_COBJS:.o=.d): %.d: %.c
  	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
--- 523,529 ----
  	$(CC) -c $(CFLAGS) $(APPL_CFLAGS) $<
  
  #
! #  依存関係作成ルールの定義
  #
  $(KERNEL_COBJS:.o=.d): %.d: %.c
  	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
***************
*** 549,555 ****
  		-O "$(CFLAGS) $(APPL_CFLAGS)" $< >> Makefile.depend
  
  #
! #  ǥեȥѥ롼
  #
  %.o: %.c
  	@echo "*** Default compile rules should not be used."
--- 558,564 ----
  		-O "$(CFLAGS) $(APPL_CFLAGS)" $< >> Makefile.depend
  
  #
! #  デフォルトコンパイルルールを上書き
  #
  %.o: %.c
  	@echo "*** Default compile rules should not be used."
diff -cr --new-file 1.9.1/asp/sample/Makefile.bak ASPs/asp/sample/Makefile.bak
*** 1.9.1/asp/sample/Makefile.bak	Thu Jan  1 09:00:00 1970
--- ASPs/asp/sample/Makefile.bak	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,578 ----
+ #
+ #  TOPPERS/ASP Kernel
+ #      Toyohashi Open Platform for Embedded Real-Time Systems/
+ #      Advanced Standard Profile Kernel
+ # 
+ #  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+ #                              Toyohashi Univ. of Technology, JAPAN
+ #  Copyright (C) 2006-2014 by Embedded and Real-Time Systems Laboratory
+ #              Graduate School of Information Science, Nagoya Univ., JAPAN
+ # 
+ #  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ #  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ #  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ #  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ #      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ #      スコード中に含まれていること．
+ #  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ #      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ #      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ #      の無保証規定を掲載すること．
+ #  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ #      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ #      と．
+ #    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ #        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ #    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ #        報告すること．
+ #  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ #      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ #      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ #      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ #      免責すること．
+ # 
+ #  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ #  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ #  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ #  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ #  の責任を負わない．
+ # 
+ #  $Id: Makefile 2594 2014-01-02 07:08:54Z ertl-hiro $
+ # 
+ 
+ #
+ #  ターゲットの指定（Makefile.targetで上書きされるのを防ぐため）
+ #
+ all:
+ 
+ #
+ #  ターゲット略称の定義
+ #
+ TARGET = @(TARGET)
+ 
+ #
+ #  プログラミング言語の定義
+ #
+ SRCLANG = @(SRCLANG)
+ ifeq ($(SRCLANG),c)
+   LIBS = -lc
+ endif
+ ifeq ($(SRCLANG),c++)
+   USE_CXX = true
+   CXXLIBS = -lstdc++ -lm -lc
+   CXXRTS = cxxrt.o newlibrt.o
+ endif
+ 
+ #
+ #  ソースファイルのディレクトリの定義
+ #
+ SRCDIR = @(SRCDIR)
+ 
+ #
+ #  オブジェクトファイル名の拡張子の設定
+ #
+ OBJEXT = @(OBJEXT)
+ 
+ #
+ #  実行環境の定義（ターゲット依存に上書きされる場合がある）
+ #
+ DBGENV := @(DBGENV)
+ 
+ #
+ #  カーネルライブラリ（libkernel.a）のディレクトリ名
+ #  （カーネルライブラリもmake対象にする時は，空に定義する）
+ #
+ KERNEL_LIB = @(KERNEL_LIB)
+ 
+ #
+ #  カーネルを関数単位でコンパイルするかどうかの定義
+ #
+ KERNEL_FUNCOBJS = @(KERNEL_FUNCOBJS)
+ 
+ #
+ #  トレースログを取得するかどうかの定義
+ #
+ ENABLE_TRACE = @(ENABLE_TRACE)
+ 
+ #
+ #  ユーティリティプログラムの名称
+ #
+ PERL = @(PERL)
+ CFG = @(CFG)
+ 
+ #
+ #  オブジェクトファイル名の定義
+ #
+ OBJNAME = asp
+ ifdef OBJEXT
+   OBJFILE = $(OBJNAME).$(OBJEXT)
+   CFG1_OUT = cfg1_out.$(OBJEXT)
+ else
+   OBJFILE = $(OBJNAME)
+   CFG1_OUT = cfg1_out
+ endif
+ 
+ #
+ #  ターゲット依存部のディレクトリの定義
+ #
+ TARGETDIR = $(SRCDIR)/target/$(TARGET)
+ 
+ #
+ #  ターゲット依存の定義のインクルード
+ #
+ include $(TARGETDIR)/Makefile.target
+ 
+ #
+ #  コンフィギュレータ関係の変数の定義
+ #
+ CFG_TABS := --api-table $(SRCDIR)/kernel/kernel_api.csv \
+ 			--cfg1-def-table $(SRCDIR)/kernel/kernel_def.csv $(CFG_TABS)
+ 
+ CFG_ASMOBJS := $(CFG_ASMOBJS)
+ CFG_COBJS := kernel_cfg.o $(CFG_COBJS)
+ CFG_OBJS := $(CFG_ASMOBJS) $(CFG_COBJS)
+ CFG2_OUT_SRCS := kernel_cfg.h kernel_cfg.c $(CFG2_OUT_SRCS)
+ 
+ #
+ #  共通コンパイルオプションの定義
+ #
+ COPTS := $(COPTS)  -g @(COPTS)
+ ifndef OMIT_WARNING_ALL
+   COPTS := $(COPTS) -Wall
+ endif
+ ifndef OMIT_OPTIMIZATION
+   COPTS := $(COPTS) -O2
+ endif
+ CDEFS := $(CDEFS) @(CDEFS)
+ INCLUDES := -I. -I$(SRCDIR)/include -I$(SRCDIR)/arch -I$(SRCDIR) $(INCLUDES)
+ LDFLAGS := $(LDFLAGS) @(LDFLAGS)
+ CFG1_OUT_LDFLAGS := $(CFG1_OUT_LDFLAGS) @(LDFLAGS)
+ LIBS := $(LIBS) $(CXXLIBS)
+ CFLAGS = $(COPTS) $(CDEFS) $(INCLUDES)
+ 
+ #
+ #  アプリケーションプログラムに関する定義
+ #
+ APPLNAME = @(APPLNAME)
+ APPLDIR = @(APPLDIR)
+ APPL_CFG = $(APPLNAME).cfg
+ 
+ APPL_DIR = $(APPLDIR) $(SRCDIR)/library
+ APPL_ASMOBJS =
+ ifdef USE_CXX
+   APPL_CXXOBJS = $(APPLNAME).o @(APPLOBJS)
+   APPL_COBJS =
+ else
+   APPL_COBJS = $(APPLNAME).o @(APPLOBJS)
+ endif
+ APPL_COBJS := $(APPL_COBJS) log_output.o vasyslog.o t_perror.o strerror.o
+ APPL_CFLAGS =
+ APPL_LIBS =
+ ifdef APPLDIR
+   INCLUDES := $(INCLUDES) $(foreach dir,$(APPLDIR),-I$(dir))
+ endif
+ 
+ #
+ #  システムサービスに関する定義
+ #
+ SYSSVC_DIR := $(SYSSVC_DIR) $(SRCDIR)/syssvc $(SRCDIR)/library
+ SYSSVC_ASMOBJS := $(SYSSVC_ASMOBJS)
+ SYSSVC_COBJS := $(SYSSVC_COBJS) banner.o syslog.o logtask.o \
+ 				@(SYSSVCOBJS) $(CXXRTS)
+ SYSSVC_CFLAGS := $(SYSSVC_CFLAGS)
+ SYSSVC_LIBS := $(SYSSVC_LIBS)
+ INCLUDES := $(INCLUDES)
+ 
+ #
+ #  カーネルに関する定義
+ #
+ #  KERNEL_ASMOBJS: カーネルライブラリに含める，ソースがアセンブリ言語の
+ #				   オブジェクトファイル．
+ #  KERNEL_COBJS: カーネルのライブラリに含める，ソースがC言語で，ソース
+ #				 ファイルと1対1に対応するオブジェクトファイル．
+ #  KERNEL_LCSRCS: カーネルのライブラリに含めるC言語のソースファイルで，
+ #				  1つのソースファイルから複数のオブジェクトファイルを生
+ #				  成するもの．
+ #  KERNEL_LCOBJS: 上のソースファイルから生成されるオブジェクトファイル．
+ #  KERNEL_AUX_COBJS: ロードモジュールに含めないが，カーネルのソースファ
+ #					 イルと同じオプションを適用してコンパイルすべき，ソー
+ #					 スがC言語のオブジェクトファイル．
+ #
+ KERNEL_DIR := $(KERNEL_DIR) $(SRCDIR)/kernel
+ KERNEL_ASMOBJS := $(KERNEL_ASMOBJS)
+ KERNEL_COBJS := $(KERNEL_COBJS)
+ KERNEL_CFLAGS := $(KERNEL_CFLAGS) -I$(SRCDIR)/kernel
+ ifdef OMIT_MAKEOFFSET
+   OFFSET_H =
+ else
+   OFFSET_H = offset.h
+ ifndef OFFSET_TF
+   KERNEL_AUX_COBJS := $(KERNEL_AUX_COBJS) makeoffset.o
+ endif
+ endif
+ 
+ #
+ #  ターゲットファイル（複数を同時に選択してはならない）
+ #
+ all: $(OBJFILE)
+ #all: $(OBJNAME).bin
+ #all: $(OBJNAME).srec
+ 
+ ##### 以下は編集しないこと #####
+ 
+ #
+ #  環境に依存するコンパイルオプションの定義
+ #
+ ifdef DBGENV
+   CDEFS := $(CDEFS) -D$(DBGENV)
+ endif
+ 
+ #
+ #  カーネルのファイル構成の定義
+ #
+ include $(SRCDIR)/kernel/Makefile.kernel
+ ifdef KERNEL_FUNCOBJS
+   KERNEL_LCSRCS := $(KERNEL_FCSRCS)
+   KERNEL_LCOBJS := $(foreach file,$(KERNEL_FCSRCS),$($(file:.c=)))
+ else
+   KERNEL_CFLAGS := -DALLFUNC $(KERNEL_CFLAGS)
+   KERNEL_COBJS := $(KERNEL_COBJS) \
+ 					$(foreach file,$(KERNEL_FCSRCS),$(file:.c=.o))
+ endif
+ 
+ #
+ #  ソースファイルのあるディレクトリに関する定義
+ #
+ vpath %.c $(KERNEL_DIR) $(SYSSVC_DIR) $(APPL_DIR)
+ vpath %.S $(KERNEL_DIR) $(SYSSVC_DIR) $(APPL_DIR)
+ vpath %.cfg $(APPL_DIR)
+ 
+ #
+ #  コンパイルのための変数の定義
+ #
+ KERNEL_LIB_OBJS = $(KERNEL_ASMOBJS) $(KERNEL_COBJS) $(KERNEL_LCOBJS)
+ SYSSVC_OBJS = $(SYSSVC_ASMOBJS) $(SYSSVC_COBJS)
+ APPL_OBJS = $(APPL_ASMOBJS) $(APPL_COBJS) $(APPL_CXXOBJS)
+ ALL_OBJS = $(START_OBJS) $(APPL_OBJS) $(SYSSVC_OBJS) $(CFG_OBJS) \
+ 											$(END_OBJS) $(HIDDEN_OBJS)
+ ifdef KERNEL_LIB
+   ALL_LIBS = $(APPL_LIBS) $(SYSSVC_LIBS) -lkernel $(LIBS)
+   LIBS_DEP = $(filter %.a,$(ALL_LIBS)) $(KERNEL_LIB)/libkernel.a
+   LDFLAGS := $(LDFLAGS) -L$(KERNEL_LIB)
+   REALCLEAN_FILES := libkernel.a $(REALCLEAN_FILES)
+ else
+   ALL_LIBS = $(APPL_LIBS) $(SYSSVC_LIBS) libkernel.a $(LIBS)
+   LIBS_DEP = $(filter %.a,$(ALL_LIBS))
+ endif
+ 
+ ifdef TEXT_START_ADDRESS
+   LDFLAGS := $(LDFLAGS) -Wl,-Ttext,$(TEXT_START_ADDRESS)
+   CFG1_OUT_LDFLAGS := $(CFG1_OUT_LDFLAGS) -Wl,-Ttext,$(TEXT_START_ADDRESS)
+ endif
+ ifdef DATA_START_ADDRESS
+   LDFLAGS := $(LDFLAGS) -Wl,-Tdata,$(DATA_START_ADDRESS)
+   CFG1_OUT_LDFLAGS := $(CFG1_OUT_LDFLAGS) -Wl,-Tdata,$(DATA_START_ADDRESS)
+ endif
+ ifdef LDSCRIPT
+   LDFLAGS := $(LDFLAGS) -T $(LDSCRIPT)
+   CFG1_OUT_LDFLAGS := $(CFG1_OUT_LDFLAGS) -T $(LDSCRIPT)
+ endif
+ 
+ #
+ #  オフセットファイル（offset.h）の生成規則
+ #
+ ifdef OFFSET_TF
+ offset.h: $(APPL_CFG) kernel_cfg.timestamp
+ 	$(CFG) --pass 3 --kernel asp $(INCLUDES) \
+ 				--rom-image cfg1_out.srec --symbol-table cfg1_out.syms \
+ 				-T $(OFFSET_TF) $(CFG_TABS) $<
+ else
+ offset.h: makeoffset.s $(SRCDIR)/utils/genoffset
+ 	$(PERL) $(SRCDIR)/utils/genoffset makeoffset.s > offset.h
+ endif
+ 
+ #
+ #  カーネルのコンフィギュレーションファイルの生成
+ #
+ cfg1_out.c: $(APPL_CFG)
+ 	$(CFG) --pass 1 --kernel asp $(INCLUDES) $(CFG_TABS) $<
+ 
+ $(CFG2_OUT_SRCS): kernel_cfg.timestamp
+ kernel_cfg.timestamp: $(APPL_CFG) \
+ 						$(START_OBJS) cfg1_out.o $(END_OBJS) $(HIDDEN_OBJS)
+ 	$(LINK) $(CFLAGS) $(CFG1_OUT_LDFLAGS) -o $(CFG1_OUT) \
+ 						$(START_OBJS) cfg1_out.o $(END_OBJS)
+ 	$(NM) -n $(CFG1_OUT) > cfg1_out.syms
+ 	$(OBJCOPY) -O srec -S $(CFG1_OUT) cfg1_out.srec
+ 	$(CFG) --pass 2 --kernel asp $(INCLUDES) \
+ 				-T $(TARGETDIR)/target.tf $(CFG_TABS) $<
+ 	touch -r kernel_cfg.c kernel_cfg.timestamp
+ 
+ #
+ #  カーネルライブラリファイルの生成
+ #
+ libkernel.a: $(OFFSET_H) $(KERNEL_LIB_OBJS)
+ 	rm -f libkernel.a
+ 	$(AR) -rcs libkernel.a $(KERNEL_LIB_OBJS)
+ 	$(RANLIB) libkernel.a
+ 
+ #
+ #  特別な依存関係の定義
+ #
+ banner.o: kernel_cfg.timestamp $(filter-out banner.o,$(ALL_OBJS)) $(LIBS_DEP)
+ 
+ #
+ #  全体のリンク
+ #
+ $(OBJFILE): $(APPL_CFG) kernel_cfg.timestamp $(ALL_OBJS) $(LIBS_DEP) 
+ 	
+ 	$(LINK) $(CFLAGS) $(LDFLAGS) -o $(OBJFILE) $(START_OBJS) \
+ 			$(APPL_OBJS) $(SYSSVC_OBJS) $(CFG_OBJS) $(ALL_LIBS) $(END_OBJS)
+ 		rm -f libasp.a
+ 		
+ 	$(AR) -rcs libasp.a $(ALL_OBJS) $(KERNEL_LIB_OBJS)
+ 	$(AR) -d  libasp.a dummy.o 				
+ 	$(NM) -n $(OBJFILE) > $(OBJNAME).syms
+ 	
+ 	$(OBJCOPY) -O srec -S $(OBJFILE) $(OBJNAME).srec
+ 	$(CFG) --pass 3 --kernel asp $(INCLUDES) \
+ 				--rom-image $(OBJNAME).srec --symbol-table $(OBJNAME).syms \
+ 				-T $(TARGETDIR)/target_check.tf $(CFG_TABS) $<
+ 
+ #
+ #  バイナリファイルの生成
+ #
+ $(OBJNAME).bin: $(OBJFILE)
+ 	$(OBJCOPY) -O binary -S $(OBJFILE) $(OBJNAME).bin
+ 
+ #
+ #  Sレコードファイルの生成
+ #
+ $(OBJNAME).srec: $(OBJFILE)
+ 	$(OBJCOPY) -O srec -S $(OBJFILE) $(OBJNAME).srec
+ 
+ #
+ #  コンパイル結果の消去
+ #
+ .PHONY: clean
+ clean:
+ 	rm -f \#* *~ *.o ../*.o $(CLEAN_FILES)
+ 	rm -f $(OBJFILE) $(OBJNAME).syms $(OBJNAME).srec $(OBJNAME).bin
+ 	rm -f kernel_cfg.timestamp $(CFG2_OUT_SRCS)
+ 	rm -f cfg1_out.c $(CFG1_OUT) cfg1_out.syms cfg1_out.srec
+ ifndef KERNEL_LIB
+ 	rm -f libkernel.a
+ endif
+ 	rm -f makeoffset.s offset.h
+ 
+ .PHONY: cleankernel
+ cleankernel:
+ 	rm -rf $(KERNEL_LIB_OBJS)
+ 	rm -f makeoffset.s offset.h
+ 
+ .PHONY: cleandep
+ cleandep:
+ 	if ! [ -f Makefile.depend ]; then \
+ 		rm -f kernel_cfg.timestamp $(CFG2_OUT_SRCS); \
+ 		rm -f cfg1_out.c cfg1_out.o $(CFG1_OUT) cfg1_out.syms cfg1_out.srec; \
+ 		rm -f makeoffset.s offset.h; \
+ 	fi
+ 	rm -f Makefile.depend
+ 
+ .PHONY: realclean
+ realclean: cleandep clean
+ 	rm -f $(REALCLEAN_FILES)
+ 
+ #
+ #  コンフィギュレータが生成したファイルのコンパイルルールと依存関係作成
+ #  ルールの定義
+ #
+ #  コンフィギュレータが生成したファイルは，アプリケーションプログラム用，
+ #  システムサービス用，カーネル用のすべてのオプションを付けてコンパイル
+ #  する．
+ #
+ ALL_CFG_COBJS = $(CFG_COBJS) cfg1_out.o
+ ALL_CFG_ASMOBJS = $(CFG_ASMOBJS)
+ CFG_CFLAGS = $(APPL_CFLAGS) $(SYSSVC_CFLAGS) $(KERNEL_CFLAGS)
+ 
+ $(ALL_CFG_COBJS): %.o: %.c
+ 	$(CC) -c $(CFLAGS) $(CFG_CFLAGS) $<
+ 
+ $(ALL_CFG_COBJS:.o=.s): %.s: %.c
+ 	$(CC) -S $(CFLAGS) $(CFG_CFLAGS) $<
+ 
+ $(ALL_CFG_COBJS:.o=.d): %.d: %.c
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(CFG_CFLAGS)" $< >> Makefile.depend
+ 
+ $(ALL_CFG_ASMOBJS): %.o: %.S
+ 	$(CC) -c $(CFLAGS) $(CFG_CFLAGS) $<
+ 
+ $(ALL_CFG_ASMOBJS:.o=.d): %.d: %.S
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(CFG_CFLAGS)" $< >> Makefile.depend
+ 
+ #
+ #  特殊な依存関係作成ルールの定義
+ #
+ cfg1_out.depend: $(APPL_CFG)
+ 	@$(CFG) -M cfg1_out.c $(INCLUDES) $< >> Makefile.depend
+ 
+ makeoffset.d: makeoffset.c
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-T "makeoffset.s" -O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend
+ 
+ #
+ #  依存関係ファイルの生成
+ #
+ .PHONY: gendepend
+ gendepend:
+ 	@echo "Generating Makefile.depend."
+ 
+ .PHONY: depend
+ ifdef KERNEL_LIB
+ depend: cleandep kernel_cfg.timestamp gendepend \
+ 		cfg1_out.depend cfg1_out.d \
+ 		$(ALL_OBJS:.o=.d)
+ else
+ depend: cleandep $(OFFSET_H) kernel_cfg.timestamp gendepend \
+ 		cfg1_out.depend cfg1_out.d \
+ 		$(KERNEL_AUX_COBJS:.o=.d) $(KERNEL_ASMOBJS:.o=.d) \
+ 		$(KERNEL_COBJS:.o=.d) $(KERNEL_LCSRCS:.c=.d) $(ALL_OBJS:.o=.d)
+ endif
+ 
+ #
+ #  依存関係ファイルをインクルード
+ #
+ -include Makefile.depend
+ 
+ #
+ #  開発ツールのコマンド名の定義
+ #
+ ifeq ($(TOOL),gcc)
+   #
+   #  GNU開発環境用
+   #
+   ifdef GCC_TARGET
+     GCC_TARGET_PREFIX = $(GCC_TARGET)-
+   else
+     GCC_TARGET_PREFIX =
+   endif
+   CC = $(GCC_TARGET_PREFIX)gcc
+   CXX = $(GCC_TARGET_PREFIX)g++
+   AS = $(GCC_TARGET_PREFIX)as
+   LD = $(GCC_TARGET_PREFIX)ld
+   AR = $(GCC_TARGET_PREFIX)ar
+   NM = $(GCC_TARGET_PREFIX)nm
+   RANLIB = $(GCC_TARGET_PREFIX)ranlib
+   OBJCOPY = $(GCC_TARGET_PREFIX)objcopy
+   OBJDUMP = $(GCC_TARGET_PREFIX)objdump
+ endif
+ 
+ ifdef USE_CXX
+   LINK = $(CXX)
+ else
+   LINK = $(CC)
+ endif
+ 
+ #
+ #  コンパイルルールの定義
+ #
+ KERNEL_ALL_COBJS = $(KERNEL_COBJS) $(KERNEL_AUX_COBJS)
+ 
+ $(KERNEL_ALL_COBJS): %.o: %.c
+ 	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<
+ 
+ $(KERNEL_ALL_COBJS:.o=.s): %.s: %.c
+ 	$(CC) -S $(CFLAGS) $(KERNEL_CFLAGS) $<
+ 
+ $(KERNEL_LCOBJS): %.o:
+ 	$(CC) -DTOPPERS_$(*F) -o $@ -c $(CFLAGS) $(KERNEL_CFLAGS) $<
+ 
+ $(KERNEL_LCOBJS:.o=.s): %.s:
+ 	$(CC) -DTOPPERS_$(*F) -o $@ -S $(CFLAGS) $(KERNEL_CFLAGS) $<
+ 
+ $(KERNEL_ASMOBJS): %.o: %.S
+ 	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<
+ 
+ $(SYSSVC_COBJS): %.o: %.c
+ 	$(CC) -c $(CFLAGS) $(SYSSVC_CFLAGS) $<
+ 
+ $(SYSSVC_COBJS:.o=.s): %.s: %.c
+ 	$(CC) -S $(CFLAGS) $(SYSSVC_CFLAGS) $<
+ 
+ $(SYSSVC_ASMOBJS): %.o: %.S
+ 	$(CC) -c $(CFLAGS) $(SYSSVC_CFLAGS) $<
+ 
+ $(APPL_COBJS): %.o: %.c
+ 	$(CC) -c $(CFLAGS) $(APPL_CFLAGS) $<
+ 
+ $(APPL_COBJS:.o=.s): %.s: %.c
+ 	$(CC) -S $(CFLAGS) $(APPL_CFLAGS) $<
+ 
+ $(APPL_CXXOBJS): %.o: %.cpp
+ 	$(CXX) -c $(CFLAGS) $(APPL_CFLAGS) $<
+ 
+ $(APPL_CXXOBJS:.o=.s): %.s: %.cpp
+ 	$(CXX) -S $(CFLAGS) $(APPL_CFLAGS) $<
+ 
+ $(APPL_ASMOBJS): %.o: %.S
+ 	$(CC) -c $(CFLAGS) $(APPL_CFLAGS) $<
+ 
+ #
+ #  依存関係作成ルールの定義
+ #
+ $(KERNEL_COBJS:.o=.d): %.d: %.c
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend
+ 
+ $(KERNEL_LCSRCS:.c=.d): %.d: %.c
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) -T "$($*)" \
+ 		-O "-DALLFUNC $(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend
+ 
+ $(KERNEL_ASMOBJS:.o=.d): %.d: %.S
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend
+ 
+ $(SYSSVC_COBJS:.o=.d): %.d: %.c
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(SYSSVC_CFLAGS)" $< >> Makefile.depend
+ 
+ $(SYSSVC_ASMOBJS:.o=.d): %.d: %.S
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(SYSSVC_CFLAGS)" $< >> Makefile.depend
+ 
+ $(APPL_COBJS:.o=.d): %.d: %.c
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(APPL_CFLAGS)" $< >> Makefile.depend
+ 
+ $(APPL_CXXOBJS:.o=.d): %.d: %.cpp
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CXX) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(APPL_CFLAGS)" $< >> Makefile.depend
+ 
+ $(APPL_ASMOBJS:.o=.d): %.d: %.S
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(APPL_CFLAGS)" $< >> Makefile.depend
+ 
+ #
+ #  デフォルトコンパイルルールを上書き
+ #
+ %.o: %.c
+ 	@echo "*** Default compile rules should not be used."
+ 	$(CC) -c $(CFLAGS) $<
+ 
+ %.s: %.c
+ 	@echo "*** Default compile rules should not be used."
+ 	$(CC) -S $(CFLAGS) $<
+ 
+ %.o: %.cpp
+ 	@echo "*** Default compile rules should not be used."
+ 	$(CXX) -c $(CFLAGS) $<
+ 
+ %.s: %.cpp
+ 	@echo "*** Default compile rules should not be used."
+ 	$(CXX) -S $(CFLAGS) $<
+ 
+ %.o: %.S
+ 	@echo "*** Default compile rules should not be used."
+ 	$(CC) -c $(CFLAGS) $<
diff -cr --new-file 1.9.1/asp/sample/sample1.c ASPs/asp/sample/sample1.c
*** 1.9.1/asp/sample/sample1.c	Fri Sep  7 17:06:21 2012
--- ASPs/asp/sample/sample1.c	Fri Dec  9 13:54:10 2022
***************
*** 8,108 ****
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: sample1.c 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /* 
!  *  ץץ(1)
   *
!  *  ASPͥδŪưǧ뤿Υץץࡥ
   *
!  *  ץγ:
   *
!  *  桼󥿥եĥᥤ󥿥ʥID: MAIN_TASKͥ
!  *  : MAIN_PRIORITYˤȡ3Ĥ¹Լ¹Ԥ륿ʥID:
!  *  TASK1TASK3ͥ: MID_PRIORITYˤǹ롥ޤư
!  *  2äμϥɥʼϥɥID: CYCHDR1ˤѤ롥
   *
!  *  ¹Լ¹Ԥ륿ϡtask_loop롼פ¹Ԥ٤ˡ
!  *  ¹Ǥ뤳Ȥ򤢤魯åɽ롥롼פ¹Ԥ
!  *  Τϡ롼פʤǥåϤȡ¿̤Υå
!  *  졤ץưǧ餯ʤ뤿Ǥ롥ޤ®ʥ
!  *  ꥢݡȤѤƥåϤˡ٤ƤΥå
!  *  ϤǤ褦ˡå̤¤Ȥͳ⤢롥
   *
!  *  ϥɥϡĤͥ١HIGH_PRIORITYMID_PRIORITY
!  *  LOW_PRIORITYˤΥǥ塼ž롥ץεưľϡ
!  *  ϥɥ߾֤ˤʤäƤ롥
   *
!  *  ᥤ󥿥ϡꥢI/OݡȤʸϤԤʸϤ
!  *  ԤäƤ֤ϡ¹Լ¹Ԥ륿¹ԤƤˡϤ줿
!  *  ʸб¹Ԥ롥Ϥ줿ʸȽδطϼ̤ꡥ
!  *  Control-Cޤ'Q'Ϥȡץλ롥
   *
!  *  '1' : оݥTASK1ڤ괹ʽˡ
!  *  '2' : оݥTASK2ڤ괹롥
!  *  '3' : оݥTASK3ڤ괹롥
!  *  'a' : оݥact_tskˤ굯ư롥
!  *  'A' : оݥФ뵯ư׵can_actˤꥭ󥻥뤹롥
!  *  'e' : оݥext_tskƤӽФλ롥
!  *  't' : оݥter_tskˤ궯λ롥
!  *  '>' : оݥͥ٤HIGH_PRIORITYˤ롥
!  *  '=' : оݥͥ٤MID_PRIORITYˤ롥
!  *  '<' : оݥͥ٤LOW_PRIORITYˤ롥
!  *  'G' : оݥͥ٤get_priɤ߽Ф
!  *  's' : оݥslp_tskƤӽФԤˤ롥
!  *  'S' : оݥtslp_tsk(10)ƤӽФԤˤ롥
!  *  'w' : оݥwup_tskˤ굯롥
!  *  'W' : оݥФ뵯׵can_wupˤꥭ󥻥뤹롥
!  *  'l' : оݥrel_waiˤ궯ŪԤˤ롥
!  *  'u' : оݥsus_tskˤ궯Ԥ֤ˤ롥
!  *  'm' : оݥζԤ֤rsm_tskˤ롥
!  *  'd' : оݥdly_tsk(10)ƤӽФַвԤˤ롥
!  *  'x' : оݥ㳰ѥ0x0001㳰׵᤹롥
!  *  'X' : оݥ㳰ѥ0x0002㳰׵᤹롥
!  *  'y' : оݥdis_texƤӽФ㳰ػߤ롥
!  *  'Y' : оݥena_texƤӽФ㳰Ĥ롥
!  *  'r' : 3Ĥͥ١HIGH_PRIORITYMID_PRIORITYLOW_PRIORITYˤΥ
!  *        ǥ塼ž롥
!  *  'c' : ϥɥưϤ롥
!  *  'C' : ϥɥưߤ롥
!  *  'b' : 顼ϥɥ5ø˵ư褦ưϤ롥
!  *  'B' : 顼ϥɥưߤ롥
!  *  'z' : оݥCPU㳰ȯʥλˡ
!  *  'Z' : оݥCPUå֤CPU㳰ȯʥץ
!  *        λˡ
!  *  'V' : get_utmǽɾѥƥ2ɤࡥ
!  *  'v' : ȯԤƥॳɽʥǥեȡˡ
!  *  'q' : ȯԤƥॳɽʤ
   */
  
  #include <kernel.h>
--- 8,108 ----
   *  Copyright (C) 2004-2012 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: sample1.c 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /* 
!  *  サンプルプログラム(1)の本体
   *
!  *  ASPカーネルの基本的な動作を確認するためのサンプルプログラム．
   *
!  *  プログラムの概要:
   *
!  *  ユーザインタフェースを受け持つメインタスク（タスクID: MAIN_TASK，優
!  *  先度: MAIN_PRIORITY）と，3つの並行実行されるタスク（タスクID:
!  *  TASK1〜TASK3，初期優先度: MID_PRIORITY）で構成される．また，起動周
!  *  期が2秒の周期ハンドラ（周期ハンドラID: CYCHDR1）を用いる．
   *
!  *  並行実行されるタスクは，task_loop回空ループを実行する度に，タスクが
!  *  実行中であることをあらわすメッセージを表示する．空ループを実行する
!  *  のは，空ループなしでメッセージを出力すると，多量のメッセージが出力
!  *  され，プログラムの動作が確認しずらくなるためである．また，低速なシ
!  *  リアルポートを用いてメッセージを出力する場合に，すべてのメッセージ
!  *  が出力できるように，メッセージの量を制限するという理由もある．
   *
!  *  周期ハンドラは，三つの優先度（HIGH_PRIORITY，MID_PRIORITY，
!  *  LOW_PRIORITY）のレディキューを回転させる．プログラムの起動直後は，
!  *  周期ハンドラは停止状態になっている．
   *
!  *  メインタスクは，シリアルI/Oポートからの文字入力を行い（文字入力を
!  *  待っている間は，並行実行されるタスクが実行されている），入力された
!  *  文字に対応した処理を実行する．入力された文字と処理の関係は次の通り．
!  *  Control-Cまたは'Q'が入力されると，プログラムを終了する．
   *
!  *  '1' : 対象タスクをTASK1に切り換える（初期設定）．
!  *  '2' : 対象タスクをTASK2に切り換える．
!  *  '3' : 対象タスクをTASK3に切り換える．
!  *  'a' : 対象タスクをact_tskにより起動する．
!  *  'A' : 対象タスクに対する起動要求をcan_actによりキャンセルする．
!  *  'e' : 対象タスクにext_tskを呼び出させ，終了させる．
!  *  't' : 対象タスクをter_tskにより強制終了する．
!  *  '>' : 対象タスクの優先度をHIGH_PRIORITYにする．
!  *  '=' : 対象タスクの優先度をMID_PRIORITYにする．
!  *  '<' : 対象タスクの優先度をLOW_PRIORITYにする．
!  *  'G' : 対象タスクの優先度をget_priで読み出す．
!  *  's' : 対象タスクにslp_tskを呼び出させ，起床待ちにさせる．
!  *  'S' : 対象タスクにtslp_tsk(10秒)を呼び出させ，起床待ちにさせる．
!  *  'w' : 対象タスクをwup_tskにより起床する．
!  *  'W' : 対象タスクに対する起床要求をcan_wupによりキャンセルする．
!  *  'l' : 対象タスクをrel_waiにより強制的に待ち解除にする．
!  *  'u' : 対象タスクをsus_tskにより強制待ち状態にする．
!  *  'm' : 対象タスクの強制待ち状態をrsm_tskにより解除する．
!  *  'd' : 対象タスクにdly_tsk(10秒)を呼び出させ，時間経過待ちにさせる．
!  *  'x' : 対象タスクに例外パターン0x0001の例外処理を要求する．
!  *  'X' : 対象タスクに例外パターン0x0002の例外処理を要求する．
!  *  'y' : 対象タスクにdis_texを呼び出させ，タスク例外を禁止する．
!  *  'Y' : 対象タスクにena_texを呼び出させ，タスク例外を許可する．
!  *  'r' : 3つの優先度（HIGH_PRIORITY，MID_PRIORITY，LOW_PRIORITY）のレ
!  *        ディキューを回転させる．
!  *  'c' : 周期ハンドラを動作開始させる．
!  *  'C' : 周期ハンドラを動作停止させる．
!  *  'b' : アラームハンドラを5秒後に起動するよう動作開始させる．
!  *  'B' : アラームハンドラを動作停止させる．
!  *  'z' : 対象タスクにCPU例外を発生させる（タスクを終了させる）．
!  *  'Z' : 対象タスクにCPUロック状態でCPU例外を発生させる（プログラムを
!  *        終了する）．
!  *  'V' : get_utmで性能評価用システム時刻を2回読む．
!  *  'v' : 発行したシステムコールを表示する（デフォルト）．
!  *  'q' : 発行したシステムコールを表示しない．
   */
  
  #include <kernel.h>
***************
*** 114,120 ****
  #include "sample1.h"
  
  /*
!  *  ӥΥ顼Υ
   */
  Inline void
  svc_perror(const char *file, int_t line, const char *expr, ER ercd)
--- 114,120 ----
  #include "sample1.h"
  
  /*
!  *  サービスコールのエラーのログ出力
   */
  Inline void
  svc_perror(const char *file, int_t line, const char *expr, ER ercd)
***************
*** 127,205 ****
  #define	SVC_PERROR(expr)	svc_perror(__FILE__, __LINE__, #expr, (expr))
  
  /*
!  *  ¹Լ¹Ԥ륿ؤΥåΰ
   */
  char	message[3];
  
  /*
!  *  롼ײ
   */
! ulong_t	task_loop;		/* ǤΥ롼ײ */
! ulong_t	tex_loop;		/* 㳰롼ǤΥ롼ײ */
  
  /*
!  *  ¹Լ¹Ԥ륿
   */
  void task(intptr_t exinf)
  {
  	volatile ulong_t	i;
  	int_t		n = 0;
  	int_t		tskno = (int_t) exinf;
  	const char	*graph[] = { "|", "  +", "    *" };
  	char		c;
- 
  	SVC_PERROR(ena_tex());
  	while (true) {
  		syslog(LOG_NOTICE, "task%d is running (%03d).   %s",
! 										tskno, ++n, graph[tskno-1]);
! 		for (i = 0; i < task_loop; i++);
! 		c = message[tskno-1];
! 		message[tskno-1] = 0;
! 		switch (c) {
! 		case 'e':
! 			syslog(LOG_INFO, "#%d#ext_tsk()", tskno);
! 			SVC_PERROR(ext_tsk());
! 			assert(0);
! 		case 's':
! 			syslog(LOG_INFO, "#%d#slp_tsk()", tskno);
! 			SVC_PERROR(slp_tsk());
! 			break;
! 		case 'S':
! 			syslog(LOG_INFO, "#%d#tslp_tsk(10000)", tskno);
! 			SVC_PERROR(tslp_tsk(10000));
! 			break;
! 		case 'd':
! 			syslog(LOG_INFO, "#%d#dly_tsk(10000)", tskno);
! 			SVC_PERROR(dly_tsk(10000));
! 			break;
! 		case 'y':
! 			syslog(LOG_INFO, "#%d#dis_tex()", tskno);
! 			SVC_PERROR(dis_tex());
! 			break;
! 		case 'Y':
! 			syslog(LOG_INFO, "#%d#ena_tex()", tskno);
! 			SVC_PERROR(ena_tex());
! 			break;
! #ifdef CPUEXC1
! 		case 'z':
! 			syslog(LOG_NOTICE, "#%d#raise CPU exception", tskno);
! 			RAISE_CPU_EXCEPTION;
! 			break;
! 		case 'Z':
! 			SVC_PERROR(loc_cpu());
! 			syslog(LOG_NOTICE, "#%d#raise CPU exception", tskno);
! 			RAISE_CPU_EXCEPTION;
! 			SVC_PERROR(unl_cpu());
! 			break;
! #endif /* CPUEXC1 */
! 		default:
! 			break;
! 		}
  	}
  }
  
  /*
!  *  ¹ԤƼ¹Ԥ륿ѤΥ㳰롼
   */
  void tex_routine(TEXPTN texptn, intptr_t exinf)
  {
--- 127,173 ----
  #define	SVC_PERROR(expr)	svc_perror(__FILE__, __LINE__, #expr, (expr))
  
  /*
!  *  並行実行されるタスクへのメッセージ領域
   */
  char	message[3];
  
  /*
!  *  ループ回数
   */
! ulong_t	task_loop;		/* タスク内でのループ回数 */
! ulong_t	tex_loop;		/* 例外処理ルーチン内でのループ回数 */
! //Wrapper
! void waisem_ether_wrapper() {
! 	wai_sem(ETHER_START_SEM);
! 
! }
! void sigsem_ether_wrapper() {
! 	sig_sem(ETHER_START_SEM);
! }
  
  /*
!  *  並行実行されるタスク
   */
  void task(intptr_t exinf)
  {
+ 
  	volatile ulong_t	i;
  	int_t		n = 0;
  	int_t		tskno = (int_t) exinf;
  	const char	*graph[] = { "|", "  +", "    *" };
  	char		c;
  	SVC_PERROR(ena_tex());
+ 
  	while (true) {
+ 		tslp_tsk(500);
  		syslog(LOG_NOTICE, "task%d is running (%03d).   %s",
! 					tskno, ++n, graph[tskno-1]);
! 
  	}
  }
  
  /*
!  *  並行して実行されるタスク用のタスク例外処理ルーチン
   */
  void tex_routine(TEXPTN texptn, intptr_t exinf)
  {
***************
*** 207,213 ****
  	int_t	tskno = (int_t) exinf;
  
  	syslog(LOG_NOTICE, "task%d receives exception 0x%04x.", tskno, texptn);
! 	for (i = 0; i < tex_loop; i++);
  
  	if ((texptn & 0x8000U) != 0U) {
  		syslog(LOG_INFO, "#%d#ext_tsk()", tskno);
--- 175,181 ----
  	int_t	tskno = (int_t) exinf;
  
  	syslog(LOG_NOTICE, "task%d receives exception 0x%04x.", tskno, texptn);
! //	for (i = 0; i < tex_loop; i++);
  
  	if ((texptn & 0x8000U) != 0U) {
  		syslog(LOG_INFO, "#%d#ext_tsk()", tskno);
***************
*** 217,223 ****
  }
  
  /*
!  *  CPU㳰ϥɥ
   */
  #ifdef CPUEXC1
  
--- 185,191 ----
  }
  
  /*
!  *  CPU例外ハンドラ
   */
  #ifdef CPUEXC1
  
***************
*** 253,262 ****
  #endif /* CPUEXC1 */
  
  /*
!  *  ϥɥ
   *
!  *  HIGH_PRIORITYMID_PRIORITYLOW_PRIORITY γͥ٤Υǥ塼
!  *  ž롥
   */
  void cyclic_handler(intptr_t exinf)
  {
--- 221,230 ----
  #endif /* CPUEXC1 */
  
  /*
!  *  周期ハンドラ
   *
!  *  HIGH_PRIORITY，MID_PRIORITY，LOW_PRIORITY の各優先度のレディキュー
!  *  を回転させる．
   */
  void cyclic_handler(intptr_t exinf)
  {
***************
*** 266,275 ****
  }
  
  /*
!  *  顼ϥɥ
   *
!  *  HIGH_PRIORITYMID_PRIORITYLOW_PRIORITY γͥ٤Υǥ塼
!  *  ž롥
   */
  void alarm_handler(intptr_t exinf)
  {
--- 234,243 ----
  }
  
  /*
!  *  アラームハンドラ
   *
!  *  HIGH_PRIORITY，MID_PRIORITY，LOW_PRIORITY の各優先度のレディキュー
!  *  を回転させる．
   */
  void alarm_handler(intptr_t exinf)
  {
***************
*** 279,285 ****
  }
  
  /*
!  *  ᥤ󥿥
   */
  void main_task(intptr_t exinf)
  {
--- 247,253 ----
  }
  
  /*
!  *  メインタスク
   */
  void main_task(intptr_t exinf)
  {
***************
*** 300,349 ****
  	syslog(LOG_NOTICE, "Sample program starts (exinf = %d).", (int_t) exinf);
  
  	/*
! 	 *  ꥢݡȤν
  	 *
! 	 *  ƥƱꥢݡȤȤʤɡꥢ
! 	 *  ݡȤץѤߤξˤϤE_OBJ顼ˤʤ뤬پ
! 	 *  ʤ
  	 */
- 	ercd = serial_opn_por(TASK_PORTID);
- 	if (ercd < 0 && MERCD(ercd) != E_OBJ) {
- 		syslog(LOG_ERROR, "%s (%d) reported by `serial_opn_por'.",
- 									itron_strerror(ercd), SERCD(ercd));
- 	}
- 	SVC_PERROR(serial_ctl_por(TASK_PORTID,
- 							(IOCTL_CRLF | IOCTL_FCSND | IOCTL_FCRCV)));
  
  	/*
!  	 *  롼ײ
  	 *
! 	 *  ¹Լ¹Ԥ륿Ǥζ롼פβtask_loopˤϡ롼
! 	 *  פμ¹Ի֤0.4äˤʤ褦ꤹ롥Τˡ
! 	 *  LOOP_REFζ롼פμ¹Ի֤򡤤get_timƤ֤Ȥ
! 	 *  ¬ꤷ¬̤롼פμ¹Ի֤0.4äˤʤ롼ײ
! 	 *  ᡤtask_loopꤹ롥
  	 *
! 	 *  LOOP_REFϡǥեȤǤ1,000,000ꤷƤ뤬ꤷ
! 	 *  ٤ץåǤϡץץμ¹ԳϤ˻֤
! 	 *  ꤹȤ롥դꤷ®ץåǤϡ
! 	 *  LOOP_REFζ롼פμ¹Ի֤ûʤꡤtask_loopꤹ
! 	 *  θ礭ʤȤ꤬롥
  	 *
! 	 *  ǡΤ褦ʥåȤǤϡtarget_test.hǡLOOP_REFŬ
! 	 *  ڤͤΤ˾ޤ
  	 *
! 	 *  ޤtask_loopͤꤷˤϡͤTASK_LOOP˥
! 	 *  롥TASK_LOOPޥƤ硤嵭¬
! 	 *  Ԥ鷺ˡTASK_LOOP줿ͤ롼פβȤ롥
  	 *
! 	 * åȤˤäƤϡ롼פμ¹Ի֤1ܤ¬ǡ
! 	 * ĹˤʤΤ롥Τ褦ʥåȤǤϡMEASURE_TWICE
! 	 * ޥ뤳Ȥǡ1ܤ¬̤ΤƤơ2ܤ¬
! 	 * Ȥ
  	 *
! 	 *  㳰롼Ǥζ롼פβtex_loopˤϡ
! 	 *  task_loop4ʬ1͡ʶ롼פμ¹Ի֤0.1äˤʤ롼ײ
! 	 *  ˤꤹ롥
  	 */
  #ifdef TASK_LOOP
  	task_loop = TASK_LOOP;
--- 268,310 ----
  	syslog(LOG_NOTICE, "Sample program starts (exinf = %d).", (int_t) exinf);
  
  	/*
! 	 *  シリアルポートの初期化
  	 *
! 	 *  システムログタスクと同じシリアルポートを使う場合など，シリアル
! 	 *  ポートがオープン済みの場合にはここでE_OBJエラーになるが，支障は
! 	 *  ない．
  	 */
  
  	/*
!  	 *  ループ回数の設定
  	 *
! 	 *  並行実行されるタスク内での空ループの回数（task_loop）は，空ルー
! 	 *  プの実行時間が約0.4秒になるように設定する．この設定のために，
! 	 *  LOOP_REF回の空ループの実行時間を，その前後でget_timを呼ぶことで
! 	 *  測定し，その測定結果から空ループの実行時間が0.4秒になるループ回
! 	 *  数を求め，task_loopに設定する．
  	 *
! 	 *  LOOP_REFは，デフォルトでは1,000,000に設定しているが，想定したよ
! 	 *  り遅いプロセッサでは，サンプルプログラムの実行開始に時間がかか
! 	 *  りすぎるという問題を生じる．逆に想定したより速いプロセッサでは，
! 	 *  LOOP_REF回の空ループの実行時間が短くなり，task_loopに設定する値
! 	 *  の誤差が大きくなるという問題がある．
  	 *
! 	 *  そこで，そのようなターゲットでは，target_test.hで，LOOP_REFを適
! 	 *  切な値に定義するのが望ましい．
  	 *
! 	 *  また，task_loopの値を固定したい場合には，その値をTASK_LOOPにマ
! 	 *  クロ定義する．TASK_LOOPがマクロ定義されている場合，上記の測定を
! 	 *  行わずに，TASK_LOOPに定義された値を空ループの回数とする．
  	 *
! 	 * ターゲットによっては，空ループの実行時間の1回目の測定で，本来よ
! 	 * りも長めになるものがある．このようなターゲットでは，MEASURE_TWICE
! 	 * をマクロ定義することで，1回目の測定結果を捨てて，2回目の測定結果
! 	 * を使う．
  	 *
! 	 *  タスク例外処理ルーチン内での空ループの回数（tex_loop）は，
! 	 *  task_loopの4分の1の値（空ループの実行時間が0.1秒になるループ回
! 	 *  数）に設定する．
  	 */
  #ifdef TASK_LOOP
  	task_loop = TASK_LOOP;
***************
*** 366,532 ****
  	tex_loop = task_loop / 4;
  
  	/*
!  	 *  εư
  	 */
  	SVC_PERROR(act_tsk(TASK1));
  	SVC_PERROR(act_tsk(TASK2));
  	SVC_PERROR(act_tsk(TASK3));
  
  	/*
!  	 *  ᥤ롼
  	 */
  	do {
! 		SVC_PERROR(serial_rea_dat(TASK_PORTID, &c, 1));
! 		switch (c) {
! 		case 'e':
! 		case 's':
! 		case 'S':
! 		case 'd':
! 		case 'y':
! 		case 'Y':
! 		case 'z':
! 		case 'Z':
! 			message[tskno-1] = c;
! 			break;
! 		case '1':
! 			tskno = 1;
! 			tskid = TASK1;
! 			break;
! 		case '2':
! 			tskno = 2;
! 			tskid = TASK2;
! 			break;
! 		case '3':
! 			tskno = 3;
! 			tskid = TASK3;
! 			break;
! 		case 'a':
! 			syslog(LOG_INFO, "#act_tsk(%d)", tskno);
! 			SVC_PERROR(act_tsk(tskid));
! 			break;
! 		case 'A':
! 			syslog(LOG_INFO, "#can_act(%d)", tskno);
! 			SVC_PERROR(ercd = can_act(tskid));
! 			if (ercd >= 0) {
! 				syslog(LOG_NOTICE, "can_act(%d) returns %d", tskno, ercd);
! 			}
! 			break;
! 		case 't':
! 			syslog(LOG_INFO, "#ter_tsk(%d)", tskno);
! 			SVC_PERROR(ter_tsk(tskid));
! 			break;
! 		case '>':
! 			syslog(LOG_INFO, "#chg_pri(%d, HIGH_PRIORITY)", tskno);
! 			SVC_PERROR(chg_pri(tskid, HIGH_PRIORITY));
! 			break;
! 		case '=':
! 			syslog(LOG_INFO, "#chg_pri(%d, MID_PRIORITY)", tskno);
! 			SVC_PERROR(chg_pri(tskid, MID_PRIORITY));
! 			break;
! 		case '<':
! 			syslog(LOG_INFO, "#chg_pri(%d, LOW_PRIORITY)", tskno);
! 			SVC_PERROR(chg_pri(tskid, LOW_PRIORITY));
! 			break;
! 		case 'G':
! 			syslog(LOG_INFO, "#get_pri(%d, &tskpri)", tskno);
! 			SVC_PERROR(ercd = get_pri(tskid, &tskpri));
! 			if (ercd >= 0) {
! 				syslog(LOG_NOTICE, "priority of task %d is %d", tskno, tskpri);
! 			}
! 			break;
! 		case 'w':
! 			syslog(LOG_INFO, "#wup_tsk(%d)", tskno);
! 			SVC_PERROR(wup_tsk(tskid));
! 			break;
! 		case 'W':
! 			syslog(LOG_INFO, "#can_wup(%d)", tskno);
! 			SVC_PERROR(ercd = can_wup(tskid));
! 			if (ercd >= 0) {
! 				syslog(LOG_NOTICE, "can_wup(%d) returns %d", tskno, ercd);
! 			}
! 			break;
! 		case 'l':
! 			syslog(LOG_INFO, "#rel_wai(%d)", tskno);
! 			SVC_PERROR(rel_wai(tskid));
! 			break;
! 		case 'u':
! 			syslog(LOG_INFO, "#sus_tsk(%d)", tskno);
! 			SVC_PERROR(sus_tsk(tskid));
! 			break;
! 		case 'm':
! 			syslog(LOG_INFO, "#rsm_tsk(%d)", tskno);
! 			SVC_PERROR(rsm_tsk(tskid));
! 			break;
! 		case 'x':
! 			syslog(LOG_INFO, "#ras_tex(%d, 0x0001U)", tskno);
! 			SVC_PERROR(ras_tex(tskid, 0x0001U));
! 			break;
! 		case 'X':
! 			syslog(LOG_INFO, "#ras_tex(%d, 0x0002U)", tskno);
! 			SVC_PERROR(ras_tex(tskid, 0x0002U));
! 			break;
! 		case 'r':
! 			syslog(LOG_INFO, "#rot_rdq(three priorities)");
! 			SVC_PERROR(rot_rdq(HIGH_PRIORITY));
! 			SVC_PERROR(rot_rdq(MID_PRIORITY));
! 			SVC_PERROR(rot_rdq(LOW_PRIORITY));
! 			break;
! 		case 'c':
! 			syslog(LOG_INFO, "#sta_cyc(1)");
! 			SVC_PERROR(sta_cyc(CYCHDR1));
! 			break;
! 		case 'C':
! 			syslog(LOG_INFO, "#stp_cyc(1)");
! 			SVC_PERROR(stp_cyc(CYCHDR1));
! 			break;
! 		case 'b':
! 			syslog(LOG_INFO, "#sta_alm(1, 5000)");
! 			SVC_PERROR(sta_alm(ALMHDR1, 5000));
! 			break;
! 		case 'B':
! 			syslog(LOG_INFO, "#stp_alm(1)");
! 			SVC_PERROR(stp_alm(ALMHDR1));
! 			break;
! 
! 		case 'V':
! #ifdef TOPPERS_SUPPORT_GET_UTM
! 			SVC_PERROR(get_utm(&utime1));
! 			SVC_PERROR(get_utm(&utime2));
! 			syslog(LOG_NOTICE, "utime1 = %ld, utime2 = %ld",
! 										(ulong_t) utime1, (ulong_t) utime2);
! #else /* TOPPERS_SUPPORT_GET_UTM */
! 			syslog(LOG_NOTICE, "get_utm is not supported.");
! #endif /* TOPPERS_SUPPORT_GET_UTM */
! 			break;
  
! 		case 'v':
! 			SVC_PERROR(syslog_msk_log(LOG_UPTO(LOG_INFO),
! 										LOG_UPTO(LOG_EMERG)));
! 			break;
! 		case 'q':
! 			SVC_PERROR(syslog_msk_log(LOG_UPTO(LOG_NOTICE),
! 										LOG_UPTO(LOG_EMERG)));
! 			break;
! 
! #ifdef BIT_KERNEL
! 		case ' ':
! 			SVC_PERROR(loc_cpu());
! 			{
! 				extern ER	bit_kernel(void);
! 
! 				SVC_PERROR(ercd = bit_kernel());
! 				if (ercd >= 0) {
! 					syslog(LOG_NOTICE, "bit_kernel passed.");
! 				}
! 			}
! 			SVC_PERROR(unl_cpu());
! 			break;
! #endif /* BIT_KERNEL */
! 
! 		default:
! 			break;
! 		}
! 	} while (c != '\003' && c != 'Q');
  
  	syslog(LOG_NOTICE, "Sample program ends.");
  	SVC_PERROR(ext_ker());
--- 327,346 ----
  	tex_loop = task_loop / 4;
  
  	/*
!  	 *  タスクの起動
  	 */
  	SVC_PERROR(act_tsk(TASK1));
  	SVC_PERROR(act_tsk(TASK2));
  	SVC_PERROR(act_tsk(TASK3));
+ 	SVC_PERROR(act_tsk(TASK4));
  
  	/*
!  	 *  メインループ
  	 */
  	do {
! 		slp_tsk();
  
! 	} while (1);
  
  	syslog(LOG_NOTICE, "Sample program ends.");
  	SVC_PERROR(ext_ker());
diff -cr --new-file 1.9.1/asp/sample/sample1.cfg ASPs/asp/sample/sample1.cfg
*** 1.9.1/asp/sample/sample1.cfg	Fri Sep  7 17:06:21 2012
--- ASPs/asp/sample/sample1.cfg	Fri Dec  9 13:54:10 2022
***************
*** 3,26 ****
   */
  
  /*
!  *  ץץ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
  INCLUDE("syssvc/banner.cfg");
- INCLUDE("syssvc/serial.cfg");
  INCLUDE("syssvc/logtask.cfg");
  
  #include "sample1.h"
  CRE_TSK(TASK1, { TA_NULL, 1, task, MID_PRIORITY, STACK_SIZE, NULL });
! CRE_TSK(TASK2, { TA_NULL, 2, task, MID_PRIORITY, STACK_SIZE, NULL });
! CRE_TSK(TASK3, { TA_NULL, 3, task, MID_PRIORITY, STACK_SIZE, NULL });
  CRE_TSK(MAIN_TASK, { TA_ACT, 0, main_task, MAIN_PRIORITY, STACK_SIZE, NULL });
  DEF_TEX(TASK1, { TA_NULL, tex_routine });
  DEF_TEX(TASK2, { TA_NULL, tex_routine });
  DEF_TEX(TASK3, { TA_NULL, tex_routine });
  CRE_CYC(CYCHDR1, { TA_NULL, 0, cyclic_handler, 2000, 0 });
  CRE_ALM(ALMHDR1, { TA_NULL, 0, alarm_handler });
  #ifdef CPUEXC1
  DEF_EXC(CPUEXC1, { TA_NULL, cpuexc_handler });
  #endif /* CPUEXC1 */
--- 3,31 ----
   */
  
  /*
!  *  サンプルプログラム(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
+ INCLUDE("target_edmac.cfg");
  INCLUDE("syssvc/syslog.cfg");
  INCLUDE("syssvc/banner.cfg");
  INCLUDE("syssvc/logtask.cfg");
  
  #include "sample1.h"
  CRE_TSK(TASK1, { TA_NULL, 1, task, MID_PRIORITY, STACK_SIZE, NULL });
! CRE_TSK(TASK2, { TA_NULL, 2, taskEther, MID_PRIORITY, NET_STACK_SIZE , NULL });
! CRE_TSK(TASK3, { TA_NULL, 3, taskDemoWolf, MID_PRIORITY, NET_STACK_SIZE, NULL });
! CRE_TSK(TASK4, { TA_NULL, 4, taskNetWork, MID_PRIORITY, NET_STACK_SIZE, NULL });
! 
  CRE_TSK(MAIN_TASK, { TA_ACT, 0, main_task, MAIN_PRIORITY, STACK_SIZE, NULL });
  DEF_TEX(TASK1, { TA_NULL, tex_routine });
  DEF_TEX(TASK2, { TA_NULL, tex_routine });
  DEF_TEX(TASK3, { TA_NULL, tex_routine });
+ DEF_TEX(TASK4, { TA_NULL, tex_routine });
+ 
  CRE_CYC(CYCHDR1, { TA_NULL, 0, cyclic_handler, 2000, 0 });
  CRE_ALM(ALMHDR1, { TA_NULL, 0, alarm_handler });
  #ifdef CPUEXC1
  DEF_EXC(CPUEXC1, { TA_NULL, cpuexc_handler });
+ 
  #endif /* CPUEXC1 */
diff -cr --new-file 1.9.1/asp/sample/sample1.h ASPs/asp/sample/sample1.h
*** 1.9.1/asp/sample/sample1.h	Sun Nov 11 16:14:24 2012
--- ASPs/asp/sample/sample1.h	Fri Dec  9 13:54:10 2022
***************
*** 8,88 ****
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   *
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   *
   *  $Id: sample1.h 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /*
!  *		ץץ(1)Υإåե
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
  
! #define MAIN_PRIORITY	5		/* ᥤ󥿥ͥ */
! 								/* HIGH_PRIORITY⤯뤳 */
  
! #define HIGH_PRIORITY	9		/* ¹Լ¹Ԥ륿ͥ */
  #define MID_PRIORITY	10
  #define LOW_PRIORITY	11
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  
  #ifndef TASK_PORTID
! #define	TASK_PORTID		1			/* ʸϤ륷ꥢݡID */
  #endif /* TASK_PORTID */
  
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  #ifndef LOOP_REF
! #define LOOP_REF		ULONG_C(1000000)	/* ®ٷ¬ѤΥ롼ײ */
  #endif /* LOOP_REF */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  extern void	task(intptr_t exinf);
  extern void	main_task(intptr_t exinf);
  extern void	tex_routine(TEXPTN texptn, intptr_t exinf);
  #ifdef CPUEXC1
  extern void	cpuexc_handler(void *p_excinf);
--- 8,96 ----
   *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   *
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   *
   *  $Id: sample1.h 2416 2012-09-07 08:06:20Z ertl-hiro $
   */
  
  /*
!  *		サンプルプログラム(1)のヘッダファイル
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
  
! #define MAIN_PRIORITY	5		/* メインタスクの優先度 */
! 								/* HIGH_PRIORITYより高くすること */
  
! #define HIGH_PRIORITY	9		/* 並行実行されるタスクの優先度 */
  #define MID_PRIORITY	10
  #define LOW_PRIORITY	11
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  
  #ifndef TASK_PORTID
! #define	TASK_PORTID		1			/* 文字入力するシリアルポートID */
  #endif /* TASK_PORTID */
  
  #ifndef STACK_SIZE
! #define	STACK_SIZE		(4096 * 4)		/* タスクのスタックサイズ */
! #endif /* STACK_SIZE */
! #ifndef NET_STACK_SIZE
! #define	NET_STACK_SIZE		(1024 * 24) 		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  #ifndef LOOP_REF
! #define LOOP_REF		ULONG_C(1000000)	/* 速度計測用のループ回数 */
  #endif /* LOOP_REF */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
  extern void	task(intptr_t exinf);
+ extern void	taskEther(intptr_t exinf);
+ extern void	taskDemoWolf(intptr_t exinf);
+ extern void	taskNetWork(intptr_t exinf);
+ 
  extern void	main_task(intptr_t exinf);
+ 
  extern void	tex_routine(TEXPTN texptn, intptr_t exinf);
  #ifdef CPUEXC1
  extern void	cpuexc_handler(void *p_excinf);
diff -cr --new-file 1.9.1/asp/syssvc/banner.c ASPs/asp/syssvc/banner.c
*** 1.9.1/asp/syssvc/banner.c	Thu Jan  2 16:08:55 2014
--- ASPs/asp/syssvc/banner.c	Fri Dec  9 13:54:10 2022
***************
*** 8,47 ****
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: banner.c 2594 2014-01-02 07:08:54Z ertl-hiro $
   */
  
  /*
!  *		ͥ뵯ưåν
   */
  
  #include <kernel.h>
--- 8,47 ----
   *  Copyright (C) 2004-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: banner.c 2594 2014-01-02 07:08:54Z ertl-hiro $
   */
  
  /*
!  *		カーネル起動メッセージの出力
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/syssvc/banner.cfg ASPs/asp/syssvc/banner.cfg
*** 1.9.1/asp/syssvc/banner.cfg	Sat Apr 12 10:31:18 2008
--- ASPs/asp/syssvc/banner.cfg	Fri Dec  9 13:54:10 2022
***************
*** 3,9 ****
   */
  
  /*
!  *		ͥ뵯ưåνϤΥե졼ե
   */
  
  #include "syssvc/banner.h"
--- 3,9 ----
   */
  
  /*
!  *		カーネル起動メッセージの出力のコンフィギュレーションファイル
   */
  
  #include "syssvc/banner.h"
diff -cr --new-file 1.9.1/asp/syssvc/banner.h ASPs/asp/syssvc/banner.h
*** 1.9.1/asp/syssvc/banner.h	Sat Apr 12 10:31:18 2008
--- ASPs/asp/syssvc/banner.h	Fri Dec  9 13:54:10 2022
***************
*** 6,52 ****
   *  Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: banner.h 774 2008-03-08 06:35:57Z hiro $
   */
  
  /*
!  *		ͥ뵯ưåν
   */
  
  #ifndef TOPPERS_BANNER_H
  #define TOPPERS_BANNER_H
  
  /*
!  *  ͥ뵯ưåν
   */
  extern void	print_banner(intptr_t exinf) throw();
  
--- 6,52 ----
   *  Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: banner.h 774 2008-03-08 06:35:57Z hiro $
   */
  
  /*
!  *		カーネル起動メッセージの出力
   */
  
  #ifndef TOPPERS_BANNER_H
  #define TOPPERS_BANNER_H
  
  /*
!  *  カーネル起動メッセージの出力
   */
  extern void	print_banner(intptr_t exinf) throw();
  
diff -cr --new-file 1.9.1/asp/syssvc/logtask.c ASPs/asp/syssvc/logtask.c
*** 1.9.1/asp/syssvc/logtask.c	Sat Aug 27 07:39:16 2011
--- ASPs/asp/syssvc/logtask.c	Fri Dec  9 13:54:10 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: logtask.c 2246 2011-08-26 22:39:15Z ertl-hiro $
   */
  
  /*
!  *		ƥ
   */
  
  #include <kernel.h>
--- 8,47 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: logtask.c 2246 2011-08-26 22:39:15Z ertl-hiro $
   */
  
  /*
!  *		システムログタスク
   */
  
  #include <kernel.h>
***************
*** 52,72 ****
  #include "logtask.h"
  
  /*
!  *  ƥνΥݡID
   */
  static ID	logtask_portid;
  
  /*
!  *  ꥢ륤󥿥եؤ1ʸ
   */
  static void
  logtask_putc(char c)
  {
! 	(void) serial_wri_dat(logtask_portid, &c, 1);
  }
  
  /*
!  *  ƥϤԤ碌
   */
  ER
  logtask_flush(uint_t count)
--- 52,72 ----
  #include "logtask.h"
  
  /*
!  *  システムログタスクの出力先のポートID
   */
  static ID	logtask_portid;
  
  /*
!  *  シリアルインタフェースへの1文字出力
   */
  static void
  logtask_putc(char c)
  {
! 	//nothing do
  }
  
  /*
!  *  システムログ出力の待ち合わせ
   */
  ER
  logtask_flush(uint_t count)
***************
*** 87,103 ****
  			if (rlog.count <= count) {
  				if (count == 0U) {
  					/*
! 					 *  count0ξˤϡꥢХåե
! 					 *  ǧ롥
  					 */
! 					if (serial_ref_por(logtask_portid, &rpor) < 0) {
! 						ercd = E_SYS;
! 						goto error_exit;
! 					}
! 					if (rpor.wricnt == 0U) {
! 						ercd = E_OK;
! 						goto error_exit;
! 					}
  				}
  				else {
  					ercd = E_OK;
--- 87,96 ----
  			if (rlog.count <= count) {
  				if (count == 0U) {
  					/*
! 					 *  countが0の場合には，シリアルバッファが空かを確
! 					 *  認する．
  					 */
! 					//nothing do
  				}
  				else {
  					ercd = E_OK;
***************
*** 106,112 ****
  			}
  
  			/*
! 			 *  LOGTASK_FLUSH_WAITߥԤġ
  			 */
  			rercd = dly_tsk(LOGTASK_FLUSH_WAIT);
  			if (rercd < 0) {
--- 99,105 ----
  			}
  
  			/*
! 			 *  LOGTASK_FLUSH_WAITミリ秒待つ．
  			 */
  			rercd = dly_tsk(LOGTASK_FLUSH_WAIT);
  			if (rercd < 0) {
***************
*** 121,127 ****
  }
  
  /*
!  *  ƥ
   */
  void
  logtask_main(intptr_t exinf)
--- 114,120 ----
  }
  
  /*
!  *  システムログタスクの本体
   */
  void
  logtask_main(intptr_t exinf)
***************
*** 129,135 ****
--- 122,132 ----
  	SYSLOG	logbuf;
  	uint_t	lostlog;
  	ER_UINT	rercd;
+ for(;;) {
+ 	(void) dly_tsk(LOGTASK_INTERVAL);
  
+ }
+ #if 0
  	logtask_portid = (ID) exinf;
  	(void) serial_opn_por(logtask_portid);
  	(void) syslog_msk_log(LOG_UPTO(LOG_NOTICE), LOG_UPTO(LOG_EMERG));
***************
*** 153,198 ****
  		}
  		(void) dly_tsk(LOGTASK_INTERVAL);
  	}
  }
  
  /*
!  *  ƥνλ
   */
  void
  logtask_terminate(intptr_t exinf)
  {
! 	char	c;
! 	SYSLOG	logbuf;
! 	bool_t	msgflg = false;
! 	ER_UINT	rercd;
! 
! 	/*
! 	 *  ꥢ륤󥿥եɥ饤ФХåեѤ줿ǡ
! 	 *  ٥ϵǽѤƽϤ롥
! 	 */
! 	while (serial_get_chr(logtask_portid, &c)) {
! 		target_fput_log(c);
! 	}
! 
! 	/*
! 	 *  Хåե˵Ͽ줿٥ϵǽѤƽ
! 	 *  Ϥ롥
! 	 */
! 	while ((rercd = syslog_rea_log(&logbuf)) >= 0) {
! 		if (!msgflg) {
! 			/*
! 			 *  Хåե˻ĤäǤ뤳Ȥ򼨤ʸ
! 			 *  Ϥ롥
! 			 */
! 			syslog_printf("-- buffered messages --\n", NULL, target_fput_log);
! 			msgflg = true;
! 		}
! 		if (rercd > 0) {
! 			syslog_lostmsg((uint_t) rercd, target_fput_log);
! 		}
! 		if (logbuf.logtype >= LOG_TYPE_COMMENT) {
! 			syslog_print(&logbuf, target_fput_log);
! 			target_fput_log('\n');
! 		}
! 	}
  }
--- 150,163 ----
  		}
  		(void) dly_tsk(LOGTASK_INTERVAL);
  	}
+ #endif
  }
  
  /*
!  *  システムログタスクの終了処理
   */
  void
  logtask_terminate(intptr_t exinf)
  {
!  // nothing do
  }
diff -cr --new-file 1.9.1/asp/syssvc/logtask.cfg ASPs/asp/syssvc/logtask.cfg
*** 1.9.1/asp/syssvc/logtask.cfg	Sat Apr 12 10:31:18 2008
--- ASPs/asp/syssvc/logtask.cfg	Fri Dec  9 13:54:10 2022
***************
*** 3,9 ****
   */
  
  /*
!  *		ƥΥե졼ե
   */
  
  #include "syssvc/logtask.h"
--- 3,9 ----
   */
  
  /*
!  *		システムログタスクのコンフィギュレーションファイル
   */
  
  #include "syssvc/logtask.h"
diff -cr --new-file 1.9.1/asp/syssvc/logtask.h ASPs/asp/syssvc/logtask.h
*** 1.9.1/asp/syssvc/logtask.h	Sat Apr 12 10:31:18 2008
--- ASPs/asp/syssvc/logtask.h	Fri Dec  9 13:54:10 2022
***************
*** 8,47 ****
   *  Copyright (C) 2004-2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: logtask.h 774 2008-03-08 06:35:57Z hiro $
   */
  
  /*
!  *		ƥ
   */
  
  #ifndef TOPPERS_LOGTASK_H
--- 8,47 ----
   *  Copyright (C) 2004-2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: logtask.h 774 2008-03-08 06:35:57Z hiro $
   */
  
  /*
!  *		システムログタスク
   */
  
  #ifndef TOPPERS_LOGTASK_H
***************
*** 54,96 ****
  #include "target_syssvc.h"
  
  /*
!  *  ƥϢΥǥեͤ
   */ 
  #ifndef LOGTASK_PRIORITY
! #define LOGTASK_PRIORITY	3		/* ͥ */
  #endif /* LOGTASK_PRIORITY */
  
  #ifndef LOGTASK_STACK_SIZE
! #define LOGTASK_STACK_SIZE	1024	/* åΰΥ */
  #endif /* LOGTASK_STACK_SIZE */
  
  #ifndef LOGTASK_PORTID
! #define LOGTASK_PORTID		1		/* ƥѤΥꥢݡֹ */
  #endif /* LOGTASK_PORTID */
  
  #ifndef LOGTASK_INTERVAL
! #define LOGTASK_INTERVAL	10U		/* ƥưֳ֡ʥߥá*/
  #endif /* LOGTASK_INTERVAL */
  
  #ifndef LOGTASK_FLUSH_WAIT
! #define LOGTASK_FLUSH_WAIT	1U		/* եåԤñ̻֡ʥߥá*/
  #endif /* LOGTASK_FLUSH_WAIT */
  
  /*
!  *  ƥϤԤ碌
   *
!  *  ХåեΥοcountʲˤʤޤԤġcount0ξ
!  *  ϡꥢХåեˤʤΤԤġ
   */
  extern ER	logtask_flush(uint_t count) throw();
  
  /*
!  *  ƥ
   */
  extern void	logtask_main(intptr_t exinf) throw();
  
  /*
!  *  ƥνλ
   */
  extern void	logtask_terminate(intptr_t exinf) throw();
  
--- 54,96 ----
  #include "target_syssvc.h"
  
  /*
!  *  システムログタスク関連の定数のデフォルト値の定義
   */ 
  #ifndef LOGTASK_PRIORITY
! #define LOGTASK_PRIORITY	3		/* 初期優先度 */
  #endif /* LOGTASK_PRIORITY */
  
  #ifndef LOGTASK_STACK_SIZE
! #define LOGTASK_STACK_SIZE	1024	/* スタック領域のサイズ */
  #endif /* LOGTASK_STACK_SIZE */
  
  #ifndef LOGTASK_PORTID
! #define LOGTASK_PORTID		1		/* システムログ用のシリアルポート番号 */
  #endif /* LOGTASK_PORTID */
  
  #ifndef LOGTASK_INTERVAL
! #define LOGTASK_INTERVAL	10U		/* システムログタスクの動作間隔（ミリ秒）*/
  #endif /* LOGTASK_INTERVAL */
  
  #ifndef LOGTASK_FLUSH_WAIT
! #define LOGTASK_FLUSH_WAIT	1U		/* フラッシュ待ちの単位時間（ミリ秒）*/
  #endif /* LOGTASK_FLUSH_WAIT */
  
  /*
!  *  システムログ出力の待ち合わせ
   *
!  *  ログバッファ中のログの数がcount以下になるまで待つ．countが0の場合に
!  *  は，シリアルバッファが空になるのも待つ．
   */
  extern ER	logtask_flush(uint_t count) throw();
  
  /*
!  *  システムログタスクの本体
   */
  extern void	logtask_main(intptr_t exinf) throw();
  
  /*
!  *  システムログタスクの終了処理
   */
  extern void	logtask_terminate(intptr_t exinf) throw();
  
diff -cr --new-file 1.9.1/asp/syssvc/serial.c ASPs/asp/syssvc/serial.c
*** 1.9.1/asp/syssvc/serial.c	Mon Sep 16 02:40:20 2013
--- ASPs/asp/syssvc/serial.c	Fri Dec  9 13:54:10 2022
***************
*** 8,47 ****
   *  Copyright (C) 2006-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: serial.c 2524 2013-09-15 17:40:06Z ertl-hiro $
   */
  
  /*
!  *		ꥢ륤󥿥եɥ饤
   */
  
  #include <kernel.h>
--- 8,47 ----
   *  Copyright (C) 2006-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: serial.c 2524 2013-09-15 17:40:06Z ertl-hiro $
   */
  
  /*
!  *		シリアルインタフェースドライバ
   */
  
  #include <kernel.h>
***************
*** 52,78 ****
  #include "kernel_cfg.h"
  
  /*
!  *  ХåեΥǥեͤȥХåե
   */
  #ifndef SERIAL_RCV_BUFSZ1
! #define	SERIAL_RCV_BUFSZ1	256			/* ݡ1μХåե */
  #endif /* SERIAL_RCV_BUFSZ1 */
  
  #ifndef SERIAL_SND_BUFSZ1
! #define	SERIAL_SND_BUFSZ1	256			/* ݡ1Хåե */
  #endif /* SERIAL_SND_BUFSZ1 */
  
  static char	rcv_buffer1[SERIAL_RCV_BUFSZ1];
  static char	snd_buffer1[SERIAL_SND_BUFSZ1];
  
! #if TNUM_PORT >= 2						/* ݡ2˴ؤ */
  
  #ifndef SERIAL_RCV_BUFSZ2
! #define	SERIAL_RCV_BUFSZ2	256			/* ݡ2μХåե */
  #endif /* SERIAL_RCV_BUFSZ2 */
  
  #ifndef SERIAL_SND_BUFSZ2
! #define	SERIAL_SND_BUFSZ2	256			/* ݡ2Хåե */
  #endif /* SERIAL_SND_BUFSZ2 */
  
  static char	rcv_buffer2[SERIAL_RCV_BUFSZ2];
--- 52,78 ----
  #include "kernel_cfg.h"
  
  /*
!  *  バッファサイズのデフォルト値とバッファの定義
   */
  #ifndef SERIAL_RCV_BUFSZ1
! #define	SERIAL_RCV_BUFSZ1	256			/* ポート1の受信バッファサイズ */
  #endif /* SERIAL_RCV_BUFSZ1 */
  
  #ifndef SERIAL_SND_BUFSZ1
! #define	SERIAL_SND_BUFSZ1	256			/* ポート1の送信バッファサイズ */
  #endif /* SERIAL_SND_BUFSZ1 */
  
  static char	rcv_buffer1[SERIAL_RCV_BUFSZ1];
  static char	snd_buffer1[SERIAL_SND_BUFSZ1];
  
! #if TNUM_PORT >= 2						/* ポート2に関する定義 */
  
  #ifndef SERIAL_RCV_BUFSZ2
! #define	SERIAL_RCV_BUFSZ2	256			/* ポート2の受信バッファサイズ */
  #endif /* SERIAL_RCV_BUFSZ2 */
  
  #ifndef SERIAL_SND_BUFSZ2
! #define	SERIAL_SND_BUFSZ2	256			/* ポート2の送信バッファサイズ */
  #endif /* SERIAL_SND_BUFSZ2 */
  
  static char	rcv_buffer2[SERIAL_RCV_BUFSZ2];
***************
*** 80,93 ****
  
  #endif /* TNUM_PORT >= 2 */
  
! #if TNUM_PORT >= 3						/* ݡ3˴ؤ */
  
  #ifndef SERIAL_RCV_BUFSZ3
! #define	SERIAL_RCV_BUFSZ3	256			/* ݡ3μХåե */
  #endif /* SERIAL_RCV_BUFSZ3 */
  
  #ifndef SERIAL_SND_BUFSZ3
! #define	SERIAL_SND_BUFSZ3	256			/* ݡ3Хåե */
  #endif /* SERIAL_SND_BUFSZ3 */
  
  static char	rcv_buffer3[SERIAL_RCV_BUFSZ3];
--- 80,93 ----
  
  #endif /* TNUM_PORT >= 2 */
  
! #if TNUM_PORT >= 3						/* ポート3に関する定義 */
  
  #ifndef SERIAL_RCV_BUFSZ3
! #define	SERIAL_RCV_BUFSZ3	256			/* ポート3の受信バッファサイズ */
  #endif /* SERIAL_RCV_BUFSZ3 */
  
  #ifndef SERIAL_SND_BUFSZ3
! #define	SERIAL_SND_BUFSZ3	256			/* ポート3の送信バッファサイズ */
  #endif /* SERIAL_SND_BUFSZ3 */
  
  static char	rcv_buffer3[SERIAL_RCV_BUFSZ3];
***************
*** 95,108 ****
  
  #endif /* TNUM_PORT >= 3 */
  
! #if TNUM_PORT >= 4						/* ݡ4˴ؤ */
  
  #ifndef SERIAL_RCV_BUFSZ4
! #define	SERIAL_RCV_BUFSZ4	256			/* ݡ4μХåե */
  #endif /* SERIAL_RCV_BUFSZ4 */
  
  #ifndef SERIAL_SND_BUFSZ4
! #define	SERIAL_SND_BUFSZ4	256			/* ݡ4Хåե */
  #endif /* SERIAL_SND_BUFSZ4 */
  
  static char	rcv_buffer4[SERIAL_RCV_BUFSZ4];
--- 95,108 ----
  
  #endif /* TNUM_PORT >= 3 */
  
! #if TNUM_PORT >= 4						/* ポート4に関する定義 */
  
  #ifndef SERIAL_RCV_BUFSZ4
! #define	SERIAL_RCV_BUFSZ4	256			/* ポート4の受信バッファサイズ */
  #endif /* SERIAL_RCV_BUFSZ4 */
  
  #ifndef SERIAL_SND_BUFSZ4
! #define	SERIAL_SND_BUFSZ4	256			/* ポート4の送信バッファサイズ */
  #endif /* SERIAL_SND_BUFSZ4 */
  
  static char	rcv_buffer4[SERIAL_RCV_BUFSZ4];
***************
*** 115,138 ****
  #endif /* TNUM_PORT >= 5 */
  
  /*
!  *  ե˴Ϣȥޥ
   */
! #define	FC_STOP			'\023'		/* ȥ-S */
! #define	FC_START		'\021'		/* ȥ-Q */
  
! #define BUFCNT_STOP(bufsz)		((bufsz) * 3 / 4)	/* STOPʸ */
! #define BUFCNT_START(bufsz)		((bufsz) / 2)		/* STARTʸ */
  
  /*
!  *  ꥢݡȽ֥å
   */
  typedef struct serial_port_initialization_block {
! 	ID		rcv_semid;		/* ХåեѥޥեID */
! 	ID		snd_semid;		/* ХåեѥޥեID */
! 	uint_t	rcv_bufsz;		/* Хåե */
! 	char	*rcv_buffer;	/* Хåե */
! 	uint_t	snd_bufsz;		/* Хåե */
! 	char	*snd_buffer;	/* Хåե */
  } SPINIB;
  
  static const SPINIB spinib_table[TNUM_PORT] = {
--- 115,138 ----
  #endif /* TNUM_PORT >= 5 */
  
  /*
!  *  フロー制御に関連する定数とマクロ
   */
! #define	FC_STOP			'\023'		/* コントロール-S */
! #define	FC_START		'\021'		/* コントロール-Q */
  
! #define BUFCNT_STOP(bufsz)		((bufsz) * 3 / 4)	/* STOPを送る基準文字数 */
! #define BUFCNT_START(bufsz)		((bufsz) / 2)		/* STARTを送る基準文字数 */
  
  /*
!  *  シリアルポート初期化ブロック
   */
  typedef struct serial_port_initialization_block {
! 	ID		rcv_semid;		/* 受信バッファ管理用セマフォのID */
! 	ID		snd_semid;		/* 送信バッファ管理用セマフォのID */
! 	uint_t	rcv_bufsz;		/* 受信バッファサイズ */
! 	char	*rcv_buffer;	/* 受信バッファ */
! 	uint_t	snd_bufsz;		/* 送信バッファサイズ */
! 	char	*snd_buffer;	/* 送信バッファ */
  } SPINIB;
  
  static const SPINIB spinib_table[TNUM_PORT] = {
***************
*** 157,193 ****
  };
  
  /*
!  *  ꥢݡȴ֥å
   */
  typedef struct serial_port_control_block {
! 	const SPINIB *p_spinib;		/* ꥢݡȽ֥å */
! 	SIOPCB	*p_siopcb;			/* ꥢI/Oݡȴ֥å */
! 	bool_t	openflag;			/* ץѤߥե饰 */
! 	bool_t	errorflag;			/* 顼ե饰 */
! 	uint_t	ioctl;				/* ư */
! 
! 	uint_t	rcv_read_ptr;		/* ХåեɽФݥ */
! 	uint_t	rcv_write_ptr;		/* Хåեߥݥ */
! 	uint_t	rcv_count;			/* Хåեʸ */
! 	char	rcv_fc_chr;			/* ٤START/STOP */
! 	bool_t	rcv_stopped;		/* STOPä֤ */
! 
! 	uint_t	snd_read_ptr;		/* ХåեɽФݥ */
! 	uint_t	snd_write_ptr;		/* Хåեߥݥ */
! 	uint_t	snd_count;			/* Хåեʸ */
! 	bool_t	snd_stopped;		/* STOPä֤ */
  } SPCB;
  
  static SPCB	spcb_table[TNUM_PORT];
  
  /*
!  *  ꥢݡID饷ꥢݡȴ֥åФΥޥ
   */
  #define INDEX_PORT(portid)	((uint_t)((portid) - 1))
  #define get_spcb(portid)	(&(spcb_table[INDEX_PORT(portid)]))
  
  /*
!  *  ݥ󥿤Υ󥯥
   */
  #define INC_PTR(ptr, bufsz) do {	\
  	if (++(ptr) == (bufsz)) {		\
--- 157,193 ----
  };
  
  /*
!  *  シリアルポート管理ブロック
   */
  typedef struct serial_port_control_block {
! 	const SPINIB *p_spinib;		/* シリアルポート初期化ブロック */
! 	SIOPCB	*p_siopcb;			/* シリアルI/Oポート管理ブロック */
! 	bool_t	openflag;			/* オープン済みフラグ */
! 	bool_t	errorflag;			/* エラーフラグ */
! 	uint_t	ioctl;				/* 動作制御の設定値 */
! 
! 	uint_t	rcv_read_ptr;		/* 受信バッファ読出しポインタ */
! 	uint_t	rcv_write_ptr;		/* 受信バッファ書込みポインタ */
! 	uint_t	rcv_count;			/* 受信バッファ中の文字数 */
! 	char	rcv_fc_chr;			/* 送るべきSTART/STOP */
! 	bool_t	rcv_stopped;		/* STOPを送った状態か？ */
! 
! 	uint_t	snd_read_ptr;		/* 送信バッファ読出しポインタ */
! 	uint_t	snd_write_ptr;		/* 送信バッファ書込みポインタ */
! 	uint_t	snd_count;			/* 送信バッファ中の文字数 */
! 	bool_t	snd_stopped;		/* STOPを受け取った状態か？ */
  } SPCB;
  
  static SPCB	spcb_table[TNUM_PORT];
  
  /*
!  *  シリアルポートIDからシリアルポート管理ブロックを取り出すためのマクロ
   */
  #define INDEX_PORT(portid)	((uint_t)((portid) - 1))
  #define get_spcb(portid)	(&(spcb_table[INDEX_PORT(portid)]))
  
  /*
!  *  ポインタのインクリメント
   */
  #define INC_PTR(ptr, bufsz) do {	\
  	if (++(ptr) == (bufsz)) {		\
***************
*** 196,205 ****
  } while (false)
  
  /*
!  *  ӥƽФޥ
   *
!  *  ӥƽФޤ༰expɾͤ顼͡ˤξ
!  *  ˤϡercercd_expɾͤerror_exitgoto롥
   */
  #define SVC(exp, ercd_exp) do {		\
  	if ((exp) < 0) {				\
--- 196,205 ----
  } while (false)
  
  /*
!  *  サービスコール呼出しマクロ
   *
!  *  サービスコール呼出しを含む式expを評価し，返値がエラー（負の値）の場
!  *  合には，ercにercd_expを評価した値を代入し，error_exitにgotoする．
   */
  #define SVC(exp, ercd_exp) do {		\
  	if ((exp) < 0) {				\
***************
*** 209,215 ****
  } while (false)
  
  /*
!  *  E_SYS顼
   */
  static ER
  gen_ercd_sys(SPCB *p_spcb)
--- 209,215 ----
  } while (false)
  
  /*
!  *  E_SYSエラーの生成
   */
  static ER
  gen_ercd_sys(SPCB *p_spcb)
***************
*** 219,225 ****
  }
  
  /*
!  *  Ԥ륵ӥ뤫Υ顼Ѵ
   */
  static ER
  gen_ercd_wait(ER rercd, SPCB *p_spcb)
--- 219,225 ----
  }
  
  /*
!  *  待ちに入るサービスコールからのエラーの変換
   */
  static ER
  gen_ercd_wait(ER rercd, SPCB *p_spcb)
***************
*** 235,241 ****
  }
  
  /*
!  *  ꥢ륤󥿥եɥ饤Фν롼
   */
  void
  serial_initialize(intptr_t exinf)
--- 235,241 ----
  }
  
  /*
!  *  シリアルインタフェースドライバの初期化ルーチン
   */
  void
  serial_initialize(intptr_t exinf)
***************
*** 251,257 ****
  }
  
  /*
!  *  ꥢݡȤΥץʥӥ
   */
  ER
  serial_opn_por(ID portid)
--- 251,257 ----
  }
  
  /*
!  *  シリアルポートのオープン（サービスコール）
   */
  ER
  serial_opn_por(ID portid)
***************
*** 259,279 ****
  	SPCB	*p_spcb;
  	ER		ercd;
  
! 	if (sns_dpn()) {				/* ƥȤΥå */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ݡֹΥå */
  	}
  	p_spcb = get_spcb(portid);
  
  	SVC(dis_dsp(), gen_ercd_sys(p_spcb));
! 	if (p_spcb->openflag) {			/* ץѤߤΥå */
  		ercd = E_OBJ;
  	}
  	else {
  		/*
! 		 *  ѿν
  		 */
  		p_spcb->ioctl = (IOCTL_ECHO | IOCTL_CRLF | IOCTL_FCSND | IOCTL_FCRCV);
  
--- 259,279 ----
  	SPCB	*p_spcb;
  	ER		ercd;
  
! 	if (sns_dpn()) {				/* コンテキストのチェック */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ポート番号のチェック */
  	}
  	p_spcb = get_spcb(portid);
  
  	SVC(dis_dsp(), gen_ercd_sys(p_spcb));
! 	if (p_spcb->openflag) {			/* オープン済みかのチェック */
  		ercd = E_OBJ;
  	}
  	else {
  		/*
! 		 *  変数の初期化
  		 */
  		p_spcb->ioctl = (IOCTL_ECHO | IOCTL_CRLF | IOCTL_FCSND | IOCTL_FCRCV);
  
***************
*** 289,295 ****
  		p_spcb->snd_stopped = false;
  
  		/*
! 		 *  ʹߡߤػߤ롥
  		 */
  		if (loc_cpu() < 0) {
  			ercd = E_SYS;
--- 289,295 ----
  		p_spcb->snd_stopped = false;
  
  		/*
! 		 *  これ以降，割込みを禁止する．
  		 */
  		if (loc_cpu() < 0) {
  			ercd = E_SYS;
***************
*** 297,308 ****
  		}
  
  		/*
! 		 *  ϡɥ¸Υץ
  		 */
  		p_spcb->p_siopcb = sio_opn_por(portid, (intptr_t) p_spcb);
  
  		/*
! 		 *  ΥХåĤ롥
  		 */
  		sio_ena_cbr(p_spcb->p_siopcb, SIO_RDY_RCV);
  		p_spcb->openflag = true;
--- 297,308 ----
  		}
  
  		/*
! 		 *  ハードウェア依存のオープン処理
  		 */
  		p_spcb->p_siopcb = sio_opn_por(portid, (intptr_t) p_spcb);
  
  		/*
! 		 *  受信通知コールバックを許可する．
  		 */
  		sio_ena_cbr(p_spcb->p_siopcb, SIO_RDY_RCV);
  		p_spcb->openflag = true;
***************
*** 324,330 ****
  }
  
  /*
!  *  ꥢݡȤΥʥӥ
   */
  ER
  serial_cls_por(ID portid)
--- 324,330 ----
  }
  
  /*
!  *  シリアルポートのクローズ（サービスコール）
   */
  ER
  serial_cls_por(ID portid)
***************
*** 333,353 ****
  	ER		ercd;
  	bool_t	eflag = false;
  
! 	if (sns_dpn()) {				/* ƥȤΥå */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ݡֹΥå */
  	}
  	p_spcb = get_spcb(portid);
  
  	SVC(dis_dsp(), gen_ercd_sys(p_spcb));
! 	if (!(p_spcb->openflag)) {		/* ץѤߤΥå */
  		ercd = E_OBJ;
  	}
  	else {
  		/*
! 		 *  ϡɥ¸Υ
  		 */
  		if (loc_cpu() < 0) {
  			eflag = true;
--- 333,353 ----
  	ER		ercd;
  	bool_t	eflag = false;
  
! 	if (sns_dpn()) {				/* コンテキストのチェック */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ポート番号のチェック */
  	}
  	p_spcb = get_spcb(portid);
  
  	SVC(dis_dsp(), gen_ercd_sys(p_spcb));
! 	if (!(p_spcb->openflag)) {		/* オープン済みかのチェック */
  		ercd = E_OBJ;
  	}
  	else {
  		/*
! 		 *  ハードウェア依存のクローズ処理
  		 */
  		if (loc_cpu() < 0) {
  			eflag = true;
***************
*** 359,365 ****
  		}
  
  		/*
! 		 *  ޥեν
  		 */
  		if (ini_sem(p_spcb->p_spinib->snd_semid) < 0) {
  			eflag = true;
--- 359,365 ----
  		}
  
  		/*
! 		 *  セマフォの初期化
  		 */
  		if (ini_sem(p_spcb->p_spinib->snd_semid) < 0) {
  			eflag = true;
***************
*** 369,375 ****
  		}
  
  		/*
! 		 *  顼ɤ
  		 */
  		if (eflag) {
  			ercd = gen_ercd_sys(p_spcb);
--- 369,375 ----
  		}
  
  		/*
! 		 *  エラーコードの設定
  		 */
  		if (eflag) {
  			ercd = gen_ercd_sys(p_spcb);
***************
*** 385,396 ****
  }
  
  /*
!  *  ꥢݡȤؤʸ
   *
!  *  p_spcbǻꤵ륷ꥢI/OݡȤФơʸc롥ʸ
!  *  쥸ˤ줿ˤtrue֤Ǥʤˤϡ
!  *  쥸ȤΤ륳ХåؿĤfalse֤
!  *  δؿϡCPUå֤ǸƤӽФ롥
   */
  Inline bool_t
  serial_snd_chr(SPCB *p_spcb, char c)
--- 385,396 ----
  }
  
  /*
!  *  シリアルポートへの文字送信
   *
!  *  p_spcbで指定されるシリアルI/Oポートに対して，文字cを送信する．文字
!  *  を送信レジスタにいれた場合にはtrueを返す．そうでない場合には，送信
!  *  レジスタが空いたことを通知するコールバック関数を許可し，falseを返す．
!  *  この関数は，CPUロック状態で呼び出される．
   */
  Inline bool_t
  serial_snd_chr(SPCB *p_spcb, char c)
***************
*** 405,411 ****
  }
  
  /*
!  *  ꥢݡȤؤ1ʸ
   */
  static ER_BOOL
  serial_wri_chr(SPCB *p_spcb, char c)
--- 405,411 ----
  }
  
  /*
!  *  シリアルポートへの1文字送信
   */
  static ER_BOOL
  serial_wri_chr(SPCB *p_spcb, char c)
***************
*** 414,426 ****
  	ER		ercd, rercd;
  
  	/*
! 	 *  LFCR롥
  	 */
  	if (c == '\n' && (p_spcb->ioctl & IOCTL_CRLF) != 0U) {
  		/*
! 		 *  ʲΥɤϺƵƽФˤʤäƤ뤬c'\n'ξ
! 		 *  c'\r'ȤƸƤӽФȤ顤κƵƽФ2ܤ
! 		 *  ƤӽФɬߤޤ롥
  		 */
  		SVC(rercd = serial_wri_chr(p_spcb, '\r'), rercd);
  		if ((bool_t) rercd) {
--- 414,426 ----
  	ER		ercd, rercd;
  
  	/*
! 	 *  LFの前にCRを送信する．
  	 */
  	if (c == '\n' && (p_spcb->ioctl & IOCTL_CRLF) != 0U) {
  		/*
! 		 *  以下のコードは再帰呼出しになっているが，引数cが'\n'の場合に
! 		 *  引数cを'\r'として呼び出すことから，この再帰呼出しは2回目の
! 		 *  呼び出しで必ず止まる．
  		 */
  		SVC(rercd = serial_wri_chr(p_spcb, '\r'), rercd);
  		if ((bool_t) rercd) {
***************
*** 433,446 ****
  	if (p_spcb->snd_count == 0U && !(p_spcb->snd_stopped)
  								&& serial_snd_chr(p_spcb, c)) {
  		/*
! 		 *  ꥢI/OǥХ쥸ʸ뤳Ȥ
! 		 *  硥
  		 */
  		buffer_full = false;
  	}
  	else {
  		/*
! 		 *  Хåեʸ롥
  		 */
  		p_spcb->p_spinib->snd_buffer[p_spcb->snd_write_ptr] = c;
  		INC_PTR(p_spcb->snd_write_ptr, p_spcb->p_spinib->snd_bufsz);
--- 433,446 ----
  	if (p_spcb->snd_count == 0U && !(p_spcb->snd_stopped)
  								&& serial_snd_chr(p_spcb, c)) {
  		/*
! 		 *  シリアルI/Oデバイスの送信レジスタに文字を入れることに成功し
! 		 *  た場合．
  		 */
  		buffer_full = false;
  	}
  	else {
  		/*
! 		 *  送信バッファに文字を入れる．
  		 */
  		p_spcb->p_spinib->snd_buffer[p_spcb->snd_write_ptr] = c;
  		INC_PTR(p_spcb->snd_write_ptr, p_spcb->p_spinib->snd_bufsz);
***************
*** 456,462 ****
  }
  
  /*
!  *  ꥢݡȤؤʸʥӥ
   */
  ER_UINT
  serial_wri_dat(ID portid, const char *buf, uint_t len)
--- 456,462 ----
  }
  
  /*
!  *  シリアルポートへの文字列送信（サービスコール）
   */
  ER_UINT
  serial_wri_dat(ID portid, const char *buf, uint_t len)
***************
*** 466,487 ****
  	uint_t	wricnt = 0U;
  	ER		ercd, rercd;
  
! 	if (sns_dpn()) {				/* ƥȤΥå */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ݡֹΥå */
  	}
  
  	p_spcb = get_spcb(portid);
! 	if (!(p_spcb->openflag)) {		/* ץѤߤΥå */
  		return(E_OBJ);
  	}
! 	if (p_spcb->errorflag) {		/* 顼֤Υå */
  		return(E_SYS);
  	}
  
! 	buffer_full = true;				/* 롼פ1wai_sem */
  	while (wricnt < len) {
  		if (buffer_full) {
  			SVC(rercd = wai_sem(p_spcb->p_spinib->snd_semid),
--- 466,487 ----
  	uint_t	wricnt = 0U;
  	ER		ercd, rercd;
  
! 	if (sns_dpn()) {				/* コンテキストのチェック */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ポート番号のチェック */
  	}
  
  	p_spcb = get_spcb(portid);
! 	if (!(p_spcb->openflag)) {		/* オープン済みかのチェック */
  		return(E_OBJ);
  	}
! 	if (p_spcb->errorflag) {		/* エラー状態かのチェック */
  		return(E_SYS);
  	}
  
! 	buffer_full = true;				/* ループの1回めはwai_semする */
  	while (wricnt < len) {
  		if (buffer_full) {
  			SVC(rercd = wai_sem(p_spcb->p_spinib->snd_semid),
***************
*** 501,507 ****
  }
  
  /*
!  *  ꥢݡȤ1ʸ
   */
  static bool_t
  serial_rea_chr(SPCB *p_spcb, char *p_c)
--- 501,507 ----
  }
  
  /*
!  *  シリアルポートからの1文字受信
   */
  static bool_t
  serial_rea_chr(SPCB *p_spcb, char *p_c)
***************
*** 512,518 ****
  	SVC(loc_cpu(), gen_ercd_sys(p_spcb));
  
  	/*
! 	 *  ХåեʸФ
  	 */
  	*p_c = p_spcb->p_spinib->rcv_buffer[p_spcb->rcv_read_ptr];
  	INC_PTR(p_spcb->rcv_read_ptr, p_spcb->p_spinib->rcv_bufsz);
--- 512,518 ----
  	SVC(loc_cpu(), gen_ercd_sys(p_spcb));
  
  	/*
! 	 *  受信バッファから文字を取り出す．
  	 */
  	*p_c = p_spcb->p_spinib->rcv_buffer[p_spcb->rcv_read_ptr];
  	INC_PTR(p_spcb->rcv_read_ptr, p_spcb->p_spinib->rcv_bufsz);
***************
*** 520,526 ****
  	buffer_empty = (p_spcb->rcv_count == 0U);
  
  	/*
! 	 *  START롥
  	 */
  	if (p_spcb->rcv_stopped && p_spcb->rcv_count
  								<= BUFCNT_START(p_spcb->p_spinib->rcv_bufsz)) {
--- 520,526 ----
  	buffer_empty = (p_spcb->rcv_count == 0U);
  
  	/*
! 	 *  STARTを送信する．
  	 */
  	if (p_spcb->rcv_stopped && p_spcb->rcv_count
  								<= BUFCNT_START(p_spcb->p_spinib->rcv_bufsz)) {
***************
*** 538,544 ****
  }
  
  /*
!  *  ꥢݡȤʸʥӥ
   */
  ER_UINT
  serial_rea_dat(ID portid, char *buf, uint_t len)
--- 538,544 ----
  }
  
  /*
!  *  シリアルポートからの文字列受信（サービスコール）
   */
  ER_UINT
  serial_rea_dat(ID portid, char *buf, uint_t len)
***************
*** 546,570 ****
  	SPCB	*p_spcb;
  	bool_t	buffer_empty;
  	uint_t	reacnt = 0U;
! 	char	c = '\0';		/* ѥηٹ޻ߤ뤿˽ */
  	ER		ercd, rercd;
  
! 	if (sns_dpn()) {				/* ƥȤΥå */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ݡֹΥå */
  	}
  
  	p_spcb = get_spcb(portid);
! 	if (!(p_spcb->openflag)) {		/* ץѤߤΥå */
  		return(E_OBJ);
  	}
! 	if (p_spcb->errorflag) {		/* 顼֤Υå */
  		return(E_SYS);
  	}
  
! 	buffer_empty = true;			/* 롼פ1wai_sem */
  	while (reacnt < len) {
  		if (buffer_empty) {
  			SVC(rercd = wai_sem(p_spcb->p_spinib->rcv_semid),
--- 546,570 ----
  	SPCB	*p_spcb;
  	bool_t	buffer_empty;
  	uint_t	reacnt = 0U;
! 	char	c = '\0';		/* コンパイラの警告を抑止するために初期化する */
  	ER		ercd, rercd;
  
! 	if (sns_dpn()) {				/* コンテキストのチェック */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ポート番号のチェック */
  	}
  
  	p_spcb = get_spcb(portid);
! 	if (!(p_spcb->openflag)) {		/* オープン済みかのチェック */
  		return(E_OBJ);
  	}
! 	if (p_spcb->errorflag) {		/* エラー状態かのチェック */
  		return(E_SYS);
  	}
  
! 	buffer_empty = true;			/* ループの1回めはwai_semする */
  	while (reacnt < len) {
  		if (buffer_empty) {
  			SVC(rercd = wai_sem(p_spcb->p_spinib->rcv_semid),
***************
*** 576,582 ****
  		buffer_empty = (bool_t) rercd;
  
  		/*
! 		 *  Хå
  		 */
  		if ((p_spcb->ioctl & IOCTL_ECHO) != 0U) {
  			SVC(rercd = wai_sem(p_spcb->p_spinib->snd_semid),
--- 576,582 ----
  		buffer_empty = (bool_t) rercd;
  
  		/*
! 		 *  エコーバック処理．
  		 */
  		if ((p_spcb->ioctl & IOCTL_ECHO) != 0U) {
  			SVC(rercd = wai_sem(p_spcb->p_spinib->snd_semid),
***************
*** 598,622 ****
  }
  
  /*
!  *  ꥢݡȤʥӥ
   */
  ER
  serial_ctl_por(ID portid, uint_t ioctl)
  {
  	SPCB	*p_spcb;
  
! 	if (sns_dpn()) {				/* ƥȤΥå */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ݡֹΥå */
  	}
  
  	p_spcb = get_spcb(portid);
! 	if (!(p_spcb->openflag)) {		/* ץѤߤΥå */
  		return(E_OBJ);
  	}
! 	if (p_spcb->errorflag) {		/* 顼֤Υå */
  		return(E_SYS);
  	}
  
--- 598,622 ----
  }
  
  /*
!  *  シリアルポートの制御（サービスコール）
   */
  ER
  serial_ctl_por(ID portid, uint_t ioctl)
  {
  	SPCB	*p_spcb;
  
! 	if (sns_dpn()) {				/* コンテキストのチェック */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ポート番号のチェック */
  	}
  
  	p_spcb = get_spcb(portid);
! 	if (!(p_spcb->openflag)) {		/* オープン済みかのチェック */
  		return(E_OBJ);
  	}
! 	if (p_spcb->errorflag) {		/* エラー状態かのチェック */
  		return(E_SYS);
  	}
  
***************
*** 625,649 ****
  }
  
  /*
!  *  ꥢݡȾ֤λȡʥӥ
   */
  ER
  serial_ref_por(ID portid, T_SERIAL_RPOR *pk_rpor)
  {
  	SPCB	*p_spcb;
  
! 	if (sns_dpn()) {				/* ƥȤΥå */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ݡֹΥå */
  	}
  
  	p_spcb = get_spcb(portid);
! 	if (!(p_spcb->openflag)) {		/* ץѤߤΥå */
  		return(E_OBJ);
  	}
! 	if (p_spcb->errorflag) {		/* 顼֤Υå */
  		return(E_SYS);
  	}
  
--- 625,649 ----
  }
  
  /*
!  *  シリアルポート状態の参照（サービスコール）
   */
  ER
  serial_ref_por(ID portid, T_SERIAL_RPOR *pk_rpor)
  {
  	SPCB	*p_spcb;
  
! 	if (sns_dpn()) {				/* コンテキストのチェック */
  		return(E_CTX);
  	}
  	if (!(1 <= portid && portid <= TNUM_PORT)) {
! 		return(E_ID);				/* ポート番号のチェック */
  	}
  
  	p_spcb = get_spcb(portid);
! 	if (!(p_spcb->openflag)) {		/* オープン済みかのチェック */
  		return(E_OBJ);
  	}
! 	if (p_spcb->errorflag) {		/* エラー状態かのチェック */
  		return(E_SYS);
  	}
  
***************
*** 653,659 ****
  }
  
  /*
!  *  ꥢݡȤǽХå
   */
  void
  sio_irdy_snd(intptr_t exinf)
--- 653,659 ----
  }
  
  /*
!  *  シリアルポートからの送信可能コールバック
   */
  void
  sio_irdy_snd(intptr_t exinf)
***************
*** 663,676 ****
  	p_spcb = (SPCB *) exinf;
  	if (p_spcb->rcv_fc_chr != '\0') {
  		/*
! 		 *  START/STOP 롥
  		 */
  		(void) sio_snd_chr(p_spcb->p_siopcb, p_spcb->rcv_fc_chr);
  		p_spcb->rcv_fc_chr = '\0';
  	}
  	else if (!(p_spcb->snd_stopped) && p_spcb->snd_count > 0U) {
  		/*
! 		 *  Хåե椫ʸФ롥
  		 */
  		(void) sio_snd_chr(p_spcb->p_siopcb,
  					p_spcb->p_spinib->snd_buffer[p_spcb->snd_read_ptr]);
--- 663,676 ----
  	p_spcb = (SPCB *) exinf;
  	if (p_spcb->rcv_fc_chr != '\0') {
  		/*
! 		 *  START/STOP を送信する．
  		 */
  		(void) sio_snd_chr(p_spcb->p_siopcb, p_spcb->rcv_fc_chr);
  		p_spcb->rcv_fc_chr = '\0';
  	}
  	else if (!(p_spcb->snd_stopped) && p_spcb->snd_count > 0U) {
  		/*
! 		 *  送信バッファ中から文字を取り出して送信する．
  		 */
  		(void) sio_snd_chr(p_spcb->p_siopcb,
  					p_spcb->p_spinib->snd_buffer[p_spcb->snd_read_ptr]);
***************
*** 684,697 ****
  	}
  	else {
  		/*
! 		 *  ٤ʸʤϡǽХåػߤ롥
  		 */
  		sio_dis_cbr(p_spcb->p_siopcb, SIO_RDY_SND);
  	}
  }
  
  /*
!  *  ꥢݡȤμΥХå
   */
  void
  sio_irdy_rcv(intptr_t exinf)
--- 684,697 ----
  	}
  	else {
  		/*
! 		 *  送信すべき文字がない場合は，送信可能コールバックを禁止する．
  		 */
  		sio_dis_cbr(p_spcb->p_siopcb, SIO_RDY_SND);
  	}
  }
  
  /*
!  *  シリアルポートからの受信通知コールバック
   */
  void
  sio_irdy_rcv(intptr_t exinf)
***************
*** 703,716 ****
  	c = (char) sio_rcv_chr(p_spcb->p_siopcb);
  	if ((p_spcb->ioctl & IOCTL_FCSND) != 0U && c == FC_STOP) {
  		/*
! 		 *  ߤ롥ʸϤΤޤ롥
  		 */
  		p_spcb->snd_stopped = true;
  	}
  	else if (p_spcb->snd_stopped && (c == FC_START
  				|| (p_spcb->ioctl & IOCTL_FCANY) != 0U)) {
  		/*
! 		 *  Ƴ롥
  		 */
  		p_spcb->snd_stopped = false;
  		if (p_spcb->snd_count > 0U) {
--- 703,716 ----
  	c = (char) sio_rcv_chr(p_spcb->p_siopcb);
  	if ((p_spcb->ioctl & IOCTL_FCSND) != 0U && c == FC_STOP) {
  		/*
! 		 *  送信を一時停止する．送信中の文字はそのまま送信する．
  		 */
  		p_spcb->snd_stopped = true;
  	}
  	else if (p_spcb->snd_stopped && (c == FC_START
  				|| (p_spcb->ioctl & IOCTL_FCANY) != 0U)) {
  		/*
! 		 *  送信を再開する．
  		 */
  		p_spcb->snd_stopped = false;
  		if (p_spcb->snd_count > 0U) {
***************
*** 728,744 ****
  	}
  	else if ((p_spcb->ioctl & IOCTL_FCSND) != 0U && c == FC_START) {
  		/*
! 		 *  Фƥե椷Ƥ硤START ϼΤƤ롥
  		 */
  	}
  	else if (p_spcb->rcv_count == p_spcb->p_spinib->rcv_bufsz) {
  		/*
! 		 *  Хåեեξ硤ʸΤƤ롥
  		 */
  	}
  	else {
  		/*
! 		 *  ʸХåե롥
  		 */
  		p_spcb->p_spinib->rcv_buffer[p_spcb->rcv_write_ptr] = c;
  		INC_PTR(p_spcb->rcv_write_ptr, p_spcb->p_spinib->rcv_bufsz);
--- 728,744 ----
  	}
  	else if ((p_spcb->ioctl & IOCTL_FCSND) != 0U && c == FC_START) {
  		/*
! 		 *  送信に対してフロー制御している場合，START は捨てる．
  		 */
  	}
  	else if (p_spcb->rcv_count == p_spcb->p_spinib->rcv_bufsz) {
  		/*
! 		 *  バッファフルの場合，受信した文字を捨てる．
  		 */
  	}
  	else {
  		/*
! 		 *  受信した文字を受信バッファに入れる．
  		 */
  		p_spcb->p_spinib->rcv_buffer[p_spcb->rcv_write_ptr] = c;
  		INC_PTR(p_spcb->rcv_write_ptr, p_spcb->p_spinib->rcv_bufsz);
***************
*** 750,756 ****
  		p_spcb->rcv_count++;
  
  		/*
! 		 *  STOP롥
  		 */
  		if ((p_spcb->ioctl & IOCTL_FCRCV) != 0U && !(p_spcb->rcv_stopped)
  						&& p_spcb->rcv_count
--- 750,756 ----
  		p_spcb->rcv_count++;
  
  		/*
! 		 *  STOPを送信する．
  		 */
  		if ((p_spcb->ioctl & IOCTL_FCRCV) != 0U && !(p_spcb->rcv_stopped)
  						&& p_spcb->rcv_count
***************
*** 764,779 ****
  }
  
  /*
!  *  ꥢ륤󥿥եɥ饤Ф̤ʸμФ
   */
  bool_t
  serial_get_chr(ID portid, char *p_c)
  {
  	SPCB	*p_spcb;
  
! 	if (1 <= portid && portid <= TNUM_PORT) {	/* ݡֹΥå */
  		p_spcb = get_spcb(portid);
! 		if (p_spcb->openflag) {					/* ץѤߤΥå */
  			if (p_spcb->snd_count > 0U) {
  				*p_c = p_spcb->p_spinib->snd_buffer[p_spcb->snd_read_ptr];
  				INC_PTR(p_spcb->snd_read_ptr, p_spcb->p_spinib->snd_bufsz);
--- 764,779 ----
  }
  
  /*
!  *  シリアルインタフェースドライバからの未送信文字の取出し
   */
  bool_t
  serial_get_chr(ID portid, char *p_c)
  {
  	SPCB	*p_spcb;
  
! 	if (1 <= portid && portid <= TNUM_PORT) {	/* ポート番号のチェック */
  		p_spcb = get_spcb(portid);
! 		if (p_spcb->openflag) {					/* オープン済みかのチェック */
  			if (p_spcb->snd_count > 0U) {
  				*p_c = p_spcb->p_spinib->snd_buffer[p_spcb->snd_read_ptr];
  				INC_PTR(p_spcb->snd_read_ptr, p_spcb->p_spinib->snd_bufsz);
diff -cr --new-file 1.9.1/asp/syssvc/serial.cfg ASPs/asp/syssvc/serial.cfg
*** 1.9.1/asp/syssvc/serial.cfg	Mon Apr 11 00:36:38 2011
--- ASPs/asp/syssvc/serial.cfg	Fri Dec  9 13:54:10 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ꥢ륤󥿥եɥ饤ФΥե졼ե
   */
  
  #include "target_syssvc.h"
--- 3,9 ----
   */
  
  /*
!  *  シリアルインタフェースドライバのコンフィギュレーションファイル
   */
  
  #include "target_syssvc.h"
diff -cr --new-file 1.9.1/asp/syssvc/serial.h ASPs/asp/syssvc/serial.h
*** 1.9.1/asp/syssvc/serial.h	Sat Aug 27 07:39:16 2011
--- ASPs/asp/syssvc/serial.h	Fri Dec  9 13:54:10 2022
***************
*** 8,47 ****
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: serial.h 2246 2011-08-26 22:39:15Z ertl-hiro $
   */
  
  /*
!  *		ꥢ륤󥿥եɥ饤
   */
  
  #ifndef TOPPERS_SERIAL_H
--- 8,47 ----
   *  Copyright (C) 2004-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: serial.h 2246 2011-08-26 22:39:15Z ertl-hiro $
   */
  
  /*
!  *		シリアルインタフェースドライバ
   */
  
  #ifndef TOPPERS_SERIAL_H
***************
*** 52,76 ****
  #endif
  
  /*
!  *  ꥢ륤󥿥եɥ饤ФѤѥå
   */
  typedef struct {
! 	uint_t		reacnt;			/* Хåեʸ */
! 	uint_t		wricnt;			/* Хåեʸ */
  } T_SERIAL_RPOR;
  
  /*
!  *  ꥢ륤󥿥եɥ饤Фν롼
   */
  extern void		serial_initialize(intptr_t exinf) throw();
  
  /*
!  *  ꥢ륤󥿥եɥ饤Ф̤ʸμФ
   */
  extern bool_t	serial_get_chr(ID portid, char *p_c) throw();
  
  /*
!  *  ꥢ륤󥿥եɥ饤ФΥӥ
   */
  extern ER		serial_opn_por(ID portid) throw();
  extern ER		serial_cls_por(ID portid) throw();
--- 52,76 ----
  #endif
  
  /*
!  *  シリアルインタフェースドライバの用いるパケット
   */
  typedef struct {
! 	uint_t		reacnt;			/* 受信バッファ中の文字数 */
! 	uint_t		wricnt;			/* 送信バッファ中の文字数 */
  } T_SERIAL_RPOR;
  
  /*
!  *  シリアルインタフェースドライバの初期化ルーチン
   */
  extern void		serial_initialize(intptr_t exinf) throw();
  
  /*
!  *  シリアルインタフェースドライバからの未送信文字の取出し
   */
  extern bool_t	serial_get_chr(ID portid, char *p_c) throw();
  
  /*
!  *  シリアルインタフェースドライバのサービスコール
   */
  extern ER		serial_opn_por(ID portid) throw();
  extern ER		serial_cls_por(ID portid) throw();
***************
*** 80,95 ****
  extern ER		serial_ref_por(ID portid, T_SERIAL_RPOR *pk_rpor) throw();
  
  /*
!  *  ꥢ륤󥿥եɥ饤ФưѤΤ
   *
!  *  ʲϡӥå¤ȤäѤ롥
   */
! #define	IOCTL_NULL	0U			/* ʤ */
! #define	IOCTL_ECHO	0x0001U		/* ʸ򥨥Хå */
! #define	IOCTL_CRLF	0x0010U		/* LFCRղ */
! #define	IOCTL_FCSND	0x0100U		/* ФƥեԤ */
! #define	IOCTL_FCANY	0x0200U		/* ɤΤ褦ʸǤƳ */
! #define	IOCTL_FCRCV	0x0400U		/* ФƥեԤ */
  
  #ifdef __cplusplus
  }
--- 80,95 ----
  extern ER		serial_ref_por(ID portid, T_SERIAL_RPOR *pk_rpor) throw();
  
  /*
!  *  シリアルインタフェースドライバの動作制御用のための定数
   *
!  *  以下の定数は，ビット毎に論理和をとって用いる．
   */
! #define	IOCTL_NULL	0U			/* 指定なし */
! #define	IOCTL_ECHO	0x0001U		/* 受信した文字をエコーバック */
! #define	IOCTL_CRLF	0x0010U		/* LFを送信する前にCRを付加 */
! #define	IOCTL_FCSND	0x0100U		/* 送信に対してフロー制御を行う */
! #define	IOCTL_FCANY	0x0200U		/* どのような文字でも送信再開 */
! #define	IOCTL_FCRCV	0x0400U		/* 受信に対してフロー制御を行う */
  
  #ifdef __cplusplus
  }
diff -cr --new-file 1.9.1/asp/syssvc/syslog.c ASPs/asp/syssvc/syslog.c
*** 1.9.1/asp/syssvc/syslog.c	Sat Aug 27 07:59:56 2011
--- ASPs/asp/syssvc/syslog.c	Fri Dec  9 13:54:10 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: syslog.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		ƥǽ
   */
  
  #include <sil.h>
--- 8,47 ----
   *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: syslog.c 2247 2011-08-26 22:59:55Z ertl-hiro $
   */
  
  /*
!  *		システムログ機能
   */
  
  #include <sil.h>
***************
*** 52,58 ****
  #include "syslog.h"
  
  /*
!  *  ȥ졼ޥΥǥե
   */
  #ifndef LOG_SYSLOG_WRI_LOG_ENTER
  #define LOG_SYSLOG_WRI_LOG_ENTER(prio, p_syslog)
--- 52,58 ----
  #include "syslog.h"
  
  /*
!  *  トレースログマクロのデフォルト定義
   */
  #ifndef LOG_SYSLOG_WRI_LOG_ENTER
  #define LOG_SYSLOG_WRI_LOG_ENTER(prio, p_syslog)
***************
*** 87,116 ****
  #endif /* LOG_SYSLOG_REF_LOG_LEAVE */
  
  /*
!  *  ߤΥƥ
   *
!  *  Фˡʤͥѿ򻲾ȤƤ
!  *  롥
   */
  extern ulong_t	_kernel_current_time;
  
  /*
!  *  ХåեȤ˥뤿Υݥ
   */
! static SYSLOG	syslog_buffer[TCNT_SYSLOG_BUFFER];	/* Хåե */
! static uint_t	syslog_count;			/* ХåեΥο */
! static uint_t	syslog_head;			/* ƬΥγǼ */
! static uint_t	syslog_tail;			/* ΥγǼ */
! static uint_t	syslog_lost;			/* 줿ο */
  
  /*
!  *  Ϥ٤ν١ʥӥåȥޥåס
   */
! static uint_t	syslog_logmask;			/* Хåե˵Ͽ٤ */
! static uint_t	syslog_lowmask_not;		/* ٥Ϥ٤١ȿž*/
  
  /*
!  *  ƥǽν
   */
  void
  syslog_initialize(intptr_t exinf)
--- 87,116 ----
  #endif /* LOG_SYSLOG_REF_LOG_LEAVE */
  
  /*
!  *  現在のシステム時刻
   *
!  *  ログ時刻を取り出すために，やむなく，カーネルの内部変数を参照してい
!  *  る．
   */
  extern ulong_t	_kernel_current_time;
  
  /*
!  *  ログバッファとそれにアクセスするためのポインタ
   */
! static SYSLOG	syslog_buffer[TCNT_SYSLOG_BUFFER];	/* ログバッファ */
! static uint_t	syslog_count;			/* ログバッファ中のログの数 */
! static uint_t	syslog_head;			/* 先頭のログの格納位置 */
! static uint_t	syslog_tail;			/* 次のログの格納位置 */
! static uint_t	syslog_lost;			/* 失われたログの数 */
  
  /*
!  *  出力すべきログ情報の重要度（ビットマップ）
   */
! static uint_t	syslog_logmask;			/* ログバッファに記録すべき重要度 */
! static uint_t	syslog_lowmask_not;		/* 低レベル出力すべき重要度（反転）*/
  
  /*
!  *  システムログ機能の初期化
   */
  void
  syslog_initialize(intptr_t exinf)
***************
*** 124,132 ****
  }     
  
  /* 
!  *  ν
   *
!  *  CPUå֤¹ԥƥȤˤ餺ưǤ褦˼Ƥ롥
   */
  ER
  syslog_wri_log(uint_t prio, const SYSLOG *p_syslog)
--- 124,132 ----
  }     
  
  /* 
!  *  ログ情報の出力
   *
!  *  CPUロック状態や実行コンテキストによらず動作できるように実装してある．
   */
  ER
  syslog_wri_log(uint_t prio, const SYSLOG *p_syslog)
***************
*** 137,148 ****
  	SIL_LOC_INT();
  
  	/*
! 	 *  
  	 */
  	((SYSLOG *) p_syslog)->logtim = _kernel_current_time;
  
  	/*
! 	 *  Хåե˵Ͽ
  	 */
  	if ((syslog_logmask & LOG_MASK(prio)) != 0U) {
  		syslog_buffer[syslog_tail] = *p_syslog;
--- 137,148 ----
  	SIL_LOC_INT();
  
  	/*
! 	 *  ログ時刻の設定
  	 */
  	((SYSLOG *) p_syslog)->logtim = _kernel_current_time;
  
  	/*
! 	 *  ログバッファに記録
  	 */
  	if ((syslog_logmask & LOG_MASK(prio)) != 0U) {
  		syslog_buffer[syslog_tail] = *p_syslog;
***************
*** 160,166 ****
  	}
  
  	/*
! 	 *  ٥
  	 */
  	if (((~syslog_lowmask_not) & LOG_MASK(prio)) != 0U) {
  		syslog_print(p_syslog, target_fput_log);
--- 160,166 ----
  	}
  
  	/*
! 	 *  低レベル出力
  	 */
  	if (((~syslog_lowmask_not) & LOG_MASK(prio)) != 0U) {
  		syslog_print(p_syslog, target_fput_log);
***************
*** 173,181 ****
  }
  
  /*
!  *  ХåեɽФ
   *
!  *  CPUå֤¹ԥƥȤˤ餺ưǤ褦˼Ƥ롥
   */
  ER_UINT
  syslog_rea_log(SYSLOG *p_syslog)
--- 173,181 ----
  }
  
  /*
!  *  ログバッファからの読出し
   *
!  *  CPUロック状態や実行コンテキストによらず動作できるように実装してある．
   */
  ER_UINT
  syslog_rea_log(SYSLOG *p_syslog)
***************
*** 187,193 ****
  	SIL_LOC_INT();
  
  	/*
! 	 *  ХåեμФ
  	 */
  	if (syslog_count > 0U) {
  		*p_syslog = syslog_buffer[syslog_head];
--- 187,193 ----
  	SIL_LOC_INT();
  
  	/*
! 	 *  ログバッファからの取出し
  	 */
  	if (syslog_count > 0U) {
  		*p_syslog = syslog_buffer[syslog_head];
***************
*** 209,215 ****
  }
  
  /* 
!  *  Ϥ٤ν٤
   */
  ER
  syslog_msk_log(uint_t logmask, uint_t lowmask)
--- 209,215 ----
  }
  
  /* 
!  *  出力すべきログ情報の重要度の設定
   */
  ER
  syslog_msk_log(uint_t logmask, uint_t lowmask)
***************
*** 222,228 ****
  }
  
  /*
!  *  Хåեξֻ
   */
  ER
  syslog_ref_log(T_SYSLOG_RLOG *pk_rlog)
--- 222,228 ----
  }
  
  /*
!  *  ログバッファの状態参照
   */
  ER
  syslog_ref_log(T_SYSLOG_RLOG *pk_rlog)
diff -cr --new-file 1.9.1/asp/syssvc/syslog.cfg ASPs/asp/syssvc/syslog.cfg
*** 1.9.1/asp/syssvc/syslog.cfg	Mon May 17 06:07:30 2010
--- ASPs/asp/syssvc/syslog.cfg	Fri Dec  9 13:54:10 2022
***************
*** 3,9 ****
   */
  
  /*
!  *		ƥǽΥե졼ե
   */
  
  #include "syssvc/syslog.h"
--- 3,9 ----
   */
  
  /*
!  *		システムログ機能のコンフィギュレーションファイル
   */
  
  #include "syssvc/syslog.h"
diff -cr --new-file 1.9.1/asp/syssvc/syslog.h ASPs/asp/syssvc/syslog.h
*** 1.9.1/asp/syssvc/syslog.h	Mon May 17 06:07:30 2010
--- ASPs/asp/syssvc/syslog.h	Fri Dec  9 13:54:10 2022
***************
*** 8,47 ****
   *  Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: syslog.h 1788 2010-05-16 21:06:02Z ertl-hiro $
   */
  
  /*
!  *		ƥǽ
   */
  
  #ifndef TOPPERS_SYSLOG_H
--- 8,47 ----
   *  Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: syslog.h 1788 2010-05-16 21:06:02Z ertl-hiro $
   */
  
  /*
!  *		システムログ機能
   */
  
  #ifndef TOPPERS_SYSLOG_H
***************
*** 52,90 ****
  #endif
  
  /*
!  *  ƥϤԤ
   */
  #include <t_syslog.h>
  
  /*
!  *  ХåեȤ˥뤿Υݥ
   */
  #ifndef TCNT_SYSLOG_BUFFER
! #define TCNT_SYSLOG_BUFFER	32		/* ХåեΥ */
  #endif /* TCNT_SYSLOG_BUFFER */
  
  /*
!  *  ƥǽν
   */
  extern void	syslog_initialize(intptr_t exinf) throw();
  
  /*
!  *  ν
   */
  extern ER	syslog_wri_log(uint_t prio, const SYSLOG *p_syslog) throw();
  
  /*
!  *  ХåեΥɽФ
   */
  extern ER_UINT	syslog_rea_log(SYSLOG *p_syslog) throw();
  
  /* 
!  *  Ϥ٤ν٤
   */
  extern ER	syslog_msk_log(uint_t logmask, uint_t lowmask) throw();
  
  /* 
!  *  Хåեξֻ
   */
  extern ER	syslog_ref_log(T_SYSLOG_RLOG *pk_rlog) throw();
  
--- 52,90 ----
  #endif
  
  /*
!  *  システムログ出力を行うための定義
   */
  #include <t_syslog.h>
  
  /*
!  *  ログバッファとそれにアクセスするためのポインタ
   */
  #ifndef TCNT_SYSLOG_BUFFER
! #define TCNT_SYSLOG_BUFFER	32		/* ログバッファのサイズ */
  #endif /* TCNT_SYSLOG_BUFFER */
  
  /*
!  *  システムログ機能の初期化
   */
  extern void	syslog_initialize(intptr_t exinf) throw();
  
  /*
!  *  ログ情報の出力
   */
  extern ER	syslog_wri_log(uint_t prio, const SYSLOG *p_syslog) throw();
  
  /*
!  *  ログバッファからのログ情報の読出し
   */
  extern ER_UINT	syslog_rea_log(SYSLOG *p_syslog) throw();
  
  /* 
!  *  出力すべきログ情報の重要度の設定
   */
  extern ER	syslog_msk_log(uint_t logmask, uint_t lowmask) throw();
  
  /* 
!  *  ログバッファの状態参照
   */
  extern ER	syslog_ref_log(T_SYSLOG_RLOG *pk_rlog) throw();
  
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/MANIFEST ASPs/asp/target/dve68k_gcc/MANIFEST
*** 1.9.1/asp/target/dve68k_gcc/MANIFEST	Sat Apr 12 14:46:45 2008
--- ASPs/asp/target/dve68k_gcc/MANIFEST	Thu Jan  1 09:00:00 1970
***************
*** 1,26 ****
- PACKAGE asp
- 
- MANIFEST
- Makefile.target
- dve68k.h
- target.tf
- target_cfg1_out.h
- target_check.tf
- target_config.c
- target_config.h
- target_def.csv
- target_kernel.h
- target_rename.def
- target_rename.h
- target_serial.c
- target_serial.cfg
- target_serial.h
- target_sil.h
- target_stddef.h
- target_support.S
- target_syssvc.h
- target_test.h
- target_timer.c
- target_timer.cfg
- target_timer.h
- target_unrename.h
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/Makefile.target ASPs/asp/target/dve68k_gcc/Makefile.target
*** 1.9.1/asp/target/dve68k_gcc/Makefile.target	Sun Nov 11 17:17:06 2012
--- ASPs/asp/target/dve68k_gcc/Makefile.target	Thu Jan  1 09:00:00 1970
***************
*** 1,84 ****
- #
- #		MakefileΥåȰ¸DVE68K/40ѡ
- #
- 
- #
- #  ܡ̾ץå̾ȯĶ̾
- #
- BOARD = dve68k
- PRC = m68k
- TOOL = gcc
- 
- #
- #  ѥ륪ץ
- #
- INCLUDES := $(INCLUDES) -I$(TARGETDIR)
- 
- #
- #  ͥ˴ؤ
- #
- KERNEL_DIR := $(KERNEL_DIR) $(TARGETDIR)
- KERNEL_ASMOBJS := $(KERNEL_ASMOBJS) target_support.o
- KERNEL_COBJS := $(KERNEL_COBJS) target_config.o target_timer.o
- 
- #
- #  ƥॵӥ˴ؤ
- #
- SYSSVC_DIR := $(SYSSVC_DIR) $(SRCDIR)/pdic/upd72001
- SYSSVC_COBJS := $(SYSSVC_COBJS) target_serial.o upd72001.o
- 
- #
- #  ե졼طѿ
- #
- CFG_TABS := $(CFG_TABS) --cfg1-def-table $(TARGETDIR)/target_def.csv
- 
- #
- #  ȥ졼ϿΥץ륳ɤ˴ؤ
- #
- ifeq ($(ENABLE_TRACE),true)
- 	COPTS := $(COPTS) -DTOPPERS_ENABLE_TRACE
- 	KERNEL_DIR := $(KERNEL_DIR) $(SRCDIR)/arch/logtrace
- 	KERNEL_COBJS := $(KERNEL_COBJS) trace_config.o trace_dump.o
- endif
- 
- #
- #  ƥȤγϥɥ쥹
- #
- TEXT_START_ADDRESS = 00010000
- DATA_START_ADDRESS = 00100000
- 
- #
- #  󥫥ץȤ
- #
- LDSCRIPT = $(SRCDIR)/arch/$(PRC)_$(TOOL)/m68kelf.ld
- 
- #
- #  ȥåץ⥸塼˴ؤ
- #
- #  m68kelf.ldˡSTARTUP(start.o)פ򵭽Ҥᡤȥåץ⥸塼
- #  ̾HIDDEN_OBJS롥ޤLDFLAGS-nostdlibɲäƤ롥
- #
- HIDDEN_OBJS = start.o
- 
- $(HIDDEN_OBJS): %.o: %.S
- 	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<
- 
- $(HIDDEN_OBJS:.o=.d): %.d: %.S
- 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
- 		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend
- 
- LDFLAGS := -nostdlib $(LDFLAGS)
- CFG1_OUT_LDFLAGS := -nostdlib $(CFG1_OUT_LDFLAGS)
- LIBS := $(LIBS) -lgcc
- 
- #
- #  ¸ط
- #
- cfg1_out.c: $(TARGETDIR)/target_def.csv
- kernel_cfg.timestamp: $(TARGETDIR)/target.tf
- $(OBJFILE): $(TARGETDIR)/target_check.tf
- 
- #
- #  ץå¸Υ󥯥롼
- #
- include $(SRCDIR)/arch/$(PRC)_$(TOOL)/Makefile.prc
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/dve68k.h ASPs/asp/target/dve68k_gcc/dve68k.h
*** 1.9.1/asp/target/dve68k_gcc/dve68k.h	Sat Aug 27 07:39:16 2011
--- ASPs/asp/target/dve68k_gcc/dve68k.h	Thu Jan  1 09:00:00 1970
***************
*** 1,246 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: dve68k.h 2246 2011-08-26 22:39:15Z ertl-hiro $
-  */
- 
- /*
-  *		DVE-68K/40 CPUܡɤΥϡɥ񸻤
-  */
- 
- #ifndef TOPPERS_DVE68K_H
- #define TOPPERS_DVE68K_H
- 
- #include <sil.h>
- 
- /*
-  *  ֹintnoˤ
-  */
- #define TINTNO_ACF		1U			/* ACFAIL */
- #define TINTNO_ABT		2U			/* ܡȳ */
- #define TINTNO_SF		3U			/* SYSFAIL */
- #define TINTNO_BER		4U			/* Х顼 */
- #define TINTNO_IAK		5U			/* IAK */
- #define TINTNO_SRQ		6U			/* SRQ */
- #define TINTNO_SAK		7U			/* SAK */
- #define TINTNO_GP7		9U			/* GP7 */
- #define TINTNO_DMA		10U			/* DMA */
- #define TINTNO_TT1		11U			/* 1 */
- #define TINTNO_TT0		12U			/* 0 */
- #define TINTNO_GP3		13U			/* եå */
- #define TINTNO_GP2		14U			/* SCSI */
- #define TINTNO_GP1		15U			/* Ethernet */
- #define TINTNO_GP0		16U			/* ꥢI/O */
- #define TINTNO_SWI7		17U			/* եȥ7 */
- #define TINTNO_SWI6		18U			/* եȥ6 */
- #define TINTNO_SWI5		19U			/* եȥ5 */
- #define TINTNO_SWI4		20U			/* եȥ4 */
- #define TINTNO_SWI3		21U			/* եȥ3 */
- #define TINTNO_SWI2		22U			/* եȥ2 */
- #define TINTNO_SWI1		23U			/* եȥ1 */
- #define TINTNO_SWI0		24U			/* եȥ0 */
- #define TINTNO_VM7		25U			/* VME7 */
- #define TINTNO_VM6		26U			/* VME6 */
- #define TINTNO_VM5		27U			/* VME5 */
- #define TINTNO_VM4		28U			/* VME4 */
- #define TINTNO_VM3		29U			/* VME3 */
- #define TINTNO_VM2		30U			/* VME2 */
- #define TINTNO_VM1		31U			/* VME1 */
- 
- /*
-  *  ߥ٥ȥͤ
-  */
- #define TVEC_G0I		0x40U		/* 롼0ߥ٥ȥ */
- #define TVEC_G1I		0x48U		/* 롼1ߥ٥ȥ */
- #define TVEC_SWI		0x50U		/* եȥߥ٥ȥ */
- #define TVEC_SPRI		0x40U		/* ץꥢߥ٥ȥ */
- 
- /*
-  *  ߥϥɥֹinhnoˤ
-  */
- #define TINHNO_ACF		0x47U		/* ACFAIL */
- #define TINHNO_ABT		0x46U		/* ܡȳ */
- #define TINHNO_SF		0x45U		/* SYSFAIL */
- #define TINHNO_BER		0x44U		/* Х顼 */
- #define TINHNO_IAK		0x43U		/* IAK */
- #define TINHNO_SRQ		0x42U		/* SRQ */
- #define TINHNO_SAK		0x41U		/* SAK */
- #define TINHNO_GP7		0x4fU		/* GP7 */
- #define TINHNO_DMA		0x4eU		/* DMA */
- #define TINHNO_TT1		0x4dU		/* 1 */
- #define TINHNO_TT0		0x4cU		/* 0 */
- #define TINHNO_GP3		0x4bU		/* եå */
- #define TINHNO_GP2		0x4aU		/* SCSI */
- #define TINHNO_GP1		0x49U		/* Ethernet */
- #define TINHNO_GP0		0x48U		/* ꥢI/O */
- #define TINHNO_SWI7		0x57U		/* եȥ7 */
- #define TINHNO_SWI6		0x56U		/* եȥ6 */
- #define TINHNO_SWI5		0x55U		/* եȥ5 */
- #define TINHNO_SWI4		0x54U		/* եȥ4 */
- #define TINHNO_SWI3		0x53U		/* եȥ3 */
- #define TINHNO_SWI2		0x52U		/* եȥ2 */
- #define TINHNO_SWI1		0x51U		/* եȥ1 */
- #define TINHNO_SWI0		0x50U		/* եȥ0 */
- #define TINHNO_SPRI		0x40U		/* ץꥢ */
- 
- /*
-  *  CPUܡɾΥ쥸
-  */
- #define TADR_BOARD_REG0		0xfff48000
- #define TADR_BOARD_REG1		0xfff48004
- #define TADR_BOARD_REG2		0xfff48008
- 
- /*
-  *  DGA-001Υ쥸Υɥ쥹
-  */
- #define TADR_DGA_CSR0		0xfff44000
- #define TADR_DGA_CSR1		0xfff44004
- #define TADR_DGA_CSR3		0xfff4400c
- #define TADR_DGA_CSR4		0xfff44010
- #define TADR_DGA_CSR5		0xfff44014
- #define TADR_DGA_CSR12		0xfff44030
- #define TADR_DGA_CSR13		0xfff44034
- #define TADR_DGA_CSR14		0xfff44038
- #define TADR_DGA_CSR15		0xfff4403c
- #define TADR_DGA_CSR18		0xfff44048
- #define TADR_DGA_CSR19		0xfff4404c
- #define TADR_DGA_CSR20		0xfff44050
- #define TADR_DGA_CSR21		0xfff44054
- #define TADR_DGA_CSR23		0xfff4405c
- #define TADR_DGA_CSR24		0xfff44060
- #define TADR_DGA_IFR0		0xfff44070
- #define TADR_DGA_IFR3		0xfff4407c
- 
- /*
-  *  DGA-001γͥΤ
-  */
- #define TIRQ_NMI		(-7)		/* Υޥ֥ */
- #define TIRQ_LEVEL6		(-6)		/* ߥ٥6 */
- #define TIRQ_LEVEL5		(-5)		/* ߥ٥5 */
- #define TIRQ_LEVEL4		(-4)		/* ߥ٥4 */
- #define TIRQ_LEVEL3		(-3)		/* ߥ٥3 */
- #define TIRQ_LEVEL2		(-2)		/* ߥ٥2 */
- #define TIRQ_LEVEL1		(-1)		/* ߥ٥1 */
- 
- /*
-  *  DGAؤΥؿ
-  */
- #define dga_rew_reg(addr)			sil_rew_mem(((uint32_t *) addr))
- #define dga_wrw_reg(addr, val)		sil_wrw_mem(((uint32_t *) addr), val)
- 
- /*
-  *  DGAΥ쥸ؤΥؿ
-  */
- #ifndef TOPPERS_MACRO_ONLY
- 
- Inline uint32_t
- dga_read(void *addr)
- {
- 	return(dga_rew_reg(addr));
- }
- 
- Inline void
- dga_write(void *addr, uint32_t val)
- {
- 	dga_wrw_reg(addr, val);
- }
- 
- Inline void
- dga_bit_or(void *addr, uint32_t bitpat)
- {
- 	dga_write(addr, dga_read(addr) | bitpat);
- }
- 
- Inline void
- dga_bit_and(void *addr, uint32_t bitpat)
- {
- 	dga_write(addr, dga_read(addr) & bitpat);
- }
- 
- Inline void
- dga_set_ilv(void *addr, uint_t shift, uint_t level)
- {
- 	dga_write(addr, (dga_read(addr) & ~(0x07 << shift)) | (level << shift));
- } 
- 
- #endif /* TOPPERS_MACRO_ONLY */
- 
- /*
-  *  PD72001MPSCˤΥ쥸Υɥ쥹
-  */
- #define TADR_UPD72001_DATAA		0xfff45003U
- #define TADR_UPD72001_CTRLA		0xfff45007U
- #define TADR_UPD72001_DATAB		0xfff4500bU
- #define TADR_UPD72001_CTRLB		0xfff4500fU
- 
- /*
-  *  PD72001ؤΥؿ
-  */
- #define upd72001_reb_reg(addr)			sil_reb_mem(((uint8_t *) addr))
- #define upd72001_wrb_reg(addr, val)		sil_wrb_mem(((uint8_t *) addr), val)
- 
- /*
-  *  ȯĶ¸ν
-  */
- #ifndef TOPPERS_MACRO_ONLY
- #ifdef TOPPERS_GDB_STUB				/* GDB */
- 
- Inline void
- dve68k_exit(void)
- {
- 	Asm("trap #2");
- }
- 
- Inline void
- dve68k_putc(char c)
- {
- 	Asm("move.l %0, %%d1; trap #3"
- 	  : /* no output */
- 	  : "g"(c)
- 	  : "d0", "d1", "d2", "d6", "d7");
- }
- 
- #else /* TOPPERS_GDB_STUB */		/* ¾γȯĶ */
- 
- extern void		dve68k_exit(void) NoReturn;
- extern void		dve68k_putc(char c);
- 
- #endif /* TOPPERS_GDB_STUB */
- #endif /* TOPPERS_MACRO_ONLY */
- #endif /* TOPPERS_DVE68K_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target.tf ASPs/asp/target/dve68k_gcc/target.tf
*** 1.9.1/asp/target/dve68k_gcc/target.tf	Fri Oct 22 11:06:45 2010
--- ASPs/asp/target/dve68k_gcc/target.tf	Thu Jan  1 09:00:00 1970
***************
*** 1,56 ****
- $ 
- $ 		ѥ2ΥåȰ¸ƥץ졼ȡDVE68K/40ѡ
- $ 
- 
- $ 
- $  ATT_ISRǻѤǤֹȤбߥϥɥֹ
- $ 
- $INTNO_ATTISR_VALID = { 1,2,...,7;9,10,...,16;17,18,...,24 }$
- $INHNO_ATTISR_VALID = { 0x47,0x46,...,0x41;0x4f,0x4e,...,0x48;
- 						0x57,0x56,...,0x50 }$
- 
- $ 
- $  DEF_INTDEF_EXCǻѤǤߥϥɥֹ桿CPU㳰ϥɥֹ
- $ 
- $INHNO_DEFINH_VALID = { 0x10,0x11,...,0x1f;0x40,0x41,...,0xff }$
- $EXCNO_DEFEXC_VALID = { 0x02,0x03,...,0x0f;0x20,0x21,...,0x3f }$
- 
- $ 
- $  CFG_INTǻѤǤֹȳͥ
- $ 
- $INTNO_CFGINT_VALID = { 1,2,...,7;9,10,...,31 }$
- $INTPRI_CFGINT_VALID = { -7,-6,...,-1 }$
- 
- $ 
- $  ɸƥץ졼ȥեΥ󥯥롼
- $ 
- $INCLUDE "kernel/kernel.tf"$
- 
- /*$NL$
- $SPC$*  Target-dependent Definitions (DVE68K/40)$NL$
- $SPC$*/$NL$
- $NL$
- 
- $ 
- $   CFG_INTΥåȰ¸Υ顼å_kernel_bitpat_cfgint
- $ 
- $bitpat_cfgint = 0$
- 
- $FOREACH intno INT.ORDER_LIST$
- 	$bitpat = (1 << (32 - INT.INTNO[intno]))$
- 	$bitpat_cfgint = bitpat_cfgint | bitpat$
- 
- 	$IF (bitpat & DGA_INT_TRG_LEVEL) != 0$
- 		$IF (INT.INTATR[intno] & TA_EDGE) != 0$
- 			$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT("Edge trigger (TA_EDGE) is not supported for intno `%1%\' in CFG_INT", INT.INTNO[intno])$$END$
- 		$END$
- 	$ELSE$
- 	$IF (bitpat & DGA_INT_TRG_EDGE) != 0$
- 		$IF (INT.INTATR[intno] & TA_EDGE) == 0$
- 			$ERROR INT.TEXT_LINE[intno]$E_RSATR: $FORMAT("Level trigger is not supported for intno `%1%\' in CFG_INT", INT.INTNO[intno])$$END$
- 		$END$
- 	$END$
- 	$END$
- $END$
- const uint32_t	_kernel_bitpat_cfgint = UINT32_C($FORMAT("0x%08x", bitpat_cfgint)$);
- $NL$
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_cfg1_out.h ASPs/asp/target/dve68k_gcc/target_cfg1_out.h
*** 1.9.1/asp/target/dve68k_gcc/target_cfg1_out.h	Mon Apr 14 16:33:19 2008
--- ASPs/asp/target/dve68k_gcc/target_cfg1_out.h	Thu Jan  1 09:00:00 1970
***************
*** 1,9 ****
- /*
-  *  @(#) $Id: target_cfg1_out.h 930 2008-04-14 07:33:19Z ertl-hiro $
-  */
- 
- /*
-  *		cfg1_out.cΥ󥯤ɬפʥ֤
-  */
- 
- #include "m68k_gcc/prc_cfg1_out.h"
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_check.tf ASPs/asp/target/dve68k_gcc/target_check.tf
*** 1.9.1/asp/target/dve68k_gcc/target_check.tf	Fri Oct 22 11:06:54 2010
--- ASPs/asp/target/dve68k_gcc/target_check.tf	Thu Jan  1 09:00:00 1970
***************
*** 1,8 ****
- $ 
- $ 		ѥ3ΥåȰ¸ƥץ졼ȡDVE68K/40ѡ
- $ 
- 
- $ 
- $  ɸƥץ졼ȥեΥ󥯥롼
- $ 
- $INCLUDE "kernel/kernel_check.tf"$
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_config.c ASPs/asp/target/dve68k_gcc/target_config.c
*** 1.9.1/asp/target/dve68k_gcc/target_config.c	Sat Aug 27 07:39:16 2011
--- ASPs/asp/target/dve68k_gcc/target_config.c	Thu Jan  1 09:00:00 1970
***************
*** 1,222 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_config.c 2246 2011-08-26 22:39:15Z ertl-hiro $
-  */
- 
- /*
-  *		åȰ¸⥸塼DVE68K/40ѡ
-  */
- 
- #include "kernel_impl.h"
- #include <sil.h>
- 
- /*
-  *  ץå̤Τѿʥޥץåб
-  */
- uint_t	board_id;			/* ܡID */
- void	*board_addr;		/* Ƭɥ쥹 */
- 
- /*
-  *  åȰ¸ν
-  */
- void
- target_initialize(void)
- {
- 	/*
- 	 *  ץå¸ν
- 	 */
- 	prc_initialize();
- 
- 	/*
- 	 *  ץå̤Τѿν
- 	 */
- 	board_id = ((uint_t)(sil_rew_mem((void *) TADR_BOARD_REG0)) & 0x1fU);
- 	board_addr = (void *)(board_id << 24);
- 
- 	/*
- 	 *  ߴϢν
- 	 *
- 	 *  °ꤵƤ뤫Ƚ̤뤿ѿ롥
- 	 *  ޤ٤Ƥγߤޥꥢߥ٥ȥꤹ
- 	 *  롥
- 	 */
- 	dga_write((void *) TADR_DGA_CSR21, 0U);
- 	dga_write((void *) TADR_DGA_CSR23, ~0U);
- 	dga_write((void *) TADR_DGA_CSR19, (TVEC_G0I << 24) | (TVEC_G1I << 16)
- 										| (TVEC_SWI << 8) | TVEC_SPRI);
- 
- 	/*
- 	 *  ܡȳߤNMI
- 	 *
- 	 *  ܡȳߤ򥨥åȥꥬߥ٥NMIꤷޥ
- 	 *  롥
- 	 */
- 	x_config_int(TINTNO_ABT, TA_EDGE, TIRQ_NMI);
- 
- 	/*
- 	 *  ΰ
- 	 *
- 	 *  VMEХǤƬɥ쥹ȥ16MBˤ
- 	 *  դ褦ꤹ롥ޤVMEХĥɥ쥹
- 	 *  դ褦ˤꤹ롥
- 	 */
- 	dga_write((void *) TADR_DGA_CSR4, (uint32_t) board_addr | 0x00ffU);
- 	dga_write((void *) TADR_DGA_CSR5, 0x0000012fU);
- 
- 	/*
- 	 *  󥿥ե쥸IFRˤ
- 	 *
- 	 *  󥿥ե쥸Υ١ɥ쥹ꤹ롥ޤ
- 	 *  ե쥸0Υӥꥯȥե饰򥯥ꥢ󥿥ե
- 	 *  쥸3˥ܡɤIDֹꡥ
- 	 */
- 	dga_write((void *) TADR_DGA_CSR3, (board_id << 4) | 0x3U);
- 	dga_write((void *) TADR_DGA_IFR0, 0x80000000U);
- 	dga_write((void *) TADR_DGA_IFR3, board_id);
- 
- 	/*
- 	 *  饦ɥӥ⡼ɤʥޥץåб
- 	 */
- 	dga_write((void *) TADR_DGA_CSR1,
- 						(dga_read((void *) TADR_DGA_CSR1) & 0xffeffcffU)
- 									| (1U << 20) | ((board_id % 4) << 8));
- }
- 
- /*
-  *  åȰ¸νλ
-  */
- void
- target_exit(void)
- {
- 	/*
- 	 *  ץå¸νλ
- 	 */
- 	prc_terminate();
- 
- 	/*
- 	 *  ٤Ƥγߤޥꥢ롥
- 	 */
- 	dga_write((void *) TADR_DGA_CSR21, 0U);
- 	dga_write((void *) TADR_DGA_CSR23, ~0U);
- 
- 	/*
- 	 *  ȯĶ¸νλ
- 	 */
- 	dve68k_exit();
- }
- 
- /*
-  *  ƥ٥ϤΤʸ
-  */
- void
- target_fput_log(char c)
- {
- 	if (c == '\n') {
- 		dve68k_putc('\r');
- 	}
- 	dve68k_putc(c);
- }
- 
- /*
-  *  ׵饤°
-  *
-  *  ASPͥǤѤꤷơѥ᡼顼ϥǥ
-  *  Ƥ롥cfg_intӥߤˤϡ顼֤褦
-  *  ˤ٤Ǥ
-  */
- void
- x_config_int(INTNO intno, ATR intatr, PRI intpri)
- {
- 	uint32_t	bitpat = DGA_INT_BITPAT(intno);
- 
- 	assert(VALID_INTNO_CFGINT(intno));
- 	assert(TIRQ_NMI <= intpri && intpri <= TIRQ_LEVEL1);
- 
- 	/*
- 	 *  ߤΥޥ
- 	 *
- 	 *  ߤդޤޡ٥ȥꥬåȥꥬ䡤
- 	 *  ͥ٤ԤΤϴʤᡤ°ˤ餺
- 	 *  öޥ롥
- 	 */
- 	(void) x_disable_int(intno);
- 
- 	/*
- 	 *  ٥ȥꥬåȥꥬ
- 	 */
- 	if ((bitpat & DGA_INT_TRG_CONF) != 0U) {
- 		/*
- 		 *  ˤǤ
- 		 */
- 		if ((intatr & TA_EDGE) != 0U) {
- 			dga_bit_or((void *) TADR_DGA_CSR18, (1U << (24 - (intno))));
- 			x_clear_int(intno);
- 		}
- 		else {
- 			dga_bit_and((void *) TADR_DGA_CSR18, ~(1U << (24 - (intno))));
- 		}
- 	}
- 	else if ((bitpat & DGA_INT_TRG_EDGE) != 0U) {
- 		/*
- 		 *  åȥꥬ˸ꤵƤ
- 		 */
- 		assert((intatr & TA_EDGE) != 0U);
- 		x_clear_int(intno);
- 	}
- 	else {
- 		/*
- 		 *  ٥ȥꥬ˸ꤵƤ
- 		 */
- 		assert((intatr & TA_EDGE) == 0U);
- 	}
- 
- 	/*
- 	 *  ͥ٤
- 	 */
- 	dga_set_ilv((void *)(TADR_DGA_CSR24 + (intno - 1) / 8 * 4),
- 				(uint_t)(((32 - intno) % 8) * 4), (uint_t)(7 + intpri));
- 
- 	/*
- 	 *  ߤΥޥɬפʾ
-  	 */
- 	if ((intatr & TA_ENAINT) != 0U) {
- 		(void) x_enable_int(intno);
- 	}
- }
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_config.h ASPs/asp/target/dve68k_gcc/target_config.h
*** 1.9.1/asp/target/dve68k_gcc/target_config.h	Sun Oct 24 09:44:27 2010
--- ASPs/asp/target/dve68k_gcc/target_config.h	Thu Jan  1 09:00:00 1970
***************
*** 1,267 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_config.h 1952 2010-10-24 00:44:26Z ertl-hiro $
-  */
- 
- /*
-  *		åȰ¸⥸塼DVE-68K/40ѡ
-  *
-  *  ͥΥåȰ¸Υ󥯥롼ɥե롥kernel_impl.hΥ
-  *  åȰ¸ΰդȤʤ롥
-  */
- 
- #ifndef TOPPERS_TARGET_CONFIG_H
- #define TOPPERS_TARGET_CONFIG_H
- 
- /*
-  *  åȥƥΥϡɥ񸻤
-  */
- #include "dve68k.h"
- 
- /*
-  *  åΥ֥°
-  */
- #define TARGET_INHATR	TA_NONKERNEL	/* ͥγ */
- 
- /*
-  *  顼åˡλ
-  */
- #define CHECK_STKSZ_ALIGN	4	/* åΥ饤ñ */
- #define CHECK_FUNC_ALIGN	2	/* ؿΥ饤ñ */
- #define CHECK_FUNC_NONNULL		/* ؿNULLå */
- #define CHECK_STACK_ALIGN	4	/* åΰΥ饤ñ */
- #define CHECK_STACK_NONNULL		/* åΰNULLå */
- #define CHECK_MPF_ALIGN		4	/* ĹסΰΥ饤ñ */
- #define CHECK_MPF_NONNULL		/* ĹסΰNULLå */
- #define CHECK_MB_ALIGN		4	/* ΰΥ饤ñ */
- 
- /*
-  *  ȥ졼˴ؤ
-  */
- #ifdef TOPPERS_ENABLE_TRACE
- #include "logtrace/trace_config.h"
- #endif /* TOPPERS_ENABLE_TRACE */
- 
- /*
-  *  ASPͥưΥޥåפȴϢ
-  *
-  *	00000000 - 0000ffff		ROM˥֥ꥢ64KB
-  *	00010000 - 000fffff		ΰ1MB
-  *	00100000 -				ǡΰ3MB
-  *			 - 003fffff		ǥեȤ󥿥ƥѤΥåΰ
-  */
- 
- /*
-  *  ǥեȤ󥿥ƥѤΥåΰ
-  */
- #define DEFAULT_ISTKSZ		0x2000U
- #define DEFAULT_ISTK		(void *)(0x00400000U - DEFAULT_ISTKSZ)
- 
- #ifndef TOPPERS_MACRO_ONLY
- 
- /*
-  *  ץå̤Τѿʥޥץåб
-  */
- extern uint_t	board_id;		/* ܡID */
- extern void		*board_addr;	/* Ƭɥ쥹 */
- 
- /*
-  *  ֹϰϤȽ
-  *
-  *  ӥåȥѥΤưפˤ뤿ˡ8Ϸ֤ˤʤäƤ롥
-  */
- #define VALID_INTNO(intno)	(1U <= (intno) && (intno) <= 31U && (intno) != 8U)
- #define	VALID_INTNO_CREISR(intno)	VALID_INTNO(intno)
- #define VALID_INTNO_DISINT(intno)	VALID_INTNO(intno)
- #define VALID_INTNO_CFGINT(intno)	VALID_INTNO(intno)
- 
- /*
-  *  ׵뤿Υӥåȥѥޥ
-  *
-  *  եȱ黻٤ץåǡ;͵ˤϡɽ
-  *  Ǽ褤ɽʤ顤ֹ8֤ˤ
-  *  ɬפϤʤ
-  */
- #define DGA_INT_BITPAT(intno)	(1U << (32U - (intno)))
- 
- /*
-  *  ٥ȥꥬåȥꥬǤ뤫Ƚ
-  */
- #define DGA_INT_TRG_CONF	(0xe0000000U)	/* ˤǤ */
- #define DGA_INT_TRG_LEVEL	(0x108f00feU)	/* ٥ȥꥬ˸ */
- #define DGA_INT_TRG_EDGE	(0x0e70ff00U)	/* åȥꥬ˸ */
- 
- /*
-  *  °ꤵƤ뤫Ƚ̤뤿ѿkernel_cfg.c
-  */
- extern const uint32_t	bitpat_cfgint;
- 
- /*
-  *  ׵ػߥե饰Υå
-  *
-  *  °ꤵƤʤ׵饤ФƳ׵ػ
-  *  ե饰򥻥åȤ褦Ȥˤϡfalse֤
-  */
- Inline bool_t
- x_disable_int(INTNO intno)
- {
- 	uint32_t	bitpat = DGA_INT_BITPAT(intno);
- 
- 	if ((bitpat_cfgint & bitpat) == 0U) {
- 		return(false);
- 	}
- 	dga_bit_and((void *) TADR_DGA_CSR21, ~bitpat);
- 	return(true);
- }
- 
- #define t_disable_int(intno)	x_disable_int(intno)
- #define i_disable_int(intno)	x_disable_int(intno)
- 
- /*
-  *  ׵ػߥե饰Υꥢ
-  *
-  *  °ꤵƤʤ׵饤ФƳ׵ػ
-  *  ե饰򥯥ꥢ褦Ȥˤϡfalse֤
-  */
- Inline bool_t
- x_enable_int(INTNO intno)
- {
- 	uint32_t	bitpat = DGA_INT_BITPAT(intno);
- 
- 	if ((bitpat_cfgint & bitpat) == 0U) {
- 		return(false);
- 	}
- 	dga_bit_or((void *) TADR_DGA_CSR21, bitpat);
- 	return(true);
- }
- 
- #define t_enable_int(intno)		x_enable_int(intno)
- #define i_enable_int(intno)		x_enable_int(intno)
- 
- /*
-  *  ׵Υꥢ
-  */
- Inline void
- x_clear_int(INTNO intno)
- {
- 	dga_write((void *) TADR_DGA_CSR23, DGA_INT_BITPAT(intno));
- }
- 
- #define t_clear_int(intno)		x_clear_int(intno)
- #define i_clear_int(intno)		x_clear_int(intno)
- 
- /*
-  *  ׵Υå
-  */
- Inline bool_t
- x_probe_int(INTNO intno)
- {
- 	return((dga_read((void *) TADR_DGA_CSR20) & DGA_INT_BITPAT(intno)) != 0U);
- }
- 
- #define t_probe_int(intno)		x_probe_int(intno)
- #define i_probe_int(intno)		x_probe_int(intno)
- 
- /*
-  *  ׵饤°
-  *
-  *  DVE-68K/40IRCǤϡ׵饤γͥ٤NMIꤹ
-  *  ȤǤᡤ-7ͿNMIꤵ뤳ȤȤʥå
-  *  γĥˡ
-  */
- extern void	x_config_int(INTNO intno, ATR intatr, PRI intpri);
- 
- /*
-  *  ߥϥɥɬפIRC
-  *
-  *  åȥꥬξˤϡ׵򥯥ꥢ롥åȥꥬ
-  *  ȥꥬǤ⡤ߤͤ򸫤˥ꥢƤ롥
-  *  ٥ȥꥬξ⥯ꥢ򤷤ƺ٤ʤŬǾä
-  *  ȤԤơꥢʤȤȤƤ롥
-  */
- Inline void
- i_begin_int(INTNO intno)
- {
- 	if ((DGA_INT_BITPAT(intno) & (DGA_INT_TRG_CONF | DGA_INT_TRG_EDGE))
- 																!= 0U) {
- 		i_clear_int(intno);
- 	}
- }
- 
- /*
-  *  ߥϥɥνиɬפIRC
-  *
-  *  DVE-68K/40ǤɬפIRCϤʤ
-  */
- Inline void
- i_end_int(INTNO intno)
- {
- }
- 
- #endif /* TOPPERS_MACRO_ONLY */
- 
- #ifndef TOPPERS_MACRO_ONLY
- 
- /*
-  *  åȥƥ¸ν
-  */
- extern void	target_initialize(void);
- 
- /*
-  *  åȥƥνλ
-  *
-  *  ƥλ˻Ȥ
-  */
- extern void	target_exit(void) NoReturn;
- 
- #endif /* TOPPERS_MACRO_ONLY */
- 
- /*
-  *  ԤΤSILΥåȰ¸
-  */
- #define SIL_DLY_TIM1	420
- #define SIL_DLY_TIM2	90
- 
- /*
-  *  ץå¸⥸塼M68040ѡ
-  */
- #include "m68k_gcc/prc_config.h"
- 
- #endif /* TOPPERS_TARGET_CONFIG_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_def.csv ASPs/asp/target/dve68k_gcc/target_def.csv
*** 1.9.1/asp/target/dve68k_gcc/target_def.csv	Fri Jul 23 15:17:08 2010
--- ASPs/asp/target/dve68k_gcc/target_def.csv	Thu Jan  1 09:00:00 1970
***************
*** 1,3 ****
- DGA_INT_TRG_CONF,DGA_INT_TRG_CONF
- DGA_INT_TRG_LEVEL,DGA_INT_TRG_LEVEL
- DGA_INT_TRG_EDGE,DGA_INT_TRG_EDGE
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_kernel.h ASPs/asp/target/dve68k_gcc/target_kernel.h
*** 1.9.1/asp/target/dve68k_gcc/target_kernel.h	Tue Jan 26 21:09:47 2010
--- ASPs/asp/target/dve68k_gcc/target_kernel.h	Thu Jan  1 09:00:00 1970
***************
*** 1,75 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2004-2010 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_kernel.h 1710 2010-01-26 12:09:09Z ertl-hiro $
-  */
- 
- /*
-  *		kernel.hΥåȰ¸DVE68K/40ѡ
-  *
-  *  Υ󥯥롼ɥեϡkernel.hǥ󥯥롼ɤ롥¾Υե
-  *  뤫ľܥ󥯥롼ɤ뤳ȤϤʤΥե򥤥󥯥롼
-  *  ˡt_stddef.h󥯥롼ɤΤǡ˰¸Ƥ
-  *  
-  */
- 
- #ifndef TOPPERS_TARGET_KERNEL_H
- #define TOPPERS_TARGET_KERNEL_H
- 
- /*
-  *  ץåǶ̤
-  */
- #include "m68k_gcc/prc_kernel.h"
- 
- /*
-  *  åȰ¸ǥݡȤǤ뵡ǽ
-  */
- #define TOPPERS_TARGET_SUPPORT_DIS_INT		/* dis_int */
- #define TOPPERS_TARGET_SUPPORT_ENA_INT		/* ena_int */
- #define TOPPERS_TARGET_SUPPORT_GET_UTM		/* get_utm */
- 
- /*
-  *  ƥå
-  */
- #ifndef TIC_NUME
- #define	TIC_NUME		1U			/* ƥåμʬ */
- #define	TIC_DENO		1U			/* ƥåμʬ */
- #endif /* TIC_NUME */
- 
- #endif /* TOPPERS_TARGET_KERNEL_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_rename.def ASPs/asp/target/dve68k_gcc/target_rename.def
*** 1.9.1/asp/target/dve68k_gcc/target_rename.def	Mon Jan 11 11:58:53 2010
--- ASPs/asp/target/dve68k_gcc/target_rename.def	Thu Jan  1 09:00:00 1970
***************
*** 1,19 ****
- # kernel_cfg.c
- bitpat_cfgint
- 
- # target_config.c
- board_id
- board_addr
- target_initialize
- target_exit
- x_config_int
- 
- # trace_config.c
- log_dsp_enter
- log_dsp_leave
- log_inh_enter
- log_inh_leave
- log_exc_enter
- log_exc_leave
- 
- INCLUDE "m68k_gcc/prc"
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_rename.h ASPs/asp/target/dve68k_gcc/target_rename.h
*** 1.9.1/asp/target/dve68k_gcc/target_rename.h	Mon Jan 11 12:03:21 2010
--- ASPs/asp/target/dve68k_gcc/target_rename.h	Thu Jan  1 09:00:00 1970
***************
*** 1,62 ****
- /* This file is generated from target_rename.def by genrename. */
- 
- #ifndef TOPPERS_TARGET_RENAME_H
- #define TOPPERS_TARGET_RENAME_H
- 
- /*
-  *  kernel_cfg.c
-  */
- #define bitpat_cfgint				_kernel_bitpat_cfgint
- 
- /*
-  *  target_config.c
-  */
- #define board_id					_kernel_board_id
- #define board_addr					_kernel_board_addr
- #define target_initialize			_kernel_target_initialize
- #define target_exit					_kernel_target_exit
- #define x_config_int				_kernel_x_config_int
- 
- /*
-  *  trace_config.c
-  */
- #define log_dsp_enter				_kernel_log_dsp_enter
- #define log_dsp_leave				_kernel_log_dsp_leave
- #define log_inh_enter				_kernel_log_inh_enter
- #define log_inh_leave				_kernel_log_inh_leave
- #define log_exc_enter				_kernel_log_exc_enter
- #define log_exc_leave				_kernel_log_exc_leave
- 
- 
- #ifdef TOPPERS_LABEL_ASM
- 
- /*
-  *  kernel_cfg.c
-  */
- #define _bitpat_cfgint				__kernel_bitpat_cfgint
- 
- /*
-  *  target_config.c
-  */
- #define _board_id					__kernel_board_id
- #define _board_addr					__kernel_board_addr
- #define _target_initialize			__kernel_target_initialize
- #define _target_exit				__kernel_target_exit
- #define _x_config_int				__kernel_x_config_int
- 
- /*
-  *  trace_config.c
-  */
- #define _log_dsp_enter				__kernel_log_dsp_enter
- #define _log_dsp_leave				__kernel_log_dsp_leave
- #define _log_inh_enter				__kernel_log_inh_enter
- #define _log_inh_leave				__kernel_log_inh_leave
- #define _log_exc_enter				__kernel_log_exc_enter
- #define _log_exc_leave				__kernel_log_exc_leave
- 
- 
- #endif /* TOPPERS_LABEL_ASM */
- 
- #include "m68k_gcc/prc_rename.h"
- 
- #endif /* TOPPERS_TARGET_RENAME_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_serial.c ASPs/asp/target/dve68k_gcc/target_serial.c
*** 1.9.1/asp/target/dve68k_gcc/target_serial.c	Sat Aug 27 07:39:16 2011
--- ASPs/asp/target/dve68k_gcc/target_serial.c	Thu Jan  1 09:00:00 1970
***************
*** 1,175 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_serial.c 2246 2011-08-26 22:39:15Z ertl-hiro $
-  */
- 
- /*
-  *		ꥢI/OǥХSIO˥ɥ饤СDVE68K/40ѡ
-  */
- 
- #include <kernel.h>
- #include <t_syslog.h>
- #include "dve68k.h"
- #include "pdic/upd72001/upd72001.h"
- #include "target_serial.h"
- 
- /*
-  *  SIOɥ饤Фν
-  */
- void
- sio_initialize(intptr_t exinf)
- {
- 	upd72001_initialize();
- }
- 
- /*
-  *  ꥢI/OݡȤΥץ
-  */
- SIOPCB *
- sio_opn_por(ID siopid, intptr_t exinf)
- {
- 	SIOPCB	*p_siopcb;
- 	bool_t	opnflg;
- 	ER		ercd;
- 
- 	/*
- 	 *  ץ󤷤ݡȤ뤫opnflgɤǤ
- 	 */
- 	opnflg = upd72001_openflag();
- 
- 	/*
- 	 *  ǥХ¸Υץ
- 	 */
- 	p_siopcb = upd72001_opn_por(siopid, exinf);
- 
- 	/*
- 	 *  ꥢI/OߤΥޥ롥
- 	 */
- 	if (!opnflg) {
- 		ercd = ena_int(INTNO_SIO);
- 		assert(ercd == E_OK);
- 	}
- 	return(p_siopcb);
- }
- 
- /*
-  *  ꥢI/OݡȤΥ
-  */
- void
- sio_cls_por(SIOPCB *p_siopcb)
- {
- 	ER		ercd;
- 
- 	/*
- 	 *  ǥХ¸Υ
- 	 */
- 	upd72001_cls_por(p_siopcb);
- 
- 	/*
- 	 *  ꥢI/Oߤޥ롥
- 	 */
- 	if (!upd72001_openflag()) {
- 		ercd = dis_int(INTNO_SIO);
- 		assert(ercd == E_OK);
- 	}
- }
- 
- /*
-  *  SIOγߥӥ롼
-  */
- void
- sio_isr(intptr_t exinf)
- {
- 	upd72001_isr();
- }
- 
- /*
-  *  ꥢI/OݡȤؤʸ
-  */
- bool_t
- sio_snd_chr(SIOPCB *siopcb, char c)
- {
- 	return(upd72001_snd_chr(siopcb, c));
- }
- 
- /*
-  *  ꥢI/OݡȤʸ
-  */
- int_t
- sio_rcv_chr(SIOPCB *siopcb)
- {
- 	return(upd72001_rcv_chr(siopcb));
- }
- 
- /*
-  *  ꥢI/OݡȤΥХåε
-  */
- void
- sio_ena_cbr(SIOPCB *siopcb, uint_t cbrtn)
- {
- 	upd72001_ena_cbr(siopcb, cbrtn);
- }
- 
- /*
-  *  ꥢI/OݡȤΥХåζػ
-  */
- void
- sio_dis_cbr(SIOPCB *siopcb, uint_t cbrtn)
- {
- 	upd72001_dis_cbr(siopcb, cbrtn);
- }
- 
- /*
-  *  ꥢI/OݡȤǽХå
-  */
- void
- upd72001_irdy_snd(intptr_t exinf)
- {
- 	sio_irdy_snd(exinf);
- }
- 
- /*
-  *  ꥢI/OݡȤμΥХå
-  */
- void
- upd72001_irdy_rcv(intptr_t exinf)
- {
- 	sio_irdy_rcv(exinf);
- }
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_serial.cfg ASPs/asp/target/dve68k_gcc/target_serial.cfg
*** 1.9.1/asp/target/dve68k_gcc/target_serial.cfg	Wed Jun 18 10:00:25 2008
--- ASPs/asp/target/dve68k_gcc/target_serial.cfg	Thu Jan  1 09:00:00 1970
***************
*** 1,12 ****
- /*
-  *  @(#) $Id: target_serial.cfg 898 2008-04-11 11:26:07Z hiro $
-  */
- 
- /*
-  *		SIOɥ饤СDVE68K/40ѡˤΥե졼ե
-  */
- 
- #include "target_serial.h"
- ATT_INI({ TA_NULL, 0, sio_initialize });
- ATT_ISR({ TA_NULL, 0, INTNO_SIO, sio_isr, 1 });
- CFG_INT(INTNO_SIO, { INTATR_SIO, INTPRI_SIO });
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_serial.h ASPs/asp/target/dve68k_gcc/target_serial.h
*** 1.9.1/asp/target/dve68k_gcc/target_serial.h	Sat Aug 27 07:39:16 2011
--- ASPs/asp/target/dve68k_gcc/target_serial.h	Thu Jan  1 09:00:00 1970
***************
*** 1,113 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_serial.h 2246 2011-08-26 22:39:15Z ertl-hiro $
-  */
- 
- /*
-  *		ꥢI/OǥХSIO˥ɥ饤СDVE68K/40ѡ
-  */
- 
- #ifndef TOPPERS_TARGET_SERIAL_H
- #define TOPPERS_TARGET_SERIAL_H
- 
- #include "dve68k.h"
- #include "pdic/upd72001/upd72001.h"
- 
- /*
-  *  SIOγֹ桤ͥ١°
-  */
- #define INTNO_SIO		TINTNO_GP0		/* ֹ */
- #define INTPRI_SIO		TIRQ_LEVEL6		/* ͥ */
- #define INTATR_SIO		TA_NULL			/* ° */
- 
- #ifndef TOPPERS_MACRO_ONLY
- 
- /*
-  *  SIOɥ饤Фν
-  */
- extern void		sio_initialize(intptr_t exinf);
- 
- /*
-  *  ꥢI/OݡȤΥץ
-  */
- extern SIOPCB	*sio_opn_por(ID siopid, intptr_t exinf);
- 
- /*
-  *  ꥢI/OݡȤΥ
-  */
- extern void		sio_cls_por(SIOPCB *p_siopcb);
- 
- /*
-  *  SIOγߥӥ롼
-  */
- extern void		sio_isr(intptr_t exinf);
- 
- /*
-  *  ꥢI/OݡȤؤʸ
-  */
- extern bool_t	sio_snd_chr(SIOPCB *siopcb, char c);
- 
- /*
-  *  ꥢI/OݡȤʸ
-  */
- extern int_t	sio_rcv_chr(SIOPCB *siopcb);
- 
- /*
-  *  ꥢI/OݡȤΥХåε
-  */
- extern void		sio_ena_cbr(SIOPCB *siopcb, uint_t cbrtn);
- 
- /*
-  *  ꥢI/OݡȤΥХåζػ
-  */
- extern void		sio_dis_cbr(SIOPCB *siopcb, uint_t cbrtn);
- 
- /*
-  *  ꥢI/OݡȤǽХå
-  */
- extern void		sio_irdy_snd(intptr_t exinf);
- 
- /*
-  *  ꥢI/OݡȤμΥХå
-  */
- extern void		sio_irdy_rcv(intptr_t exinf);
- 
- #endif /* TOPPERS_MACRO_ONLY */
- #endif /* TOPPERS_TARGET_SERIAL_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_sil.h ASPs/asp/target/dve68k_gcc/target_sil.h
*** 1.9.1/asp/target/dve68k_gcc/target_sil.h	Sat Apr 12 10:31:03 2008
--- ASPs/asp/target/dve68k_gcc/target_sil.h	Thu Jan  1 09:00:00 1970
***************
*** 1,59 ****
- /*
-  *  TOPPERS Software
-  *      Toyohashi Open Platform for Embedded Real-Time Systems
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2004-2006 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_sil.h 264 2007-07-12 08:23:10Z hiro $
-  */
- 
- /*
-  *		sil.hΥåȰ¸DVE68K/40ѡ
-  *
-  *  Υ󥯥롼ɥեϡsil.hƬǥ󥯥롼ɤ롥¾Υե
-  *  뤫ľܥ󥯥롼ɤ뤳ȤϤʤΥե򥤥󥯥롼
-  *  ɤˡt_stddef.h󥯥롼ɤΤǡ˰¸Ƥ
-  *  褤
-  */
- 
- #ifndef TOPPERS_TARGET_SIL_H
- #define TOPPERS_TARGET_SIL_H
- 
- /*
-  *  ץåǶ̤
-  */
- #include "m68k_gcc/prc_sil.h"
- 
- #endif /* TOPPERS_TARGET_SIL_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_stddef.h ASPs/asp/target/dve68k_gcc/target_stddef.h
*** 1.9.1/asp/target/dve68k_gcc/target_stddef.h	Sat Apr 12 10:31:03 2008
--- ASPs/asp/target/dve68k_gcc/target_stddef.h	Thu Jan  1 09:00:00 1970
***************
*** 1,92 ****
- /*
-  *  TOPPERS Software
-  *      Toyohashi Open Platform for Embedded Real-Time Systems
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2004-2008 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_stddef.h 778 2008-03-11 02:12:39Z hiro $
-  */
- 
- /*
-  *		t_stddef.hΥåȰ¸DVE68K/40ѡ
-  *
-  *  Υ󥯥롼ɥեϡt_stddef.hƬǥ󥯥롼ɤ롥
-  *  ¾Υե뤫ľܥ󥯥롼ɤ뤳ȤϤʤ¾Υ󥯥롼
-  *  եΩäƽ뤿ᡤ¾Υ󥯥롼ɥե˰¸
-  *  ƤϤʤʤ
-  */
- 
- #ifndef TOPPERS_TARGET_STDDEF_H
- #define TOPPERS_TARGET_STDDEF_H
- 
- /*
-  *  åȤ̤뤿Υޥ
-  */
- #define TOPPERS_DVE68K				/* ƥά */
- 
- /*
-  *  ȯĶǶ̤
-  *
-  *  ȯĶstdint.hѰդƤˤϡTOPPERS_STDINT_TYPE1
-  *  ޥstdint.h򥤥󥯥롼ɤФ褤
-  */
- #define TOPPERS_STDINT_TYPE1
- #define TOPPERS_STDFLOAT_TYPE1
- #include "gcc/tool_stddef.h"
- 
- /*
-  *  ץåǶ̤
-  */
- #include "m68k_gcc/prc_stddef.h"
- 
- /*
-  *  μԻμ¹ǽ
-  */
- #ifndef TOPPERS_MACRO_ONLY
- #ifdef TOPPERS_GDB_STUB				/* GDB */
- 
- Inline void
- TOPPERS_assert_abort(void)
- {
- 	Asm("trap #2");
- }
- 
- #else /* TOPPERS_GDB_STUB */		/* ¾γȯĶ */
- 
- extern void		TOPPERS_assert_abort(void);
- 
- #endif /* TOPPERS_GDB_STUB */
- #endif /* TOPPERS_MACRO_ONLY */
- #endif /* TOPPERS_TARGET_STDDEF_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_support.S ASPs/asp/target/dve68k_gcc/target_support.S
*** 1.9.1/asp/target/dve68k_gcc/target_support.S	Sat Apr 12 10:31:03 2008
--- ASPs/asp/target/dve68k_gcc/target_support.S	Thu Jan  1 09:00:00 1970
***************
*** 1,61 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_support.S 264 2007-07-12 08:23:10Z hiro $
-  */
- 
- /*
-  *		åȰ¸⥸塼 ֥DVE-68K/40ѡ
-  */
- 
- #define	TOPPERS_MACRO_ONLY
- #include "kernel_impl.h"
- 
- /*
-  *  ٥ΥåȰ¸ν
-  *
-  *  ȥåץ⥸塼ǡν˸ƤӽФ롥
-  */
- 	.text
- 	.globl hardware_init_hook
- hardware_init_hook:	
- 	move.l #0x09, TADR_BOARD_REG1
- 	move.l #0x2c07e000, TADR_DGA_CSR0
- 	move.l #0x60000300, TADR_DGA_CSR1
- 	rts
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_syssvc.h ASPs/asp/target/dve68k_gcc/target_syssvc.h
*** 1.9.1/asp/target/dve68k_gcc/target_syssvc.h	Sat Aug 27 07:39:16 2011
--- ASPs/asp/target/dve68k_gcc/target_syssvc.h	Thu Jan  1 09:00:00 1970
***************
*** 1,97 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_syssvc.h 2246 2011-08-26 22:39:15Z ertl-hiro $
-  */
- 
- /*
-  *		ƥॵӥΥåȰ¸DVE-68K/40ѡ
-  *
-  *  ƥॵӥΥåȰ¸Υ󥯥롼ɥե롥Υե
-  *  Ƥϡݡͥȵҥե˵Ҥ졤Υե
-  *  ̵ʤ븫ߡ
-  */
- 
- #ifndef TOPPERS_TARGET_SYSSVC_H
- #define TOPPERS_TARGET_SYSSVC_H
- 
- /*
-  *  åȥƥΥϡɥ񸻤
-  */
- #include "dve68k.h"
- 
- /*
-  *  ȥ졼˴ؤ
-  */
- #ifdef TOPPERS_ENABLE_TRACE
- #include "logtrace/trace_config.h"
- #endif /* TOPPERS_ENABLE_TRACE */
- 
- /*
-  *  ưåΥåȥƥ̾
-  */
- #define TARGET_NAME	"DVE-68K/40"
- 
- /*
-  *  ƥ٥ϤΤʸ
-  *
-  *  åȰ¸ˡǡʸcɽ//¸롥
-  */
- extern void	target_fput_log(char c);
- 
- /*
-  *  ꥢݡȿ
-  */
- #define TNUM_PORT		2		/* ݡȤ륷ꥢݡȤο */
- 
- /*
-  *  ꥢݡȤΥܡ졼Ȥ˴ؤ
-  *
-  *  PD72001Υܡ졼ȥͥ졼ꤹ٤͡
-  */
- #define BRG1_DEF	0x00U		/* 9600bpsʾ̡*/
- #define BRG2_DEF	0x1eU		/* 9600bpsʲ̡*/
- 
- /*
-  *  ƥϢ
-  *
-  *  ǥե̤ͤꡥ
-  */
- 
- #endif /* TOPPERS_TARGET_SYSSVC_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_test.h ASPs/asp/target/dve68k_gcc/target_test.h
*** 1.9.1/asp/target/dve68k_gcc/target_test.h	Sat Apr 12 10:31:03 2008
--- ASPs/asp/target/dve68k_gcc/target_test.h	Thu Jan  1 09:00:00 1970
***************
*** 1,53 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_test.h 328 2007-07-17 07:07:27Z hiro $
-  */
- 
- /*
-  *		ƥȥץΥåȰ¸DVE-68K/40ѡ
-  */
- 
- #ifndef TOPPERS_TARGET_TEST_H
- #define TOPPERS_TARGET_TEST_H
- 
- /*
-  *  ץåǶ̤
-  */
- #include "m68k_gcc/prc_test.h"
- 
- #endif /* TOPPERS_TARGET_TEST_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_timer.c ASPs/asp/target/dve68k_gcc/target_timer.c
*** 1.9.1/asp/target/dve68k_gcc/target_timer.c	Sun Jan 31 22:01:59 2010
--- ASPs/asp/target/dve68k_gcc/target_timer.c	Thu Jan  1 09:00:00 1970
***************
*** 1,91 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2005,2006 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_timer.c 264 2007-07-12 08:23:10Z hiro $
-  */
- 
- /*
-  *		ޥɥ饤СDVE68K/40ѡ
-  */
- 
- #include "kernel_impl.h"
- #include "time_event.h"
- #include <sil.h>
- #include "target_timer.h"
- 
- /*
-  *  ޤεư
-  */
- void
- target_timer_initialize(intptr_t exinf)
- {
- 	CLOCK	cyc = TO_CLOCK(TIC_NUME, TIC_DENO);
- 
- 	/*
- 	 *  ޼ꤷޤư򳫻Ϥ롥
- 	 */
- 	assert(cyc <= MAX_CLOCK);
- 	dga_write((void *) TADR_DGA_CSR12, CSR12_START | cyc);
- 
- 	/*
- 	 *  ޳׵򥯥ꥢ롥
- 	 */
- 	x_clear_int(INTNO_TIMER);
- }
- 
- /*
-  *  ޤ߽
-  */
- void
- target_timer_terminate(intptr_t exinf)
- {
- 	/*
- 	 *  ޤưߤ롥
- 	 */
- 	dga_write((void *) TADR_DGA_CSR12, CSR12_STOP);
- }
- 
- /*
-  *  ޳ߥϥɥ
-  */
- void
- target_timer_handler(void)
- {
- 	i_begin_int(INTNO_TIMER);
- 	signal_time();					/* ƥåζ */
- 	i_end_int(INTNO_TIMER);
- }
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_timer.cfg ASPs/asp/target/dve68k_gcc/target_timer.cfg
*** 1.9.1/asp/target/dve68k_gcc/target_timer.cfg	Thu Jun 19 16:06:40 2008
--- ASPs/asp/target/dve68k_gcc/target_timer.cfg	Thu Jan  1 09:00:00 1970
***************
*** 1,13 ****
- /*
-  *  @(#) $Id: target_timer.cfg 1142 2008-06-19 07:06:39Z ertl-hiro $
-  */
- 
- /*
-  *		ޥɥ饤ФΥե졼ե
-  */
- 
- #include "target_timer.h"
- ATT_INI({ TA_NULL, 0, target_timer_initialize });
- ATT_TER({ TA_NULL, 0, target_timer_terminate });
- CFG_INT(INTNO_TIMER, { TA_ENAINT | INTATR_TIMER, INTPRI_TIMER });
- DEF_INH(INHNO_TIMER, { TA_NULL, target_timer_handler });
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_timer.h ASPs/asp/target/dve68k_gcc/target_timer.h
*** 1.9.1/asp/target/dve68k_gcc/target_timer.h	Sat Apr 12 10:31:03 2008
--- ASPs/asp/target/dve68k_gcc/target_timer.h	Thu Jan  1 09:00:00 1970
***************
*** 1,150 ****
- /*
-  *  TOPPERS/ASP Kernel
-  *      Toyohashi Open Platform for Embedded Real-Time Systems/
-  *      Advanced Standard Profile Kernel
-  * 
-  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
-  *                              Toyohashi Univ. of Technology, JAPAN
-  *  Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
-  *              Graduate School of Information Science, Nagoya Univ., JAPAN
-  * 
-  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
-  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
-  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
-  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
-  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
-  *      ˴ޤޤƤ뤳ȡ
-  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
-  *      ѤǤǺۤˤϡۤȼɥȡ
-  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
-  *      ̵ݾڵǺܤ뤳ȡ
-  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
-  *      ѤǤʤǺۤˤϡΤ줫ξ
-  *      ȡ
-  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
-  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
-  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
-  *        𤹤뤳ȡ
-  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
-  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
-  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
-  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
-  *      դ뤳ȡ
-  * 
-  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
-  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
-  *  ФŬޤơʤݾڤԤʤޤܥեȥ
-  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
-  *  Ǥʤ
-  * 
-  *  @(#) $Id: target_timer.h 889 2008-04-11 11:17:35Z hiro $
-  */
- 
- /*
-  *		ޥɥ饤СDVE68K/40ѡ
-  */
- 
- #ifndef TOPPERS_TARGET_TIMER_H
- #define TOPPERS_TARGET_TIMER_H
- 
- #include <sil.h>
- #include "dve68k.h"
- 
- /*
-  *  ޳ߥϥɥϿΤ
-  */
- #define INHNO_TIMER		TINHNO_TT0		/* ߥϥɥֹ */
- #define INTNO_TIMER		TINTNO_TT0		/* ֹ */
- #define INTPRI_TIMER	TIRQ_LEVEL4		/* ͥ */
- #define INTATR_TIMER	TA_EDGE			/* ° */
- 
- #ifndef TOPPERS_MACRO_ONLY
- 
- /*
-  *  ͤɽη
-  */
- typedef uint32_t	CLOCK;
- 
- /*
-  *  ͤɽȥߥáñ̤ȤѴ
-  *
-  *  DVE68K/40Ǥϡޤ1˥ȥåפ롥
-  */
- #define TIMER_CLOCK				1000U
- #define TO_CLOCK(nume, deno)	((CLOCK)(TIMER_CLOCK * (nume) / (deno)))
- #define TO_USEC(clock)			(((SYSUTM) clock) * 1000U / TIMER_CLOCK)
- 
- /*
-  *  ǤΥ޼ñ̤ɽ
-  */
- #define MAX_CLOCK		((CLOCK) 0xffffffU)
- 
- /*
-  *  ߤޤǤλ֡nsecñ̡
-  *
-  *  ͤ˺Ϥʤ
-  */
- #define TIMER_STOP_DELAY	200U
- 
- /*
-  *  쥸
-  */
- #define CSR12_START		0x80000000U		/* ư */
- #define CSR12_STOP		0x00000000U		/*  */
- 
- /*
-  *  ޤεư
-  *
-  *  ޤŪʥ޳׵ȯ롥
-  */
- extern void	target_timer_initialize(intptr_t exinf);
- 
- /*
-  *  ޤ߽
-  *
-  *  ޤưߤ롥
-  */
- extern void	target_timer_terminate(intptr_t exinf);
- 
- /*
-  *  ޤθͤɽФ
-  */
- Inline CLOCK
- target_timer_get_current(void)
- {
- 	CLOCK		clk;
- 	uint32_t	saved_csr12;
- 	SIL_PRE_LOC;
- 
- 	/*
- 	 *  ޤưŪߤͤɤ߽Фޤư
- 	 *  Ūߤȡƥ郎뤿˾ޤʤ
- 	 *  DVE68K/40ΥϡɥŪǤꡤ򤨤ʤ
- 	 *  Ǿޤ뤿ˡߥå֤Ȥ롥
- 	 */
- 	SIL_LOC_INT();
- 	saved_csr12 = dga_read((void *) TADR_DGA_CSR12);
- 	dga_write((void *) TADR_DGA_CSR12, CSR12_STOP);
- 	sil_dly_nse(TIMER_STOP_DELAY);
- 	clk = dga_read((void *) TADR_DGA_CSR13) & 0x00ffffffU;
- 	dga_write((void *) TADR_DGA_CSR12, saved_csr12);
- 	SIL_UNL_INT();
- 	return(clk);
- }
- 
- /*
-  *  ޳׵Υå
-  */
- Inline bool_t
- target_timer_probe_int(void)
- {
- 	return(x_probe_int(INTNO_TIMER));
- }
- 
- /*
-  *  ޳ߥϥɥ
-  */
- extern void	target_timer_handler(void);
- 
- #endif /* TOPPERS_MACRO_ONLY */
- #endif /* TOPPERS_TARGET_TIMER_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/dve68k_gcc/target_unrename.h ASPs/asp/target/dve68k_gcc/target_unrename.h
*** 1.9.1/asp/target/dve68k_gcc/target_unrename.h	Mon Jan 11 12:03:21 2010
--- ASPs/asp/target/dve68k_gcc/target_unrename.h	Thu Jan  1 09:00:00 1970
***************
*** 1,63 ****
- /* This file is generated from target_rename.def by genrename. */
- 
- /* This file is included only when target_rename.h has been included. */
- #ifdef TOPPERS_TARGET_RENAME_H
- #undef TOPPERS_TARGET_RENAME_H
- 
- /*
-  *  kernel_cfg.c
-  */
- #undef bitpat_cfgint
- 
- /*
-  *  target_config.c
-  */
- #undef board_id
- #undef board_addr
- #undef target_initialize
- #undef target_exit
- #undef x_config_int
- 
- /*
-  *  trace_config.c
-  */
- #undef log_dsp_enter
- #undef log_dsp_leave
- #undef log_inh_enter
- #undef log_inh_leave
- #undef log_exc_enter
- #undef log_exc_leave
- 
- 
- #ifdef TOPPERS_LABEL_ASM
- 
- /*
-  *  kernel_cfg.c
-  */
- #undef _bitpat_cfgint
- 
- /*
-  *  target_config.c
-  */
- #undef _board_id
- #undef _board_addr
- #undef _target_initialize
- #undef _target_exit
- #undef _x_config_int
- 
- /*
-  *  trace_config.c
-  */
- #undef _log_dsp_enter
- #undef _log_dsp_leave
- #undef _log_inh_enter
- #undef _log_inh_leave
- #undef _log_exc_enter
- #undef _log_exc_leave
- 
- 
- #endif /* TOPPERS_LABEL_ASM */
- 
- #include "m68k_gcc/prc_unrename.h"
- 
- #endif /* TOPPERS_TARGET_RENAME_H */
--- 0 ----
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/E_PACKAGE ASPs/asp/target/rx72n_gcc/E_PACKAGE
*** 1.9.1/asp/target/rx72n_gcc/E_PACKAGE	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/E_PACKAGE	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,6 ----
+ E_PACKAGE asp_rsk_rx_hew
+ VERSION %date
+ 
+ INCLUDE ../../MANIFEST
+ INCLUDE ../../arch/rx_rxc/MANIFEST
+ INCLUDE ../../cfg/MANIFEST
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/MANIFEST ASPs/asp/target/rx72n_gcc/MANIFEST
*** 1.9.1/asp/target/rx72n_gcc/MANIFEST	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/MANIFEST	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,31 ----
+ PACKAGE asp_target_rsk_rx_hew
+ VERSION 1.6.0
+ 
+ sample_workspace
+ E_PACKAGE
+ MANIFEST
+ asm_config.cfg
+ asm_config_pass1.bat
+ asm_config_pass2.bat
+ sectrx.inc
+ starter_kit.h
+ target.tf
+ target_asm_config.tf
+ target_cfg1_out.h
+ target_check.tf
+ target_config.c
+ target_config.h
+ target_def.csv
+ target_kernel.h
+ target_rename.def
+ target_rename.h
+ target_sil.h
+ target_stddef.h
+ target_support.src
+ target_syssvc.h
+ target_test.h
+ target_timer.c
+ target_timer.cfg
+ target_timer.h
+ target_unrename.h
+ target_user.txt
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/Makefile.target ASPs/asp/target/rx72n_gcc/Makefile.target
*** 1.9.1/asp/target/rx72n_gcc/Makefile.target	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/Makefile.target	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,88 ----
+ #
+ #		Makefileのターゲット依存部（RX用）
+ #
+ 
+ #
+ #  ボード名，プロセッサ名，開発環境名の定義
+ #
+ BOARD = RX72N
+ PRC = rx72n
+ TOOL = gcc
+ 
+ # gcc target prefix
+ GCC_TARGET = rx-elf
+ 
+ #
+ #  コンパイルオプション
+ #
+ INCLUDES := $(INCLUDES) -I$(TARGETDIR)
+ #COPTS :=
+ #CDEFS :=
+ #LDFLAGS :=
+ #LIBS :=
+ 
+ #
+ #  Driver Setting
+ #
+ 
+ DRIVERDIR = $(SRCDIR)/driver/rx_gcc
+ 
+ 
+ #
+ #  カーネルに関する定義
+ #
+ KERNEL_DIR := $(KERNEL_DIR) $(TARGETDIR) $(DRIVERDIR)
+ KERNEL_ASMOBJS := $(KERNEL_ASMOBJS) target_support.o
+ KERNEL_COBJS := $(KERNEL_COBJS)  target_config.o target_timer.o target_edmac.o dummy.o$(DRIVER_COBJS)
+ 
+ 
+ #
+ #  コンフィギュレータ関係の変数の定義
+ #
+ CFG_TABS := $(CFG_TABS) --cfg1-def-table $(TARGETDIR)/target_def.csv
+ 
+ #
+ #  各セグメントの開始アドレスの定義
+ #
+ TEXT_START_ADDRESS =
+ DATA_START_ADDRESS =
+ 
+ #
+ #  リンカスクリプトの定義
+ #
+ LDSCRIPT = $(TARGETDIR)/rx72n_gcc.ld
+ 
+ #
+ #  スタートアップモジュールに関する定義
+ #
+ #  rxelf.ldに「STARTUP(start.o)」を記述したため，スタートアップモジュー
+ #  ルの名前をHIDDEN_OBJSに定義する．また，LDFLAGSに-nostdlibを追加している．
+ #
+ 
+ HIDDEN_OBJS = start.o
+ 
+ $(HIDDEN_OBJS): %.o: %.S
+ 	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<
+ 
+ $(HIDDEN_OBJS:.o=.d): %.d: %.S
+ 	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
+ 		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend
+ 
+ LDFLAGS := -nostdlib $(LDFLAGS)
+ CFG1_OUT_LDFLAGS := -nostdlib $(CFG1_OUT_LDFLAGS)
+ LIBS := $(LIBS) -lgcc
+ 
+ 
+ CFG_ASMOBJS := $(CFG_ASMOBJS) kernel_cfg_asm.o  sectrx.o
+ 
+ #
+ #  依存関係の定義
+ #
+ cfg1_out.c: $(TARGETDIR)/target_def.csv
+ kernel_cfg.timestamp: $(TARGETDIR)/target.tf
+ $(OBJFILE): $(TARGETDIR)/target_check.tf
+ 
+ #
+ #  プロセッサ依存部のインクルード
+ #
+ include $(SRCDIR)/arch/rx_$(TOOL)/$(PRC)/Makefile.prc 
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/asm_config.cfg ASPs/asp/target/rx72n_gcc/asm_config.cfg
*** 1.9.1/asp/target/rx72n_gcc/asm_config.cfg	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/asm_config.cfg	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,6 ----
+ /*
+  *  asm_config.inc 生成プロジェクト用コンフィギュレーションファイル
+  *
+  *  コンフィギュレーションは行なわないため空ファイルとする.
+  */
+ 
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/dummy.c ASPs/asp/target/rx72n_gcc/dummy.c
*** 1.9.1/asp/target/rx72n_gcc/dummy.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/dummy.c	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,23 ----
+ /*
+  * dummy.c
+  *
+  *  Created on: 2022/10/16
+  *      Author: nekom
+  */
+ #include "kernel.h"
+ 
+  STK_T *const	istack;		/* スタックポインタの初期値 */
+ 
+  void ether_int_Wrapper() {
+ 
+  }
+  void taskDemoWolf(intptr_t exinf) {
+ }
+  void taskNetWork(intptr_t exinf) {
+  }
+  void taskEther(intptr_t exinf) {
+ }
+  void timer_int_Wrapper() {
+  }
+  void timer_cm2_int_Wrapper() {
+   }
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/linker_script.ld ASPs/asp/target/rx72n_gcc/linker_script.ld
*** 1.9.1/asp/target/rx72n_gcc/linker_script.ld	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/linker_script.ld	Fri Dec  9 13:54:10 2022
***************
*** 0 ****
--- 1,197 ----
+ MEMORY
+ {
+ 	RAM : ORIGIN = 0x4, LENGTH = 0x7fffc
+ 	RAM2 : ORIGIN = 0x00800000, LENGTH = 524288
+ 	ROM : ORIGIN = 0xFFE00000, LENGTH = 2097152
+ 	OFS : ORIGIN = 0xFE7F5D00, LENGTH = 128
+ }
+ SECTIONS
+ {
+ 	.exvectors 0xFFFFFF80: AT(0xFFFFFF80)
+ 	{
+ 		"_exvectors_start" = .;
+ 		KEEP(*(.exvectors))
+ 	"_exvectors_end" = .;
+ 	} >ROM
+ 	.fvectors 0xFFFFFFFC: AT(0xFFFFFFFC)
+ 	{
+ 		KEEP(*(.fvectors))
+ 	} > ROM
+ 	.text 0xFFE00000: AT(0xFFE00000)
+ 	{
+ 		*(C$VECT)
+ 		
+ 		*(.text)
+ 		*(.text.*)
+ 		*(P)
+ 		etext = .;
+ 	} > ROM
+ 	.rvectors ALIGN(4):
+ 	{
+ 		_rvectors_start = .;
+ 		INCLUDE ../src/smc_gen/r_bsp/mcu/all/linker_script_rvectors.inc
+ 	} > ROM
+ 	.init :
+ 	{
+ 		KEEP(*(.init))
+ 		__preinit_array_start = .;
+ 		KEEP(*(.preinit_array))
+ 		__preinit_array_end = .;
+ 		__init_array_start = (. + 3) & ~ 3;
+ 		KEEP(*(.init_array))
+ 		KEEP(*(SORT(.init_array.*)))
+ 		__init_array_end = .;
+ 		__fini_array_start = .;
+ 		KEEP(*(.fini_array))
+ 		KEEP(*(SORT(.fini_array.*)))
+ 		__fini_array_end = .;
+ 	} > ROM
+ 	.fini :
+ 	{
+ 		KEEP(*(.fini))
+ 	} > ROM
+ 	.got :
+ 	{
+ 		*(.got)
+ 		*(.got.plt)
+ 	} > ROM
+ 	.rodata :
+ 	{
+ 		*(.rodata)
+ 		*(.rodata.*)
+ 		*(C_1)
+ 		*(C_2)
+ 		*(C)
+ 		_erodata = .;
+ 	} > ROM
+ 	gcc_exceptions_table :
+ 	{
+ 	    KEEP (*(.gcc_except_table))
+ 	    *(.gcc_except_table.*)
+ 	} > ROM
+ 	.eh_frame_hdr :
+ 	{
+ 		*(.eh_frame_hdr)
+ 	} > ROM
+ 	.eh_frame :
+ 	{
+ 		*(.eh_frame)
+ 	} > ROM
+ 	.jcr :
+ 	{
+ 		*(.jcr)
+ 	} > ROM
+ 	.tors :
+ 	{
+ 		__CTOR_LIST__ = .;
+ 		. = ALIGN(2);
+ 		___ctors = .;
+ 		*(.ctors)
+ 		___ctors_end = .;
+ 		__CTOR_END__ = .;
+ 		__DTOR_LIST__ = .;
+ 		___dtors = .;
+ 		*(.dtors)
+ 		___dtors_end = .;
+ 		__DTOR_END__ = .;
+ 		. = ALIGN(2);
+ 		_mdata = .;
+ 	} > ROM
+ 	.data : AT(_mdata)
+ 	{
+ 		_data = .;
+ 		*(.data)
+ 		*(.data.*)
+ 		*(D)
+ 		*(D_1)
+ 		*(D_2)
+ 		_edata = .;
+ 	} > RAM
+ 	.B_TX_DESC_1  : ALIGN(16)
+ 	{
+ 		*(B_TX_DESC_1)
+ 		
+ 	}> RAM
+ 	.B_RX_DESC_1  : ALIGN(16)
+ 	{
+ 		*(B_RX_DESC_1)
+ 		
+ 	}> RAM
+ 	.B_ETHERNET_BUFFERS_1  : ALIGN(32)
+ 	{
+ 		*(B_ETHERNET_BUFFERS_1)
+ 		
+ 	}> RAM
+ 	
+ 	
+ 	.bss : ALIGN(128)
+ 	{
+ 		_bss = .;
+ 		*(.bss)
+ 		*(.bss.**)
+ 		*(COMMON)
+ 		*(B)
+ 		*(B_1)
+ 		
+ 		
+ 		
+ 		
+ 		*(B_2)
+ 		_ebss = .;
+ 		. = ALIGN(128);
+ 		_end = .;
+ 	} > RAM
+ 	.ofs1 0xFE7F5D00: AT(0xFE7F5D00)
+ 	{
+ 		KEEP(*(.ofs1))
+ 	} > OFS
+ 	.ofs2 0xFE7F5D10: AT(0xFE7F5D10)
+ 	{
+ 		KEEP(*(.ofs2))
+ 	} > OFS
+ 	.ofs3 0xFE7F5D20: AT(0xFE7F5D20)
+ 	{
+ 		KEEP(*(.ofs3))
+ 	} > OFS
+ 	.ofs4 0xFE7F5D40: AT(0xFE7F5D40)
+ 	{
+ 		KEEP(*(.ofs4))
+ 	} > OFS
+ 	.ofs5 0xFE7F5D48: AT(0xFE7F5D48)
+ 	{
+ 		KEEP(*(.ofs5))
+ 	} > OFS
+ 	.ofs6 0xFE7F5D50: AT(0xFE7F5D50)
+ 	{
+ 		KEEP(*(.ofs6))
+ 	} > OFS
+ 	.ofs7 0xFE7F5D64: AT(0xFE7F5D64)
+ 	{
+ 		KEEP(*(.ofs7))
+ 	} > OFS
+ 	.ofs8 0xFE7F5D70: AT(0xFE7F5D70)
+ 	{
+ 		KEEP(*(.ofs8))
+ 	} > OFS
+ 	.r_bsp_NULL :
+ 	{
+ 		. += 0x100;
+ 		"_r_bsp_NULL_end" = .;
+ 	} >RAM AT>RAM
+ .r_bsp_istack BLOCK(0x4) (NOLOAD) :
+ 	{
+ 		KEEP(*(.r_bsp_istack))
+ 	} >RAM AT>RAM
+ .istack :
+ 	{
+ 		"_istack" = .;
+ 	} >RAM
+ .r_bsp_ustack BLOCK(0x4) (NOLOAD) :
+ 	{
+ 		KEEP(*(.r_bsp_ustack))
+ 	} >RAM AT>RAM
+ .ustack :
+ 	{
+ 		"_ustack" = .;
+ 	} >RAM
+ }
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/rx72n_gcc.ld ASPs/asp/target/rx72n_gcc/rx72n_gcc.ld
*** 1.9.1/asp/target/rx72n_gcc/rx72n_gcc.ld	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/rx72n_gcc.ld	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,82 ----
+ MEMORY
+ {
+ 	RAM : ORIGIN = 0x4, LENGTH = 0x7fffc
+ 	RAM2 : ORIGIN = 0x00800000, LENGTH = 524288
+ 	ROM : ORIGIN = 0xFFE00000, LENGTH = 2097152
+ 
+ }
+ 
+ PROVIDE(hardware_init_hook = 0);
+ PROVIDE(software_init_hook = 0);
+ PROVIDE(software_term_hook = 0);
+ STARTUP(start.o)
+ 
+ SECTIONS
+ {
+ 
+ 	.text :
+ 	{
+ 		__text = .;
+ 		*(.vector)
+ 		*(.text)
+ 		*(.text.*)
+ 		*(P)
+ 	} > ROM
+ 	_etext = .;
+ 	PROVIDE(etext = .);
+ 
+ 	.rodata :
+ 	{
+ 		*(.rodata)
+ 		*(.rodata.*)
+ 		*(C_1)
+ 		*(C_2)
+ 		*(C)
+ 		*(C$VECT)
+ 	} > ROM
+     __rodata_end = .;
+ 	__exidx_start = .;
+ 	__exidx_end = .;
+ 
+ 	. = 0x0; /*RAM START ADDRES*/
+ 	.bss : 
+ 	{
+ 		__bss_start  = .;
+         *(DTCA_VECTOR_SEC)
+         __dtca_start = .;
+ 		*(.bss)
+ 		*(.bss.*)
+ 		*(COMMON)
+ 		*(B)
+ 		*(B_1)
+ 		*(B_2)
+ 		*(SI) /* SI is kernel stack section*/
+ 	    __bss_end = .;
+ 	} > RAM
+ 
+     . = __rodata_end;
+ 	. = ALIGN(4);
+ 	__idata_start = .;
+ 	.data : 
+ 	{
+ 		__data_start = .;
+ 		*(.data)
+ 		*(.data.*)
+ 		*(D)
+ 		*(D_1)
+ 		*(D_2)
+ 	    __data_end = .;
+ 	} > RAM AT> ROM
+     
+ 	__idata_end = __idata_start + SIZEOF(.data);
+ 	_edata = .;
+ 	PROVIDE(edata = .);
+     
+ 	. = ALIGN(4);
+     .fvectors 0xFFFFFF80 :
+    {
+       *(.fvect)
+     } > ROM
+ 	_end = .;
+ 	PROVIDE(end = .);
+ }
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/sectrx.S ASPs/asp/target/rx72n_gcc/sectrx.S
*** 1.9.1/asp/target/rx72n_gcc/sectrx.S	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/sectrx.S	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,58 ----
+ ;*
+ ;*  TOPPERS/ASP Kernel
+ ;*      Toyohashi Open Platform for Embedded Real-Time Systems/
+ ;*      Advanced Standard Profile Kernel
+ ;* 
+ ;*  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+ ;* 
+ ;*  ��L���쌠�҂́CFree Software Foundation �ɂ���Č��\����Ă��� 
+ ;*  GNU General Public License �� Version 2 �ɋL�q����Ă���������C��
+ ;*  ����(1)�`(4)�̏����桙スススス鼾ソスノ鯉ソスススCス{ス\スtスgスEスFスAスiス{ス\スtスgスEスF
+ ;*  スAスススススマゑソススススススフゑソススワむ．スネ会ソススススススjスススgスpスEスススススEスススマ・スト配スzスiスネ会ソススC
+ ;*  スススpスニ呼ぶ）ススス驍アスニを無擾ソススナ具ソスススススススD
+ ;*  (1) ス{ス\スtスgスEスFスAススス\ス[スXスRス[スhスフ形スナ暦ソススpスススス鼾ソスノは，ススLスフ抵ソススス
+ ;*      ススス\スススCスススフ暦ソススpススススススススム会ソススLスフ厄ソススロ証規ス閧ェスCスススブまの形スナソス[
+ ;*      スXスRス[スhスススノ含まゑソストゑソスス驍アスニ．
+ ;*  (2) ス{ス\スtスgスEスFスAスススト暦ソススpスツ能スネバスCスiスススRス[スhスiスススススPス[ズスuスススIスu
+ ;*      スWスFスNスgスtス@スCススス窿会ソスCスuスススススネど）スフ形スナ暦ソススpスススス鼾ソスノは，スススp
+ ;*      スノ費ソススススhスLスススススススgスiスススpスメマスjスススAスススネど）スノ，ススLスフ抵ソスス申\���C
+ ;*      ���̗��p��������щ��L�̖��ۏ؋K����f�ڂ��邱�ƁD
+ ;*  (3) �{�\�t�g�E�F�A���ė��p�s�\�ȃo�C�i���R�[�h�̌`�܂��͋@��ɑg
+ ;*      �ݍ��`�ŗ��p����ꍇ�ɂ́C���̂����ꂩ�̏����������ƁD
+ ;*    (a) ���p�ɔ����h�L�������g�i���p�҃}�j���A���Ȃǁj�ɁC��L�̒���
+ ;*        ���\���C���̗��p��������щ��L�̖��ۏ؋K����f�ڂ��邱�ƁD
+ ;*    (b) ���p�̌`�Ԃ��C�ʂɒ�߂���@�ɂ���āC��L���쌠�҂ɕ���
+ ;*        ���ƁD
+ ;*  (4) �{�\�t�g�E�F�A�̗��p�ɂ�蒼�ړI�܂��͊ԐړI�ɐ����邢���Ȃ鑹
+ ;*      �Q������C��L���쌠�҂�Ɛӂ��邱�ƁD
+ ;* 
+ ;*  �{�\�t�g�E�F�A�́C���ۏ؂Œ氓ススストゑソスススススフでゑソスススDススLススス申҂́C
+ ;*  �{�\�t�g�E�F�A�Ɋւ��āC���̓K�p�\�����܂߂āC�����Ȃ�ۏ؂��s��
+ ;*  �Ȃ��D�܂��C�{�\�t�g�E�F�A�̗��p�ɂ�蒼�ړI�܂��͊ԐړI�ɐ�������
+ ;*  ���Ȃ鑹�Q�Ɋւ��Ă��C���̐ӔC�奄スネゑソススD
+ ;*
+ 
+ 
+ ;
+ ;  ズス[スQスbスgスVスXスeスススヒ托ソススZスNスVスススススス`スtス@スCスス(スXズス[ズス[スLスbスgスp)
+ ;
+ 
+ ;
+ ;  スZスNスVスススススフ抵ソス`
+ ;
+ ;  スZスNスVスススススフアスhスススXスス`ススHEWススフ最適スススススススJスス
+ ;  スIスvスVスススススノて趣ソスス{スススス.
+ ;
+ 
+ 	.section	SI,"aw",@nobits
+ 	.balign 4
+ 	.glb _DEFAULT_ISTACK
+ _DEFAULT_ISTACK:
+ 	.blkb		0x10000
+ 	.glb DEFAULT_ISTACK_TOP
+ DEFAULT_ISTACK_TOP:
+ 
+ 
+ 
+ 
+ 
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target.tf ASPs/asp/target/rx72n_gcc/target.tf
*** 1.9.1/asp/target/rx72n_gcc/target.tf	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target.tf	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,56 ----
+ $ 
+ $  TOPPERS/ASP Kernel
+ $      Toyohashi Open Platform for Embedded Real-Time Systems/
+ $      Advanced Standard Profile Kernel
+ $ 
+ $  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+ $ 
+ $  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ $  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ $  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ $  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ $      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ $      スコード中に含まれていること．
+ $  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ $      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ $      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ $      の無保証規定を掲載すること．
+ $  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ $      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ $      と．
+ $    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ $        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ $    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ $        報告すること．
+ $  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ $      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ $      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ $      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ $      免責すること．
+ $ 
+ $  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ $  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ $  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ $  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ $  の責任を負わない．
+ $ 
+ $ 
+ 
+ $ 
+ $  ターゲット依存テンプレート（RX72N用）
+ $ 
+ 
+ 
+ /*$NL$
+ $SPC$*  Target-dependent Definitions (RX72N)$NL$
+ $SPC$*/$NL$
+ $NL$
+ 
+ $INCLUDE "target_asm_config.tf"$
+ 
+ 
+ $ 
+ $  RX72n依存部の読み込み
+ $ 
+ $INCLUDE "rx_gcc/rx72n/rx72n.tf"$
+ 
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_asm_config.tf ASPs/asp/target/rx72n_gcc/target_asm_config.tf
*** 1.9.1/asp/target/rx72n_gcc/target_asm_config.tf	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_asm_config.tf	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,20 ----
+ $
+ $     asm_config.inc 生成用
+ $     パス2のターゲット依存テンプレート（kaede_gcc用）
+ $
+ $     Copyright (C) 2010 by Witz Corporation, JAPAN
+ $     Copyright (C) 2016- by Hisashi Hata, JAPAN
+ 
+ $
+ 
+ $
+ $  プロセッサ依存のテンプレートファイルのインクルード
+ $
+ $INCLUDE"prc_asm_config.tf"$
+ 
+ $FILE "asm_config.inc"$
+ 
+ $NL$
+ 
+ #define SIL_DLY_TIM1 $TAB$ $TAB$ $+SIL_DLY_TIM1$ $NL$
+ #define SIL_DLY_TIM2 $TAB$ $TAB$ $+SIL_DLY_TIM2$ $NL$
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_board.h ASPs/asp/target/rx72n_gcc/target_board.h
*** 1.9.1/asp/target/rx72n_gcc/target_board.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_board.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,54 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation 
+  *  によって公表されている GNU General Public License の Version 2 に記
+  *  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
+  *  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+  *  利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
+  *  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
+  *  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
+  * 
+  */
+ 
+ #ifndef	TOPPERS_STARTER_KIT_H
+ #define	TOPPERS_STARTER_KIT_H
+ 
+ 
+ /*
+  *  MCU依存情報の読み込み
+  */
+ #include <rx72n.h>
+ 
+ 
+ 
+ #define F_PCLKA		96000000UL	/* PCLKA frequency (configured by SCKCR.PCK) */
+ #define F_PCLKB		48000000UL	/* PCLKB frequency (configured by SCKCR.PCK) */
+ 
+ 
+ #endif	/* TOPPERS_STARTER_KIT_H */
+ 
+  
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_cfg1_out.h ASPs/asp/target/rx72n_gcc/target_cfg1_out.h
*** 1.9.1/asp/target/rx72n_gcc/target_cfg1_out.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_cfg1_out.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,7 ----
+ /*
+  *		cfg1_out.cのリンクに必要なスタブの定義
+  */
+ 
+ #include "prc_cfg1_out.h"
+ #include "sil.h"
+ 
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_check.tf ASPs/asp/target/rx72n_gcc/target_check.tf
*** 1.9.1/asp/target/rx72n_gcc/target_check.tf	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_check.tf	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,45 ----
+ $ 
+ $  TOPPERS/ASP Kernel
+ $      Toyohashi Open Platform for Embedded Real-Time Systems/
+ $      Advanced Standard Profile Kernel
+ $ 
+ $  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+ $ 
+ $  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+ $  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+ $  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+ $  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ $      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ $      スコード中に含まれていること．
+ $  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+ $      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+ $      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+ $      の無保証規定を掲載すること．
+ $  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+ $      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+ $      と．
+ $    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+ $        作権表示，この利用条件および下記の無保証規定を掲載すること．
+ $    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+ $        報告すること．
+ $  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ $      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+ $      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+ $      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+ $      免責すること．
+ $ 
+ $  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+ $  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+ $  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+ $  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+ $  の責任を負わない．
+ $ 
+ 
+ $ 
+ $     パス3のターゲット依存テンプレート（RX72N用）
+ $ 
+ 
+ $ 
+ $  パス3のSH4A依存のテンプレートのインクルード
+ $ 
+ $INCLUDE"prc_check.tf"$
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_config.c ASPs/asp/target/rx72n_gcc/target_config.c
*** 1.9.1/asp/target/rx72n_gcc/target_config.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_config.c	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,83 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation 
+  *  によって公表されている GNU General Public License の Version 2 に記
+  *  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
+  *  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+  *  利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
+  *  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
+  *  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
+  * 
+  */
+ 
+ 
+ /*
+  *	ターゲットシステム依存モジュール（RX72N用）
+  */
+ 
+ 
+ #include "kernel_impl.h"
+ #include <sil.h>
+ #include "target_board.h"
+ 
+ 
+ 
+ void
+ target_initialize( void )
+ {
+ 
+ 	/*
+ 	 *  プロセッサ依存の初期化
+ 	 */
+ 
+   prc_initialize();
+ 
+ }
+ 
+ /*
+  *  ターゲットシステムの終了ルーチン
+  */
+ void
+ target_exit( void )
+ {
+ 	/*
+ 	 *	プロセッサ依存の終了処理
+ 	 */
+ 	prc_terminate();
+ 
+ 	while ( 1 );
+ }
+ 
+ /*
+  *  システムログの低レベル出力のための文字出力
+  */
+ void
+ target_fput_log( char c )
+ {
+ 
+ }
+ 
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_config.h ASPs/asp/target/rx72n_gcc/target_config.h
*** 1.9.1/asp/target/rx72n_gcc/target_config.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_config.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,134 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2005-2007 by Embedded and Real-Time Systems Laboratory
+  *              Graduate School of Information Science, Nagoya Univ., JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  *
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  *
+  */
+ 
+ /*
+  *		ターゲット依存モジュール（TX72N用）
+  *
+  *  カーネルのターゲット依存部のインクルードファイル．kernel_impl.hのター
+  *  ゲット依存部の位置付けとなる．
+  */
+ 
+ #ifndef TOPPERS_TARGET_CONFIG_H
+ #define TOPPERS_TARGET_CONFIG_H
+ 
+ /*
+  *  ターゲットシステムのハードウェア資源の定義
+  */
+ #include "target_board.h"
+ 
+ 
+ /*
+  *  デフォルトの非タスクコンテキスト用のスタック領域の定義
+  *
+  *  スタックサイズを変更する場合は, sectrx.incの_DEFAULT_ISTACK
+  *  ラベルの位置にある.blkb命令のサイズと, 以下DEFAULT_ISTKSZの
+  *  サイズを合わせて同じ値に変更すること.
+  */
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ extern uint32_t	DEFAULT_ISTACK[];
+ #endif
+ 
+ #define DEFAULT_ISTKSZ		(0x1000U) //( 0x1e00CU ) //wata
+ #define DEFAULT_ISTK		( (void *)&DEFAULT_ISTACK[0] )
+ 
+ 
+ /*
+  *  ターゲット依存の文字出力に使用するポートの定義
+  */
+ #define TARGET_PUTC_PORTID	( 1 )
+ 
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  ターゲットシステム依存の初期化
+  */
+ extern void	target_initialize( void );
+ 
+ /*
+  *  ターゲットシステムの終了
+  *
+  *  システムを終了する時に使う．
+  */
+ extern void	target_exit( void )	NoReturn;
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ 
+ 
+ /*
+  *  プロセッサ依存モジュール（RX63n用）
+  */
+ #include "rx72n_config.h"
+ 
+ 
+ /*
+  *  トレースログに関する設定
+  */
+ #define TCNT_TRACE_BUFFER	( 32 )
+ 
+ /*
+  *  トレースログ出力する箇所の選択
+  *    ログ出力する箇所を1で定義
+  *    ログ出力しない箇所を0で定義
+  */
+ #ifdef TOPPERS_ENABLE_TRACE
+ #define LOG_DSP_ENTER	( 1 )
+ #define LOG_DSP_LEAVE	( 1 )
+ #define LOG_INH_ENTER	( 0 )
+ #define LOG_INH_LEAVE	( 0 )
+ #define LOG_EXC_ENTER	( 0 )
+ #define LOG_EXC_LEAVE	( 0 )
+ #else
+ #define LOG_DSP_ENTER	( 0 )
+ #define LOG_DSP_LEAVE	( 0 )
+ #define LOG_INH_ENTER	( 0 )
+ #define LOG_INH_LEAVE	( 0 )
+ #define LOG_EXC_ENTER	( 0 )
+ #define LOG_EXC_LEAVE	( 0 )
+ #endif
+ 
+ #ifdef TOPPERS_ENABLE_TRACE
+ #include "logtrace/trace_config.h"
+ #endif /* TOPPERS_ENABLE_TRACE */
+ 
+ #endif /* TOPPERS_TARGET_CONFIG_H */
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_def.csv ASPs/asp/target/rx72n_gcc/target_def.csv
*** 1.9.1/asp/target/rx72n_gcc/target_def.csv	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_def.csv	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,2 ----
+ SIL_DLY_TIM1,SIL_DLY_TIM1
+ SIL_DLY_TIM2,SIL_DLY_TIM2
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_edmac.c ASPs/asp/target/rx72n_gcc/target_edmac.c
*** 1.9.1/asp/target/rx72n_gcc/target_edmac.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_edmac.c	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,62 ----
+ /*
+ 
+ 
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2010 by Witz Corporation, JAPAN
+  *
+  *  上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation
+  *  によって公表されている GNU General Public License の Version 2 に記
+  *  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
+  *  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+  *  利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
+  *  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
+  *  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
+  *
+  */
+ 
+ #include "kernel_impl.h"
+ #include <sil.h>
+ #include "target_edmac.h"
+ 
+ extern void ether_int_Wrapper();
+ /*
+  *	ターゲットシステム依存モジュール（RX72N用 EDMAC Wrapper）
+  */
+ 
+ void
+ rx72n_edmac_interrput_wrapper(void){
+ 	i_begin_int(INTNO_EDMAC_0);
+ 
+ 	ether_int_Wrapper();
+ 
+ 	i_end_int(INTNO_EDMAC_0);
+ 
+ }
+ void
+ rx72n_edmac_interrput_wrapper_term(void){
+ 
+ }
+ 
+ 
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_edmac.cfg ASPs/asp/target/rx72n_gcc/target_edmac.cfg
*** 1.9.1/asp/target/rx72n_gcc/target_edmac.cfg	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_edmac.cfg	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,8 ----
+ /*
+  *  タイマドライバ（RX610用）のコンフィギュレーションファイル
+  */
+ 
+ #include "target_edmac.h"
+ DEF_INH(INHNO_EDMAC_0, { TA_NULL, rx72n_edmac_interrput_wrapper });
+ CFG_INT(INTNO_EDMAC_0, { INTATR_EDMAC_0, INTPRI_EDMAC_0 });
+ CRE_SEM(ETHER_START_SEM, {TA_TPRI, 0, 1 });
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_edmac.h ASPs/asp/target/rx72n_gcc/target_edmac.h
*** 1.9.1/asp/target/rx72n_gcc/target_edmac.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_edmac.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,69 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  *
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2005-2007 by Embedded and Real-Time Systems Laboratory
+  *              Graduate School of Information Science, Nagoya Univ., JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  *
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  *
+  */
+ 
+ /*
+  *		ターゲット依存モジュール（RX72N用）
+  *
+  *  カーネルのターゲット依存部のインクルードファイル．kernel_impl.hのター
+  *  ゲット依存部の位置付けとなる．
+  */
+ 
+ #ifndef TOPPERS_TARGET_72N_EDMAC_H
+ #define TOPPERS_TARGET_72N_EDMAC_H
+ #include <sil.h>
+ #include "target_board.h"
+ #include "prc_kernel.h"
+ 
+ //#define INTNO_EDMAC_0	113			/* 割込み番号 */
+ 
+ #define INHNO_EDMAC_0		INT_EDMAC0		/* 割込みハンドラ番号 */
+ #define INTNO_EDMAC_0		INT_EDMAC0		/* 割込み番号 */
+ #define INTPRI_EDMAC_0	-5					/* 割込み優先度 */
+ #define INTATR_EDMAC_0	TA_ENAINT | TA_EDGE	/* 割込み属性 */
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ extern void	rx72n_edmac_interrput_wrapper(void);
+ 
+ #endif
+ #endif /* TOPPERS_TARGET_72N_EDMAC_H */
+ 
+ 
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_kernel.h ASPs/asp/target/rx72n_gcc/target_kernel.h
*** 1.9.1/asp/target/rx72n_gcc/target_kernel.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_kernel.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,74 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2003-2004 by Naoki Saito
+  *             Nagoya Municipal Industrial Research Institute, JAPAN
+  *  Copyright (C) 2003-2004 by Platform Development Center
+  *                                          RICOH COMPANY,LTD. JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *  このインクルードファイルは，kernel.hでインクルードされる．他のファ
+  *  イルから直接インクルードすることはない．このファイルをインクルード
+  *  する前に，t_stddef.hがインクルードされるので，それらに依存してもよ
+  *  い．
+  */
+ 
+ #ifndef TOPPERS_TARGET_KERNEL_H
+ #define TOPPERS_TARGET_KERNEL_H
+ 
+ 
+ /*
+  *  プロセッサで共通な定義
+  */
+ #include "prc_kernel.h"
+ 
+ 
+ /*
+  *  サポートする機能の定義
+  */
+ #define	TOPPERS_TARGET_SUPPORT_GET_UTM		/* get_utmをサポートする */
+ 
+ 
+ /*
+  *  タイムティックの定義
+  */
+ #define	TIC_NUME		( 1U )		/* タイムティックの周期の分子 */
+ #define	TIC_DENO		( 1U )		/* タイムティックの周期の分母 */
+ 
+ #endif /* TOPPERS_TARGET_KERNEL_H */
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_offset.tf ASPs/asp/target/rx72n_gcc/target_offset.tf
*** 1.9.1/asp/target/rx72n_gcc/target_offset.tf	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_offset.tf	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,13 ----
+ $
+ $       オフセットファイル生成用テンプレートファイル（Rx用）
+ $
+ 
+ $
+ $  標準テンプレートファイルのインクルード
+ $
+ $INCLUDE "kernel/genoffset.tf"$
+ 
+ $ 
+ $  コア依存テンプレートのインクルード（Rx用）
+ $ 
+ $INCLUDE "core_offset.tf"$
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_rename.def ASPs/asp/target/rx72n_gcc/target_rename.def
*** 1.9.1/asp/target/rx72n_gcc/target_rename.def	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_rename.def	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,13 ----
+ # target_config.c
+ target_initialize
+ target_exit
+ 
+ #trace_config.c
+ log_dsp_enter
+ log_dsp_leave
+ log_inh_enter
+ log_inh_leave
+ log_exc_enter
+ log_exc_leave
+ 
+ INCLUDE "prc"
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_rename.h ASPs/asp/target/rx72n_gcc/target_rename.h
*** 1.9.1/asp/target/rx72n_gcc/target_rename.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_rename.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,49 ----
+ /* This file is generated from target_rename.def by genrename. */
+ 
+ #ifndef TOPPERS_TARGET_RENAME_H
+ #define TOPPERS_TARGET_RENAME_H
+ 
+ /*
+  *  target_config.c
+  */
+ #define target_initialize			_kernel_target_initialize
+ #define target_exit					_kernel_target_exit
+ 
+ /*
+  *  trace_config.c
+  */
+ #define log_dsp_enter				_kernel_log_dsp_enter
+ #define log_dsp_leave				_kernel_log_dsp_leave
+ #define log_inh_enter				_kernel_log_inh_enter
+ #define log_inh_leave				_kernel_log_inh_leave
+ #define log_exc_enter				_kernel_log_exc_enter
+ #define log_exc_leave				_kernel_log_exc_leave
+ 
+ 
+ #ifdef TOPPERS_LABEL_ASM
+ 
+ /*
+  *  target_config.c
+  */
+ #define _board_id					__kernel_board_id
+ #define _board_addr					__kernel_board_addr
+ #define _target_initialize			__kernel_target_initialize
+ #define _target_exit				__kernel_target_exit
+ #define _x_config_int				__kernel_x_config_int
+ 
+ /*
+  *  trace_config.c
+  */
+ #define _log_dsp_enter				__kernel_log_dsp_enter
+ #define _log_dsp_leave				__kernel_log_dsp_leave
+ #define _log_inh_enter				__kernel_log_inh_enter
+ #define _log_inh_leave				__kernel_log_inh_leave
+ #define _log_exc_enter				__kernel_log_exc_enter
+ #define _log_exc_leave				__kernel_log_exc_leave
+ 
+ 
+ #endif /* TOPPERS_LABEL_ASM */
+ 
+ #include "prc_rename.h"
+ 
+ #endif /* TOPPERS_TARGET_RENAME_H */
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_serial.h ASPs/asp/target/rx72n_gcc/target_serial.h
*** 1.9.1/asp/target/rx72n_gcc/target_serial.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_serial.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,133 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2003-2004 by Naoki Saito
+  *             Nagoya Municipal Industrial Research Institute, JAPAN
+  *  Copyright (C) 2003-2004 by Platform Development Center
+  *                                          RICOH COMPANY,LTD. JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		シリアルI/Oデバイス（SIO）ドライバ（RX610用）
+  */
+ 
+ #ifndef TOPPERS_TARGET_SERIAL_H
+ #define TOPPERS_TARGET_SERIAL_H
+ 
+ #include "target_board.h"
+ #include "driver/rx_gcc/SCIc.h"
+ 
+ /*
+  *  SIOの割込みハンドラのベクタ番号
+  */
+ #define INHNO_SIO_TX	INT_SCI0_TEI0			/* 割込みハンドラ番号 */
+ #define INTNO_SIO_TX	INT_SCI0_TEI0			/* 割込み番号 */
+ #define INHNO_SIO_RX	INT_SCI0_RXI0			/* 割込みハンドラ番号 */
+ #define INTNO_SIO_RX	INT_SCI0_RXI0			/* 割込み番号 */
+ #define INTPRI_SIO		-4						/* 割込み優先度 */
+ #define INTATR_SIO		(TA_NULL)				/* 割込み属性 */
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ 
+ 
+ /*
+  *  カーネル起動時のバナー出力用の初期化
+  */
+ void
+ std_uart_init(ID siopid, uint8_t bitrate, uint8_t clksrc);
+ 
+ /*
+  *  シリアルI/Oポートへのポーリングでの出力
+  */
+ void sci_uart_pol_putc(char c, ID siopid);
+   
+ /*
+  *  SIOドライバの初期化
+  */
+ extern void		sio_initialize(intptr_t exinf);
+ 
+ /*
+  *  シリアルI/Oポートのオープン
+  */
+ extern SIOPCB	*sio_opn_por(ID siopid, intptr_t exinf);
+ 
+ /*
+  *  シリアルI/Oポートのクローズ
+  */
+ extern void		sio_cls_por(SIOPCB *p_siopcb);
+ 
+ /*
+  *  SIOの割込みハンドラ
+  */
+ extern void 	sio_tx_isr(intptr_t exinf);
+ extern void 	sio_rx_isr(intptr_t exinf);
+ 
+ /*
+  *  シリアルI/Oポートへの文字送信
+  */
+ extern bool_t	sio_snd_chr(SIOPCB *siopcb, char c);
+ 
+ /*
+  *  シリアルI/Oポートからの文字受信
+  */
+ extern int_t	sio_rcv_chr(SIOPCB *siopcb);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの許可
+  */
+ extern void		sio_ena_cbr(SIOPCB *siopcb, uint_t cbrtn);
+ 
+ /*
+  *  シリアルI/Oポートからのコールバックの禁止
+  */
+ extern void		sio_dis_cbr(SIOPCB *siopcb, uint_t cbrtn);
+ 
+ /*
+  *  シリアルI/Oポートからの送信可能コールバック
+  */
+ extern void		sio_irdy_snd(intptr_t exinf);
+ 
+ /*
+  *  シリアルI/Oポートからの受信通知コールバック
+  */
+ extern void		sio_irdy_rcv(intptr_t exinf);
+ 
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ #endif /* TOPPERS_TARGET_SERIAL_H */
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_sil.h ASPs/asp/target/rx72n_gcc/target_sil.h
*** 1.9.1/asp/target/rx72n_gcc/target_sil.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_sil.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,61 ----
+ /*
+  *  TOPPERS Software
+  *      Toyohashi Open Platform for Embedded Real-Time Systems
+  * 
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		sil.hのターゲット依存部（RX72N用）
+  *
+  *  このインクルードファイルは，sil.hの先頭でインクルードされる．他のファ
+  *  イルからは直接インクルードすることはない．このファイルをインクルー
+  *  ドする前に，t_stddef.hがインクルードされるので，それらに依存しても
+  *  よい．
+  */
+ 
+ #ifndef TOPPERS_TARGET_SIL_H
+ #define TOPPERS_TARGET_SIL_H
+ 
+ /*
+  *  微少時間待ちのための定義
+  */
+ #define SIL_DLY_TIM1     69
+ #define SIL_DLY_TIM2     50
+ 
+ /*
+  *  プロセッサで共通な定義
+  */
+ #include "prc_sil.h"
+ 
+ #endif /* TOPPERS_TARGET_SIL_H */
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_stddef.h ASPs/asp/target/rx72n_gcc/target_stddef.h
*** 1.9.1/asp/target/rx72n_gcc/target_stddef.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_stddef.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,97 ----
+ /*
+  *  TOPPERS Software
+  *      Toyohashi Open Platform for Embedded Real-Time Systems
+  * 
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2003-2004 by Naoki Saito
+  *             Nagoya Municipal Industrial Research Institute, JAPAN
+  *  Copyright (C) 2003-2004 by Platform Development Center
+  *                                          RICOH COMPANY,LTD. JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *  t_stddef.hのターゲット依存部（Starter_Kit用）
+  *
+  *  このインクルードファイルは，t_stddef.hの先頭でインクルードされる．
+  *  他のファイルからは直接インクルードすることはない．他のインクルード
+  *  ファイルに先立って処理されるため，他のインクルードファイルに依存し
+  *  てはならない．
+  */
+ 
+ #ifndef TOPPERS_TARGET_STDDEF_H
+ #define TOPPERS_TARGET_STDDEF_H
+ 
+ /*
+  *  ターゲットを識別するためのマクロの定義
+  */
+ #define TOPPERS_STARTER_KIT			/* システム略称 */
+ 
+ 
+ /*
+  *  開発環境で共通な定義
+  */
+ #define TOPPERS_STDINT_TYPE1
+ #define TOPPERS_STDFLOAT_TYPE1
+ #include "gcc/tool_stddef.h"
+ 
+ 
+ /*
+  *  プロセッサで共通な定義
+  */
+ #include "prc_stddef.h"
+ 
+ 
+ /*
+  *  アサーションの失敗時の実行中断処理
+  */
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ Inline void
+ TOPPERS_assert_abort( void )
+ {
+ }
+ 
+ 
+ /*
+  *  構造体メンバのアライメント数指定
+  *
+  *  本拡張機能を使用することで, 構造体メンバの
+  *  アライメントを1バイトアライメントにする.
+  */
+ //#pragma pack
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ 
+ #endif /* TOPPERS_TARGET_STDDEF_H */
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_support.S ASPs/asp/target/rx72n_gcc/target_support.S
*** 1.9.1/asp/target/rx72n_gcc/target_support.S	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_support.S	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,94 ----
+ ;*
+ ;*  TOPPERS/ASP Kernel
+ ;*      Toyohashi Open Platform for Embedded Real-Time Systems/
+ ;*      Advanced Standard Profile Kernel
+ ;* 
+ ;*  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+ ;*                              Toyohashi Univ. of Technology, JAPAN
+ ;*  Copyright (C) 2001 by OAKS16KIT support
+ ;*  Copyright (C) 2003-2004 by Naoki Saito
+ ;*             Nagoya Municipal Industrial Research Institute, JAPAN
+ ;*  Copyright (C) 2003-2004 by Ryosuke Takeuchi
+ ;*               Platform Development Center RICOH COMPANY,LTD. JAPAN
+ ;*  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+ ;* 
+ ;*  上記著作権者は，Free Software Foundation によって公表されている 
+ ;*  GNU General Public License の Version 2 に記述されている条件か，以
+ ;*  下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェア（本ソフトウェ
+ ;*  アを改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
+ ;*  利用と呼ぶ）することを無償で許諾する．
+ ;*  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+ ;*      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+ ;*      スコード中に含まれていること．
+ ;*  (2) 本ソフトウェアを再利用可能なバイナリコード（リロケータブルオブ
+ ;*      ジェクトファイルやライブラリなど）の形で利用する場合には，利用
+ ;*      に伴うドキュメント（利用者マニュアルなど）に，上記の著作権表示，
+ ;*      この利用条件および下記の無保証規定を掲載すること．
+ ;*  (3) 本ソフトウェアを再利用不可能なバイナリコードの形または機器に組
+ ;*      み込んだ形で利用する場合には，次のいずれかの条件を満たすこと．
+ ;*    (a) 利用に伴うドキュメント（利用者マニュアルなど）に，上記の著作
+ ;*        権表示，この利用条件および下記の無保証規定を掲載すること．
+ ;*    (b) 利用の形態を，別に定める方法によって，上記著作権者に報告する
+ ;*        こと．
+ ;*  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+ ;*      害からも，上記著作権者を免責すること．
+ ;* 
+ ;*  本ソフトウェアは，無保証で提供されているものである．上記著作権者は，
+ ;*  本ソフトウェアに関して，その適用可能性も含めて，いかなる保証も行わ
+ ;*  ない．また，本ソフトウェアの利用により直接的または間接的に生じたい
+ ;*  かなる損害に関しても，その責任を負わない．
+ 
+ .text
+ .balign 4
+ 	
+ 
+ ;
+ ;  レジスタ定義
+ ;
+ .equ SCKCR,	0x080020
+ 
+ ;
+ ;  定義値
+ ;
+ .equ CLOCK_VAL,	0x00020100
+ 
+ 
+ .global	_hardware_init_hook
+ .global	_software_init_hook
+ 
+ 
+ _hardware_init_hook:
+ 	;
+ 	;  動作モード設定
+ 	;
+ 	;  動作モードはボード上の端子によって決定されるため,
+ 	;  ここでは特別設定しない.
+ 	;  ただし, リトルエンディアン/シングルチップモード
+ 	;  であることを前提とする.
+ 	;
+ 	;  またリセット後, 内蔵ROM：有効, 内蔵RAM：有効, 外部バス：無効
+ 	;  である.
+ 	;
+ 
+ 	;
+ 	;  モジュールストップ
+ 	;
+ 	;  リセット後, 動作している内蔵周辺モジュールはDMAC, DTC,
+ 	;  内蔵RAMのみである.
+ 	;  それ以外の内蔵周辺モジュールに関しては使用する側で
+ 	;  設定すること.
+ 	;
+ 
+ 	rts
+ 
+ 
+ _software_init_hook:
+ 	;
+ 	;  本コンパイラではweak definitionの機能が無いため,
+ 	;  特に必要な処理はないが, 必ず呼び出すこととする.
+ 	;
+ 	rts
+ 
+ 
+ .end
+ 
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_syssvc.h ASPs/asp/target/rx72n_gcc/target_syssvc.h
*** 1.9.1/asp/target/rx72n_gcc/target_syssvc.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_syssvc.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,120 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2003-2004 by Naoki Saito
+  *             Nagoya Municipal Industrial Research Institute, JAPAN
+  *  Copyright (C) 2003-2004 by Platform Development Center
+  *                                          RICOH COMPANY,LTD. JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		システムサービスのターゲット依存部（RX72N用）
+  *
+  *  システムサービスのターゲット依存部のインクルードファイル．このファ
+  *  イルの内容は，コンポーネント記述ファイルに記述され，このファイルは
+  *  無くなる見込み．
+  */
+ 
+ #ifndef TOPPERS_TARGET_SYSSVC_H
+ #define TOPPERS_TARGET_SYSSVC_H
+ 
+ 
+ /*
+  *  プロセッサ依存の定義
+  */
+ #include "prc_syssvc.h"
+ 
+ 
+ /*
+  *  トレースログに関する設定
+  */
+ #ifdef TOPPERS_ENABLE_TRACE
+ #include "logtrace/trace_config.h"
+ #endif /* TOPPERS_ENABLE_TRACE */
+ 
+ 
+ /*
+  *  ボード依存情報の読み込み
+  */
+ #include "target_board.h"
+ 
+ 
+ /*
+  *  起動メッセージのターゲットシステム名
+  */
+ #define	TARGET_NAME	"RX72N"
+ 
+ 
+ /*
+  *  システムログの低レベル出力のための文字出力
+  *
+  *  ターゲット依存の方法で，文字cを表示/出力/保存する．
+  */
+ extern void	target_fput_log( char c );
+ 
+ 
+ /*
+  *  起動メッセージにターゲット依存部の著作権表示を
+  *  追加するためのマクロ．
+  */
+ #ifdef PRC_COPYRIGHT
+ #define	TARGET_COPYRIGHT	PRC_COPYRIGHT
+ #endif /* PRC_COPYRIGHT */
+ 
+ 
+ /*
+  *  シリアルポート数の定義
+  */
+ #define	TNUM_PORT			UINT_C( 1 )
+ 
+ 
+ /*
+  *  使用するシリアルポートID
+  */
+ #define	SIO_PORTID			UINT_C( 1 )
+ 
+ #define LOGTASK_PORTID		SIO_PORTID
+ 
+ 
+ /*
+  *  システムログタスク関連の定数の定義
+  *
+  *  デフォルト値の通り．
+  */
+ 
+ #endif /* TOPPERS_TARGET_SYSSVC_H */
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_test.h ASPs/asp/target/rx72n_gcc/target_test.h
*** 1.9.1/asp/target/rx72n_gcc/target_test.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_test.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,63 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2003-2004 by Naoki Saito
+  *             Nagoya Municipal Industrial Research Institute, JAPAN
+  *  Copyright (C) 2003-2004 by Platform Development Center
+  *                                          RICOH COMPANY,LTD. JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		テストプログラムのターゲット依存定義（Starter Kit用）
+  */
+ 
+ #ifndef TOPPERS_TARGET_TEST_H
+ #define TOPPERS_TARGET_TEST_H
+ 
+ /*
+  *  プロセッサで共通な定義
+  */
+ #include "prc_test.h"
+ 
+ /*
+  *  タスクで使用するシリアルポートID
+  */
+ #define	TASK_PORTID		( 1 )
+ 
+ 
+ #endif /* TOPPERS_TARGET_TEST_H */
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_timer.c ASPs/asp/target/rx72n_gcc/target_timer.c
*** 1.9.1/asp/target/rx72n_gcc/target_timer.c	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_timer.c	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,164 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2003-2004 by Naoki Saito
+  *             Nagoya Municipal Industrial Research Institute, JAPAN
+  *  Copyright (C) 2003-2004 by Platform Development Center
+  *                                          RICOH COMPANY,LTD. JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2016- by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		タイマドライバ（RX63n 用）
+  */
+ 
+ #include "kernel_impl.h"
+ #include "time_event.h"
+ #include <sil.h>
+ #include "target_timer.h"
+ 
+ /*
+  *  タイマの初期化処理
+  */
+ void
+ target_timer_initialize(intptr_t exinf)
+ {
+   //unlock register access 
+   sil_wrh_mem((void *)(SYSTEM_PRCR_ADDR), SYSTEM_PRKEY | SYSTEM_PRC1);
+   /*
+    * モジュールストップ機能の設定(CMT)
+    */
+   *SYSTEM_MSTPCRA_ADDR &= ~(SYSTEM_MSTPCRA_MSTPA15_CMT_U0); /* CMT0_UNIT 0 */
+   //lock register access
+   sil_wrh_mem((void *)(SYSTEM_PRCR_ADDR), SYSTEM_PRKEY );
+ 
+   /* 
+    * タイマ停止 
+    */
+   *CMT_CMSTR0_ADDR &= ~CMT_CMSTR0_STR0_BIT;
+ 
+   /*
+    * カウントアップに用いられるクロック設定
+    * PCLKB/8を選択
+    */
+  // *CMT0_CMCR_ADDR = CMT_PCLK_DIV_8;
+   *CMT0_CMCR_ADDR = (0x0001U);
+   /* 
+    * コンペアマッチタイマカウンタ設定
+    */
+   *CMT0_CMCNT_ADDR = 0U;
+ 
+   /* 
+    * コンペアマッチタイマ周期設定
+    */
+   /* CMT0 Toppers Setting 10msec  */
+   *CMT0_CMCOR_ADDR = RX72N_CMCOR ;// CMCOR_PERIOD ;// 18749;//CMCOR_PERIOD;
+ 
+   /*
+    *  タイマ動作開始前の割込み要求をクリア
+    */
+ 	x_clear_int(INTNO_TIMER);
+ 
+   /* 
+    * コンペアマッチタイマ割り込みを許可
+    */
+    *CMT0_CMCR_ADDR |= CMT0_CMCR_CMIE_BIT;
+ 
+   /* 
+    * タイマ動作開始
+    */
+   *CMT_CMSTR0_ADDR |= CMT_CMSTR0_STR0_BIT;
+ }
+ void
+ target_timer_cmt1_initialize(intptr_t exinf)
+ {
+ 	//to BSP initialize
+ }
+ void
+ target_timer_cmt2_initialize(intptr_t exinf)
+ {
+ 	//to BSP initialize
+ }
+ /*
+  *  タイマの停止処理
+  */
+ void
+ target_timer_terminate(intptr_t exinf)
+ {
+ 	/* 
+ 	 * タイマ停止 
+ 	 */
+ 	*CMT_CMSTR0_ADDR &= ~CMT_CMSTR0_STR0_BIT;
+ }
+ void
+ target_timer_cmt1_terminate(intptr_t exinf)
+ {
+  // renesas bsp
+ }
+ void
+ target_timer_cmt2_terminate(intptr_t exinf)
+ {
+ // renesas bsp
+ }
+ 
+ /*
+  *  タイマ割込みハンドラ
+  */
+ void target_timer_handler(void)
+ {
+ 	i_begin_int(INTNO_TIMER);
+ 	
+ 	signal_time();				/* タイムティックの供給 */
+ 	i_end_int(INTNO_TIMER);
+ }
+ void target_timer_cmt1_handler(void)
+ {
+ 	i_begin_int(INHNO_TIMER_CMT1);
+ 
+ 	signal_time();				/* タイムティックの供給 */
+ 	timer_int_Wrapper();
+ 	i_end_int(INHNO_TIMER_CMT1);
+ }
+ void target_timer_cmt2_handler(void)
+ {
+ 	i_begin_int(INHNO_TIMER_CMT2);
+ 
+ 	signal_time();				/* タイムティックの供給 */
+ 	timer_cm2_int_Wrapper();
+ 	i_end_int(INHNO_TIMER_CMT2);
+ }
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_timer.cfg ASPs/asp/target/rx72n_gcc/target_timer.cfg
*** 1.9.1/asp/target/rx72n_gcc/target_timer.cfg	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_timer.cfg	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,19 ----
+ /*
+  *  タイマドライバ（RX72N用）のコンフィギュレーションファイル
+  */
+ 
+ #include "target_timer.h"
+ ATT_INI({ TA_NULL, 0, target_timer_initialize });
+ ATT_TER({ TA_NULL, 0, target_timer_terminate });
+ DEF_INH(INHNO_TIMER, { TA_NULL, target_timer_handler });
+ CFG_INT(INTNO_TIMER, { INTATR_TIMER, INTPRI_TIMER });
+ 
+ ATT_INI({ TA_NULL, 0, target_timer_cmt1_initialize });
+ ATT_TER({ TA_NULL, 0, target_timer_cmt1_terminate });
+ DEF_INH(INHNO_TIMER_CMT1, { TA_NULL, target_timer_cmt1_handler });
+ CFG_INT(INTNO_TIMER_CMT1, { INTATR_TIMER, INTPRI_TIMER });
+ 
+ ATT_INI({ TA_NULL, 0, target_timer_cmt2_initialize });
+ ATT_TER({ TA_NULL, 0, target_timer_cmt2_terminate });
+ DEF_INH(INHNO_TIMER_CMT2, { TA_NULL, target_timer_cmt2_handler });
+ CFG_INT(INTNO_TIMER_CMT2, { INTATR_TIMER, INTPRI_TIMER });
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_timer.h ASPs/asp/target/rx72n_gcc/target_timer.h
*** 1.9.1/asp/target/rx72n_gcc/target_timer.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_timer.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,199 ----
+ /*
+  *  TOPPERS/ASP Kernel
+  *      Toyohashi Open Platform for Embedded Real-Time Systems/
+  *      Advanced Standard Profile Kernel
+  * 
+  *  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
+  *                              Toyohashi Univ. of Technology, JAPAN
+  *  Copyright (C) 2003-2004 by Naoki Saito
+  *             Nagoya Municipal Industrial Research Institute, JAPAN
+  *  Copyright (C) 2003-2004 by Platform Development Center
+  *                                          RICOH COMPANY,LTD. JAPAN
+  *  Copyright (C) 2008-2010 by Witz Corporation, JAPAN
+  *  Copyright (C) 2016 by Hisashi Hata, JAPAN
+  * 
+  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
+  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
+  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
+  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
+  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
+  *      スコード中に含まれていること．
+  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
+  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
+  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
+  *      の無保証規定を掲載すること．
+  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
+  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
+  *      と．
+  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
+  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
+  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
+  *        報告すること．
+  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
+  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
+  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
+  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
+  *      免責すること．
+  * 
+  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
+  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
+  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
+  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
+  *  の責任を負わない．
+  * 
+  */
+ 
+ /*
+  *		タイマドライバ（RX72n 用）
+  */
+  
+ #ifndef TOPPERS_TARGET_TIMER_H
+ #define TOPPERS_TARGET_TIMER_H
+ 
+ #include <sil.h>
+ #include "target_board.h"
+ #include "target_syssvc.h"
+ 
+ /*
+  *  タイマ割込みハンドラ登録のための定数
+  */
+ #define INHNO_TIMER		INT_CMT0_CMI0		/* 割込みハンドラ番号 */
+ #define INTNO_TIMER		INT_CMT0_CMI0		/* 割込み番号 */
+ #define INHNO_TIMER_CMT1		INT_CMT1_CMI1		/* 割込みハンドラ番号 */
+ #define INTNO_TIMER_CMT1		INT_CMT1_CMI1		/* 割込み番号 */
+ #define INHNO_TIMER_CMT2		INT_CMT2_CMI2		/* 割込みハンドラ番号 */
+ #define INTNO_TIMER_CMT2		INT_CMT2_CMI2		/* 割込み番号 */
+ 
+ #define INTPRI_TIMER	-5					/* 割込み優先度 */
+ #define INTATR_TIMER	TA_ENAINT | TA_EDGE	/* 割込み属性 */
+ 
+ #ifndef TOPPERS_MACRO_ONLY
+ 
+ /*
+  *  タイマ値の内部表現の型
+  */
+ typedef uint16_t	CLOCK;
+ 
+ /*
+  *  タイマ値の内部表現とミリ秒単位との変換
+  *
+  *  1msのタイマー割り込みを使用するのでそのクロックを定義する．
+  */
+ #define TIMER_CLOCK				(6000U)		/* 6.000MHz */
+ #define TO_CLOCK(nume, deno)	((CLOCK)(TIMER_CLOCK * (nume) / (deno)))
+ #define	TO_USEC(clock)			((SYSUTM)((clock) * 1000U / TIMER_CLOCK))
+ 
+ #define RX72N_PCLK 				(60000000) // Renesas BSP Setting PCLK
+ #define RX72N_PCLK_CKS 			(32) // Renesas BSP Setting PCLK CKS
+ #define RX72N_PCLK_DIV 			(100) // divide value (10msec)
+ 
+ #define RX72N_CMCOR			    ((unsigned short)(RX72N_PCLK / RX72N_PCLK_CKS / RX72N_PCLK_DIV) - 1)
+ /*
+  *  設定できる最大のタイマ周期（単位は内部表現）
+  */
+ #define	MAX_CLOCK	((CLOCK) 0xFFFFU)
+ 
+ /*
+  *  性能評価用システム時刻を取り出す際の処理時間の見積り値（単位は内部表現）
+  */
+ #define	GET_TOLERANCE	(100U)	/* 処理遅れの見積り値（単位は内部表現）*/
+ #define	BEFORE_IREQ(clock) \
+ 		((clock) >= (TO_CLOCK(TIC_NUME, TIC_DENO) - GET_TOLERANCE))
+ 
+ /*
+  *  コンペアマッチタイマコントロールレジスタの設定値
+  */
+ /*
+  *  クロック選択ビット
+  *
+  *  bit7は予約領域であり, 書込みは1固定
+  */
+ #define CMT_PCLK_DIV_8			(0x0080U)
+ #define CMT_PCLK_DIV_32			(0x0081U)
+ #define CMT_PCLK_DIV_128		(0x0082U)
+ #define CMT_PCLK_DIV_512		(0x0083U)
+ 
+ /*
+  *  コンペアマッチタイマコンスタントレジスタ（CMCOR）
+  *
+  *  コンペアマッチ周期を1msとする．
+  *  周辺モジュールクロック（PCLK）48MHzを8分周するので，
+  *  1周期あたり166.6nsecとなり，6000周期で1ms（タイムティックの周期）とする．
+  */
+ #define CMCOR_PERIOD			(6000U)
+ 
+ /*
+  * コンペアマッチタイマ割り込み要求先設定レジスタi（ISELRi）（i= 割り込みベクタ番号）
+  */
+ #define ICU_ISEL_CPU			(0x00U)
+ 
+ 
+ /*
+  *	ターゲットシステム依存モジュール（RX72N用 Timer (CMT0) Interrupt Wrapper）
+  */
+ 
+ extern void timer_int_Wrapper();
+ 
+ 
+ /*
+  *  タイマの起動処理
+  *
+  *  タイマを初期化し，周期的なタイマ割込み要求を発生させる．
+  */
+ extern void	target_timer_initialize(intptr_t exinf);
+ extern void	target_timer_cmt1_initialize(intptr_t exinf);
+ extern void	target_timer_cmt2_initialize(intptr_t exinf);
+ 
+ /*
+  *  タイマの停止処理
+  *
+  *  タイマの動作を停止させる．
+  */
+ extern void	target_timer_terminate(intptr_t exinf);
+ extern void	target_timer_cmt1_terminate(intptr_t exinf);
+ extern void	target_timer_cmt2_terminate(intptr_t exinf);
+ 
+ /*
+  *  タイマレジスタ値の読み出し
+  */
+ Inline uint16_t rx72n_cmt_getcount(void)
+ {
+ 	return *CMT0_CMCNT_ADDR;
+ }
+ 
+ /*
+  *  タイマレジスタ値の書き込み
+  */
+ Inline void rx72n_cmt_setcount(uint16_t count)
+ {
+ 	*CMT0_CMCNT_ADDR = count;
+ }
+ 
+ /*
+  *  タイマの現在値の読出し
+  */
+ Inline CLOCK
+ target_timer_get_current(void)
+ {
+ 	/* アップカウントのためタイマレジスタ値をそのまま返す	*/
+ 	return (rx72n_cmt_getcount());
+ }
+ 
+ /*
+  *  タイマ割込み要求のチェック
+  */
+ Inline bool_t
+ target_timer_probe_int(void)
+ {
+ 	return(x_probe_int(INTNO_TIMER));
+ }
+ 
+ /*
+  *  タイマ割込みハンドラ
+  */
+ extern void	target_timer_handler(void);
+ extern void	target_timer_cm1_handler(void);
+ extern void	target_timer_cm2_handler(void);
+ 
+ #endif /* TOPPERS_MACRO_ONLY */
+ #endif /* TOPPERS_TARGET_TIMER_H */
diff -cr --new-file 1.9.1/asp/target/rx72n_gcc/target_unrename.h ASPs/asp/target/rx72n_gcc/target_unrename.h
*** 1.9.1/asp/target/rx72n_gcc/target_unrename.h	Thu Jan  1 09:00:00 1970
--- ASPs/asp/target/rx72n_gcc/target_unrename.h	Fri Dec  9 13:54:11 2022
***************
*** 0 ****
--- 1,46 ----
+ /* This file is generated from target_rename.def by genrename. */
+ 
+ #ifndef TOPPERS_TARGET_RENAME_H
+ #define TOPPERS_TARGET_RENAME_H
+ 
+ /*
+  *  target_config.c
+  */
+ #undef target_initialize
+ #undef target_exit
+ 
+ /*
+  *  trace_config.c
+  */
+ #undef log_dsp_enter
+ #undef log_dsp_leave
+ #undef log_inh_enter
+ #undef log_inh_leave
+ #undef log_exc_enter
+ #undef log_exc_leave
+ 
+ 
+ #ifdef TOPPERS_LABEL_ASM
+ 
+ /*
+  *  target_config.c
+  */
+ #undef _target_initialize
+ #undef _target_exit
+ 
+ /*
+  *  trace_config.c
+  */
+ #undef _log_dsp_enter
+ #undef _log_dsp_leave
+ #undef _log_inh_enter
+ #undef _log_inh_leave
+ #undef _log_exc_enter
+ #undef _log_exc_leave
+ 
+ 
+ #endif /* TOPPERS_LABEL_ASM */
+ 
+ #include "prc_unrename.h"
+ 
+ #endif /* TOPPERS_TARGET_RENAME_H */
diff -cr --new-file 1.9.1/asp/test/bit_kernel.c ASPs/asp/test/bit_kernel.c
*** 1.9.1/asp/test/bit_kernel.c	Sun Jun 26 10:21:12 2011
--- ASPs/asp/test/bit_kernel.c	Fri Dec  9 13:54:11 2022
***************
*** 6,45 ****
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: bit_kernel.c 2128 2011-06-26 01:21:05Z ertl-hiro $
   */
  
  /*
!  *		ͥ
   */
  
  #include "kernel/kernel_impl.h"
--- 6,45 ----
   *  Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: bit_kernel.c 2128 2011-06-26 01:21:05Z ertl-hiro $
   */
  
  /*
!  *		カーネルの整合性検査
   */
  
  #include "kernel/kernel_impl.h"
***************
*** 54,65 ****
  #include "kernel/time_event.h"
  
  /*
!  *   顼ɤ
   */
  #define E_SYS_LINENO	ERCD(E_SYS, -(__LINE__))
  
  /*
!  *  ֥åΥɥ쥹Υå
   */
  #define VALID_TCB(p_tcb) \
  		((((char *) p_tcb) - ((char *) tcb_table)) % sizeof(TCB) == 0 \
--- 54,65 ----
  #include "kernel/time_event.h"
  
  /*
!  *   エラーコードの定義
   */
  #define E_SYS_LINENO	ERCD(E_SYS, -(__LINE__))
  
  /*
!  *  管理ブロックのアドレスの正当性のチェック
   */
  #define VALID_TCB(p_tcb) \
  		((((char *) p_tcb) - ((char *) tcb_table)) % sizeof(TCB) == 0 \
***************
*** 90,100 ****
  			&& TMIN_MPFID <= MPFID(p_mpfcb) && MPFID(p_mpfcb) <= tmax_mpfid)
  
  /*
!  *  塼ΥåΤδؿ
   *
!  *  p_queuep_entryޤޤƤ뤫Ĵ٤롥ޤޤƤtrueޤ
!  *  Ƥʤˤfalse֤֥󥯤ξˤ⡤
!  *  false֤
   */
  static bool_t
  in_queue(QUEUE *p_queue, QUEUE *p_entry)
--- 90,100 ----
  			&& TMIN_MPFID <= MPFID(p_mpfcb) && MPFID(p_mpfcb) <= tmax_mpfid)
  
  /*
!  *  キューのチェックのための関数
   *
!  *  p_queueにp_entryが含まれているかを調べる．含まれていればtrue，含ま
!  *  れていない場合にはfalseを返す．ダブルリンクの不整合の場合にも，
!  *  falseを返す．
   */
  static bool_t
  in_queue(QUEUE *p_queue, QUEUE *p_entry)
***************
*** 103,121 ****
  
  	p_current = p_queue->p_next;
  	if (p_current->p_prev != p_queue) {
! 		return(false);					/* ֥󥯤 */
  	}
  	while (p_current != p_queue) {
  		if (p_current == p_entry) {
! 			return(true);				/* p_entryޤޤƤ */
  		}
  
  		/*
! 		 *  塼μǤ˿ʤ
  		 */
  		p_next = p_current->p_next;
  		if (p_next->p_prev != p_current) {
! 			return(false);				 /* ֥󥯤 */
  		}
  		p_current = p_next;
  	}
--- 103,121 ----
  
  	p_current = p_queue->p_next;
  	if (p_current->p_prev != p_queue) {
! 		return(false);					/* ダブルリンクの不整合 */
  	}
  	while (p_current != p_queue) {
  		if (p_current == p_entry) {
! 			return(true);				/* p_entryが含まれていた */
  		}
  
  		/*
! 		 *  キューの次の要素に進む
  		 */
  		p_next = p_current->p_next;
  		if (p_next->p_prev != p_current) {
! 			return(false);				 /* ダブルリンクの不整合 */
  		}
  		p_current = p_next;
  	}
***************
*** 123,129 ****
  }
  
  /*
!  *  åؤƤ뤫θ
   */
  static bool_t
  on_stack(void *addr, const TINIB *p_tinib)
--- 123,129 ----
  }
  
  /*
!  *  スタック上を指しているかの検査
   */
  static bool_t
  on_stack(void *addr, const TINIB *p_tinib)
***************
*** 136,142 ****
  }
  
  /*
!  *  
   */
  static ER
  bit_task(ID tskid)
--- 136,142 ----
  }
  
  /*
!  *  タスク毎の整合性検査
   */
  static ER
  bit_task(ID tskid)
***************
*** 162,175 ****
  	pri = p_tcb->priority;
  
  	/*
! 	 *  ֥åؤΥݥ󥿤θ
  	 */
  	if (p_tinib != &(tinib_table[INDEX_TSK(tskid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  tstatθ
  	 */
  	switch (tstat & (TS_RUNNABLE | TS_WAITING | TS_SUSPENDED)) {
  	case TS_DORMANT:
--- 162,175 ----
  	pri = p_tcb->priority;
  
  	/*
! 	 *  初期化ブロックへのポインタの検査
  	 */
  	if (p_tinib != &(tinib_table[INDEX_TSK(tskid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  tstatの検査
  	 */
  	switch (tstat & (TS_RUNNABLE | TS_WAITING | TS_SUSPENDED)) {
  	case TS_DORMANT:
***************
*** 202,229 ****
  	}
  
  	/*
! 	 *  actqueθ
  	 */
  	if (TSTAT_DORMANT(tstat) && p_tcb->actque) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  ͥ٤θ
  	 */
  	if (pri >= TNUM_TPRI) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  texptnθ
  	 */
  	if (p_tcb->p_tinib->texrtn == NULL && p_tcb->texptn != 0U) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  ٻ߾֤ˤå
  	 */
  	if (TSTAT_DORMANT(tstat)) {
  		if (!(pri == p_tinib->ipriority)
--- 202,229 ----
  	}
  
  	/*
! 	 *  actqueの検査
  	 */
  	if (TSTAT_DORMANT(tstat) && p_tcb->actque) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  タスク優先度の検査
  	 */
  	if (pri >= TNUM_TPRI) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  texptnの検査
  	 */
  	if (p_tcb->p_tinib->texrtn == NULL && p_tcb->texptn != 0U) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  休止状態におけるチェック
  	 */
  	if (TSTAT_DORMANT(tstat)) {
  		if (!(pri == p_tinib->ipriority)
***************
*** 235,241 ****
  	}
  
  	/*
! 	 *  ¹ԤǤ֤ˤå
  	 */
  	if (TSTAT_RUNNABLE(tstat)) {
  		if (!in_queue(&ready_queue[pri], &(p_tcb->task_queue))) {
--- 235,241 ----
  	}
  
  	/*
! 	 *  実行できる状態におけるチェック
  	 */
  	if (TSTAT_RUNNABLE(tstat)) {
  		if (!in_queue(&ready_queue[pri], &(p_tcb->task_queue))) {
***************
*** 244,250 ****
  	}
  
  	/*
! 	 *  Ԥ֤ˤå
  	 */
  	if (TSTAT_WAITING(tstat)) {
  		if (!on_stack(p_tcb->p_winfo, p_tinib)) {
--- 244,250 ----
  	}
  
  	/*
! 	 *  待ち状態におけるチェック
  	 */
  	if (TSTAT_WAITING(tstat)) {
  		if (!on_stack(p_tcb->p_winfo, p_tinib)) {
***************
*** 256,262 ****
  				return(E_SYS_LINENO);
  			}
  			/*
! 			 *  (*p_tmevtb)θ̤
  			 */
  		}
  
--- 256,262 ----
  				return(E_SYS_LINENO);
  			}
  			/*
! 			 *  (*p_tmevtb)の検査（未完成）
  			 */
  		}
  
***************
*** 356,366 ****
  	}
  
  	/*
! 	 *  tskctxbθ
  	 */
  	if (!TSTAT_DORMANT(tstat) && p_tcb != p_runtsk) {
  		/*
! 		 *  åȰ¸θ
  		 */
  #if 0
  		if (bit_tskctxb(&(p_tcb->tskctxb))) {
--- 356,366 ----
  	}
  
  	/*
! 	 *  tskctxbの検査
  	 */
  	if (!TSTAT_DORMANT(tstat) && p_tcb != p_runtsk) {
  		/*
! 		 *  ターゲット依存の検査
  		 */
  #if 0
  		if (bit_tskctxb(&(p_tcb->tskctxb))) {
***************
*** 372,378 ****
  }
  
  /*
!  *  ޥե
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
--- 372,378 ----
  }
  
  /*
!  *  セマフォ毎の整合性検査
   */
  #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
  #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
***************
*** 394,414 ****
  	semcnt = p_semcb->semcnt;
  
  	/*
! 	 *  ֥åؤΥݥ󥿤θ
  	 */
  	if (p_seminib != &(seminib_table[INDEX_SEM(semid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  semcntθ
  	 */
  	if (semcnt > p_seminib->maxsem) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  wait_queueθ
  	 */
  	if (semcnt == 0) {
  		p_queue = p_semcb->wait_queue.p_next;
--- 394,414 ----
  	semcnt = p_semcb->semcnt;
  
  	/*
! 	 *  初期化ブロックへのポインタの検査
  	 */
  	if (p_seminib != &(seminib_table[INDEX_SEM(semid)])) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  semcntの検査
  	 */
  	if (semcnt > p_seminib->maxsem) {
  		return(E_SYS_LINENO);
  	}
  
  	/*
! 	 *  wait_queueの検査
  	 */
  	if (semcnt == 0) {
  		p_queue = p_semcb->wait_queue.p_next;
***************
*** 435,441 ****
  }
  
  /*
!  *  롼
   */
  ER
  bit_kernel(void)
--- 435,441 ----
  }
  
  /*
!  *  整合性検査ルーチン本体
   */
  ER
  bit_kernel(void)
***************
*** 445,451 ****
  	ER		ercd;
  
  	/*
! 	 *  θ
  	 */
  	for (tskid = TMIN_TSKID; tskid <= tmax_tskid; tskid++) {
  		ercd = bit_task(tskid);
--- 445,451 ----
  	ER		ercd;
  
  	/*
! 	 *  タスク毎の検査
  	 */
  	for (tskid = TMIN_TSKID; tskid <= tmax_tskid; tskid++) {
  		ercd = bit_task(tskid);
***************
*** 455,461 ****
  	}
  
  	/*
! 	 *  ޥեθ
  	 */
  	for (semid = TMIN_SEMID; semid <= tmax_semid; semid++) {
  		ercd = bit_semaphore(semid);
--- 455,461 ----
  	}
  
  	/*
! 	 *  セマフォ毎の検査
  	 */
  	for (semid = TMIN_SEMID; semid <= tmax_semid; semid++) {
  		ercd = bit_semaphore(semid);
diff -cr --new-file 1.9.1/asp/test/perf0.c ASPs/asp/test/perf0.c
*** 1.9.1/asp/test/perf0.c	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf0.c	Fri Dec  9 13:54:11 2022
***************
*** 5,46 ****
   *  Copyright (C) 2006-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf0.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		ͥǽɾץ(0)
   *
!  *  ַ¬ΥХإåɤ¬뤿Υץࡥ
   */
  
  #include <kernel.h>
--- 5,46 ----
   *  Copyright (C) 2006-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf0.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(0)
   *
!  *  時間計測のオーバヘッドを計測するためのプログラム．
   */
  
  #include <kernel.h>
***************
*** 51,68 ****
  #include "perf0.h"
  
  /*
!  *  ¬ȼ¹ԻʬۤϿ
   */
! #define NO_MEASURE	10000U			/* ¬ */
! #define MAX_TIME	1000U			/* ¹ԻʬۤϿ */
  
  /*
!  *  ¹ԻʬۤϿΰ
   */
  static uint_t	histarea1[MAX_TIME + 1];
  
  /*
!  *  ᥤ󥿥
   */
  void main_task(intptr_t exinf)
  {
--- 51,68 ----
  #include "perf0.h"
  
  /*
!  *  計測回数と実行時間分布を記録する最大時間
   */
! #define NO_MEASURE	10000U			/* 計測回数 */
! #define MAX_TIME	1000U			/* 実行時間分布を記録する最大時間 */
  
  /*
!  *  実行時間分布を記録するメモリ領域
   */
  static uint_t	histarea1[MAX_TIME + 1];
  
  /*
!  *  メインタスク
   */
  void main_task(intptr_t exinf)
  {
diff -cr --new-file 1.9.1/asp/test/perf0.cfg ASPs/asp/test/perf0.cfg
*** 1.9.1/asp/test/perf0.cfg	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf0.cfg	Fri Dec  9 13:54:11 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ͥǽɾץ(0)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  カーネル性能評価プログラム(0)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/perf0.h ASPs/asp/test/perf0.h
*** 1.9.1/asp/test/perf0.h	Sat Apr 12 10:30:55 2008
--- ASPs/asp/test/perf0.h	Fri Dec  9 13:54:11 2022
***************
*** 5,64 ****
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf0.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /*
!  *		ͥǽɾץ(0)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
! #define MAIN_PRIORITY	11		/* ᥤ󥿥ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  extern void	main_task(intptr_t exinf);
--- 5,64 ----
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf0.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(0)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
! #define MAIN_PRIORITY	11		/* メインタスクの優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  extern void	main_task(intptr_t exinf);
diff -cr --new-file 1.9.1/asp/test/perf1.c ASPs/asp/test/perf1.c
*** 1.9.1/asp/test/perf1.c	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf1.c	Fri Dec  9 13:54:11 2022
***************
*** 5,46 ****
   *  Copyright (C) 2006-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf1.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		ͥǽɾץ(1)
   *
!  *  slp_tskwup_tskˤ륿ڴ֤¬뤿Υץࡥ
   */
  
  #include <kernel.h>
--- 5,46 ----
   *  Copyright (C) 2006-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf1.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(1)
   *
!  *  slp_tsk，wup_tskによるタスク切換え時間を計測するためのプログラム．
   */
  
  #include <kernel.h>
***************
*** 51,69 ****
  #include "perf1.h"
  
  /*
!  *  ¬ȼ¹ԻʬۤϿ
   */
! #define NO_MEASURE	10000U			/* ¬ */
! #define MAX_TIME	1000U			/* ¹ԻʬۤϿ */
  
  /*
!  *  ¹ԻʬۤϿΰ
   */
  static uint_t	histarea1[MAX_TIME + 1];
  static uint_t	histarea2[MAX_TIME + 1];
  
  /*
!  *  ¬1ʹͥ١
   */
  void task1(intptr_t exinf)
  {
--- 51,69 ----
  #include "perf1.h"
  
  /*
!  *  計測回数と実行時間分布を記録する最大時間
   */
! #define NO_MEASURE	10000U			/* 計測回数 */
! #define MAX_TIME	1000U			/* 実行時間分布を記録する最大時間 */
  
  /*
!  *  実行時間分布を記録するメモリ領域
   */
  static uint_t	histarea1[MAX_TIME + 1];
  static uint_t	histarea2[MAX_TIME + 1];
  
  /*
!  *  計測タスク1（高優先度）
   */
  void task1(intptr_t exinf)
  {
***************
*** 81,87 ****
  }
  
  /*
!  *  ¬2ͥ١
   */
  void task2(intptr_t exinf)
  {
--- 81,87 ----
  }
  
  /*
!  *  計測タスク2（中優先度）
   */
  void task2(intptr_t exinf)
  {
***************
*** 96,102 ****
  }
  
  /*
!  *  ᥤ󥿥ͥ١
   */
  void main_task(intptr_t exinf)
  {
--- 96,102 ----
  }
  
  /*
!  *  メインタスク（低優先度）
   */
  void main_task(intptr_t exinf)
  {
diff -cr --new-file 1.9.1/asp/test/perf1.cfg ASPs/asp/test/perf1.cfg
*** 1.9.1/asp/test/perf1.cfg	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf1.cfg	Fri Dec  9 13:54:11 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ͥǽɾץ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  カーネル性能評価プログラム(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/perf1.h ASPs/asp/test/perf1.h
*** 1.9.1/asp/test/perf1.h	Sat Apr 12 10:30:55 2008
--- ASPs/asp/test/perf1.h	Fri Dec  9 13:54:11 2022
***************
*** 5,67 ****
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf1.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /*
!  *		ͥǽɾץ(1)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
! #define TASK1_PRIORITY	9		/* ¬1ͥ */
! #define TASK2_PRIORITY	10		/* ¬2ͥ */
! #define MAIN_PRIORITY	11		/* ᥤ󥿥ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  extern void	task1(intptr_t exinf);
  extern void	task2(intptr_t exinf);
--- 5,67 ----
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf1.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(1)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
! #define TASK1_PRIORITY	9		/* 計測タスク1の優先度 */
! #define TASK2_PRIORITY	10		/* 計測タスク2の優先度 */
! #define MAIN_PRIORITY	11		/* メインタスクの優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  extern void	task1(intptr_t exinf);
  extern void	task2(intptr_t exinf);
diff -cr --new-file 1.9.1/asp/test/perf2.c ASPs/asp/test/perf2.c
*** 1.9.1/asp/test/perf2.c	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf2.c	Fri Dec  9 13:54:11 2022
***************
*** 5,47 ****
   *  Copyright (C) 2007-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf2.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		ͥǽɾץ(2)
   *
!  *  ͥ٥ǡ塼ѤƤǡοˤꡤsnd_pdqν
!  *  ֤ɤΤ褦Ѳ뤫¬뤿Υץࡥ
   */
  
  #include <kernel.h>
--- 5,47 ----
   *  Copyright (C) 2007-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf2.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(2)
   *
!  *  優先度データキューに蓄積されているデータの数により，snd_pdqの処理時
!  *  間がどのように変化するかを計測するためのプログラム．
   */
  
  #include <kernel.h>
***************
*** 52,69 ****
  #include "perf2.h"
  
  /*
!  *  ¬ȼ¹ԻʬۤϿ
   */
! #define NO_MEASURE	10000U			/* ¬ */
! #define MAX_TIME	1000U			/* ¹ԻʬۤϿ */
  
  /*
!  *  ¹ԻʬۤϿΰ
   */
  static uint_t	histarea1[MAX_TIME + 1];
  
  /*
!  *  ¬롼
   */
  void
  perf_eval(uint_t n)
--- 52,69 ----
  #include "perf2.h"
  
  /*
!  *  計測回数と実行時間分布を記録する最大時間
   */
! #define NO_MEASURE	10000U			/* 計測回数 */
! #define MAX_TIME	1000U			/* 実行時間分布を記録する最大時間 */
  
  /*
!  *  実行時間分布を記録するメモリ領域
   */
  static uint_t	histarea1[MAX_TIME + 1];
  
  /*
!  *  計測ルーチン
   */
  void
  perf_eval(uint_t n)
***************
*** 95,101 ****
  }
  
  /*
!  *  ᥤ󥿥ͥ١
   */
  void main_task(intptr_t exinf)
  {
--- 95,101 ----
  }
  
  /*
!  *  メインタスク（低優先度）
   */
  void main_task(intptr_t exinf)
  {
diff -cr --new-file 1.9.1/asp/test/perf2.cfg ASPs/asp/test/perf2.cfg
*** 1.9.1/asp/test/perf2.cfg	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf2.cfg	Fri Dec  9 13:54:11 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ͥǽɾץ(2)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  カーネル性能評価プログラム(2)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/perf2.h ASPs/asp/test/perf2.h
*** 1.9.1/asp/test/perf2.h	Sat Apr 12 10:30:55 2008
--- ASPs/asp/test/perf2.h	Fri Dec  9 13:54:11 2022
***************
*** 5,64 ****
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf2.h 459 2007-08-05 14:08:56Z hiro $
   */
  
  /*
!  *		ͥǽɾץ(2)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
! #define MAIN_PRIORITY	11		/* ᥤ󥿥ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  extern void	main_task(intptr_t exinf);
--- 5,64 ----
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf2.h 459 2007-08-05 14:08:56Z hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(2)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
! #define MAIN_PRIORITY	11		/* メインタスクの優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  extern void	main_task(intptr_t exinf);
diff -cr --new-file 1.9.1/asp/test/perf3.c ASPs/asp/test/perf3.c
*** 1.9.1/asp/test/perf3.c	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf3.c	Fri Dec  9 13:54:11 2022
***************
*** 5,47 ****
   *  Copyright (C) 2007-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf3.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		ͥǽɾץ(3)
   *
!  *  Ԥ륿οˤꡤset_flgν֤ɤΤ褦Ѳ
!  *  ¬뤿Υץࡥ
   */
  
  #include <kernel.h>
--- 5,47 ----
   *  Copyright (C) 2007-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf3.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(3)
   *
!  *  待ち解除するタスクの数により，set_flgの処理時間がどのように変化する
!  *  かを計測するためのプログラム．
   */
  
  #include <kernel.h>
***************
*** 52,69 ****
  #include "perf3.h"
  
  /*
!  *  ¬ȼ¹ԻʬۤϿ
   */
! #define NO_MEASURE	10000U			/* ¬ */
! #define MAX_TIME	1000U			/* ¹ԻʬۤϿ */
  
  /*
!  *  ¹ԻʬۤϿΰ
   */
  static uint_t	histarea1[MAX_TIME + 1];
  
  /*
!  *  ¬Υꥹ
   */
  static ID task_list[20] = {
  	TASK1, TASK2, TASK3, TASK4, TASK5,
--- 52,69 ----
  #include "perf3.h"
  
  /*
!  *  計測回数と実行時間分布を記録する最大時間
   */
! #define NO_MEASURE	10000U			/* 計測回数 */
! #define MAX_TIME	1000U			/* 実行時間分布を記録する最大時間 */
  
  /*
!  *  実行時間分布を記録するメモリ領域
   */
  static uint_t	histarea1[MAX_TIME + 1];
  
  /*
!  *  計測タスクのリスト
   */
  static ID task_list[20] = {
  	TASK1, TASK2, TASK3, TASK4, TASK5,
***************
*** 73,79 ****
  };
  
  /*
!  *  ¬ͥ١
   */
  void task(intptr_t exinf)
  {
--- 73,79 ----
  };
  
  /*
!  *  計測タスク（中優先度）
   */
  void task(intptr_t exinf)
  {
***************
*** 83,89 ****
  }
  
  /*
!  *  ¬롼
   */
  void
  perf_eval(uint_t n)
--- 83,89 ----
  }
  
  /*
!  *  計測ルーチン
   */
  void
  perf_eval(uint_t n)
***************
*** 98,104 ****
  			act_tsk(task_list[j]);
  		}
  		chg_pri(TSK_SELF, MAIN_PRIORITY_LOW);
! 		/* Ԥ֤ΤԤ */
  		chg_pri(TSK_SELF, TPRI_INI);
  
  		begin_measure(1);
--- 98,104 ----
  			act_tsk(task_list[j]);
  		}
  		chg_pri(TSK_SELF, MAIN_PRIORITY_LOW);
! 		/* タスクが待ち状態に入るのを待つ */
  		chg_pri(TSK_SELF, TPRI_INI);
  
  		begin_measure(1);
***************
*** 106,112 ****
  		end_measure(1);
  
  		chg_pri(TSK_SELF, MAIN_PRIORITY_LOW);
! 		/* λΤԤ */
  		chg_pri(TSK_SELF, TPRI_INI);
  	}
  
--- 106,112 ----
  		end_measure(1);
  
  		chg_pri(TSK_SELF, MAIN_PRIORITY_LOW);
! 		/* タスクが終了するのを待つ */
  		chg_pri(TSK_SELF, TPRI_INI);
  	}
  
***************
*** 117,123 ****
  }
  
  /*
!  *  ᥤ󥿥ʹͥ١
   */
  void main_task(intptr_t exinf)
  {
--- 117,123 ----
  }
  
  /*
!  *  メインタスク（高優先度）
   */
  void main_task(intptr_t exinf)
  {
diff -cr --new-file 1.9.1/asp/test/perf3.cfg ASPs/asp/test/perf3.cfg
*** 1.9.1/asp/test/perf3.cfg	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf3.cfg	Fri Dec  9 13:54:11 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ͥǽɾץ(3)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  カーネル性能評価プログラム(3)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/perf3.h ASPs/asp/test/perf3.h
*** 1.9.1/asp/test/perf3.h	Sat Apr 12 10:30:55 2008
--- ASPs/asp/test/perf3.h	Fri Dec  9 13:54:11 2022
***************
*** 5,67 ****
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf3.h 459 2007-08-05 14:08:56Z hiro $
   */
  
  /*
!  *		ͥǽɾץ(3)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
! #define TASK_PRIORITY		10		/* ͥ */
! #define MAIN_PRIORITY		9		/* ᥤ󥿥ͥ */
! #define MAIN_PRIORITY_LOW	11		/* ᥤ󥿥ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  extern void	task(intptr_t exinf);
  extern void	main_task(intptr_t exinf);
--- 5,67 ----
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf3.h 459 2007-08-05 14:08:56Z hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(3)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
! #define TASK_PRIORITY		10		/* タスクの優先度 */
! #define MAIN_PRIORITY		9		/* メインタスクの優先度 */
! #define MAIN_PRIORITY_LOW	11		/* メインタスクの低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  extern void	task(intptr_t exinf);
  extern void	main_task(intptr_t exinf);
diff -cr --new-file 1.9.1/asp/test/perf4.c ASPs/asp/test/perf4.c
*** 1.9.1/asp/test/perf4.c	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf4.c	Fri Dec  9 13:54:11 2022
***************
*** 5,62 ****
   *  Copyright (C) 2006-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf4.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		ͥǽɾץ(4)
   *
!  *  act_tskiact_tskν֤ȥڴ֤¬뤿Υץ
!  *  ࡥʲ3Ĥλ֤¬ꤹ롥
   *
!  *  (1) ڴ򵯤ʤact_tskν֡ͥ
!  *      㤤Фact_tskȯԤٻ߾֤¹ԤǤ
!  *      ܤλ֡
   *
!  *  (2) ڴ򵯤act_tskν֡ͥ٤ι
!  *      Фact_tskȯԤٻ߾֤¹ԤǤ֤
!  *      ܤڴ򵯤ơ⤤ͥ٤Υμ¹ԤϤ
!  *      ޤǤλ֡
   *
!  *  (3) ڴ򵯤iact_tskν֡ϥɥ餫顤¹
!  *      ֤Υ⤤ͥ٤ΥФact_tskȯԤ
!  *      ߾֤¹ԤǤ֤ܤȤ˼ϥɥ餫꥿
!  *      󤷡ڴ򵯤ơ⤤ͥ٤Υμ¹ԤϤޤ
!  *      ޤǤλ֡
   */
  
  #include <kernel.h>
--- 5,62 ----
   *  Copyright (C) 2006-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf4.c 1575 2009-05-31 14:15:46Z ertl-hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(4)
   *
!  *  act_tsk，iact_tskの処理時間とタスク切換え時間を計測するためのプログ
!  *  ラム．以下の3つの時間を測定する．
   *
!  *  (1) タスク切換えを起こさないact_tskの処理時間．自タスクよりも優先度
!  *      の低いタスクに対してact_tskを発行し，休止状態から実行できる状態
!  *      に遷移させる処理の時間．
   *
!  *  (2) タスク切換えを起こすact_tskの処理時間．自タスクよりも優先度の高
!  *      いタスクに対してact_tskを発行し，休止状態から実行できる状態に遷
!  *      移させ，タスク切換えを起こして，高い優先度のタスクの実行が始ま
!  *      るまでの時間．
   *
!  *  (3) タスク切換えを起こすiact_tskの処理時間．周期ハンドラから，実行
!  *      状態のタスクよりも高い優先度のタスクに対してact_tskを発行し，休
!  *      止状態から実行できる状態に遷移させたあとに周期ハンドラからリター
!  *      ンし，タスク切換えを起こして，高い優先度のタスクの実行が始まる
!  *      までの時間．
   */
  
  #include <kernel.h>
***************
*** 67,86 ****
  #include "perf4.h"
  
  /*
!  *  ¬ȼ¹ԻʬۤϿ
   */
! #define NO_MEASURE	10000U			/* ¬ */
! #define MAX_TIME	1000U			/* ¹ԻʬۤϿ */
  
  /*
!  *  ¹ԻʬۤϿΰ
   */
  static uint_t	histarea1[MAX_TIME + 1];
  static uint_t	histarea2[MAX_TIME + 1];
  static uint_t	histarea3[MAX_TIME + 1];
  
  /*
!  *  ¬1ʹͥ١
   */
  void task1(intptr_t exinf)
  {
--- 67,86 ----
  #include "perf4.h"
  
  /*
!  *  計測回数と実行時間分布を記録する最大時間
   */
! #define NO_MEASURE	10000U			/* 計測回数 */
! #define MAX_TIME	1000U			/* 実行時間分布を記録する最大時間 */
  
  /*
!  *  実行時間分布を記録するメモリ領域
   */
  static uint_t	histarea1[MAX_TIME + 1];
  static uint_t	histarea2[MAX_TIME + 1];
  static uint_t	histarea3[MAX_TIME + 1];
  
  /*
!  *  計測タスク1（高優先度）
   */
  void task1(intptr_t exinf)
  {
***************
*** 89,100 ****
  }
  
  /*
!  *  ¬2ȥᥤ󥿥ζͭѿ
   */
  volatile uint_t		task2_count;
  
  /*
!  *  ¬2ʹͥ١
   */
  void task2(intptr_t exinf)
  {
--- 89,100 ----
  }
  
  /*
!  *  計測タスク2とメインタスクの共有変数
   */
  volatile uint_t		task2_count;
  
  /*
!  *  計測タスク2（高優先度）
   */
  void task2(intptr_t exinf)
  {
***************
*** 104,110 ****
  }
  
  /*
!  *  ¬3ͥ١
   */
  void task3(intptr_t exinf)
  {
--- 104,110 ----
  }
  
  /*
!  *  計測タスク3（低優先度）
   */
  void task3(intptr_t exinf)
  {
***************
*** 112,118 ****
  }
  
  /*
!  *  ¬4ʺͥ١
   */
  void task4(intptr_t exinf)
  {
--- 112,118 ----
  }
  
  /*
!  *  計測タスク4（最低優先度）
   */
  void task4(intptr_t exinf)
  {
***************
*** 122,128 ****
  }
  
  /*
!  *  ϥɥ
   */
  void cyclic_handler(intptr_t exinf)
  {
--- 122,128 ----
  }
  
  /*
!  *  周期ハンドラ
   */
  void cyclic_handler(intptr_t exinf)
  {
***************
*** 131,137 ****
  }
  
  /*
!  *  ᥤ󥿥ͥ١
   */
  void main_task(intptr_t exinf)
  {
--- 131,137 ----
  }
  
  /*
!  *  メインタスク（中優先度）
   */
  void main_task(intptr_t exinf)
  {
***************
*** 144,150 ****
  	syslog_flush();
  
  	/*
! 	 *  ڴ򵯤ʤact_tskν֤¬
  	 */
  	for (i = 0; i < NO_MEASURE; i++) {
  		begin_measure(1);
--- 144,150 ----
  	syslog_flush();
  
  	/*
! 	 *  タスク切換えを起こさないact_tskの処理時間の測定
  	 */
  	for (i = 0; i < NO_MEASURE; i++) {
  		begin_measure(1);
***************
*** 154,160 ****
  	}
  
  	/*
! 	 *  ڴ򵯤act_tskν֤¬
  	 */
  	for (i = 0; i < NO_MEASURE; i++) {
  		begin_measure(2);
--- 154,160 ----
  	}
  
  	/*
! 	 *  タスク切換えを起こすact_tskの処理時間の測定
  	 */
  	for (i = 0; i < NO_MEASURE; i++) {
  		begin_measure(2);
***************
*** 162,168 ****
  	}
  
  	/*
! 	 *  ڴ򵯤iact_tskν֤¬¬10ʬ1
  	 */
  	task2_count = 0;
  	sta_cyc(CYC1);
--- 162,168 ----
  	}
  
  	/*
! 	 *  タスク切換えを起こすiact_tskの処理時間の測定（測定回数は10分の1）
  	 */
  	task2_count = 0;
  	sta_cyc(CYC1);
diff -cr --new-file 1.9.1/asp/test/perf4.cfg ASPs/asp/test/perf4.cfg
*** 1.9.1/asp/test/perf4.cfg	Sun May 31 23:15:57 2009
--- ASPs/asp/test/perf4.cfg	Fri Dec  9 13:54:11 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ͥǽɾץ(4)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  カーネル性能評価プログラム(4)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/perf4.h ASPs/asp/test/perf4.h
*** 1.9.1/asp/test/perf4.h	Tue May 12 11:36:44 2009
--- ASPs/asp/test/perf4.h	Fri Dec  9 13:54:11 2022
***************
*** 5,69 ****
   *  Copyright (C) 2006-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: perf4.h 1552 2009-05-12 02:35:57Z ertl-hiro $
   */
  
  /*
!  *		ͥǽɾץ(4)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
! #define TASK1_PRIORITY	9		/* ¬1ͥ */
! #define TASK2_PRIORITY	9		/* ¬2ͥ */
! #define TASK3_PRIORITY	11		/* ¬3ͥ */
! #define TASK4_PRIORITY	12		/* ¬4ͥ */
! #define MAIN_PRIORITY	10		/* ᥤ󥿥ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  extern void	task1(intptr_t exinf);
  extern void	task2(intptr_t exinf);
--- 5,69 ----
   *  Copyright (C) 2006-2009 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: perf4.h 1552 2009-05-12 02:35:57Z ertl-hiro $
   */
  
  /*
!  *		カーネル性能評価プログラム(4)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
! #define TASK1_PRIORITY	9		/* 計測タスク1の優先度 */
! #define TASK2_PRIORITY	9		/* 計測タスク2の優先度 */
! #define TASK3_PRIORITY	11		/* 計測タスク3の優先度 */
! #define TASK4_PRIORITY	12		/* 計測タスク4の優先度 */
! #define MAIN_PRIORITY	10		/* メインタスクの優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  extern void	task1(intptr_t exinf);
  extern void	task2(intptr_t exinf);
diff -cr --new-file 1.9.1/asp/test/test_cpuexc.cfg ASPs/asp/test/test_cpuexc.cfg
*** 1.9.1/asp/test/test_cpuexc.cfg	Sun May 31 22:40:50 2009
--- ASPs/asp/test/test_cpuexc.cfg	Fri Dec  9 13:54:11 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  CPU㳰Υƥ(1)(13)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  CPU例外処理のテスト(1)〜(13)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/test_cpuexc.h ASPs/asp/test/test_cpuexc.h
*** 1.9.1/asp/test/test_cpuexc.h	Sat Apr 12 10:30:56 2008
--- ASPs/asp/test/test_cpuexc.h	Fri Dec  9 13:54:11 2022
***************
*** 5,66 ****
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_cpuexc.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(1)(13)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,66 ----
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_cpuexc.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(1)〜(13)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/test/test_cpuexc1.c ASPs/asp/test/test_cpuexc1.c
*** 1.9.1/asp/test/test_cpuexc1.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc1.c	Fri Dec  9 13:54:12 2022
***************
*** 5,110 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc1.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(1)
   *
!  * ڥƥȤŪ
   *
!  *  󥿥ƥȡå֤ȯCPU㳰ˤ륷
!  *  ֤Υƥȡͥ٥ޥTIPM_ENAALLǥѥåػ߾
!  *  ֡㳰ľ֤ǥƥȤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *  ⡤󥿥ƥȡå֤ȯCPU㳰ˤ
!  *  ơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *		ߥå֤ȯCPU㳰Ǥϡƥ֤
!  *		뤳ȤݾڤʤᡤƥȤǤʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		ߥå֤ȯCPU㳰Ǥϡƥ֤
!  *		뤳ȤݾڤʤᡤƥȤǤʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *		ߥå֤ȯCPU㳰Ǥϡƥ֤
!  *		뤳ȤݾڤʤᡤƥȤǤʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *		ߥå֤ȯCPU㳰Ǥϡƥ֤
!  *		뤳ȤݾڤʤᡤƥȤǤʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *	ALM1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		dis_dsp()
   *		ena_tex()
!  *	2:	֤Υå
   *		sta_alm(ALM1, 1U)
!  *		顼ϥɥ1μ¹ԤԤ
   *	== ALM1 ==
!  *	3:	֤Υå
   *		SIL_LOC_INT()
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
   *	4:	xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	5:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	5:	꥿
!  *	== ALM1³==
   *	6:	SIL_UNL_LOC()
!  *	7:	֤Υå				... (E)(G)(H)
!  *		꥿
!  *	== TASK1³==
!  *	8:	֤Υå				... (F)
!  *	9:	ƥȽλ
   */
  
  #include <sil.h>
--- 5,110 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc1.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(1)
   *
!  * 【テストの目的】
   *
!  *  非タスクコンテキスト，割込ロック状態で発生したCPU例外におけるシステ
!  *  ム状態のテスト．割込み優先度マスク＝TIPM_ENAALL，ディスパッチ禁止状
!  *  態，タスク例外許可状態でテストする．
!  *
!  * 【テスト項目】
!  *
!  *  いずれも，非タスクコンテキスト，割込ロック状態で発生したCPU例外にお
!  *  いて，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *		！割込みロック状態で発生したCPU例外では，システム状態を正しく読
!  *		めることが保証されないため，テストできない．
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！割込みロック状態で発生したCPU例外では，システム状態を正しく読
!  *		めることが保証されないため，テストできない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *		！割込みロック状態で発生したCPU例外では，システム状態を正しく読
!  *		めることが保証されないため，テストできない．
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *		！割込みロック状態で発生したCPU例外では，システム状態を正しく読
!  *		めることが保証されないため，テストできない．
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *	ALM1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		dis_dsp()
   *		ena_tex()
!  *	2:	状態のチェック
   *		sta_alm(ALM1, 1U)
!  *		アラームハンドラ1の実行を待つ
   *	== ALM1 ==
!  *	3:	状態のチェック
   *		SIL_LOC_INT()
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
   *	4:	xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	5:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	5:	リターン
!  *	== ALM1（続き）==
   *	6:	SIL_UNL_LOC()
!  *	7:	状態のチェック				... (E)(G)(H)
!  *		リターン
!  *	== TASK1（続き）==
!  *	8:	状態のチェック				... (F)
!  *	9:	テスト終了
   */
  
  #include <sil.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc10.c ASPs/asp/test/test_cpuexc10.c
*** 1.9.1/asp/test/test_cpuexc10.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc10.c	Fri Dec  9 13:54:12 2022
***************
*** 5,97 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc10.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(10)
   *
!  * ڥƥȤŪ
   *
!  *  ͥ٥ޥTMIN_INTPRI-1ǥѥåľ֡㳰
!  *  ľ֤ȯCPU㳰ˤ륷ƥ֤Υƥȡ
   *
!  *  ΥƥȤϡͥ٥ޥTMIN_INTPRI-1ǤΤ
!  *  »ܤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *  ⡤ͥ٥ޥTMIN_INTPRI-1ǥѥåľ֡
!  *  㳰ľ֤ȯCPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		chg_ipm(TMIN_INTPRI-1)
   *		ena_tex()
!  *	2:	֤Υå
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	4:	꥿
!  *	== TASK1³==
!  *	5:	֤Υå				... (E)(F)(G)(H)
!  *	6:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,97 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc10.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(10)
   *
!  * 【テストの目的】
   *
!  *  割込み優先度マスク＝TMIN_INTPRI-1，ディスパッチ許可状態，タスク例外
!  *  許可状態で発生したCPU例外におけるシステム状態のテスト．
   *
!  *  このテストは，割込み優先度マスクをTMIN_INTPRI-1に設定できる場合のみ
!  *  実施する．
!  *
!  * 【テスト項目】
!  *
!  *  いずれも，割込み優先度マスク＝TMIN_INTPRI-1，ディスパッチ許可状態，
!  *  タスク例外許可状態で発生したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		chg_ipm(TMIN_INTPRI-1)
   *		ena_tex()
!  *	2:	状態のチェック
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	4:	リターン
!  *	== TASK1（続き）==
!  *	5:	状態のチェック				... (E)(F)(G)(H)
!  *	6:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc11.c ASPs/asp/test/test_cpuexc11.c
*** 1.9.1/asp/test/test_cpuexc11.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc11.c	Fri Dec  9 13:54:12 2022
***************
*** 5,115 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc11.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(11)
   *
!  * ڥƥȤŪ
   *
!  *  ͥ٥ޥTIPM_ENAALLǥѥåľ֡㳰
!  *  ľ֤ȯCPU㳰ˤ륷ƥ֤Υƥȡڴ
!  *  ꥫХ꡼Ǥ뤳ȤƥȤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *  ⡤ͥ٥ޥTIPM_ENAALLǥѥåľ֡
!  *  㳰ľ֤ȯCPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *	(I) xsns_xpnfalse֤
!  *	(J) xsns_dpnfalse֤
!  *	(K) ڴˤꥫХ꡼Ǥ뤳
!  *	(L) 㳰ˤꥫХ꡼Ǥ뤳
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
!  *	TASK2: TA_NULLͥ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١1ܡ==
!  *	1:	֤Υå
   *		ena_tex()
!  *	2:	֤Υå
   *		RAISE_CPU_EXCEPTION
!  *	== CPUEXC11ܡ==
!  *	3:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == false			... (I)
   *		xsns_dpn() == false			... (J)
   *	4:	iact_tsk(TASK2)
   *		iloc_cpu()
!  *		꥿
!  *	== TASK2ʹͥ١==
!  *	5:	֤Υå				... (E)(F)(G)(H)
   *	6:	ter_tsk(TASK1)				... (K)
   *	7:	act_tsk(TASK1)				... (K)
   *	8:	ext_tsk()
!  *	== TASK1ͥ١2ܡ==
!  *	9:	֤Υå				... (K)
   *		ena_tex()
!  *	10:	֤Υå
   *		RAISE_CPU_EXCEPTION
!  *	== CPUEXC12ܡ==
!  *	11:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == false			... (I)
   *		xsns_dpn() == false			... (J)
   *	12:	iras_tex(TASK1, 1U)
   *		iloc_cpu()
!  *		꥿
!  *	== TASK1Υ㳰롼 ==
!  *	13:	֤Υå				... (E)(F)(G)(H)
   *	14:	act_tsk(TASK1)				... (L)
   *	15:	ext_tsk()					... (L)
!  *	== TASK1ͥ١3ܡ==
!  *	16:	֤Υå				... (L)
!  *	17:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,115 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc11.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(11)
   *
!  * 【テストの目的】
   *
!  *  割込み優先度マスク＝TIPM_ENAALL，ディスパッチ許可状態，タスク例外許
!  *  可状態で発生したCPU例外におけるシステム状態のテスト．タスク切換えに
!  *  よりリカバリーできることもテストする．
!  *
!  * 【テスト項目】
!  *
!  *  いずれも，割込み優先度マスク＝TIPM_ENAALL，ディスパッチ許可状態，タ
!  *  スク例外許可状態で発生したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *	(I) xsns_xpnがfalseを返すこと
!  *	(J) xsns_dpnがfalseを返すこと
!  *	(K) タスク切換えによるリカバリーができること
!  *	(L) タスク例外によるリカバリーができること
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
!  *	TASK2: TA_NULL，高優先度
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度，1回目）==
!  *	1:	状態のチェック
   *		ena_tex()
!  *	2:	状態のチェック
   *		RAISE_CPU_EXCEPTION
!  *	== CPUEXC1（1回目）==
!  *	3:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == false			... (I)
   *		xsns_dpn() == false			... (J)
   *	4:	iact_tsk(TASK2)
   *		iloc_cpu()
!  *		リターン
!  *	== TASK2（高優先度）==
!  *	5:	状態のチェック				... (E)(F)(G)(H)
   *	6:	ter_tsk(TASK1)				... (K)
   *	7:	act_tsk(TASK1)				... (K)
   *	8:	ext_tsk()
!  *	== TASK1（中優先度，2回目）==
!  *	9:	状態のチェック				... (K)
   *		ena_tex()
!  *	10:	状態のチェック
   *		RAISE_CPU_EXCEPTION
!  *	== CPUEXC1（2回目）==
!  *	11:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == false			... (I)
   *		xsns_dpn() == false			... (J)
   *	12:	iras_tex(TASK1, 1U)
   *		iloc_cpu()
!  *		リターン
!  *	== TASK1のタスク例外処理ルーチン ==
!  *	13:	状態のチェック				... (E)(F)(G)(H)
   *	14:	act_tsk(TASK1)				... (L)
   *	15:	ext_tsk()					... (L)
!  *	== TASK1（中優先度，3回目）==
!  *	16:	状態のチェック				... (L)
!  *	17:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc12.c ASPs/asp/test/test_cpuexc12.c
*** 1.9.1/asp/test/test_cpuexc12.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc12.c	Fri Dec  9 13:54:12 2022
***************
*** 5,93 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc12.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(12)
   *
!  * ڥƥȤŪ
   *
!  *  ͥ٥ޥTIPM_ENAALLǥѥåػ߾֡㳰
!  *  ߾֤ȯCPU㳰ˤ륷ƥ֤Υƥȡ
   *
!  * ڥƥȹܡ
   *
!  *  ⡤ͥ٥ޥTIPM_ENAALLǥѥåػ߾֡
!  *  㳰ػ߾֤ȯCPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		dis_dsp()
!  *	2:	֤Υå
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	4:	꥿
!  *	== TASK1³==
!  *	5:	֤Υå				... (E)(F)(G)(H)
!  *	6:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,93 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc12.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(12)
   *
!  * 【テストの目的】
   *
!  *  割込み優先度マスク＝TIPM_ENAALL，ディスパッチ禁止状態，タスク例外禁
!  *  止状態で発生したCPU例外におけるシステム状態のテスト．
   *
!  * 【テスト項目】
   *
!  *  いずれも，割込み優先度マスク＝TIPM_ENAALL，ディスパッチ禁止状態，タ
!  *  スク例外禁止状態で発生したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		dis_dsp()
!  *	2:	状態のチェック
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	4:	リターン
!  *	== TASK1（続き）==
!  *	5:	状態のチェック				... (E)(F)(G)(H)
!  *	6:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc13.c ASPs/asp/test/test_cpuexc13.c
*** 1.9.1/asp/test/test_cpuexc13.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc13.c	Fri Dec  9 13:54:12 2022
***************
*** 5,93 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc13.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(13)
   *
!  * ڥƥȤŪ
   *
!  *  ͥ٥ޥTMIN_INTPRIǥѥåľ֡㳰
!  *  ߾֤ȯCPU㳰ˤ륷ƥ֤Υƥȡ
   *
!  * ڥƥȹܡ
   *
!  *  ⡤ͥ٥ޥTMIN_INTPRIǥѥåľ֡
!  *  㳰ػ߾֤ȯCPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		chg_ipm(TMIN_INTPRI)
!  *	2:	֤Υå
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	4:	꥿
!  *	== TASK1³==
!  *	5:	֤Υå				... (E)(F)(G)(H)
!  *	6:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,93 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc13.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(13)
   *
!  * 【テストの目的】
   *
!  *  割込み優先度マスク＝TMIN_INTPRI，ディスパッチ許可状態，タスク例外禁
!  *  止状態で発生したCPU例外におけるシステム状態のテスト．
   *
!  * 【テスト項目】
   *
!  *  いずれも，割込み優先度マスク＝TMIN_INTPRI，ディスパッチ許可状態，タ
!  *  スク例外禁止状態で発生したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		chg_ipm(TMIN_INTPRI)
!  *	2:	状態のチェック
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	4:	リターン
!  *	== TASK1（続き）==
!  *	5:	状態のチェック				... (E)(F)(G)(H)
!  *	6:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc2.c ASPs/asp/test/test_cpuexc2.c
*** 1.9.1/asp/test/test_cpuexc2.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc2.c	Fri Dec  9 13:54:12 2022
***************
*** 5,104 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc2.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(2)
   *
!  * ڥƥȤŪ
   *
!  *  󥿥ƥȡåCPUå֤ȯCPU
!  *  ˤ륷ƥ֤Υƥȡͥ٥ޥTIPM_ENAALLǥ
!  *  ѥåػ߾֡㳰ľ֤ǥƥȤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *  ⡤󥿥ƥȡåCPUå֤ȯ
!  *  CPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *	ALM1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		dis_dsp()
   *		ena_tex()
!  *	2:	֤Υå
   *		sta_alm(ALM1, 1U)
!  *		顼ϥɥ1μ¹ԤԤ
   *	== ALM1 ==
!  *	3:	֤Υå
   *		iloc_cpu()
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	4:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	5:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	5:	꥿
!  *	== ALM1³==
!  *	6:	֤Υå				... (E)(G)(H)
!  *		꥿
!  *	== TASK1³==
!  *	7:	֤Υå				... (F)
!  *	8:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,104 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc2.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(2)
   *
!  * 【テストの目的】
   *
!  *  非タスクコンテキスト，割込ロック解除，CPUロック状態で発生したCPU例
!  *  外におけるシステム状態のテスト．割込み優先度マスク＝TIPM_ENAALL，ディ
!  *  スパッチ禁止状態，タスク例外許可状態でテストする．
!  *
!  * 【テスト項目】
!  *
!  *  いずれも，非タスクコンテキスト，割込ロック解除，CPUロック状態で発生
!  *  したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *	ALM1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		dis_dsp()
   *		ena_tex()
!  *	2:	状態のチェック
   *		sta_alm(ALM1, 1U)
!  *		アラームハンドラ1の実行を待つ
   *	== ALM1 ==
!  *	3:	状態のチェック
   *		iloc_cpu()
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	4:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	5:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	5:	リターン
!  *	== ALM1（続き）==
!  *	6:	状態のチェック				... (E)(G)(H)
!  *		リターン
!  *	== TASK1（続き）==
!  *	7:	状態のチェック				... (F)
!  *	8:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc3.c ASPs/asp/test/test_cpuexc3.c
*** 1.9.1/asp/test/test_cpuexc3.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc3.c	Fri Dec  9 13:54:12 2022
***************
*** 5,103 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc3.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(3)
   *
!  * ڥƥȤŪ
   *
!  *  󥿥ƥȡåCPUåȯCPU
!  *  ˤ륷ƥ֤Υƥȡͥ٥ޥTIPM_ENAALLǥ
!  *  ѥåػ߾֡㳰ľ֤ǥƥȤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *  ⡤󥿥ƥȡåCPUåȯ
!  *  CPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *	ALM1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		dis_dsp()
   *		ena_tex()
!  *	2:	֤Υå
   *		sta_alm(ALM1, 1U)
!  *		顼ϥɥ1μ¹ԤԤ
   *	== ALM1 ==
!  *	3:	֤Υå
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	4:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	5:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	5:	꥿
!  *	== ALM1³==
!  *	6:	֤Υå				... (E)(G)(H)
!  *		꥿
!  *	== TASK1³==
!  *	7:	֤Υå				... (F)
!  *	8:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,103 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc3.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(3)
   *
!  * 【テストの目的】
   *
!  *  非タスクコンテキスト，割込ロック解除，CPUロック解除で発生したCPU例
!  *  外におけるシステム状態のテスト．割込み優先度マスク＝TIPM_ENAALL，ディ
!  *  スパッチ禁止状態，タスク例外許可状態でテストする．
!  *
!  * 【テスト項目】
!  *
!  *  いずれも，非タスクコンテキスト，割込ロック解除，CPUロック解除で発生
!  *  したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *	ALM1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		dis_dsp()
   *		ena_tex()
!  *	2:	状態のチェック
   *		sta_alm(ALM1, 1U)
!  *		アラームハンドラ1の実行を待つ
   *	== ALM1 ==
!  *	3:	状態のチェック
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	4:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	5:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	5:	リターン
!  *	== ALM1（続き）==
!  *	6:	状態のチェック				... (E)(G)(H)
!  *		リターン
!  *	== TASK1（続き）==
!  *	7:	状態のチェック				... (F)
!  *	8:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc4.c ASPs/asp/test/test_cpuexc4.c
*** 1.9.1/asp/test/test_cpuexc4.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc4.c	Fri Dec  9 13:54:12 2022
***************
*** 5,102 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc4.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(4)
   *
!  * ڥƥȤŪ
   *
!  *  ƥȡå֤ȯCPU㳰ˤ륷ƥ
!  *  ֤Υƥȡͥ٥ޥTIPM_ENAALLǥѥåػ߾֡
!  *  㳰ľ֤ǥƥȤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *  ⡤ƥȡå֤ȯCPU㳰ˤ
!  *  ơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *		ߥå֤ȯCPU㳰Ǥϡƥ֤
!  *		뤳ȤݾڤʤᡤƥȤǤʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		ߥå֤ȯCPU㳰Ǥϡƥ֤
!  *		뤳ȤݾڤʤᡤƥȤǤʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *		ߥå֤ȯCPU㳰Ǥϡƥ֤
!  *		뤳ȤݾڤʤᡤƥȤǤʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *		ߥå֤ȯCPU㳰Ǥϡƥ֤
!  *		뤳ȤݾڤʤᡤƥȤǤʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		dis_dsp()
   *		ena_tex()
!  *	2:	֤Υå
   *		SIL_LOC_INT()
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
   *	3:	xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	4:	꥿
!  *	== TASK1³==
   *	5:	SIL_UNL_LOC()
!  *	6:	֤Υå				... (E)(F)(G)(H)
!  *	7:	ƥȽλ
   */
  
  #include <sil.h>
--- 5,102 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc4.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(4)
   *
!  * 【テストの目的】
   *
!  *  タスクコンテキスト，割込ロック状態で発生したCPU例外におけるシステム
!  *  状態のテスト．割込み優先度マスク＝TIPM_ENAALL，ディスパッチ禁止状態，
!  *  タスク例外許可状態でテストする．
!  *
!  * 【テスト項目】
!  *
!  *  いずれも，タスクコンテキスト，割込ロック状態で発生したCPU例外におい
!  *  て，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *		！割込みロック状態で発生したCPU例外では，システム状態を正しく読
!  *		めることが保証されないため，テストできない．
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！割込みロック状態で発生したCPU例外では，システム状態を正しく読
!  *		めることが保証されないため，テストできない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *		！割込みロック状態で発生したCPU例外では，システム状態を正しく読
!  *		めることが保証されないため，テストできない．
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *		！割込みロック状態で発生したCPU例外では，システム状態を正しく読
!  *		めることが保証されないため，テストできない．
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		dis_dsp()
   *		ena_tex()
!  *	2:	状態のチェック
   *		SIL_LOC_INT()
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
   *	3:	xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	4:	リターン
!  *	== TASK1（続き）==
   *	5:	SIL_UNL_LOC()
!  *	6:	状態のチェック				... (E)(F)(G)(H)
!  *	7:	テスト終了
   */
  
  #include <sil.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc5.c ASPs/asp/test/test_cpuexc5.c
*** 1.9.1/asp/test/test_cpuexc5.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc5.c	Fri Dec  9 13:54:12 2022
***************
*** 5,96 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc5.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(5)
   *
!  * ڥƥȤŪ
   *
!  *  ƥȡåCPUå֤ȯCPU㳰
!  *  ˤ륷ƥ֤Υƥȡͥ٥ޥTIPM_ENAALLǥ
!  *  ѥåػ߾֡㳰ľ֤ǥƥȤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *  ⡤ƥȡåCPUå֤ȯ
!  *  CPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		dis_dsp()
   *		ena_tex()
   *		loc_cpu()
!  *	2:	֤Υå
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	4:	꥿
!  *	== TASK1³==
!  *	5:	֤Υå				... (E)(F)(G)(H)
!  *	6:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,96 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc5.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(5)
   *
!  * 【テストの目的】
   *
!  *  タスクコンテキスト，割込ロック解除，CPUロック状態で発生したCPU例外
!  *  におけるシステム状態のテスト．割込み優先度マスク＝TIPM_ENAALL，ディ
!  *  スパッチ禁止状態，タスク例外許可状態でテストする．
!  *
!  * 【テスト項目】
!  *
!  *  いずれも，タスクコンテキスト，割込ロック解除，CPUロック状態で発生し
!  *  たCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		dis_dsp()
   *		ena_tex()
   *		loc_cpu()
!  *	2:	状態のチェック
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	4:	リターン
!  *	== TASK1（続き）==
!  *	5:	状態のチェック				... (E)(F)(G)(H)
!  *	6:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc6.c ASPs/asp/test/test_cpuexc6.c
*** 1.9.1/asp/test/test_cpuexc6.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc6.c	Fri Dec  9 13:54:12 2022
***************
*** 5,96 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc6.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(6)
   *
!  * ڥƥȤŪ
   *
!  *  ͥ٥ޥTIPM_ENAALLǥѥåľ֡㳰
!  *  ߾֤ȯCPU㳰ˤ륷ƥ֤Υƥȡڴ
!  *  ꥫХ꡼Ǥ뤳ȤƥȤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *  ⡤ͥ٥ޥTIPM_ENAALLǥѥåľ֡
!  *  㳰ػ߾֤ȯCPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpnfalse֤
!  *	(K) ڴˤꥫХ꡼Ǥ뤳
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
!  *	TASK2: TA_NULLͥ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١1ܡ==
!  *	1:	֤Υå
   *	2:	RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	֤Υå				... (A),(C),(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == false			... (J)
   *  4:	iact_tsk(TASK2)
   *		iloc_cpu()
!  *  	꥿
!  *	== TASK2ʹͥ١==
!  *	5:	֤Υå				... (E),(F),(G),(H)
   *	6:	ter_tsk(TASK1)				... (K)
   *	7:	act_tsk(TASK1)				... (K)
   *	8:	ext_tsk()
!  *	== TASK1ͥ١2ܡ==
!  *	9:	֤Υå				... (K)
!  *	10:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,96 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc6.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(6)
   *
!  * 【テストの目的】
   *
!  *  割込み優先度マスク＝TIPM_ENAALL，ディスパッチ許可状態，タスク例外禁
!  *  止状態で発生したCPU例外におけるシステム状態のテスト．タスク切換えに
!  *  よりリカバリーできることもテストする．
!  *
!  * 【テスト項目】
!  *
!  *  いずれも，割込み優先度マスク＝TIPM_ENAALL，ディスパッチ許可状態，タ
!  *  スク例外禁止状態で発生したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがfalseを返すこと
!  *	(K) タスク切換えによるリカバリーができること
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
!  *	TASK2: TA_NULL，高優先度
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度，1回目）==
!  *	1:	状態のチェック
   *	2:	RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	状態のチェック				... (A),(C),(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == false			... (J)
   *  4:	iact_tsk(TASK2)
   *		iloc_cpu()
!  *  	リターン
!  *	== TASK2（高優先度）==
!  *	5:	状態のチェック				... (E),(F),(G),(H)
   *	6:	ter_tsk(TASK1)				... (K)
   *	7:	act_tsk(TASK1)				... (K)
   *	8:	ext_tsk()
!  *	== TASK1（中優先度，2回目）==
!  *	9:	状態のチェック				... (K)
!  *	10:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc7.c ASPs/asp/test/test_cpuexc7.c
*** 1.9.1/asp/test/test_cpuexc7.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc7.c	Fri Dec  9 13:54:12 2022
***************
*** 5,97 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc7.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(7)
   *
!  * ڥƥȤŪ
   *
!  *  ͥ٥ޥTIPM_ENAALLǥѥåػ߾֡㳰
!  *  ľ֤ȯCPU㳰ˤ륷ƥ֤Υƥȡ㳰ˤ
!  *  ꥫХ꡼Ǥ뤳ȤƥȤ롥
!  *
!  * ڥƥȹܡ
!  *
!  *  ⡤ͥ٥ޥTIPM_ENAALLǥѥåػ߾֡
!  *  㳰ľ֤ȯCPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *	(I) xsns_xpnfalse֤
!  *	(J) xsns_dpntrue֤
!  *	(L) 㳰ˤꥫХ꡼Ǥ뤳
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١1ܡ==
!  *	1:	֤Υå
   *		dis_dsp()
   *		ena_tex()
!  *	2:	֤Υå
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	֤Υå				... (A),(C),(D)
   *		xsns_xpn() == false			... (I)
   *		xsns_dpn() == true			... (J)
   *	4:	iras_tex(TASK1, 1U)
   *		iloc_cpu()
!  *		꥿
!  *	== TASK1Υ㳰롼 ==
!  *	5:	֤Υå				... (E),(F),(G),(H)
   *	6:	act_tsk(TASK1)				... (L)
   *	7:	ext_tsk()					... (L)
!  *	== TASK1ͥ١2ܡ==
!  *	8:	֤Υå				... (L)
!  *	9:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,97 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc7.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(7)
   *
!  * 【テストの目的】
   *
!  *  割込み優先度マスク＝TIPM_ENAALL，ディスパッチ禁止状態，タスク例外許
!  *  可状態で発生したCPU例外におけるシステム状態のテスト．タスク例外によ
!  *  りリカバリーできることもテストする．
!  *
!  * 【テスト項目】
!  *
!  *  いずれも，割込み優先度マスク＝TIPM_ENAALL，ディスパッチ禁止状態，タ
!  *  スク例外許可状態で発生したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *	(I) xsns_xpnがfalseを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
!  *	(L) タスク例外によるリカバリーができること
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度，1回目）==
!  *	1:	状態のチェック
   *		dis_dsp()
   *		ena_tex()
!  *	2:	状態のチェック
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	状態のチェック				... (A),(C),(D)
   *		xsns_xpn() == false			... (I)
   *		xsns_dpn() == true			... (J)
   *	4:	iras_tex(TASK1, 1U)
   *		iloc_cpu()
!  *		リターン
!  *	== TASK1のタスク例外処理ルーチン ==
!  *	5:	状態のチェック				... (E),(F),(G),(H)
   *	6:	act_tsk(TASK1)				... (L)
   *	7:	ext_tsk()					... (L)
!  *	== TASK1（中優先度，2回目）==
!  *	8:	状態のチェック				... (L)
!  *	9:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc8.c ASPs/asp/test/test_cpuexc8.c
*** 1.9.1/asp/test/test_cpuexc8.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc8.c	Fri Dec  9 13:54:12 2022
***************
*** 5,96 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc8.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(8)
   *
!  * ڥƥȤŪ
   *
!  *  ͥ٥ޥTMAX_INTPRIǥѥåľ֡㳰
!  *  ľ֤ȯCPU㳰ˤ륷ƥ֤Υƥȡ
   *
!  *  ΥƥȤϡTMAX_INTPRITMIN_INTPRIۤʤΤ߼»ܤ롥
   *
!  * ڥƥȹܡ
!  *
!  *  ⡤ͥ٥ޥTMAX_INTPRIǥѥåľ֡
!  *  㳰ľ֤ȯCPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()
!  *	2:	֤Υå
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	4:	꥿
!  *	== TASK1³==
!  *	5:	֤Υå				... (E)(F)(G)(H)
!  *	6:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,96 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc8.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(8)
   *
!  * 【テストの目的】
   *
!  *  割込み優先度マスク＝TMAX_INTPRI，ディスパッチ許可状態，タスク例外許
!  *  可状態で発生したCPU例外におけるシステム状態のテスト．
   *
!  *  このテストは，TMAX_INTPRIとTMIN_INTPRIが異なる場合のみ実施する．
   *
!  * 【テスト項目】
!  *
!  *  いずれも，割込み優先度マスク＝TMAX_INTPRI，ディスパッチ許可状態，タ
!  *  スク例外許可状態で発生したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()
!  *	2:	状態のチェック
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	4:	リターン
!  *	== TASK1（続き）==
!  *	5:	状態のチェック				... (E)(F)(G)(H)
!  *	6:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_cpuexc9.c ASPs/asp/test/test_cpuexc9.c
*** 1.9.1/asp/test/test_cpuexc9.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_cpuexc9.c	Fri Dec  9 13:54:12 2022
***************
*** 5,94 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_cpuexc9.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU㳰Υƥ(9)
   *
!  * ڥƥȤŪ
   *
!  *  ͥ٥ޥTMIN_INTPRIǥѥåľ֡㳰
!  *  ľ֤ȯCPU㳰ˤ륷ƥ֤Υƥȡ
   *
!  * ڥƥȹܡ
   *
!  *  ⡤ͥ٥ޥTMIN_INTPRIǥѥåľ֡
!  *  㳰ľ֤ȯCPU㳰ˤơ
!  *
!  *	(A) CPU㳰ϥɥ¹ԳϻCPUåե饰Ѳʤ
!  *	(B) CPU㳰ϥɥ¹Գϻ˳ͥ٥ޥѲʤ
!  *		CPU㳰ϥɥǳͥ٥ޥɤʤᡤƥȤ
!  *		ʤ
!  *	(C) CPU㳰ϥɥ¹Գϻ˥ǥѥåػߥե饰Ѳʤ
!  *	(D) CPU㳰ϥɥ¹Գϻ˥㳰ػߥե饰Ѳʤ
!  *	(E) CPU㳰ϥɥ꥿CPUåե饰뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(F) CPU㳰ϥɥ꥿˳ͥ٥ޥ뤳
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(G) CPU㳰ϥɥ꥿˥ǥѥåػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(H) CPU㳰ϥɥ꥿˥㳰ػߥե饰Ѳʤ
!  *		CPU㳰ϥɥ餫꥿ǤΤߥƥȤ롥
!  *	(I) xsns_xpntrue֤
!  *	(J) xsns_dpntrue֤
   *
!  * ڻѥ꥽
   *
!  *	TASK1: TA_ACTͥ١㳰롼Ͽ
   *	CPUEXC1: TA_NULL
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
!  *	1:	֤Υå
   *		chg_ipm(TMIN_INTPRI)
   *		ena_tex()
!  *	2:	֤Υå
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	֤Υå				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU㳰ϥɥ餫꥿Ǥʤϡǽλ
!  *	4:	꥿
!  *	== TASK1³==
!  *	5:	֤Υå				... (E)(F)(G)(H)
!  *	6:	ƥȽλ
   */
  
  #include <kernel.h>
--- 5,94 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_cpuexc9.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		CPU例外処理のテスト(9)
   *
!  * 【テストの目的】
   *
!  *  割込み優先度マスク＝TMIN_INTPRI，ディスパッチ許可状態，タスク例外許
!  *  可状態で発生したCPU例外におけるシステム状態のテスト．
   *
!  * 【テスト項目】
   *
!  *  いずれも，割込み優先度マスク＝TMIN_INTPRI，ディスパッチ許可状態，タ
!  *  スク例外許可状態で発生したCPU例外において，
!  *
!  *	(A) CPU例外ハンドラ実行開始時にCPUロックフラグが変化しないこと
!  *	(B) CPU例外ハンドラ実行開始時に割込み優先度マスクが変化しないこと
!  *		！CPU例外ハンドラ中で割込み優先度マスクを読めないため，テストで
!  *		きない．
!  *	(C) CPU例外ハンドラ実行開始時にディスパッチ禁止フラグが変化しないこと
!  *	(D) CPU例外ハンドラ実行開始時にタスク例外処理禁止フラグが変化しないこと
!  *	(E) CPU例外ハンドラリターン時にCPUロックフラグが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(F) CPU例外ハンドラリターン時に割込み優先度マスクが元に戻ること
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(G) CPU例外ハンドラリターン時にディスパッチ禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(H) CPU例外ハンドラリターン時にタスク例外処理禁止フラグが変化しないこと
!  *		！CPU例外ハンドラからリターンできる場合のみテストする．
!  *	(I) xsns_xpnがtrueを返すこと
!  *	(J) xsns_dpnがtrueを返すこと
   *
!  * 【使用リソース】
   *
!  *	TASK1: TA_ACT，中優先度，タスク例外処理ルーチン登録
   *	CPUEXC1: TA_NULL
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（中優先度）==
!  *	1:	状態のチェック
   *		chg_ipm(TMIN_INTPRI)
   *		ena_tex()
!  *	2:	状態のチェック
   *		RAISE_CPU_EXCEPTION
   *	== CPUEXC1 ==
!  *	3:	状態のチェック				... (A)(C)(D)
   *		xsns_xpn() == true			... (I)
   *		xsns_dpn() == true			... (J)
!  *	4:	CPU例外ハンドラからリターンできない場合は，ここで終了
!  *	4:	リターン
!  *	== TASK1（続き）==
!  *	5:	状態のチェック				... (E)(F)(G)(H)
!  *	6:	テスト終了
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_dlynse.c ASPs/asp/test/test_dlynse.c
*** 1.9.1/asp/test/test_dlynse.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_dlynse.c	Fri Dec  9 13:54:12 2022
***************
*** 7,46 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_dlynse.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /*
!  *		sil_dly_nse˴ؤƥ
   */
  
  #include <kernel.h>
--- 7,46 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_dlynse.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /*
!  *		sil_dly_nseに関するテスト
   */
  
  #include <kernel.h>
***************
*** 51,58 ****
  #include "test_dlynse.h"
  
  /*
!  *  SIL_DLY_TIM1SIL_DLY_TIM2򻲾Ȥ뤿ˡͥѤΥإåե
!  *  򥤥󥯥롼ɤ롥
   */
  #include "kernel/kernel_impl.h"
  
--- 51,58 ----
  #include "test_dlynse.h"
  
  /*
!  *  SIL_DLY_TIM1とSIL_DLY_TIM2を参照するために，カーネル用のヘッダファ
!  *  イルをインクルードする．
   */
  #include "kernel/kernel_impl.h"
  
diff -cr --new-file 1.9.1/asp/test/test_dlynse.cfg ASPs/asp/test/test_dlynse.cfg
*** 1.9.1/asp/test/test_dlynse.cfg	Sun May 31 22:40:50 2009
--- ASPs/asp/test/test_dlynse.cfg	Fri Dec  9 13:54:12 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  sil_dly_nse˴ؤƥȤΥƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  sil_dly_nseに関するテストのシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/test_dlynse.h ASPs/asp/test/test_dlynse.h
*** 1.9.1/asp/test/test_dlynse.h	Fri Feb 12 00:59:30 2010
--- ASPs/asp/test/test_dlynse.h	Fri Dec  9 13:54:12 2022
***************
*** 5,65 ****
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_dlynse.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /*
!  *		sil_dly_nse˴ؤƥ
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
  #define MAIN_PRIORITY	10
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,65 ----
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_dlynse.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /*
!  *		sil_dly_nseに関するテスト
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
  #define MAIN_PRIORITY	10
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/test/test_sem1.c ASPs/asp/test/test_sem1.c
*** 1.9.1/asp/test/test_sem1.c	Sat Jan 11 23:15:56 2014
--- ASPs/asp/test/test_sem1.c	Fri Dec  9 13:54:12 2022
***************
*** 5,107 ****
   *  Copyright (C) 2008-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_sem1.c 2606 2014-01-11 14:15:55Z ertl-hiro $
   */
  
  /* 
!  *		ޥեǽΥƥ(1)
   *
!  * ڥƥȤŪ
   *
!  *  sig_semwai_semCRE_SEMŪ˥ƥȤ롥
!  *  CRE_SEMΥ顼ΥƥȤϽ
   *
!  * ڥƥȹܡ
   *
!  *	(A) sig_semŪ顼Υƥ
!  *		(A-1) 󥿥ƥȤθƽФ
!  *		(A-2) CPUå֤θƽФ
!  *		(A-3) semidʾ
!  *		(A-4) semid礭
!  *	(B) sig_semˤꥻޥեԤ֤ΥԤ
!  *		(B-1) Ԥ줿ڤ괹
!  *		(B-2) ǥѥåα֤ǡڤ괹ʤ
!  *		(B-3) Ԥ줿Ԥ֤ǡڤ괹ʤ
!  *		(B-4) Ԥ줿ͥ٤㤯ڤ괹ʤ
!  *	(C) sig_semˤꥻޥեλ񸻿1
!  *		(C-1) ޥեλ񸻿01ˤʤ
!  *		(C-2) ޥեλ񸻿12ˤʤ
!  *	(D) sig_semE_QOVR顼Ȥʤ
!  *		(D-1) ޥեκ񸻿1λ
!  *		(D-2) ޥեκ񸻿2λ
!  *	(E) wai_semŪ顼Υƥ
!  *		(E-1) 󥿥ƥȤθƽФ
!  *		(E-2) CPUå֤θƽФ
!  *		(E-3) ǥѥåػ߾֤θƽФ
!  *		(E-4) ͥ٥ޥǤʤ֤θƽФ
!  *		(E-5) semidʾ
!  *		(E-6) semid礭
!  *	(F) wai_semˤꥻޥեλ񸻿1
!  *		(F-1) ޥեλ񸻿10ˤʤ
!  *		(F-2) ޥեλ񸻿21ˤʤ
!  *	(G) wai_semˤꥻޥեԤ֤ˤʤ
!  *		(G-1) TA_TNULL°ΥޥեǡԤäƤ륿ʤä
!  *		(G-2) TA_TNULL°ΥޥեǡԤäƤ륿ä
!  *		(G-3) TA_TPRI°ΥޥեǡԤäƤ륿ʤä
!  *		(G-4) TA_TPRI°Υޥեǡͥ٤⤤ԤäƤ
!  *		(G-5) TA_TPRI°Υޥեǡͥ٤ƱԤäƤ
!  *		(G-6) TA_TPRI°Υޥեǡͥ٤㤤ԤäƤ
!  *	(H) ޥեԤ֤
!  *	(I) ޥեԤ֤δ֤˥ޥե
!  *	(J) ޥեλ񸻿νͤꤵ
!  *		(J-1) ޥեλ񸻿νͤ0
!  *		(J-2) ޥեλ񸻿νͤ1
!  *		(J-3) ޥեλ񸻿νͤ2
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥TA_ACT°
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	TASK4: ͥ٥
!  *	TASK5: ͥ٥
!  *	ALM1:  顼ϥɥ
!  *  SEM1:  TA_NULL°񸻿1񸻿1
!  *  SEM2:  TA_NULL°񸻿2񸻿2
!  *  SEM3:  TA_TPRI°񸻿0񸻿1
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *  1:	ref_sem(SEM1, &rsem)
   *		assert(rsem.wtskid == TSK_NONE)
   *		assert(rsem.semcnt == 1)			... (J-2)
--- 5,107 ----
   *  Copyright (C) 2008-2014 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_sem1.c 2606 2014-01-11 14:15:55Z ertl-hiro $
   */
  
  /* 
!  *		セマフォ機能のテスト(1)
   *
!  * 【テストの目的】
   *
!  *  sig_sem，wai_sem，CRE_SEMを網羅的にテストする．
!  *  ただし，CRE_SEMのエラーのテストは除く．
   *
!  * 【テスト項目】
   *
!  *	(A) sig_semの静的エラーのテスト
!  *		(A-1) 非タスクコンテキストからの呼出し
!  *		(A-2) CPUロック状態からの呼出し
!  *		(A-3) semidが不正（小さすぎる）
!  *		(A-4) semidが不正（大きすぎる）
!  *	(B) sig_semによりセマフォ待ち状態のタスクが待ち解除される
!  *		(B-1) 待ち解除されたタスクに切り換わる
!  *		(B-2) ディスパッチ保留状態で，切り換わらない
!  *		(B-3) 待ち解除されたタスクが強制待ち状態で，切り換わらない
!  *		(B-4) 待ち解除されたタスクが優先度が低く，切り換わらない
!  *	(C) sig_semによりセマフォの資源数が1増える
!  *		(C-1) セマフォの資源数が0から1になる
!  *		(C-2) セマフォの資源数が1から2になる
!  *	(D) sig_semがE_QOVRエラーとなる
!  *		(D-1) セマフォの最大資源数が1の時
!  *		(D-2) セマフォの最大資源数が2の時
!  *	(E) wai_semの静的エラーのテスト
!  *		(E-1) 非タスクコンテキストからの呼出し
!  *		(E-2) CPUロック状態からの呼出し
!  *		(E-3) ディスパッチ禁止状態からの呼出し
!  *		(E-4) 割込み優先度マスク全解除でない状態からの呼出し
!  *		(E-5) semidが不正（小さすぎる）
!  *		(E-6) semidが不正（大きすぎる）
!  *	(F) wai_semによりセマフォの資源数が1減る
!  *		(F-1) セマフォの資源数が1から0になる
!  *		(F-2) セマフォの資源数が2から1になる
!  *	(G) wai_semによりセマフォ待ち状態になる
!  *		(G-1) TA_TNULL属性のセマフォで，待っているタスクがなかった場合
!  *		(G-2) TA_TNULL属性のセマフォで，待っているタスクがあった場合
!  *		(G-3) TA_TPRI属性のセマフォで，待っているタスクがなかった場合
!  *		(G-4) TA_TPRI属性のセマフォで，優先度が高いタスクが待っている場合
!  *		(G-5) TA_TPRI属性のセマフォで，優先度が同じタスクが待っている場合
!  *		(G-6) TA_TPRI属性のセマフォで，優先度が低いタスクが待っている場合
!  *	(H) セマフォ待ち状態が強制解除される
!  *	(I) セマフォ待ち状態の間にセマフォが初期化される
!  *	(J) セマフォの資源数の初期値が正しく設定される
!  *		(J-1) セマフォの資源数の初期値が0
!  *		(J-2) セマフォの資源数の初期値が1
!  *		(J-3) セマフォの資源数の初期値が2
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 中優先度タスク，TA_ACT属性
!  *	TASK2: 高優先度タスク
!  *	TASK3: 低優先度タスク
!  *	TASK4: 中優先度タスク
!  *	TASK5: 中優先度タスク
!  *	ALM1:  アラームハンドラ
!  *  SEM1:  TA_NULL属性，初期資源数1，最大資源数1
!  *  SEM2:  TA_NULL属性，初期資源数2，最大資源数2
!  *  SEM3:  TA_TPRI属性，初期資源数0，最大資源数1
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：中）==
   *  1:	ref_sem(SEM1, &rsem)
   *		assert(rsem.wtskid == TSK_NONE)
   *		assert(rsem.semcnt == 1)			... (J-2)
***************
*** 127,133 ****
   *		wai_sem(TNUM_SEMID+1) -> E_ID		... (E-6)
   *	3:	act_tsk(TASK3)
   *	4:	slp_tsk()
!  *	== TASK3ͥ١==
   *	5:	wai_sem(SEM1)						... (F-1)
   *  6:	ref_sem(SEM1, &rsem)
   *		assert(rsem.wtskid == TSK_NONE)
--- 127,133 ----
   *		wai_sem(TNUM_SEMID+1) -> E_ID		... (E-6)
   *	3:	act_tsk(TASK3)
   *	4:	slp_tsk()
!  *	== TASK3（優先度：低）==
   *	5:	wai_sem(SEM1)						... (F-1)
   *  6:	ref_sem(SEM1, &rsem)
   *		assert(rsem.wtskid == TSK_NONE)
***************
*** 139,163 ****
   *		wai_sem(SEM1) -> E_CTX				... (E-1)
   *	10:	iwup_tsk(TASK1)
   *	11:	RETURN
!  *	== TASK1³==
   *	12:	act_tsk(TASK2)
!  *	== TASK2ͥ١==
   *	13:	wai_sem(SEM1)						... (G-2)
!  *	== TASK1³==
   *  14:	ref_sem(SEM1, &rsem)
   *		assert(rsem.wtskid == TASK3)
   *		assert(rsem.semcnt == 0)
   *	15:	sig_sem(SEM1)						... (B-4)
   *	16:	sig_sem(SEM1)						... (B-1)
!  *	== TASK2³==
   *	17:	wai_sem(SEM1)						... (G-1)
!  *	== TASK1³==
   *	18: dis_dsp()
   *	19:	sig_sem(SEM1)						... (B-2)
   *	20:	ena_dsp()
!  *	== TASK2³==
   *	21:	wai_sem(SEM1)						... (G-1)
!  *	== TASK1³==
   *	22: sus_tsk(TASK2)
   *	23:	sig_sem(SEM1)						... (B-3)
   *	24: sig_sem(SEM1)						... (C-1)
--- 139,163 ----
   *		wai_sem(SEM1) -> E_CTX				... (E-1)
   *	10:	iwup_tsk(TASK1)
   *	11:	RETURN
!  *	== TASK1（続き）==
   *	12:	act_tsk(TASK2)
!  *	== TASK2（優先度：高）==
   *	13:	wai_sem(SEM1)						... (G-2)
!  *	== TASK1（続き）==
   *  14:	ref_sem(SEM1, &rsem)
   *		assert(rsem.wtskid == TASK3)
   *		assert(rsem.semcnt == 0)
   *	15:	sig_sem(SEM1)						... (B-4)
   *	16:	sig_sem(SEM1)						... (B-1)
!  *	== TASK2（続き）==
   *	17:	wai_sem(SEM1)						... (G-1)
!  *	== TASK1（続き）==
   *	18: dis_dsp()
   *	19:	sig_sem(SEM1)						... (B-2)
   *	20:	ena_dsp()
!  *	== TASK2（続き）==
   *	21:	wai_sem(SEM1)						... (G-1)
!  *	== TASK1（続き）==
   *	22: sus_tsk(TASK2)
   *	23:	sig_sem(SEM1)						... (B-3)
   *	24: sig_sem(SEM1)						... (C-1)
***************
*** 166,183 ****
   *		assert(rsem.wtskid == TSK_NONE)
   *		assert(rsem.semcnt == 1)
   *	27:	rsm_tsk(TASK2)
!  *	== TASK2³==
   *	28:	wai_sem(SEM2)						... (F-2)
   *  29:	ref_sem(SEM2, &rsem)
   *		assert(rsem.wtskid == TSK_NONE)
   *		assert(rsem.semcnt == 1)
   *	30:	wai_sem(SEM2)						... (F-1)
   *	31: wai_sem(SEM2)						... (G-1)
!  *	== TASK1³==
   *	32:	sig_sem(SEM2)						... (B-1)
!  *	== TASK2³==
   *	33:	wai_sem(SEM3)						... (G-3)
!  *	== TASK1³==
   *	34:	sig_sem(SEM2)						... (C-1)
   *	35:	sig_sem(SEM2)						... (C-2)
   *  36:	ref_sem(SEM2, &rsem)
--- 166,183 ----
   *		assert(rsem.wtskid == TSK_NONE)
   *		assert(rsem.semcnt == 1)
   *	27:	rsm_tsk(TASK2)
!  *	== TASK2（続き）==
   *	28:	wai_sem(SEM2)						... (F-2)
   *  29:	ref_sem(SEM2, &rsem)
   *		assert(rsem.wtskid == TSK_NONE)
   *		assert(rsem.semcnt == 1)
   *	30:	wai_sem(SEM2)						... (F-1)
   *	31: wai_sem(SEM2)						... (G-1)
!  *	== TASK1（続き）==
   *	32:	sig_sem(SEM2)						... (B-1)
!  *	== TASK2（続き）==
   *	33:	wai_sem(SEM3)						... (G-3)
!  *	== TASK1（続き）==
   *	34:	sig_sem(SEM2)						... (C-1)
   *	35:	sig_sem(SEM2)						... (C-2)
   *  36:	ref_sem(SEM2, &rsem)
***************
*** 188,232 ****
   *		assert(rsem.wtskid == TSK_NONE)
   *		assert(rsem.semcnt == 2)
   *	39:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK3³==
   *	40:	wai_sem(SEM3)						... (G-4)
!  *	== TASK1³==
   *	41:	act_tsk(TASK4)
   *	42:	act_tsk(TASK5)
   *	43:	rot_rdq(TPRI_SELF)
!  *	== TASK4ͥ١==
   *	44:	wai_sem(SEM3)						... (G-6)
!  *	== TASK5ͥ١==
   *	45:	wai_sem(SEM3)						... (G-5)
!  *	== TASK1³==
   *	46:	sig_sem(SEM3)						... (B-1)
!  *	== TASK2³==
   *	47:	wai_sem(SEM1)
   *		wai_sem(SEM1) -> E_RLWAI
!  *	== TASK1³==
   *	48:	sig_sem(SEM3)						... (B-4)
   *	49:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK4³==
   *	50:	ext_tsk() -> noreturn
!  *	== TASK1³==
   *	51:	sig_sem(SEM3)						... (B-4)
   *	52:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK5³==
   *	53:	ext_tsk() -> noreturn
!  *	== TASK1³==
   *	54:	sig_sem(SEM3)						... (B-4)
   *	55:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK3³==
   *	56:	ext_tsk() -> noreturn
!  *	== TASK1³==
   *	57: rel_wai(TASK2)						... (H)
!  *	== TASK2³==
   *	58:	wai_sem(SEM1) -> E_DLT
!  *	== TASK1³==
   *	59: ini_sem(SEM1)						... (I)
!  *	== TASK2³==
   *	60: ext_tsk() -> noreturn
!  *	== TASK1³==
   *	61: END
   */
  
--- 188,232 ----
   *		assert(rsem.wtskid == TSK_NONE)
   *		assert(rsem.semcnt == 2)
   *	39:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK3（続き）==
   *	40:	wai_sem(SEM3)						... (G-4)
!  *	== TASK1（続き）==
   *	41:	act_tsk(TASK4)
   *	42:	act_tsk(TASK5)
   *	43:	rot_rdq(TPRI_SELF)
!  *	== TASK4（優先度：中）==
   *	44:	wai_sem(SEM3)						... (G-6)
!  *	== TASK5（優先度：中）==
   *	45:	wai_sem(SEM3)						... (G-5)
!  *	== TASK1（続き）==
   *	46:	sig_sem(SEM3)						... (B-1)
!  *	== TASK2（続き）==
   *	47:	wai_sem(SEM1)
   *		wai_sem(SEM1) -> E_RLWAI
!  *	== TASK1（続き）==
   *	48:	sig_sem(SEM3)						... (B-4)
   *	49:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK4（続き）==
   *	50:	ext_tsk() -> noreturn
!  *	== TASK1（続き）==
   *	51:	sig_sem(SEM3)						... (B-4)
   *	52:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK5（続き）==
   *	53:	ext_tsk() -> noreturn
!  *	== TASK1（続き）==
   *	54:	sig_sem(SEM3)						... (B-4)
   *	55:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK3（続き）==
   *	56:	ext_tsk() -> noreturn
!  *	== TASK1（続き）==
   *	57: rel_wai(TASK2)						... (H)
!  *	== TASK2（続き）==
   *	58:	wai_sem(SEM1) -> E_DLT
!  *	== TASK1（続き）==
   *	59: ini_sem(SEM1)						... (I)
!  *	== TASK2（続き）==
   *	60: ext_tsk() -> noreturn
!  *	== TASK1（続き）==
   *	61: END
   */
  
diff -cr --new-file 1.9.1/asp/test/test_sem1.cfg ASPs/asp/test/test_sem1.cfg
*** 1.9.1/asp/test/test_sem1.cfg	Sun May 31 22:40:50 2009
--- ASPs/asp/test/test_sem1.cfg	Fri Dec  9 13:54:12 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ޥեǽΥƥ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  セマフォ機能のテスト(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/test_sem1.h ASPs/asp/test/test_sem1.h
*** 1.9.1/asp/test/test_sem1.h	Sat Aug  9 22:30:42 2008
--- ASPs/asp/test/test_sem1.h	Fri Dec  9 13:54:12 2022
***************
*** 5,67 ****
   *  Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_sem1.h 1232 2008-08-09 13:30:32Z ertl-hiro $
   */
  
  /* 
!  *		ޥեǽΥƥ(1)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_sem1.h 1232 2008-08-09 13:30:32Z ertl-hiro $
   */
  
  /* 
!  *		セマフォ機能のテスト(1)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/test/test_sem2.c ASPs/asp/test/test_sem2.c
*** 1.9.1/asp/test/test_sem2.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_sem2.c	Fri Dec  9 13:54:12 2022
***************
*** 5,92 ****
   *  Copyright (C) 2008-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_sem2.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		ޥեǽΥƥ(2)
   *
!  * ڥƥȤŪ
   *
!  *  isig_semsig_semȤΰ㤤濴˥ƥȤ롥
!  *  pol_semtwai_semwai_semȤΰ㤤濴˥ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) isig_semŪ顼Υƥ
!  *		(A-1) ƥȤθƽФ
!  *		(A-2) CPUå֤θƽФ
!  *	(B) isig_semˤꥻޥեԤ֤ΥԤ
!  *		(B-1) ɥ֤顤Ԥ줿ڤ괹
!  *		(B-2) ¹Ծ֤Υ顤Ԥ줿ڤ괹
!  *		(B-3) ǥѥåα֤ǡڤ괹ʤ
!  *		(B-4) Ԥ줿Ԥ֤ǡڤ괹ʤ
!  *		(B-5) Ԥ줿ͥ٤㤯ڤ괹ʤ
!  *	(C) pol_semŪ顼Υƥ
!  *		(C-1) 󥿥ƥȤθƽФ
!  *		(C-2) CPUå֤θƽФ
!  *		(C-3) ǥѥåػ߾֤θƽФE_CTX顼ˤʤʤ
!  *		(C-4) ͥ٥ޥǤʤ֤θƽФE_CTX顼
!  *		      ˤʤʤ
!  *	(D) pol_semǥݡ󥰼Ԥ
!  *	(E) twai_semŪ顼Υƥ
!  *		(E-1) 󥿥ƥȤθƽФ
!  *		(E-2) CPUå֤θƽФ
!  *		(E-3) ǥѥåػ߾֤θƽФ
!  *		(E-4) ͥ٥ޥǤʤ֤θƽФ
!  *		(E-5) tmout
!  *	(F) twai_semtmout=TMO_POLλ˥ݡ󥰼Ԥ
!  *	(G) twai_semtmout=TMO_FEVRλ˥ޥեԤ֤ˤʤ
!  *	(H) twai_semtmout˥ॢȤꤷˡॢդ
!  *		ޥեԤ֤ˤʤ
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥TA_ACT°
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	TASK4: ͥ٥
!  *	TASK5: ͥ٥
!  *	ALM1:  顼ϥɥ
!  *  SEM1:  TA_NULL°񸻿1񸻿1
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *  1:	isig_sem(SEM1) -> E_CTX				... (A-1)
   *	2:	loc_cpu()
   *		pol_sem(SEM1) -> E_CTX				... (C-2)
--- 5,92 ----
   *  Copyright (C) 2008-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_sem2.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		セマフォ機能のテスト(2)
   *
!  * 【テストの目的】
   *
!  *  isig_semを，sig_semとの違いを中心にテストする．
!  *  pol_sem，twai_semを，wai_semとの違いを中心にテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) isig_semの静的エラーのテスト
!  *		(A-1) タスクコンテキストからの呼出し
!  *		(A-2) CPUロック状態からの呼出し
!  *	(B) isig_semによりセマフォ待ち状態のタスクが待ち解除される
!  *		(B-1) アイドル状態から，待ち解除されたタスクに切り換わる
!  *		(B-2) 実行状態のタスクから，待ち解除されたタスクに切り換わる
!  *		(B-3) ディスパッチ保留状態で，切り換わらない
!  *		(B-4) 待ち解除されたタスクが強制待ち状態で，切り換わらない
!  *		(B-5) 待ち解除されたタスクが優先度が低く，切り換わらない
!  *	(C) pol_semの静的エラーのテスト
!  *		(C-1) 非タスクコンテキストからの呼出し
!  *		(C-2) CPUロック状態からの呼出し
!  *		(C-3) ディスパッチ禁止状態からの呼出し（E_CTXエラーにならない）
!  *		(C-4) 割込み優先度マスク全解除でない状態からの呼出し（E_CTXエラー
!  *		      にならない）
!  *	(D) pol_semでポーリング失敗する
!  *	(E) twai_semの静的エラーのテスト
!  *		(E-1) 非タスクコンテキストからの呼出し
!  *		(E-2) CPUロック状態からの呼出し
!  *		(E-3) ディスパッチ禁止状態からの呼出し
!  *		(E-4) 割込み優先度マスク全解除でない状態からの呼出し
!  *		(E-5) tmoutが不正
!  *	(F) twai_semでtmout=TMO_POLの時にポーリング失敗する
!  *	(G) twai_semでtmout=TMO_FEVRの時にセマフォ待ち状態になる
!  *	(H) twai_semでtmoutにタイムアウトを設定した時に，タイムアウト付きの
!  *		セマフォ待ち状態になる
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 中優先度タスク，TA_ACT属性
!  *	TASK2: 高優先度タスク
!  *	TASK3: 低優先度タスク
!  *	TASK4: 中優先度タスク
!  *	TASK5: 中優先度タスク
!  *	ALM1:  アラームハンドラ
!  *  SEM1:  TA_NULL属性，初期資源数1，最大資源数1
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：中）==
   *  1:	isig_sem(SEM1) -> E_CTX				... (A-1)
   *	2:	loc_cpu()
   *		pol_sem(SEM1) -> E_CTX				... (C-2)
***************
*** 112,130 ****
   *		iunl_cpu()
   *	10:	isig_sem(SEM1)						... (B-1)
   *		RETURN
!  *	== TASK1³==
   *	11:	act_tsk(TASK3)
   *	12:	wai_sem(SEM1)
!  *	== TASK3ͥ١==
   *	13:	sta_alm(ALM1, 10)
   *		call(wait_var())
   *	== ALM1-2 ==
   *	14:	isig_sem(SEM1)						... (B-2)
   *		call(signal_var())
   *		RETURN
!  *	== TASK1³==
   *	15:	wai_sem(SEM1)
!  *	== TASK3³==
   *	16:	sta_alm(ALM1, 10)
   *		dis_dsp()
   *		call(wait_var())
--- 112,130 ----
   *		iunl_cpu()
   *	10:	isig_sem(SEM1)						... (B-1)
   *		RETURN
!  *	== TASK1（続き）==
   *	11:	act_tsk(TASK3)
   *	12:	wai_sem(SEM1)
!  *	== TASK3（優先度：低）==
   *	13:	sta_alm(ALM1, 10)
   *		call(wait_var())
   *	== ALM1-2 ==
   *	14:	isig_sem(SEM1)						... (B-2)
   *		call(signal_var())
   *		RETURN
!  *	== TASK1（続き）==
   *	15:	wai_sem(SEM1)
!  *	== TASK3（続き）==
   *	16:	sta_alm(ALM1, 10)
   *		dis_dsp()
   *		call(wait_var())
***************
*** 132,142 ****
   *	17:	isig_sem(SEM1)						... (B-3)
   *		call(signal_var())
   *		RETURN
!  *	== TASK3³==
   *	18:	ena_dsp()
!  *	== TASK1³==
   *	19:	wai_sem(SEM1)
!  *	== TASK3³==
   *	20:	sta_alm(ALM1, 10)
   *		sus_tsk(TASK1)
   *		call(wait_var())
--- 132,142 ----
   *	17:	isig_sem(SEM1)						... (B-3)
   *		call(signal_var())
   *		RETURN
!  *	== TASK3（続き）==
   *	18:	ena_dsp()
!  *	== TASK1（続き）==
   *	19:	wai_sem(SEM1)
!  *	== TASK3（続き）==
   *	20:	sta_alm(ALM1, 10)
   *		sus_tsk(TASK1)
   *		call(wait_var())
***************
*** 144,175 ****
   *	21:	isig_sem(SEM1)						... (B-4)
   *		call(signal_var())
   *		RETURN
!  *	== TASK3³==
   *	22:	rsm_tsk(TASK1)
!  *	== TASK1³==
   *	23:	act_tsk(TASK2)
!  *	== TASK2ͥ١==
   *	24:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK1³==
   *	25:	wai_sem(SEM1)
!  *	== TASK3³==
   *	26:	ext_tsk() -> noreturn
!  *	== TASK2³==
   *	27:	sta_alm(ALM1, 10)
   *		call(wait_var())
   *	== ALM1-5 ==
   *	28:	isig_sem(SEM1)						... (B-5)
   *		call(signal_var())
   *		RETURN
!  *	== TASK2³==
   *	29:	ext_tsk() -> noreturn
!  *	== TASK1³==
   *	30:	sta_alm(ALM1, 10)
   *	31:	twai_sem(SEM1, 100) -> E_RLWAI
   *	== ALM1-6 ==
   *	32:	irel_wai(TASK1)
   *		RETURN
!  *	== TASK1³==
   *	33:	sta_alm(ALM1, 100)
   *	34:	twai_sem(SEM1, 10) -> E_TMOUT		... (H)
   *	35:	stp_alm(ALM1)
--- 144,175 ----
   *	21:	isig_sem(SEM1)						... (B-4)
   *		call(signal_var())
   *		RETURN
!  *	== TASK3（続き）==
   *	22:	rsm_tsk(TASK1)
!  *	== TASK1（続き）==
   *	23:	act_tsk(TASK2)
!  *	== TASK2（優先度：高）==
   *	24:	tslp_tsk(10) -> E_TMOUT
!  *	== TASK1（続き）==
   *	25:	wai_sem(SEM1)
!  *	== TASK3（続き）==
   *	26:	ext_tsk() -> noreturn
!  *	== TASK2（続き）==
   *	27:	sta_alm(ALM1, 10)
   *		call(wait_var())
   *	== ALM1-5 ==
   *	28:	isig_sem(SEM1)						... (B-5)
   *		call(signal_var())
   *		RETURN
!  *	== TASK2（続き）==
   *	29:	ext_tsk() -> noreturn
!  *	== TASK1（続き）==
   *	30:	sta_alm(ALM1, 10)
   *	31:	twai_sem(SEM1, 100) -> E_RLWAI
   *	== ALM1-6 ==
   *	32:	irel_wai(TASK1)
   *		RETURN
!  *	== TASK1（続き）==
   *	33:	sta_alm(ALM1, 100)
   *	34:	twai_sem(SEM1, 10) -> E_TMOUT		... (H)
   *	35:	stp_alm(ALM1)
diff -cr --new-file 1.9.1/asp/test/test_sem2.cfg ASPs/asp/test/test_sem2.cfg
*** 1.9.1/asp/test/test_sem2.cfg	Sun May 31 22:40:50 2009
--- ASPs/asp/test/test_sem2.cfg	Fri Dec  9 13:54:12 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ޥեǽΥƥ(2)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  セマフォ機能のテスト(2)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/test_sem2.h ASPs/asp/test/test_sem2.h
*** 1.9.1/asp/test/test_sem2.h	Sun Nov 23 23:24:14 2008
--- ASPs/asp/test/test_sem2.h	Fri Dec  9 13:54:12 2022
***************
*** 5,67 ****
   *  Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_sem2.h 1390 2008-11-23 14:24:08Z ertl-hiro $
   */
  
  /* 
!  *		ޥեǽΥƥ(2)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	9		/* ͥ */
! #define MID_PRIORITY	10		/* ͥ */
! #define LOW_PRIORITY	11		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_sem2.h 1390 2008-11-23 14:24:08Z ertl-hiro $
   */
  
  /* 
!  *		セマフォ機能のテスト(2)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	9		/* 高優先度 */
! #define MID_PRIORITY	10		/* 中優先度 */
! #define LOW_PRIORITY	11		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/test/test_sysstat1.c ASPs/asp/test/test_sysstat1.c
*** 1.9.1/asp/test/test_sysstat1.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_sysstat1.c	Fri Dec  9 13:54:12 2022
***************
*** 5,50 ****
   *  Copyright (C) 2006-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_sysstat1.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		ƥ֤˴ؤƥ(1)
   *
!  *  ƥȥ󥹡
   *
!  *	== TASK1ͥ١10==
!  *	1:	֤Υå
!  *	2:	loc_cpu() ... ƥ֤Ѳ
   *		chg_ipm(TMAX_INTPRI) -> E_CTX
   *	3:	unl_cpu()
   *	4:	chg_ipm(TMAX_INTPRI)
--- 5,50 ----
   *  Copyright (C) 2006-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_sysstat1.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		システム状態に関するテスト(1)
   *
!  *  テストシーケンス：
   *
!  *	== TASK1（優先度：10）==
!  *	1:	初期状態のチェック
!  *	2:	loc_cpu() ... システム状態をランダムに変化させる
   *		chg_ipm(TMAX_INTPRI) -> E_CTX
   *	3:	unl_cpu()
   *	4:	chg_ipm(TMAX_INTPRI)
***************
*** 53,74 ****
   *	7:	chg_ipm(TIPM_ENAALL)
   *	8:	ena_dsp()
   *	9:	dis_tex()
!  *	10:	dis_dsp() ... 㳰롼ƤӽФ
   *		ena_tex()
   *	11:	ras_tex(TSK_SELF, 0x0001)
!  *	== TASK1㳰롼1ܡ==
!  *	12:	֤Υå
!  *	13:	ena_dsp() ... 3Ĥξ֤Ѳ꥿Ǹˤɤ뤫Ĵ٤
   *		chg_ipm(TMIN_INTPRI)
   *		ena_tex()
!  *		꥿
!  *	== TASK1³==
!  *	14:	äƤ֤Υå
!  *	15:	loc_cpu() ... CPUå֤Τޤޥλ
!  *	16:	꥿ʡ᥿λ
!  *	== TASK2ͥ١10	==
!  *	17:	֤Υå
!  *	18:	λ
   */
  
  #include <kernel.h>
--- 53,74 ----
   *	7:	chg_ipm(TIPM_ENAALL)
   *	8:	ena_dsp()
   *	9:	dis_tex()
!  *	10:	dis_dsp() ... タスク例外処理ルーチンを呼び出す準備
   *		ena_tex()
   *	11:	ras_tex(TSK_SELF, 0x0001)
!  *	== TASK1タスク例外処理ルーチン（1回目）==
!  *	12:	初期状態のチェック
!  *	13:	ena_dsp() ... 3つの状態を変化させ，リターンで元にもどるか調べる
   *		chg_ipm(TMIN_INTPRI)
   *		ena_tex()
!  *		リターン
!  *	== TASK1（続き）==
!  *	14:	戻ってきた状態のチェック
!  *	15:	loc_cpu() ... CPUロック状態のままタスクを終了させる
!  *	16:	リターン（＝タスク終了）
!  *	== TASK2（優先度：10）	==
!  *	17:	初期状態のチェック
!  *	18:	終了
   */
  
  #include <kernel.h>
***************
*** 88,94 ****
  		check_state(false, false, TIPM_ENAALL, true, true, true);
  
  		/*
! 		 *  ǥѥåġͥ٥ޥѹ㳰
  		 */
  		check_point(13);
  		ercd = ena_dsp();
--- 88,94 ----
  		check_state(false, false, TIPM_ENAALL, true, true, true);
  
  		/*
! 		 *  ディスパッチ許可，割込み優先度マスク変更，タスク例外処理許可
  		 */
  		check_point(13);
  		ercd = ena_dsp();
***************
*** 114,126 ****
  	test_start(__FILE__);
  
  	/*
! 	 *  ֤Υå
  	 */
  	check_point(1);
  	check_state(false, false, TIPM_ENAALL, false, false, true);
  
  	/*
! 	 *  CPUå֤Υå
  	 */
  	check_point(2);
  	ercd = loc_cpu();
--- 114,126 ----
  	test_start(__FILE__);
  
  	/*
! 	 *  初期状態のチェック
  	 */
  	check_point(1);
  	check_state(false, false, TIPM_ENAALL, false, false, true);
  
  	/*
! 	 *  CPUロック状態のチェック
  	 */
  	check_point(2);
  	ercd = loc_cpu();
***************
*** 128,141 ****
  	check_state(false, true, TIPM_ENAALL, false, true, true);
  
  	/*
! 	 *  ͥ٥ޥѹΥå
  	 */
  	ercd = chg_ipm(TMAX_INTPRI);
  	check_ercd(ercd, E_CTX);
  	check_state(false, true, TIPM_ENAALL, false, true, true);
  
  	/*
! 	 *  CPUåΥå
  	 */
  	check_point(3);
  	ercd = unl_cpu();
--- 128,141 ----
  	check_state(false, true, TIPM_ENAALL, false, true, true);
  
  	/*
! 	 *  割込み優先度マスク変更のチェック
  	 */
  	ercd = chg_ipm(TMAX_INTPRI);
  	check_ercd(ercd, E_CTX);
  	check_state(false, true, TIPM_ENAALL, false, true, true);
  
  	/*
! 	 *  CPUロック解除のチェック
  	 */
  	check_point(3);
  	ercd = unl_cpu();
***************
*** 143,149 ****
  	check_state(false, false, TIPM_ENAALL, false, false, true);
  
  	/*
! 	 *  ͥ٥ޥѹΥå
  	 */
  	check_point(4);
  	ercd = chg_ipm(TMAX_INTPRI);
--- 143,149 ----
  	check_state(false, false, TIPM_ENAALL, false, false, true);
  
  	/*
! 	 *  割込み優先度マスク変更のチェック
  	 */
  	check_point(4);
  	ercd = chg_ipm(TMAX_INTPRI);
***************
*** 151,157 ****
  	check_state(false, false, TMAX_INTPRI, false, true, true);
  
  	/*
! 	 *  ǥѥåػߤΥå
  	 */
  	check_point(5);
  	ercd = dis_dsp();
--- 151,157 ----
  	check_state(false, false, TMAX_INTPRI, false, true, true);
  
  	/*
! 	 *  ディスパッチ禁止のチェック
  	 */
  	check_point(5);
  	ercd = dis_dsp();
***************
*** 159,165 ****
  	check_state(false, false, TMAX_INTPRI, true, true, true);
  
  	/*
! 	 *  㳰ĤΥå
  	 */
  	check_point(6);
  	ercd = ena_tex();
--- 159,165 ----
  	check_state(false, false, TMAX_INTPRI, true, true, true);
  
  	/*
! 	 *  タスク例外処理許可のチェック
  	 */
  	check_point(6);
  	ercd = ena_tex();
***************
*** 167,173 ****
  	check_state(false, false, TMAX_INTPRI, true, true, false);
  
  	/*
! 	 *  ͥ٥ޥΥå
  	 */
  	check_point(7);
  	ercd = chg_ipm(TIPM_ENAALL);
--- 167,173 ----
  	check_state(false, false, TMAX_INTPRI, true, true, false);
  
  	/*
! 	 *  割込み優先度マスク全解除のチェック
  	 */
  	check_point(7);
  	ercd = chg_ipm(TIPM_ENAALL);
***************
*** 175,181 ****
  	check_state(false, false, TIPM_ENAALL, true, true, false);
  
  	/*
! 	 *  ǥѥåĤΥå
  	 */
  	check_point(8);
  	ercd = ena_dsp();
--- 175,181 ----
  	check_state(false, false, TIPM_ENAALL, true, true, false);
  
  	/*
! 	 *  ディスパッチ許可のチェック
  	 */
  	check_point(8);
  	ercd = ena_dsp();
***************
*** 183,189 ****
  	check_state(false, false, TIPM_ENAALL, false, false, false);
  
  	/*
! 	 *  㳰ػߤΥå
  	 */
  	check_point(9);
  	ercd = dis_tex();
--- 183,189 ----
  	check_state(false, false, TIPM_ENAALL, false, false, false);
  
  	/*
! 	 *  タスク例外処理禁止のチェック
  	 */
  	check_point(9);
  	ercd = dis_tex();
***************
*** 191,197 ****
  	check_state(false, false, TIPM_ENAALL, false, false, true);
  
  	/*
! 	 *  ǥѥåػߡ㳰
  	 */
  	check_point(10);
  	ercd = dis_dsp();
--- 191,197 ----
  	check_state(false, false, TIPM_ENAALL, false, false, true);
  
  	/*
! 	 *  ディスパッチ禁止，タスク例外処理許可
  	 */
  	check_point(10);
  	ercd = dis_dsp();
***************
*** 201,229 ****
  	check_state(false, false, TIPM_ENAALL, true, true, false);
  
  	/*
! 	 *  㳰׵
  	 */
  	check_point(11);
  	ercd = ras_tex(TSK_SELF, 0x0001);
! 	/* ǥ㳰롼ư */
  	check_ercd(ercd, E_OK);
  
  	/*
! 	 *  㳰Υ꥿ˤ긵ξ֤äƤ뤳Ȥ
! 	 *  å
  	 */
  	check_point(14);
  	check_state(false, false, TIPM_ENAALL, true, true, false);
  
  	/*
! 	 *  CPUå֤
  	 */
  	check_point(15);
  	ercd = loc_cpu();
  	check_ercd(ercd, E_OK);
  
  	/*
! 	 *  Τޤޥλ
  	 */
  	check_point(16);
  }
--- 201,229 ----
  	check_state(false, false, TIPM_ENAALL, true, true, false);
  
  	/*
! 	 *  タスク例外処理を要求
  	 */
  	check_point(11);
  	ercd = ras_tex(TSK_SELF, 0x0001);
! 	/* ここでタスク例外処理ルーチンが動作する */
  	check_ercd(ercd, E_OK);
  
  	/*
! 	 *  タスク例外処理からのリターンにより元の状態に戻っていることを
! 	 *  チェック
  	 */
  	check_point(14);
  	check_state(false, false, TIPM_ENAALL, true, true, false);
  
  	/*
! 	 *  CPUロック状態に
  	 */
  	check_point(15);
  	ercd = loc_cpu();
  	check_ercd(ercd, E_OK);
  
  	/*
! 	 *  そのままタスク終了
  	 */
  	check_point(16);
  }
***************
*** 232,238 ****
  task2(intptr_t exinf)
  {
  	/*
! 	 *  ֤Υå
  	 */
  	check_point(17);
  	check_state(false, false, TIPM_ENAALL, false, false, true);
--- 232,238 ----
  task2(intptr_t exinf)
  {
  	/*
! 	 *  初期状態のチェック
  	 */
  	check_point(17);
  	check_state(false, false, TIPM_ENAALL, false, false, true);
diff -cr --new-file 1.9.1/asp/test/test_sysstat1.cfg ASPs/asp/test/test_sysstat1.cfg
*** 1.9.1/asp/test/test_sysstat1.cfg	Sun May 31 22:40:50 2009
--- ASPs/asp/test/test_sysstat1.cfg	Fri Dec  9 13:54:12 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ƥ֤˴ؤƥ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  システム状態に関するテスト(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/test_sysstat1.h ASPs/asp/test/test_sysstat1.h
*** 1.9.1/asp/test/test_sysstat1.h	Sat Apr 12 10:30:56 2008
--- ASPs/asp/test/test_sysstat1.h	Fri Dec  9 13:54:12 2022
***************
*** 5,66 ****
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_sysstat1.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		ƥ֤˴ؤƥ(1)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
! #define TASK1_PRIORITY	10		/* 1ͥ */
! #define TASK2_PRIORITY	10		/* 2ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,66 ----
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_sysstat1.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		システム状態に関するテスト(1)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
! #define TASK1_PRIORITY	10		/* タスク1の優先度 */
! #define TASK2_PRIORITY	10		/* タスク2の優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/test/test_task1.c ASPs/asp/test/test_task1.c
*** 1.9.1/asp/test/test_task1.c	Sun Oct 13 21:27:41 2013
--- ASPs/asp/test/test_task1.c	Fri Dec  9 13:54:12 2022
***************
*** 5,108 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_task1.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		⥸塼Υƥ(1)
   *
!  * ڥƥȤŪ
   *
!  *  make_runnablemake_non_runnableŪ˥ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) ¹Ծ֤Υ⤤ͥ٤Υ¹ԤǤ֤ˤ
!  *		(A-1) ǥѥåα֤ǤϤʤ
!  *		(A-2) ǥѥåα֤ξ
!  *	(B) ¹Ծ֤ΥƱͥ٤Υ¹ԤǤ֤ˤ
!  *		Ʊͥ٤Υ뤳Ȥǧ
!  *	(C) ¹Ծ֤Υ㤤ͥ٤Υ¹ԤǤ֤ˤ
!  *		Ʊͥ٤Υ뤳Ȥǧ
!  *	(D) ¹ԤǤ֤Υʤ֤ǡ¹ԤǤ֤ˤ
!  *		ξϡǥѥåα֤ǤϤʤ
!  *	(E) ǥѥåα֤ǡ¹Ծ֤ˤʤ٤¹Բǽ֥
!  *		⤤ͥ٤Υ򡤼¹ԤǤ֤ˤ
!  *	(F) ǥѥåα֤ǡ¹Ծ֤ˤʤ٤¹Բǽ֥
!  *		Ʊͥ٤Υ򡤼¹ԤǤ֤ˤ
!  *	(G) ǥѥåα֤ǡ¹Ծ֤ˤʤ٤¹Բǽ֥
!  *		㤤ͥ٤Υ򡤼¹ԤǤ֤ˤ
!  *	(H) ¹Ծ֤Υ򡤼¹ԤǤ֤Ǥʤ
!  *		(H-1) ¹ԤǤ֤Υʤʤ
!  *		(H-2) Ʊͥ٤Υʤʤ
!  *		(H-3) Ʊͥ٤Υʤʤʤ
!  *	(I) ¹Բǽ֤Υ򡤼¹ԤǤ֤Ǥʤ
!  *		(I-1) Ʊͥ٤Υʤʤ
!  *		(I-2) Ʊͥ٤Υʤʤʤ
!  *	(J) ǥѥåα֤ǡ¹Ծ֤ˤʤ٤¹Բǽ֤Ȥʤ
!  *		Ƥ륿򡤼¹ԤǤ֤Ǥʤ
!  *		(J-1) Ʊͥ٤Υʤʤ
!  *		(J-2) Ʊͥ٤Υʤʤʤ
!  *	(K) ǥѥåα֤ǡ¹Բǽ֤ˤʤ٤¹Ծ֤Υ
!  *		򡤼¹ԤǤ֤Ǥʤ
!  *		ǥѥåαǤϡ¹Ծ֤Υ¹ԤǤ֤Ǥʤ
!  *		ʤ褦ܤ򵯤ȤǤʤᡤξϵʤ
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ͥ٥ᥤ󥿥ǽ餫鵯ư
!  *	TASK2: ͥ٥
!  *	TASK3: ͥ٥
!  *	TASK4: ͥ٥
!  *	TASK5: ͥ٥
!  *	TASK6: ͥ٥
!  *	ALM1:  顼ϥɥ
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١==
   *	1:	act_tsk(TASK2)					... (A-1)
!  *	== TASK2ͥ١==
   *	2:	slp_tsk()						... (H-2)
!  *	== TASK1³==
   *	3:	act_tsk(TASK3)					... (B)
   *	4:	act_tsk(TASK4)					... (B)
   *	5:	slp_tsk()						... (H-3)
!  *	== TASK3ͥ١==
   *	6:	slp_tsk()						... (H-3)
!  *	== TASK4ͥ١==
   *	7:	wup_tsk(TASK1)
   *	8:	slp_tsk()						... (H-3)
!  *	== TASK1³==
   *	9:	act_tsk(TASK5)					... (C)
   *	10:	act_tsk(TASK6)					... (C)
   *	11:	sus_tsk(TASK6)					... (I-2)
--- 5,108 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_task1.c 2534 2013-10-13 12:27:37Z ertl-hiro $
   */
  
  /* 
!  *		タスク管理モジュールのテスト(1)
   *
!  * 【テストの目的】
   *
!  *  make_runnableとmake_non_runnableを網羅的にテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) 実行状態のタスクよりも高い優先度のタスクを実行できる状態にする
!  *		(A-1) ディスパッチ保留状態ではない場合
!  *		(A-2) ディスパッチ保留状態の場合
!  *	(B) 実行状態のタスクと同じ優先度のタスクを実行できる状態にする
!  *		！同じ優先度のタスクの中の末尾に入ることを確認する
!  *	(C) 実行状態のタスクよりも低い優先度のタスクを実行できる状態にする
!  *		！同じ優先度のタスクの中の末尾に入ることを確認する
!  *	(D) 実行できる状態のタスクがない状態で，タスクを実行できる状態にする
!  *		！この場合は，ディスパッチ保留状態ではない
!  *	(E) ディスパッチ保留状態で，実行状態になるべきだが実行可能状態タス
!  *		クよりも高い優先度のタスクを，実行できる状態にする
!  *	(F) ディスパッチ保留状態で，実行状態になるべきだが実行可能状態タス
!  *		クと同じ優先度のタスクを，実行できる状態にする
!  *	(G) ディスパッチ保留状態で，実行状態になるべきだが実行可能状態タス
!  *		クよりも低い優先度のタスクを，実行できる状態にする
!  *	(H) 実行状態のタスクを，実行できる状態でなくす
!  *		(H-1) 実行できる状態のタスクがなくなる場合
!  *		(H-2) 同一優先度のタスクがなくなる場合
!  *		(H-3) 同一優先度のタスクがなくならない場合
!  *	(I) 実行可能状態のタスクを，実行できる状態でなくす
!  *		(I-1) 同一優先度のタスクがなくなる場合
!  *		(I-2) 同一優先度のタスクがなくならない場合
!  *	(J) ディスパッチ保留状態で，実行状態になるべきだが実行可能状態となっ
!  *		ているタスクを，実行できる状態でなくす
!  *		(J-1) 同一優先度のタスクがなくなる場合
!  *		(J-2) 同一優先度のタスクがなくならない場合
!  *	(K) ディスパッチ保留状態で，実行可能状態になるべきだが実行状態のタ
!  *		スクを，実行できる状態でなくす
!  *		！ディスパッチ保留では，実行状態のタスクが実行できる状態でなく
!  *		なるような遷移を起こすことができないため，この状況は起こらない．
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: 中優先度タスク，メインタスク，最初から起動
!  *	TASK2: 高優先度タスク
!  *	TASK3: 中優先度タスク
!  *	TASK4: 中優先度タスク
!  *	TASK5: 低優先度タスク
!  *	TASK6: 低優先度タスク
!  *	ALM1:  アラームハンドラ
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：中）==
   *	1:	act_tsk(TASK2)					... (A-1)
!  *	== TASK2（優先度：高）==
   *	2:	slp_tsk()						... (H-2)
!  *	== TASK1（続き）==
   *	3:	act_tsk(TASK3)					... (B)
   *	4:	act_tsk(TASK4)					... (B)
   *	5:	slp_tsk()						... (H-3)
!  *	== TASK3（優先度：中）==
   *	6:	slp_tsk()						... (H-3)
!  *	== TASK4（優先度：中）==
   *	7:	wup_tsk(TASK1)
   *	8:	slp_tsk()						... (H-3)
!  *	== TASK1（続き）==
   *	9:	act_tsk(TASK5)					... (C)
   *	10:	act_tsk(TASK6)					... (C)
   *	11:	sus_tsk(TASK6)					... (I-2)
***************
*** 110,118 ****
   *	13:	rsm_tsk(TASK5)					... (C)
   *	14:	rsm_tsk(TASK6)					... (C)
   *	15:	slp_tsk()						... (H-2)
!  *	== TASK5ͥ١==
   *	16:	slp_tsk()						... (H-3)
!  *	== TASK6ͥ١==
   *	17:	dis_dsp()
   *	18:	wup_tsk(TASK1)					... (A-2)
   *	19:	wup_tsk(TASK2)					... (E)
--- 110,118 ----
   *	13:	rsm_tsk(TASK5)					... (C)
   *	14:	rsm_tsk(TASK6)					... (C)
   *	15:	slp_tsk()						... (H-2)
!  *	== TASK5（優先度：低）==
   *	16:	slp_tsk()						... (H-3)
!  *	== TASK6（優先度：低）==
   *	17:	dis_dsp()
   *	18:	wup_tsk(TASK1)					... (A-2)
   *	19:	wup_tsk(TASK2)					... (E)
***************
*** 121,140 ****
   *	22:	wup_tsk(TASK4)					... (F)
   *	23:	sus_tsk(TASK1)					... (J-2)
   *	24:	ena_dsp()
!  *	== TASK3³==
   *	25:	slp_tsk()						... (H-3)
!  *	== TASK4³==
   *	26:	slp_tsk()						... (H-2)
!  *	== TASK6³==
   *	27:	dis_dsp()
   *	28:	rsm_tsk(TASK1)					... (A-2)
   *	29:	wup_tsk(TASK5)					... (G)
   *	30:	ena_dsp()
!  *	== TASK1³==
   *	31:	slp_tsk()						... (H-2)
!  *	== TASK6³==
   *	32:	slp_tsk()						... (H-3)
!  *	== TASK5³==
   *	33:	sta_alm(ALM1, 10)
   *	34:	slp_tsk()						... (H-1)
   *	== ALM1 ==
--- 121,140 ----
   *	22:	wup_tsk(TASK4)					... (F)
   *	23:	sus_tsk(TASK1)					... (J-2)
   *	24:	ena_dsp()
!  *	== TASK3（続き）==
   *	25:	slp_tsk()						... (H-3)
!  *	== TASK4（続き）==
   *	26:	slp_tsk()						... (H-2)
!  *	== TASK6（続き）==
   *	27:	dis_dsp()
   *	28:	rsm_tsk(TASK1)					... (A-2)
   *	29:	wup_tsk(TASK5)					... (G)
   *	30:	ena_dsp()
!  *	== TASK1（続き）==
   *	31:	slp_tsk()						... (H-2)
!  *	== TASK6（続き）==
   *	32:	slp_tsk()						... (H-3)
!  *	== TASK5（続き）==
   *	33:	sta_alm(ALM1, 10)
   *	34:	slp_tsk()						... (H-1)
   *	== ALM1 ==
***************
*** 142,148 ****
   *		assert(tskid == TSK_NONE)
   *	36:	iwup_tsk(TASK1)					... (D)
   *	37:	RETURN
!  *	== TASK1³==
   *	38: END
   */
  
--- 142,148 ----
   *		assert(tskid == TSK_NONE)
   *	36:	iwup_tsk(TASK1)					... (D)
   *	37:	RETURN
!  *	== TASK1（続き）==
   *	38: END
   */
  
diff -cr --new-file 1.9.1/asp/test/test_task1.cfg ASPs/asp/test/test_task1.cfg
*** 1.9.1/asp/test/test_task1.cfg	Sun May 31 22:23:58 2009
--- ASPs/asp/test/test_task1.cfg	Fri Dec  9 13:54:12 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  ⥸塼Υƥ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  タスク管理モジュールのテスト(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/test_task1.h ASPs/asp/test/test_task1.h
*** 1.9.1/asp/test/test_task1.h	Sat Apr 12 10:30:55 2008
--- ASPs/asp/test/test_task1.h	Fri Dec  9 13:54:12 2022
***************
*** 5,67 ****
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_task1.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		⥸塼Υƥ(1)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ͥ٤
   */
! #define HIGH_PRIORITY	4		/* ͥ */
! #define MID_PRIORITY	9		/* ͥ */
! #define LOW_PRIORITY	14		/* ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,67 ----
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_task1.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		タスク管理モジュールのテスト(1)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  優先度の定義
   */
! #define HIGH_PRIORITY	4		/* 高優先度 */
! #define MID_PRIORITY	9		/* 中優先度 */
! #define LOW_PRIORITY	14		/* 低優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/test/test_tex1.c ASPs/asp/test/test_tex1.c
*** 1.9.1/asp/test/test_tex1.c	Thu Jan  2 21:21:32 2014
--- ASPs/asp/test/test_tex1.c	Fri Dec  9 13:54:12 2022
***************
*** 5,101 ****
   *  Copyright (C) 2006-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_tex1.c 2596 2014-01-02 12:21:31Z ertl-hiro $
   */
  
  /* 
!  *		㳰˴ؤƥ(1)
   *
!  * ڥƥȤŪ
   *
!  *  饿㳰롼ưŪ˥ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) ras_texΥ顼
!  *		(A-1) оݥٻ߾֡NGKI1413
!  *		(A-2) оݥΥ㳰롼ƤʤNGKI1414
!  *	(B) dis_texΥ顼
!  *		(B-1) Υ㳰롼ƤʤNGKI1421
!  *	(C) ena_texΥ顼
!  *		(C-1) Υ㳰롼ƤʤNGKI1426
!  *	(D) ref_texΥ顼
!  *		(D-1) оݥٻ߾֡NGKI1439
!  *		(D-2) оݥΥ㳰롼ƤʤNGKI1440
!  *	(E) ras_texNGKI1415
!  *		(E-1) оݥ㳰ġĳͥ
!  *			  ٥ޥ֤ǡ˼¹Գ
!  *		(E-2) оݥǤʤ
!  *		(E-3) оݥ㳰ػ
!  *		(E-4) оݥǥ㳰Ĥͥ
!  *			  ٥ޥǤʤ
!  *	(F) ena_texNGKI1427
!  *		(F-1) 㳰׵᤬ꡤĳͥ٥ޥ
!  *			  ֤ǡ˼¹Գ
!  *		(F-2) 㳰׵᤬ʤ
!  *		(F-3) 㳰׵᤬뤬ͥ٥ޥ
!  *			  ʤ
!  *	(G) chg_ipm
!  *		(G-1) 㳰׵᤬ꡤĥ㳰Ĥǡ
!  *			  ˼¹Գ
!  *		(G-2) 㳰׵᤬ʤ
!  *		(G-3) 㳰׵᤬뤬㳰ػ
!  *		(G-4) 㳰׵᤬뤬ͥ٥ޥ
!  *			  ʤ
!  *	(H) ǥѥåˤ뵯ư
!  *		(H-1) ǥѥåΥ㳰Ĥǥ㳰
!  *			  ᤢ
!  *	(I) 㳰롼󤫤Υ꥿ˤ뵯ưϢ³ư
!  *	(J) 㳰롼󤫤ˤ
!  *		(J-1) äƤ
!  *		(J-2) 㳰롼Ϣ³ư
!  *	(K) 㳰롼¿ŵư
!  *	(L) 㳰롼󤫤Υڴ
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ᥤΥФƥ㳰׵᤹
!  *	TASK2: ¾Фƥ㳰׵᤹оݥ
!  *	TASK3: 㳰롼Ƥʤ
!  *	TASK4: ٻ߾֤Υ
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١10==
   *	1:	state(false, false, TIPM_ENAALL, false, false, true)
   *		ref_tex(TSK_SELF, &rtex)
   *		assert((rtex.texstat & TTEX_DIS) != 0U)
--- 5,101 ----
   *  Copyright (C) 2006-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_tex1.c 2596 2014-01-02 12:21:31Z ertl-hiro $
   */
  
  /* 
!  *		タスク例外処理に関するテスト(1)
   *
!  * 【テストの目的】
   *
!  *  タスクからタスク例外処理ルーチンを起動する処理を網羅的にテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) ras_texのエラー検出
!  *		(A-1) 対象タスクが休止状態［NGKI1413］
!  *		(A-2) 対象タスクのタスク例外処理ルーチンが定義されていない［NGKI1414］
!  *	(B) dis_texのエラー検出
!  *		(B-1) 自タスクのタスク例外処理ルーチンが定義されていない［NGKI1421］
!  *	(C) ena_texのエラー検出
!  *		(C-1) 自タスクのタスク例外処理ルーチンが定義されていない［NGKI1426］
!  *	(D) ref_texのエラー検出
!  *		(D-1) 対象タスクが休止状態［NGKI1439］
!  *		(D-2) 対象タスクのタスク例外処理ルーチンが定義されていない［NGKI1440］
!  *	(E) ras_texの正常処理［NGKI1415］
!  *		(E-1) 対象タスクが自タスク，タスク例外処理許可，かつ割込み優先
!  *			  度マスク全解除状態で，すぐに実行開始
!  *		(E-2) 対象タスクが自タスクでない
!  *		(E-3) 対象タスクが自タスクだが，タスク例外処理禁止
!  *		(E-4) 対象タスクが自タスクでタスク例外処理許可だが，割込み優先
!  *			  度マスクが全解除でない
!  *	(F) ena_texの正常処理［NGKI1427］
!  *		(F-1) タスク例外処理要求があり，かつ割込み優先度マスク全解除状
!  *			  態で，すぐに実行開始
!  *		(F-2) タスク例外処理要求がない
!  *		(F-3) タスク例外処理要求があるが，割込み優先度マスクが全解除で
!  *			  ない
!  *	(G) chg_ipmの正常処理
!  *		(G-1) タスク例外処理要求があり，かつタスク例外処理許可で，すぐ
!  *			  に実行開始
!  *		(G-2) タスク例外処理要求がない
!  *		(G-3) タスク例外処理要求があるが，タスク例外処理禁止
!  *		(G-4) タスク例外処理要求があるが，割込み優先度マスクが全解除で
!  *			  ない
!  *	(H) タスクディスパッチャによる起動
!  *		(H-1) ディスパッチ後のタスクがタスク例外許可でタスク例外処理要
!  *			  求あり
!  *	(I) タスク例外処理ルーチンからのリターンによる起動（連続起動）
!  *	(J) タスク例外処理ルーチンからの戻り時による状態復帰
!  *		(J-1) タスクに戻ってくる時
!  *		(J-2) タスク例外処理ルーチンが連続起動される時
!  *	(K) タスク例外処理ルーチンの多重起動
!  *	(L) タスク例外処理ルーチンからの戻り時のタスク切換え
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: メインのタスク．自タスクに対してタスク例外処理を要求する
!  *	TASK2: 他タスクに対してタスク例外処理を要求する対象タスク
!  *	TASK3: タスク例外処理ルーチンが定義されていないタスク
!  *	TASK4: 休止状態のタスク
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：10）==
   *	1:	state(false, false, TIPM_ENAALL, false, false, true)
   *		ref_tex(TSK_SELF, &rtex)
   *		assert((rtex.texstat & TTEX_DIS) != 0U)
***************
*** 110,127 ****
   *		assert((rtex.texstat & TTEX_ENA) != 0U)
   *		assert(rtex.pndptn == 0U)
   *	3:	ras_tex(TSK_SELF, 0x0001)			... (E-1)
!  *	== TASK1-TEX-11ܡ==
   *	4:	assert(texptn == 0x0001)
   *		state(false, false, TIPM_ENAALL, false, false, true)
!  *	5:	dis_dsp() ... 4Ĥξ֤򤽤줾Ѳ
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()
   *		loc_cpu()
   *		state(false, true, TMAX_INTPRI, true, true, false)
   *		RETURN
!  *	== TASK1³==
   *	6:	state(false, false, TIPM_ENAALL, false, false, false)	... (J-1)
!  *	7:	dis_dsp() ... ǥѥåػߡ㳰ػ
   *		dis_tex()
   *		state(false, false, TIPM_ENAALL, true, true, true)
   *	8:	ras_tex(TASK1, 0x0002)				... (E-3)
--- 110,127 ----
   *		assert((rtex.texstat & TTEX_ENA) != 0U)
   *		assert(rtex.pndptn == 0U)
   *	3:	ras_tex(TSK_SELF, 0x0001)			... (E-1)
!  *	== TASK1-TEX-1（1回目）==
   *	4:	assert(texptn == 0x0001)
   *		state(false, false, TIPM_ENAALL, false, false, true)
!  *	5:	dis_dsp() ... 4つの状態をそれぞれ変化させる
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()
   *		loc_cpu()
   *		state(false, true, TMAX_INTPRI, true, true, false)
   *		RETURN
!  *	== TASK1（続き）==
   *	6:	state(false, false, TIPM_ENAALL, false, false, false)	... (J-1)
!  *	7:	dis_dsp() ... ディスパッチ禁止，タスク例外処理禁止
   *		dis_tex()
   *		state(false, false, TIPM_ENAALL, true, true, true)
   *	8:	ras_tex(TASK1, 0x0002)				... (E-3)
***************
*** 129,148 ****
   *		assert((rtex.texstat & TTEX_DIS) != 0)
   *		assert(rtex.pndptn == 0x0002)
   *	9:	ena_tex()							... (F-1)
!  *	== TASK1-TEX-22ܡ==
   *	10:	assert(texptn == 0x0002)
   *		state(false, false, TIPM_ENAALL, true, true, true)
   *	11:	ras_tex(TASK1, 0x0001)				... (E-3)
   *		ras_tex(TASK1, 0x0002)				... (E-3)
!  *	12:	ena_dsp() ... 3Ĥξ֤򤽤줾Ѳ
   *		chg_ipm(TMAX_INTPRI)
   *		loc_cpu()
   *		state(false, true, TMAX_INTPRI, false, true, true)
   *		RETURN								... (I)
!  *	== TASK1-TEX-33ܡ==
   *	13:	assert(texptn == 0x0003)
   *		state(false, false, TIPM_ENAALL, true, true, true)	... (J-2)
!  *	14:	ena_dsp() ... ǥѥåġ㳰
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()
   *		state(false, false, TMAX_INTPRI, false, true, false)
--- 129,148 ----
   *		assert((rtex.texstat & TTEX_DIS) != 0)
   *		assert(rtex.pndptn == 0x0002)
   *	9:	ena_tex()							... (F-1)
!  *	== TASK1-TEX-2（2回目）==
   *	10:	assert(texptn == 0x0002)
   *		state(false, false, TIPM_ENAALL, true, true, true)
   *	11:	ras_tex(TASK1, 0x0001)				... (E-3)
   *		ras_tex(TASK1, 0x0002)				... (E-3)
!  *	12:	ena_dsp() ... 3つの状態をそれぞれ変化させる
   *		chg_ipm(TMAX_INTPRI)
   *		loc_cpu()
   *		state(false, true, TMAX_INTPRI, false, true, true)
   *		RETURN								... (I)
!  *	== TASK1-TEX-3（3回目）==
   *	13:	assert(texptn == 0x0003)
   *		state(false, false, TIPM_ENAALL, true, true, true)	... (J-2)
!  *	14:	ena_dsp() ... ディスパッチ許可，タスク例外許可
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()
   *		state(false, false, TMAX_INTPRI, false, true, false)
***************
*** 155,206 ****
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()							... (F-3)
   *	16:	chg_ipm(TIPM_ENAALL)				... (G-1)(K)
!  *	== TASK1-TEX-44ܡ==
   *	17:	assert(texptn == 0x0004)
   *		state(false, false, TIPM_ENAALL, false, false, true)
!  *	18:	dis_dsp() ... 3Ĥξ֤򤽤줾Ѳ
   *		chg_ipm(TMAX_INTPRI)
   *		loc_cpu()
   *		state(false, true, TMAX_INTPRI, true, true, true)
   *		RETURN
!  *	== TASK1-TEX-33³==
   *	19:	state(false, false, TIPM_ENAALL, false, false, false)
   *		RETURN
!  *	== TASK1³==
   *	20:	state(false, false, TIPM_ENAALL, true, true, false)	... (J-1)
   *	21: ena_dsp()
   *		rot_rdq(TPRI_SELF)
!  *	== TASK2ͥ١10	==
   *	22:	state(false, false, TIPM_ENAALL, false, false, true)
   *	23:	ena_tex()
   *		state(false, false, TIPM_ENAALL, false, false, false)
   *		rot_rdq(TPRI_SELF)
!  *	== TASK3ͥ١10	==
   *	24:	state(false, false, TIPM_ENAALL, false, false, true)
   *	25:	ena_tex() -> E_OBJ					... (C-1)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *	26:	dis_tex() -> E_OBJ					... (B-1)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		ext_tsk()
!  *	== TASK1³==
   *	27: ras_tex(TASK2, 0x0001)				... (E-2)
   *		ref_tex(TASK2, &rtex)
   *	28:	rot_rdq(TPRI_SELF)					... (H-1)
!  *	== TASK2-TEX-11ܡ==
   *	29:	assert(texptn == 0x0001)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		RETURN
!  *	== TASK2³==
   *	30: ras_tex(TSK_SELF, 0x0002)
!  *	== TASK2-TEX-22ܡ==
   *	31:	assert(texptn == 0x0002)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *	32:	dis_dsp()
   *		rot_rdq(TPRI_SELF)
   *	33:	RETURN
!  *	== TASK1³==
   *	34:	RETURN
!  *	== TASK2³==
   *	35:	END
   */
  
--- 155,206 ----
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()							... (F-3)
   *	16:	chg_ipm(TIPM_ENAALL)				... (G-1)(K)
!  *	== TASK1-TEX-4（4回目）==
   *	17:	assert(texptn == 0x0004)
   *		state(false, false, TIPM_ENAALL, false, false, true)
!  *	18:	dis_dsp() ... 3つの状態をそれぞれ変化させる
   *		chg_ipm(TMAX_INTPRI)
   *		loc_cpu()
   *		state(false, true, TMAX_INTPRI, true, true, true)
   *		RETURN
!  *	== TASK1-TEX-3（3回目続き）==
   *	19:	state(false, false, TIPM_ENAALL, false, false, false)
   *		RETURN
!  *	== TASK1（続き）==
   *	20:	state(false, false, TIPM_ENAALL, true, true, false)	... (J-1)
   *	21: ena_dsp()
   *		rot_rdq(TPRI_SELF)
!  *	== TASK2（優先度：10）	==
   *	22:	state(false, false, TIPM_ENAALL, false, false, true)
   *	23:	ena_tex()
   *		state(false, false, TIPM_ENAALL, false, false, false)
   *		rot_rdq(TPRI_SELF)
!  *	== TASK3（優先度：10）	==
   *	24:	state(false, false, TIPM_ENAALL, false, false, true)
   *	25:	ena_tex() -> E_OBJ					... (C-1)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *	26:	dis_tex() -> E_OBJ					... (B-1)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		ext_tsk()
!  *	== TASK1（続き）==
   *	27: ras_tex(TASK2, 0x0001)				... (E-2)
   *		ref_tex(TASK2, &rtex)
   *	28:	rot_rdq(TPRI_SELF)					... (H-1)
!  *	== TASK2-TEX-1（1回目）==
   *	29:	assert(texptn == 0x0001)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		RETURN
!  *	== TASK2（続き）==
   *	30: ras_tex(TSK_SELF, 0x0002)
!  *	== TASK2-TEX-2（2回目）==
   *	31:	assert(texptn == 0x0002)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *	32:	dis_dsp()
   *		rot_rdq(TPRI_SELF)
   *	33:	RETURN
!  *	== TASK1（続き）==
   *	34:	RETURN
!  *	== TASK2（続き）==
   *	35:	END
   */
  
***************
*** 211,217 ****
  #include "test_tex1.h"
  
  /*
!  *  task4tex_task4ʤ
   */
  
  void
--- 211,217 ----
  #include "test_tex1.h"
  
  /*
!  *  task4とtex_task4は生成されない
   */
  
  void
diff -cr --new-file 1.9.1/asp/test/test_tex1.cfg ASPs/asp/test/test_tex1.cfg
*** 1.9.1/asp/test/test_tex1.cfg	Sun May 31 22:40:50 2009
--- ASPs/asp/test/test_tex1.cfg	Fri Dec  9 13:54:12 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  㳰˴ؤƥ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  タスク例外処理に関するテスト(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/test_tex1.h ASPs/asp/test/test_tex1.h
*** 1.9.1/asp/test/test_tex1.h	Sat Apr 12 10:30:55 2008
--- ASPs/asp/test/test_tex1.h	Fri Dec  9 13:54:12 2022
***************
*** 5,68 ****
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_tex1.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		㳰˴ؤƥ(1)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
! #define TASK1_PRIORITY	10		/* 1ͥ */
! #define TASK2_PRIORITY	10		/* 2ͥ */
! #define TASK3_PRIORITY	10		/* 3ͥ */
! #define TASK4_PRIORITY	10		/* 4ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,68 ----
   *  Copyright (C) 2006,2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_tex1.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		タスク例外処理に関するテスト(1)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
! #define TASK1_PRIORITY	10		/* タスク1の優先度 */
! #define TASK2_PRIORITY	10		/* タスク2の優先度 */
! #define TASK3_PRIORITY	10		/* タスク3の優先度 */
! #define TASK4_PRIORITY	10		/* タスク4の優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/test/test_tex2.c ASPs/asp/test/test_tex2.c
*** 1.9.1/asp/test/test_tex2.c	Thu Jan  2 21:21:32 2014
--- ASPs/asp/test/test_tex2.c	Fri Dec  9 13:54:12 2022
***************
*** 5,93 ****
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_tex2.c 2596 2014-01-02 12:21:31Z ertl-hiro $
   */
  
  /* 
!  *		㳰˴ؤƥ(2)
   *
!  * ڥƥȤŪ
   *
!  *  ߥϥɥʥ顼ϥɥˤCPU㳰ϥɥ餫饿
!  *  롼ưŪ˥ƥȤ롥
   *
!  * ڥƥȹܡ
   *
!  *	(A) iras_texΥ顼
!  *		(A-1) оݥٻ߾
!  *		(A-2) оݥΥ㳰롼Ƥʤ
!  *	(B) ߥϥɥ餫ƤФ줿iras_tex
!  *		(B-1) оݥ¹Ծ֤Υĥ㳰
!  *		(B-2) оݥ¹Ծ֤ΥǤʤ
!  *		(B-3) оݥ¹Ծ֤Υ㳰ػ
!  *	(C) CPU㳰ϥɥ餫ƤФ줿iras_tex
!  *		(C-1) оݥ¹Ծ֤Υĥ㳰
!  *		(C-2) оݥ¹Ծ֤ΥǤʤ
!  *		(C-3) оݥ¹Ծ֤Υ㳰ػ
!  *				 »ܤʤʥå¸˼¸Ǥʤ
!  *	(D) ߥϥɥνиˤ뵯ư
!  *		(D-1) ǥѥåΥ㳰Ĥǥ㳰
!  *			  ᤢ
!  *	(E) CPU㳰ϥɥνиˤ뵯ư
!  *		(E-1) ǥѥåΥ㳰Ĥǥ㳰
!  *			  ᤢ
!  *	(F) sns_texǼ¹Ծ֤Υʤ
!  *
!  * ڻѥ꥽
!  *
!  *	TASK1: ᥤΥ¹Ծ֤ΥФƥ㳰׵᤹
!  *		   оݥ
!  *	TASK2: ¹Ծ֤ǤʤФƥ㳰׵᤹оݥ
!  *	TASK3: 㳰롼Ƥʤ
!  *	TASK4: ٻ߾֤Υ
!  *	ALM1:  顼ϥɥ1
!  *	ALM2:  顼ϥɥ2
!  *	ALM3:  顼ϥɥ3
!  *	CPUEXC: CPU㳰ϥɥ
   *
!  * ڥƥȥ󥹡
   *
!  *	== TASK1ͥ١10==
   *	1:	state(false, false, TIPM_ENAALL, false, false, true)
   *		ref_tex(TSK_SELF, &rtex)
   *		assert((rtex.texstat & TTEX_DIS) != 0U)
   *		assert(rtex.pndptn == 0U)
   *	2:	sta_alm(ALM1, 1U)
!  *		DO(while (!(alm1_flag)))	... 顼ϥɥ1μ¹ԤԤ
   *	== ALM1 ==
   *	3:	state_i(true, false, false, true, true)
   *		iras_tex(TASK3, 0x0001) -> E_OBJ		... (A-2)
--- 5,93 ----
   *  Copyright (C) 2007-2013 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_tex2.c 2596 2014-01-02 12:21:31Z ertl-hiro $
   */
  
  /* 
!  *		タスク例外処理に関するテスト(2)
   *
!  * 【テストの目的】
   *
!  *  割込みハンドラ（アラームハンドラ）およびCPU例外ハンドラからタスク例
!  *  外処理ルーチンを起動する処理を網羅的にテストする．
   *
!  * 【テスト項目】
   *
!  *	(A) iras_texのエラー検出
!  *		(A-1) 対象タスクが休止状態
!  *		(A-2) 対象タスクのタスク例外処理ルーチンが定義されていない
!  *	(B) 割込みハンドラから呼ばれたiras_texの正常処理
!  *		(B-1) 対象タスクが実行状態のタスクかつタスク例外処理許可
!  *		(B-2) 対象タスクが実行状態のタスクでない
!  *		(B-3) 対象タスクが実行状態のタスクだがタスク例外処理禁止
!  *	(C) CPU例外ハンドラから呼ばれたiras_texの正常処理
!  *		(C-1) 対象タスクが実行状態のタスクかつタスク例外処理許可
!  *		(C-2) 対象タスクが実行状態のタスクでない
!  *		(C-3) 対象タスクが実行状態のタスクだがタスク例外処理禁止
!  *				→ 実施しない（ターゲット非依存に実現できない）
!  *	(D) 割込みハンドラの出口処理による起動
!  *		(D-1) ディスパッチ後のタスクがタスク例外許可でタスク例外処理要
!  *			  求あり
!  *	(E) CPU例外ハンドラの出口処理による起動
!  *		(E-1) ディスパッチ後のタスクがタスク例外許可でタスク例外処理要
!  *			  求あり
!  *	(F) sns_texで実行状態のタスクがない
!  *
!  * 【使用リソース】
!  *
!  *	TASK1: メインのタスク．実行状態のタスクに対してタスク例外処理を要求す
!  *		   る対象タスク
!  *	TASK2: 実行状態でないタスクに対してタスク例外処理を要求する対象タスク
!  *	TASK3: タスク例外処理ルーチンが定義されていないタスク
!  *	TASK4: 休止状態のタスク
!  *	ALM1:  アラームハンドラ1
!  *	ALM2:  アラームハンドラ2
!  *	ALM3:  アラームハンドラ3
!  *	CPUEXC: CPU例外ハンドラ
   *
!  * 【テストシーケンス】
   *
!  *	== TASK1（優先度：10）==
   *	1:	state(false, false, TIPM_ENAALL, false, false, true)
   *		ref_tex(TSK_SELF, &rtex)
   *		assert((rtex.texstat & TTEX_DIS) != 0U)
   *		assert(rtex.pndptn == 0U)
   *	2:	sta_alm(ALM1, 1U)
!  *		DO(while (!(alm1_flag)))	... アラームハンドラ1の実行を待つ
   *	== ALM1 ==
   *	3:	state_i(true, false, false, true, true)
   *		iras_tex(TASK3, 0x0001) -> E_OBJ		... (A-2)
***************
*** 96,113 ****
   *		iras_tex(TASK1, 0x0001)					... (B-3)
   *		DO(alm1_flag = true)
   *		RETURN
!  *	== TASK1³==
   *	4:	ena_tex()
!  *	== TASK1-TEX-11ܡ==
   *	5:	assert(texptn == 0x0001)
   *		state(false, false, TIPM_ENAALL, false, false, true)
!  *	6:	dis_dsp() ... 4Ĥξ֤򤽤줾Ѳ
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()
   *		loc_cpu()
   *		state(false, true, TMAX_INTPRI, true, true, false)
   *		RETURN
!  *	== TASK1³==
   *	7:	state(false, false, TIPM_ENAALL, false, false, false)
   *		ref_tex(TSK_SELF, &rtex)
   *		assert((rtex.texstat & TTEX_ENA) != 0U)
--- 96,113 ----
   *		iras_tex(TASK1, 0x0001)					... (B-3)
   *		DO(alm1_flag = true)
   *		RETURN
!  *	== TASK1（続き）==
   *	4:	ena_tex()
!  *	== TASK1-TEX-1（1回目）==
   *	5:	assert(texptn == 0x0001)
   *		state(false, false, TIPM_ENAALL, false, false, true)
!  *	6:	dis_dsp() ... 4つの状態をそれぞれ変化させる
   *		chg_ipm(TMAX_INTPRI)
   *		ena_tex()
   *		loc_cpu()
   *		state(false, true, TMAX_INTPRI, true, true, false)
   *		RETURN
!  *	== TASK1（続き）==
   *	7:	state(false, false, TIPM_ENAALL, false, false, false)
   *		ref_tex(TSK_SELF, &rtex)
   *		assert((rtex.texstat & TTEX_ENA) != 0U)
***************
*** 119,145 ****
   *		iras_tex(TASK1, 0x0002)					... (B-1)
   *		DO(alm2_flag = true)
   *		RETURN									... (D-1)
!  *	== TASK1-TEX-22ܡ==
   *	10:	assert(texptn == 0x0002)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		RETURN
!  *	== TASK1³==
   *	11:	sus_tsk(TASK2)
   *		sus_tsk(TASK3)
   *	12:	sta_alm(ALM3, 10U)
   *	13:	dly_tsk(50U)
   *	== ALM3 ==
!  *	14:	state_i(true, false, false, true, true)	... (F)sns_tex()ޤ
   *		iget_tid(&tskid)
   *		assert(tskid == TSK_NONE)
   *		iras_tex(TASK1, 0x0004)
   *		DO(alm3_flag = true)
   *		RETURN
!  *	== TASK1-TEX-33ܡ==
   *	15:	assert(texptn == 0x0004)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		RETURN
!  *	== TASK1³==
   *	16:	rsm_tsk(TASK2)
   *		rsm_tsk(TASK3)
   *		dis_dsp()
--- 119,145 ----
   *		iras_tex(TASK1, 0x0002)					... (B-1)
   *		DO(alm2_flag = true)
   *		RETURN									... (D-1)
!  *	== TASK1-TEX-2（2回目）==
   *	10:	assert(texptn == 0x0002)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		RETURN
!  *	== TASK1（続き）==
   *	11:	sus_tsk(TASK2)
   *		sus_tsk(TASK3)
   *	12:	sta_alm(ALM3, 10U)
   *	13:	dly_tsk(50U)
   *	== ALM3 ==
!  *	14:	state_i(true, false, false, true, true)	... (F)［sns_tex()を含む］
   *		iget_tid(&tskid)
   *		assert(tskid == TSK_NONE)
   *		iras_tex(TASK1, 0x0004)
   *		DO(alm3_flag = true)
   *		RETURN
!  *	== TASK1-TEX-3（3回目）==
   *	15:	assert(texptn == 0x0004)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		RETURN
!  *	== TASK1（続き）==
   *	16:	rsm_tsk(TASK2)
   *		rsm_tsk(TASK3)
   *		dis_dsp()
***************
*** 152,169 ****
   *		iras_tex(TASK2, 0x0010)					... (C-2)
   *		iras_tex(TASK1, 0x0010)					... (C-1)
   *		RETURN									... (E-1)
!  *	== TASK1-TEX-44ܡ==
   *	19:	assert(texptn == 0x0010)
   *		state(false, false, TIPM_ENAALL, true, true, true)
   *	20:	ext_tsk()
!  *	== TASK2ͥ١10==
   *	21:	state(false, false, TIPM_ENAALL, false, false, true)
   *	22:	ena_tex()
   *	== TASK2-TEX ==
   *	23:	assert(texptn == 0x0011)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		RETURN
!  *	== TASK2³==
   *	24:	sus_tsk(TASK3)
   *	25:	END
   */
--- 152,169 ----
   *		iras_tex(TASK2, 0x0010)					... (C-2)
   *		iras_tex(TASK1, 0x0010)					... (C-1)
   *		RETURN									... (E-1)
!  *	== TASK1-TEX-4（4回目）==
   *	19:	assert(texptn == 0x0010)
   *		state(false, false, TIPM_ENAALL, true, true, true)
   *	20:	ext_tsk()
!  *	== TASK2（優先度：10）==
   *	21:	state(false, false, TIPM_ENAALL, false, false, true)
   *	22:	ena_tex()
   *	== TASK2-TEX ==
   *	23:	assert(texptn == 0x0011)
   *		state(false, false, TIPM_ENAALL, false, false, true)
   *		RETURN
!  *	== TASK2（続き）==
   *	24:	sus_tsk(TASK3)
   *	25:	END
   */
***************
*** 179,185 ****
  volatile bool_t	alm3_flag = false;
  
  /*
!  *  task3task4tex_task4ʤ
   */
  
  void
--- 179,185 ----
  volatile bool_t	alm3_flag = false;
  
  /*
!  *  task3，task4とtex_task4は生成されない
   */
  
  void
diff -cr --new-file 1.9.1/asp/test/test_tex2.cfg ASPs/asp/test/test_tex2.cfg
*** 1.9.1/asp/test/test_tex2.cfg	Wed Jul 11 11:48:58 2012
--- ASPs/asp/test/test_tex2.cfg	Fri Dec  9 13:54:12 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  㳰˴ؤƥ(2)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  タスク例外処理に関するテスト(2)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/test_tex2.h ASPs/asp/test/test_tex2.h
*** 1.9.1/asp/test/test_tex2.h	Sat Apr 12 10:30:55 2008
--- ASPs/asp/test/test_tex2.h	Fri Dec  9 13:54:12 2022
***************
*** 5,68 ****
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  @(#) $Id: test_tex2.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		㳰˴ؤƥ(2)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
! #define TASK1_PRIORITY	10		/* 1ͥ */
! #define TASK2_PRIORITY	10		/* 2ͥ */
! #define TASK3_PRIORITY	10		/* 3ͥ */
! #define TASK4_PRIORITY	10		/* 4ͥ */
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,68 ----
   *  Copyright (C) 2007 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  @(#) $Id: test_tex2.h 329 2007-07-17 07:28:32Z hiro $
   */
  
  /* 
!  *		タスク例外処理に関するテスト(2)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
! #define TASK1_PRIORITY	10		/* タスク1の優先度 */
! #define TASK2_PRIORITY	10		/* タスク2の優先度 */
! #define TASK3_PRIORITY	10		/* タスク3の優先度 */
! #define TASK4_PRIORITY	10		/* タスク4の優先度 */
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
diff -cr --new-file 1.9.1/asp/test/test_utm1.c ASPs/asp/test/test_utm1.c
*** 1.9.1/asp/test/test_utm1.c	Sun Oct 13 21:08:32 2013
--- ASPs/asp/test/test_utm1.c	Fri Dec  9 13:54:12 2022
***************
*** 7,60 ****
   *  Copyright (C) 2007-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_utm1.c 2305 2012-01-29 11:51:08Z ertl-hiro $
   */
  
  /*
!  *		get_utm˴ؤƥ(1)
   *
!  * ڥƥȤŪ
   *
!  *  ǽɾѥƥ郎չԤ뤳ȤʤȤƥȤ롥
   *
!  * ڥƥȤơ
   *
!  *  ᥤ󥿥Ǥϡǽɾѥƥ򷫤֤郎
!  *  ʤʤå롥¹Ԥơϥɥ1ߥ
!  *  Ǽ¹ԤǤǽɾѥƥơ郎
!  *  ʤʤå롥
   *
!  *  ʤǽɾѥƥ郎ͤĶ0ϹθƤ
!  *  ʤ
   */
  
  #include <kernel.h>
--- 7,60 ----
   *  Copyright (C) 2007-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_utm1.c 2305 2012-01-29 11:51:08Z ertl-hiro $
   */
  
  /*
!  *		get_utmに関するテスト(1)
   *
!  * 【テストの目的】
   *
!  *  性能評価用システム時刻が逆行することがないことをテストする．
   *
!  * 【テストの内容】
   *
!  *  メインタスクでは，性能評価用システム時刻を繰り返し取得し，時刻が小
!  *  さくならないかをチェックする．それと並行して，周期ハンドラを1ミリ秒
!  *  周期で実行し，その中でも性能評価用システム時刻を取得して，時刻が小
!  *  さくならないかをチェックする．
   *
!  *  なお，性能評価用システム時刻が最大値を超えて0に戻る状況は考慮してい
!  *  ない．
   */
  
  #include <kernel.h>
diff -cr --new-file 1.9.1/asp/test/test_utm1.cfg ASPs/asp/test/test_utm1.cfg
*** 1.9.1/asp/test/test_utm1.cfg	Fri Feb 12 03:19:14 2010
--- ASPs/asp/test/test_utm1.cfg	Fri Dec  9 13:54:12 2022
***************
*** 3,9 ****
   */
  
  /*
!  *  get_utm˴ؤƥ(1)Υƥॳե졼ե
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
--- 3,9 ----
   */
  
  /*
!  *  get_utmに関するテスト(1)のシステムコンフィギュレーションファイル
   */
  INCLUDE("target_timer.cfg");
  INCLUDE("syssvc/syslog.cfg");
diff -cr --new-file 1.9.1/asp/test/test_utm1.h ASPs/asp/test/test_utm1.h
*** 1.9.1/asp/test/test_utm1.h	Fri Feb 12 03:19:14 2010
--- ASPs/asp/test/test_utm1.h	Fri Dec  9 13:54:12 2022
***************
*** 5,65 ****
   *  Copyright (C) 2006-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  嵭Ԥϡʲ(1)(4)ξ˸¤ꡤܥեȥ
!  *  ܥեȥѤΤޤࡥʲƱˤѡʣ
!  *  ѡۡʰʲѤȸƤ֡ˤ뤳Ȥ̵ǵ롥
!  *  (1) ܥեȥ򥽡ɤηѤˤϡ嵭
!  *      ɽѾ浪Ӳ̵ݾڵ꤬Τޤޤηǥ
!  *      ˴ޤޤƤ뤳ȡ
!  *  (2) ܥեȥ򡤥饤֥ʤɡ¾Υեȥȯ˻
!  *      ѤǤǺۤˤϡۤȼɥȡ
!  *      ԥޥ˥奢ʤɡˤˡ嵭ɽѾ浪Ӳ
!  *      ̵ݾڵǺܤ뤳ȡ
!  *  (3) ܥեȥ򡤵Ȥ߹ʤɡ¾Υեȥȯ˻
!  *      ѤǤʤǺۤˤϡΤ줫ξ
!  *      ȡ
!  *    (a) ۤȼɥȡѼԥޥ˥奢ʤɡˤˡ嵭
!  *        ɽѾ浪Ӳ̵ݾڵǺܤ뤳ȡ
!  *    (b) ۤη֤̤ˡˤäơTOPPERSץȤ
!  *        𤹤뤳ȡ
!  *  (4) ܥեȥѤˤľŪޤϴŪ뤤ʤ»
!  *      ⡤嵭ԤTOPPERSץȤդ뤳ȡ
!  *      ޤܥեȥΥ桼ޤϥɥ桼Τʤ
!  *      ͳ˴Ťᤫ⡤嵭ԤTOPPERSץȤ
!  *      դ뤳ȡ
   * 
!  *  ܥեȥϡ̵ݾڤ󶡤ƤΤǤ롥嵭Ԥ
!  *  TOPPERSץȤϡܥեȥ˴ؤơλŪ
!  *  ФŬޤơʤݾڤԤʤޤܥեȥ
!  *  ѤˤľŪޤϴŪʤ»˴ؤƤ⡤
!  *  Ǥʤ
   * 
   *  $Id: test_utm1.h 1746 2010-02-11 18:18:25Z ertl-hiro $
   */
  
  /*
!  *		get_utm˴ؤƥ(1)
   */
  
  /*
!  *  åȰ¸
   */
  #include "target_test.h"
  
  /*
!  *  ƥͥ٤
   */
  #define MAIN_PRIORITY	10
  
  /*
!  *  åȤ˰¸ǽΤ
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* Υå */
  #endif /* STACK_SIZE */
  
  /*
!  *  ؿΥץȥ
   */
  #ifndef TOPPERS_MACRO_ONLY
  
--- 5,65 ----
   *  Copyright (C) 2006-2010 by Embedded and Real-Time Systems Laboratory
   *              Graduate School of Information Science, Nagoya Univ., JAPAN
   * 
!  *  上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
!  *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
!  *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
!  *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
!  *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
!  *      スコード中に含まれていること．
!  *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
!  *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
!  *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
!  *      の無保証規定を掲載すること．
!  *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
!  *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
!  *      と．
!  *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
!  *        作権表示，この利用条件および下記の無保証規定を掲載すること．
!  *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
!  *        報告すること．
!  *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
!  *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
!  *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
!  *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
!  *      免責すること．
   * 
!  *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
!  *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
!  *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
!  *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
!  *  の責任を負わない．
   * 
   *  $Id: test_utm1.h 1746 2010-02-11 18:18:25Z ertl-hiro $
   */
  
  /*
!  *		get_utmに関するテスト(1)
   */
  
  /*
!  *  ターゲット依存の定義
   */
  #include "target_test.h"
  
  /*
!  *  各タスクの優先度の定義
   */
  #define MAIN_PRIORITY	10
  
  /*
!  *  ターゲットに依存する可能性のある定数の定義
   */
  #ifndef STACK_SIZE
! #define	STACK_SIZE		4096		/* タスクのスタックサイズ */
  #endif /* STACK_SIZE */
  
  /*
!  *  関数のプロトタイプ宣言
   */
  #ifndef TOPPERS_MACRO_ONLY
  
